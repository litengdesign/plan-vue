!function(Q){var B={};function F(U){if(B[U])return B[U].exports;var n=B[U]={i:U,l:!1,exports:{}};return Q[U].call(n.exports,n,n.exports,F),n.l=!0,n.exports}F.m=Q,F.c=B,F.d=function(Q,B,U){F.o(Q,B)||Object.defineProperty(Q,B,{enumerable:!0,get:U})},F.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},F.t=function(Q,B){if(1&B&&(Q=F(Q)),8&B)return Q;if(4&B&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(F.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&B&&"string"!=typeof Q)for(var n in Q)F.d(U,n,function(B){return Q[B]}.bind(null,n));return U},F.n=function(Q){var B=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return F.d(B,"a",B),B},F.o=function(Q,B){return Object.prototype.hasOwnProperty.call(Q,B)},F.p="http://localhost:8888/",F(F.s="./src/vendor/vue.js")}({"./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n")},"./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/setimmediate/setImmediate.js\n')},"./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLGlFQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/timers-browserify/main.js\n')},"./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1, eval)("this");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === "object") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoIChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n')},"./src/vendor/vue.js":
/*!***************************!*\
  !*** ./src/vendor/vue.js ***!
  \***************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.5.17\n * (c) 2014-2018 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() : undefined;\n})(this, function () {\n  'use strict';\n  /*  */\n\n  var emptyObject = Object.freeze({}); // these helpers produces better vm code in JS engines due to their\n  // explicitness and function inlining\n\n  function isUndef(v) {\n    return v === undefined || v === null;\n  }\n\n  function isDef(v) {\n    return v !== undefined && v !== null;\n  }\n\n  function isTrue(v) {\n    return v === true;\n  }\n\n  function isFalse(v) {\n    return v === false;\n  }\n  /**\n   * Check if value is primitive\n   */\n\n\n  function isPrimitive(value) {\n    return typeof value === 'string' || typeof value === 'number' || // $flow-disable-line\n    typeof value === 'symbol' || typeof value === 'boolean';\n  }\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n\n\n  function isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n  }\n  /**\n   * Get the raw type string of a value e.g. [object Object]\n   */\n\n\n  var _toString = Object.prototype.toString;\n\n  function toRawType(value) {\n    return _toString.call(value).slice(8, -1);\n  }\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n\n\n  function isPlainObject(obj) {\n    return _toString.call(obj) === '[object Object]';\n  }\n\n  function isRegExp(v) {\n    return _toString.call(v) === '[object RegExp]';\n  }\n  /**\n   * Check if val is a valid array index.\n   */\n\n\n  function isValidArrayIndex(val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val);\n  }\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n\n\n  function toString(val) {\n    return val == null ? '' : typeof val === 'object' ? JSON.stringify(val, null, 2) : String(val);\n  }\n  /**\n   * Convert a input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n\n\n  function toNumber(val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n;\n  }\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n\n\n  function makeMap(str, expectsLowerCase) {\n    var map = Object.create(null);\n    var list = str.split(',');\n\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n\n    return expectsLowerCase ? function (val) {\n      return map[val.toLowerCase()];\n    } : function (val) {\n      return map[val];\n    };\n  }\n  /**\n   * Check if a tag is a built-in tag.\n   */\n\n\n  var isBuiltInTag = makeMap('slot,component', true);\n  /**\n   * Check if a attribute is a reserved attribute.\n   */\n\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n  /**\n   * Remove an item from an array\n   */\n\n  function remove(arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n\n      if (index > -1) {\n        return arr.splice(index, 1);\n      }\n    }\n  }\n  /**\n   * Check whether the object has the property.\n   */\n\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n  /**\n   * Create a cached version of a pure function.\n   */\n\n\n  function cached(fn) {\n    var cache = Object.create(null);\n    return function cachedFn(str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str));\n    };\n  }\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n\n\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) {\n      return c ? c.toUpperCase() : '';\n    });\n  });\n  /**\n   * Capitalize a string.\n   */\n\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  });\n  /**\n   * Hyphenate a camelCase string.\n   */\n\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase();\n  });\n  /**\n   * Simple bind polyfill for environments that do not support it... e.g.\n   * PhantomJS 1.x. Technically we don't need this anymore since native bind is\n   * now more performant in most browsers, but removing it would be breaking for\n   * code that was able to run in PhantomJS 1.x, so this must be kept for\n   * backwards compatibility.\n   */\n\n  /* istanbul ignore next */\n\n  function polyfillBind(fn, ctx) {\n    function boundFn(a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    }\n\n    boundFn._length = fn.length;\n    return boundFn;\n  }\n\n  function nativeBind(fn, ctx) {\n    return fn.bind(ctx);\n  }\n\n  var bind = Function.prototype.bind ? nativeBind : polyfillBind;\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n\n    return ret;\n  }\n  /**\n   * Mix properties into target object.\n   */\n\n\n  function extend(to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n\n    return to;\n  }\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n\n\n  function toObject(arr) {\n    var res = {};\n\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n\n    return res;\n  }\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n   */\n\n\n  function noop(a, b, c) {}\n  /**\n   * Always return false.\n   */\n\n\n  var no = function (a, b, c) {\n    return false;\n  };\n  /**\n   * Return same value\n   */\n\n\n  var identity = function (_) {\n    return _;\n  };\n  /**\n   * Generate a static keys string from compiler modules.\n   */\n\n\n  function genStaticKeys(modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || []);\n    }, []).join(',');\n  }\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n\n\n  function looseEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i]);\n          });\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key]);\n          });\n        } else {\n          /* istanbul ignore next */\n          return false;\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false;\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b);\n    } else {\n      return false;\n    }\n  }\n\n  function looseIndexOf(arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /**\n   * Ensure a function is called only once.\n   */\n\n\n  function once(fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    };\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n  var ASSET_TYPES = ['component', 'directive', 'filter'];\n  var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];\n  /*  */\n\n  var config = {\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  };\n  /*  */\n\n  /**\n   * Check if a string starts with $ or _\n   */\n\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n  /**\n   * Define a property.\n   */\n\n\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n  /**\n   * Parse simple path.\n   */\n\n\n  var bailRE = /[^\\w.$]/;\n\n  function parsePath(path) {\n    if (bailRE.test(path)) {\n      return;\n    }\n\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) {\n          return;\n        }\n\n        obj = obj[segments[i]];\n      }\n\n      return obj;\n    };\n  }\n  /*  */\n  // can we use __proto__?\n\n\n  var hasProto = '__proto__' in {}; // Browser environment sniffing\n\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';\n  var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge; // Firefox has a \"watch\" function on Object.prototype...\n\n  var nativeWatch = {}.watch;\n  var supportsPassive = false;\n\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', {\n        get: function get() {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      }); // https://github.com/facebook/flow/issues/285\n\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  } // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n\n\n  var _isServer;\n\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n\n    return _isServer;\n  }; // detect devtools\n\n\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n  /* istanbul ignore next */\n\n  function isNative(Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n  }\n\n  var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */\n  // $flow-disable-line\n\n\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = function () {\n      function Set() {\n        this.set = Object.create(null);\n      }\n\n      Set.prototype.has = function has(key) {\n        return this.set[key] === true;\n      };\n\n      Set.prototype.add = function add(key) {\n        this.set[key] = true;\n      };\n\n      Set.prototype.clear = function clear() {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }();\n  }\n  /*  */\n\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = noop; // work around flow check\n\n  var formatComponentName = noop;\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n\n    var classify = function (str) {\n      return str.replace(classifyRE, function (c) {\n        return c.toUpperCase();\n      }).replace(/[-_]/g, '');\n    };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && !config.silent) {\n        console.error(\"[Vue warn]: \" + msg + trace);\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && !config.silent) {\n        console.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>';\n      }\n\n      var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n\n      while (n) {\n        if (n % 2 === 1) {\n          res += str;\n        }\n\n        if (n > 1) {\n          str += str;\n        }\n\n        n >>= 1;\n      }\n\n      return res;\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue;\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n\n        return '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n          return \"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n        }).join('\\n');\n      } else {\n        return \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n      }\n    };\n  }\n  /*  */\n\n  var uid = 0;\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n\n  var Dep = function Dep() {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub(sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub(sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend() {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify() {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  }; // the current target watcher being evaluated.\n  // this is globally unique because there could be only one\n  // watcher being evaluated at any time.\n\n\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget(_target) {\n    if (Dep.target) {\n      targetStack.push(Dep.target);\n    }\n\n    Dep.target = _target;\n  }\n\n  function popTarget() {\n    Dep.target = targetStack.pop();\n  }\n  /*  */\n\n\n  var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = {\n    child: {\n      configurable: true\n    }\n  }; // DEPRECATED: alias for componentInstance for backwards compat.\n\n  /* istanbul ignore next */\n\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance;\n  };\n\n  Object.defineProperties(VNode.prototype, prototypeAccessors);\n\n  var createEmptyVNode = function (text) {\n    if (text === void 0) text = '';\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node;\n  };\n\n  function createTextVNode(val) {\n    return new VNode(undefined, undefined, undefined, String(val));\n  } // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n\n\n  function cloneVNode(vnode) {\n    var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.isCloned = true;\n    return cloned;\n  }\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n  var methodsToPatch = ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'];\n  /**\n   * Intercept mutating methods and emit events\n   */\n\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break;\n\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n\n      if (inserted) {\n        ob.observeArray(inserted);\n      } // notify change\n\n\n      ob.dep.notify();\n      return result;\n    });\n  });\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n\n  var shouldObserve = true;\n\n  function toggleObserving(value) {\n    shouldObserve = value;\n  }\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n\n\n  var Observer = function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n\n    if (Array.isArray(value)) {\n      var augment = hasProto ? protoAugment : copyAugment;\n      augment(value, arrayMethods, arrayKeys);\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n\n\n  Observer.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i]);\n    }\n  };\n  /**\n   * Observe a list of Array items.\n   */\n\n\n  Observer.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  }; // helpers\n\n  /**\n   * Augment an target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n\n\n  function protoAugment(target, src, keys) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n  /**\n   * Augment an target Object or Array by defining\n   * hidden properties.\n   */\n\n  /* istanbul ignore next */\n\n\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n\n\n  function observe(value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return;\n    }\n\n    var ob;\n\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldObserve && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n\n    return ob;\n  }\n  /**\n   * Define a reactive property on an Object.\n   */\n\n\n  function defineReactive(obj, key, val, customSetter, shallow) {\n    var dep = new Dep();\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n\n    if (property && property.configurable === false) {\n      return;\n    } // cater for pre-defined getter/setters\n\n\n    var getter = property && property.get;\n\n    if (!getter && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var setter = property && property.set;\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n\n        if (Dep.target) {\n          dep.depend();\n\n          if (childOb) {\n            childOb.dep.depend();\n\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n\n        if (newVal === value || newVal !== newVal && value !== value) {\n          return;\n        }\n        /* eslint-enable no-self-compare */\n\n\n        if (\"development\" !== 'production' && customSetter) {\n          customSetter();\n        }\n\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n\n\n  function set(target, key, val) {\n    if (\"development\" !== 'production' && (isUndef(target) || isPrimitive(target))) {\n      warn(\"Cannot set reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val;\n    }\n\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n      return val;\n    }\n\n    if (!ob) {\n      target[key] = val;\n      return val;\n    }\n\n    defineReactive(ob.value, key, val);\n    ob.dep.notify();\n    return val;\n  }\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n\n\n  function del(target, key) {\n    if (\"development\" !== 'production' && (isUndef(target) || isPrimitive(target))) {\n      warn(\"Cannot delete reactive property on undefined, null, or primitive value: \" + target);\n    }\n\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return;\n    }\n\n    var ob = target.__ob__;\n\n    if (target._isVue || ob && ob.vmCount) {\n      \"development\" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n      return;\n    }\n\n    if (!hasOwn(target, key)) {\n      return;\n    }\n\n    delete target[key];\n\n    if (!ob) {\n      return;\n    }\n\n    ob.dep.notify();\n  }\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n\n\n  function dependArray(value) {\n    for (var e = void 0, i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n\n\n  var strats = config.optionMergeStrategies;\n  /**\n   * Options with restrictions\n   */\n\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n      }\n\n      return defaultStrat(parent, child);\n    };\n  }\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n\n  function mergeData(to, from) {\n    if (!from) {\n      return to;\n    }\n\n    var key, toVal, fromVal;\n    var keys = Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      toVal = to[key];\n      fromVal = from[key];\n\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n\n    return to;\n  }\n  /**\n   * Data\n   */\n\n\n  function mergeDataOrFn(parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n\n      if (!parentVal) {\n        return childVal;\n      } // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n\n\n      return function mergedDataFn() {\n        return mergeData(typeof childVal === 'function' ? childVal.call(this, this) : childVal, typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal);\n      };\n    } else {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm, vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm, vm) : parentVal;\n\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  }\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        \"development\" !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n        return parentVal;\n      }\n\n      return mergeDataOrFn(parentVal, childVal);\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm);\n  };\n  /**\n   * Hooks and props are merged as arrays.\n   */\n\n\n  function mergeHook(parentVal, childVal) {\n    return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n\n  function mergeAssets(parentVal, childVal, vm, key) {\n    var res = Object.create(parentVal || null);\n\n    if (childVal) {\n      \"development\" !== 'production' && assertObjectType(key, childVal, vm);\n      return extend(res, childVal);\n    } else {\n      return res;\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n\n  strats.watch = function (parentVal, childVal, vm, key) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) {\n      parentVal = undefined;\n    }\n\n    if (childVal === nativeWatch) {\n      childVal = undefined;\n    }\n    /* istanbul ignore if */\n\n\n    if (!childVal) {\n      return Object.create(parentVal || null);\n    }\n\n    {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = {};\n    extend(ret, parentVal);\n\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n\n      ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];\n    }\n\n    return ret;\n  };\n  /**\n   * Other object hashes.\n   */\n\n\n  strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n\n    if (!parentVal) {\n      return childVal;\n    }\n\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n\n    if (childVal) {\n      extend(ret, childVal);\n    }\n\n    return ret;\n  };\n\n  strats.provide = mergeDataOrFn;\n  /**\n   * Default strategy.\n   */\n\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n  /**\n   * Validate component names\n   */\n\n\n  function checkComponents(options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName(name) {\n    if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n      warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n    }\n\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + name);\n    }\n  }\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n\n\n  function normalizeProps(options, vm) {\n    var props = options.props;\n\n    if (!props) {\n      return;\n    }\n\n    var res = {};\n    var i, val, name;\n\n    if (Array.isArray(props)) {\n      i = props.length;\n\n      while (i--) {\n        val = props[i];\n\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = {\n            type: null\n          };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val) ? val : {\n          type: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"props\\\": expected an Array or an Object, \" + \"but got \" + toRawType(props) + \".\", vm);\n    }\n\n    options.props = res;\n  }\n  /**\n   * Normalize all injections into Object-based format\n   */\n\n\n  function normalizeInject(options, vm) {\n    var inject = options.inject;\n\n    if (!inject) {\n      return;\n    }\n\n    var normalized = options.inject = {};\n\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = {\n          from: inject[i]\n        };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val) ? extend({\n          from: key\n        }, val) : {\n          from: val\n        };\n      }\n    } else {\n      warn(\"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" + \"but got \" + toRawType(inject) + \".\", vm);\n    }\n  }\n  /**\n   * Normalize raw function directives into object format.\n   */\n\n\n  function normalizeDirectives(options) {\n    var dirs = options.directives;\n\n    if (dirs) {\n      for (var key in dirs) {\n        var def = dirs[key];\n\n        if (typeof def === 'function') {\n          dirs[key] = {\n            bind: def,\n            update: def\n          };\n        }\n      }\n    }\n  }\n\n  function assertObjectType(name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" + \"but got \" + toRawType(value) + \".\", vm);\n    }\n  }\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n\n\n  function mergeOptions(parent, child, vm) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n    var extendsFrom = child.extends;\n\n    if (extendsFrom) {\n      parent = mergeOptions(parent, extendsFrom, vm);\n    }\n\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n\n    var options = {};\n    var key;\n\n    for (key in parent) {\n      mergeField(key);\n    }\n\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n\n    return options;\n  }\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n\n\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n\n    var assets = options[type]; // check local registration variations first\n\n    if (hasOwn(assets, id)) {\n      return assets[id];\n    }\n\n    var camelizedId = camelize(id);\n\n    if (hasOwn(assets, camelizedId)) {\n      return assets[camelizedId];\n    }\n\n    var PascalCaseId = capitalize(camelizedId);\n\n    if (hasOwn(assets, PascalCaseId)) {\n      return assets[PascalCaseId];\n    } // fallback to prototype chain\n\n\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\n    if (\"development\" !== 'production' && warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function validateProp(key, propOptions, propsData, vm) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key]; // boolean casting\n\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    } // check default value\n\n\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key); // since the default value is a fresh copy,\n      // make sure to observe it.\n\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value;\n  }\n  /**\n   * Get the default value of a prop.\n   */\n\n\n  function getPropDefaultValue(vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined;\n    }\n\n    var def = prop.default; // warn against non-factory defaults for Object & Array\n\n    if (\"development\" !== 'production' && isObject(def)) {\n      warn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    } // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n\n\n    if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n      return vm._props[key];\n    } // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n\n\n    return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n  }\n  /**\n   * Assert whether a prop is valid.\n   */\n\n\n  function assertProp(prop, name, value, vm, absent) {\n    if (prop.required && absent) {\n      warn('Missing required prop: \"' + name + '\"', vm);\n      return;\n    }\n\n    if (value == null && !prop.required) {\n      return;\n    }\n\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(\"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" + \" Expected \" + expectedTypes.map(capitalize).join(', ') + \", got \" + toRawType(value) + \".\", vm);\n      return;\n    }\n\n    var validator = prop.validator;\n\n    if (validator) {\n      if (!validator(value)) {\n        warn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType = getType(type);\n\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase(); // for primitive wrapper objects\n\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n\n\n  function getType(fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : '';\n  }\n\n  function isSameType(a, b) {\n    return getType(a) === getType(b);\n  }\n\n  function getTypeIndex(type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1;\n    }\n\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n  /*  */\n\n\n  function handleError(err, vm, info) {\n    if (vm) {\n      var cur = vm;\n\n      while (cur = cur.$parent) {\n        var hooks = cur.$options.errorCaptured;\n\n        if (hooks) {\n          for (var i = 0; i < hooks.length; i++) {\n            try {\n              var capture = hooks[i].call(cur, err, vm, info) === false;\n\n              if (capture) {\n                return;\n              }\n            } catch (e) {\n              globalHandleError(e, cur, 'errorCaptured hook');\n            }\n          }\n        }\n      }\n    }\n\n    globalHandleError(err, vm, info);\n  }\n\n  function globalHandleError(err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info);\n      } catch (e) {\n        logError(e, null, 'config.errorHandler');\n      }\n    }\n\n    logError(err, vm, info);\n  }\n\n  function logError(err, vm, info) {\n    {\n      warn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n    }\n    /* istanbul ignore else */\n\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err;\n    }\n  }\n  /*  */\n\n  /* globals MessageChannel */\n\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks() {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  } // Here we have async deferring wrappers using both microtasks and (macro) tasks.\n  // In < 2.4 we used microtasks everywhere, but there are some scenarios where\n  // microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690) or even between bubbling of the same\n  // event (#6566). However, using (macro) tasks everywhere also has subtle problems\n  // when state is changed right before repaint (e.g. #6813, out-in transitions).\n  // Here we use microtask by default, but expose a way to force (macro) task when\n  // needed (e.g. in event handlers attached by v-on).\n\n\n  var microTimerFunc;\n  var macroTimerFunc;\n  var useMacroTask = false; // Determine (macro) task defer implementation.\n  // Technically setImmediate should be the ideal choice, but it's only available\n  // in IE. The only polyfill that consistently queues the callback after all DOM\n  // events triggered in the same loop is by using MessageChannel.\n\n  /* istanbul ignore if */\n\n  if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    macroTimerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) || // PhantomJS\n  MessageChannel.toString() === '[object MessageChannelConstructor]')) {\n    var channel = new MessageChannel();\n    var port = channel.port2;\n    channel.port1.onmessage = flushCallbacks;\n\n    macroTimerFunc = function () {\n      port.postMessage(1);\n    };\n  } else {\n    /* istanbul ignore next */\n    macroTimerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  } // Determine microtask defer implementation.\n\n  /* istanbul ignore next, $flow-disable-line */\n\n\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n\n    microTimerFunc = function () {\n      p.then(flushCallbacks); // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n\n      if (isIOS) {\n        setTimeout(noop);\n      }\n    };\n  } else {\n    // fallback to macro\n    microTimerFunc = macroTimerFunc;\n  }\n  /**\n   * Wrap a function so that if any code inside triggers state change,\n   * the changes are queued using a (macro) task instead of a microtask.\n   */\n\n\n  function withMacroTask(fn) {\n    return fn._withTask || (fn._withTask = function () {\n      useMacroTask = true;\n      var res = fn.apply(null, arguments);\n      useMacroTask = false;\n      return res;\n    });\n  }\n\n  function nextTick(cb, ctx) {\n    var _resolve;\n\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n\n    if (!pending) {\n      pending = true;\n\n      if (useMacroTask) {\n        macroTimerFunc();\n      } else {\n        microTimerFunc();\n      }\n    } // $flow-disable-line\n\n\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      });\n    }\n  }\n  /*  */\n\n\n  var mark;\n  var measure;\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n\n    if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n      mark = function (tag) {\n        return perf.mark(tag);\n      };\n\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        perf.clearMeasures(name);\n      };\n    }\n  }\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n  {\n    var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);\n    };\n\n    var hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set(target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n            return false;\n          } else {\n            target[key] = value;\n            return true;\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has(target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n\n        if (!has && !isAllowed) {\n          warnNonPresent(target, key);\n        }\n\n        return has || !isAllowed;\n      }\n    };\n    var getHandler = {\n      get: function get(target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          warnNonPresent(target, key);\n        }\n\n        return target[key];\n      }\n    };\n\n    initProxy = function initProxy(vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n  /*  */\n\n  var seenObjects = new _Set();\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n\n  function traverse(val) {\n    _traverse(val, seenObjects);\n\n    seenObjects.clear();\n  }\n\n  function _traverse(val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n\n    if (!isA && !isObject(val) || Object.isFrozen(val) || val instanceof VNode) {\n      return;\n    }\n\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n\n      if (seen.has(depId)) {\n        return;\n      }\n\n      seen.add(depId);\n    }\n\n    if (isA) {\n      i = val.length;\n\n      while (i--) {\n        _traverse(val[i], seen);\n      }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n\n      while (i--) {\n        _traverse(val[keys[i]], seen);\n      }\n    }\n  }\n  /*  */\n\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    };\n  });\n\n  function createFnInvoker(fns) {\n    function invoker() {\n      var arguments$1 = arguments;\n      var fns = invoker.fns;\n\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n\n        for (var i = 0; i < cloned.length; i++) {\n          cloned[i].apply(null, arguments$1);\n        }\n      } else {\n        // return handler return value for single handlers\n        return fns.apply(null, arguments);\n      }\n    }\n\n    invoker.fns = fns;\n    return invoker;\n  }\n\n  function updateListeners(on, oldOn, add, remove$$1, vm) {\n    var name, def, cur, old, event;\n\n    for (name in on) {\n      def = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      /* istanbul ignore if */\n\n      if (isUndef(cur)) {\n        \"development\" !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur);\n        }\n\n        add(event.name, cur, event.once, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n  /*  */\n\n\n  function mergeVNodeHook(def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook() {\n      hook.apply(this, arguments); // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n  /*  */\n\n\n  function extractPropsFromVNodeData(data, Ctor, tag) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n\n    if (isUndef(propOptions)) {\n      return;\n    }\n\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n\n          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n            tip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n          }\n        }\n        checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n      }\n    }\n\n    return res;\n  }\n\n  function checkProp(res, hash, key, altKey, preserve) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n\n        if (!preserve) {\n          delete hash[key];\n        }\n\n        return true;\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n\n        if (!preserve) {\n          delete hash[altKey];\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n\n\n  function simpleNormalizeChildren(children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children);\n      }\n    }\n\n    return children;\n  } // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n\n\n  function normalizeChildren(children) {\n    return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n  }\n\n  function isTextNode(node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment);\n  }\n\n  function normalizeArrayChildren(children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n\n      if (isUndef(c) || typeof c === 'boolean') {\n        continue;\n      }\n\n      lastIndex = res.length - 1;\n      last = res[lastIndex]; //  nested\n\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i); // merge adjacent text nodes\n\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + c[0].text);\n            c.shift();\n          }\n\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n\n          res.push(c);\n        }\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  function ensureCtor(comp, base) {\n    if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {\n      comp = comp.default;\n    }\n\n    return isObject(comp) ? base.extend(comp) : comp;\n  }\n\n  function createAsyncPlaceholder(factory, data, context, children, tag) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = {\n      data: data,\n      context: context,\n      children: children,\n      tag: tag\n    };\n    return node;\n  }\n\n  function resolveAsyncComponent(factory, baseCtor, context) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp;\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved;\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp;\n    }\n\n    if (isDef(factory.contexts)) {\n      // already pending\n      factory.contexts.push(context);\n    } else {\n      var contexts = factory.contexts = [context];\n      var sync = true;\n\n      var forceRender = function () {\n        for (var i = 0, l = contexts.length; i < l; i++) {\n          contexts[i].$forceUpdate();\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor); // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n\n        if (!sync) {\n          forceRender();\n        }\n      });\n      var reject = once(function (reason) {\n        \"development\" !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender();\n        }\n      });\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (typeof res.then === 'function') {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isDef(res.component) && typeof res.component.then === 'function') {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              setTimeout(function () {\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender();\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            setTimeout(function () {\n              if (isUndef(factory.resolved)) {\n                reject(\"timeout (\" + res.timeout + \"ms)\");\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false; // return in case resolved synchronously\n\n      return factory.loading ? factory.loadingComp : factory.resolved;\n    }\n  }\n  /*  */\n\n\n  function isAsyncPlaceholder(node) {\n    return node.isComment && node.asyncFactory;\n  }\n  /*  */\n\n\n  function getFirstComponentChild(children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c;\n        }\n      }\n    }\n  }\n  /*  */\n\n  /*  */\n\n\n  function initEvents(vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false; // init parent attached events\n\n    var listeners = vm.$options._parentListeners;\n\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add(event, fn, once) {\n    if (once) {\n      target.$once(event, fn);\n    } else {\n      target.$on(event, fn);\n    }\n  }\n\n  function remove$1(event, fn) {\n    target.$off(event, fn);\n  }\n\n  function updateComponentListeners(vm, listeners, oldListeners) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n    target = undefined;\n  }\n\n  function eventsMixin(Vue) {\n    var hookRE = /^hook:/;\n\n    Vue.prototype.$on = function (event, fn) {\n      var this$1 = this;\n      var vm = this;\n\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          this$1.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n\n      function on() {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm;\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var this$1 = this;\n      var vm = this; // all\n\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm;\n      } // array of events\n\n\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          this$1.$off(event[i], fn);\n        }\n\n        return vm;\n      } // specific event\n\n\n      var cbs = vm._events[event];\n\n      if (!cbs) {\n        return vm;\n      }\n\n      if (!fn) {\n        vm._events[event] = null;\n        return vm;\n      }\n\n      if (fn) {\n        // specific handler\n        var cb;\n        var i$1 = cbs.length;\n\n        while (i$1--) {\n          cb = cbs[i$1];\n\n          if (cb === fn || cb.fn === fn) {\n            cbs.splice(i$1, 1);\n            break;\n          }\n        }\n      }\n\n      return vm;\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n        }\n      }\n      var cbs = vm._events[event];\n\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          try {\n            cbs[i].apply(vm, args);\n          } catch (e) {\n            handleError(e, vm, \"event handler for \\\"\" + event + \"\\\"\");\n          }\n        }\n      }\n\n      return vm;\n    };\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n\n\n  function resolveSlots(children, context) {\n    var slots = {};\n\n    if (!children) {\n      return slots;\n    }\n\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node\n\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      } // named slots should only be respected if the vnode was rendered in the\n      // same context.\n\n\n      if ((child.context === context || child.fnContext === context) && data && data.slot != null) {\n        var name = data.slot;\n        var slot = slots[name] || (slots[name] = []);\n\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    } // ignore slots that contains only whitespace\n\n\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n\n    return slots;\n  }\n\n  function isWhitespace(node) {\n    return node.isComment && !node.asyncFactory || node.text === ' ';\n  }\n\n  function resolveScopedSlots(fns, // see flow/vnode\n  res) {\n    res = res || {};\n\n    for (var i = 0; i < fns.length; i++) {\n      if (Array.isArray(fns[i])) {\n        resolveScopedSlots(fns[i], res);\n      } else {\n        res[fns[i].key] = fns[i].fn;\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function initLifecycle(vm) {\n    var options = vm.$options; // locate first non-abstract parent\n\n    var parent = options.parent;\n\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n    vm.$children = [];\n    vm.$refs = {};\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin(Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n\n      if (vm._isMounted) {\n        callHook(vm, 'beforeUpdate');\n      }\n\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var prevActiveInstance = activeInstance;\n      activeInstance = vm;\n      vm._vnode = vnode; // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false\n        /* removeOnly */\n        , vm.$options._parentElm, vm.$options._refElm); // no need for the ref nodes after initial patch\n        // this prevents keeping a detached DOM tree in memory (#5851)\n\n        vm.$options._parentElm = vm.$options._refElm = null;\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n\n      activeInstance = prevActiveInstance; // update __vue__ reference\n\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      } // if parent is an HOC, update its $el as well\n\n\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      } // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n\n      if (vm._isBeingDestroyed) {\n        return;\n      }\n\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true; // remove self from parent\n\n      var parent = vm.$parent;\n\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      } // teardown watchers\n\n\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n\n      var i = vm._watchers.length;\n\n      while (i--) {\n        vm._watchers[i].teardown();\n      } // remove reference from data ob\n      // frozen object may not have observer.\n\n\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      } // call the last hook...\n\n\n      vm._isDestroyed = true; // invoke destroy hooks on current rendered tree\n\n      vm.__patch__(vm._vnode, null); // fire destroyed hook\n\n\n      callHook(vm, 'destroyed'); // turn off all instance listeners.\n\n      vm.$off(); // remove __vue__ reference\n\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      } // release circular reference (#6759)\n\n\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent(vm, el, hydrating) {\n    vm.$el = el;\n\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n          warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n        } else {\n          warn('Failed to mount component: template or render function not defined.', vm);\n        }\n      }\n    }\n\n    callHook(vm, 'beforeMount');\n    var updateComponent;\n    /* istanbul ignore if */\n\n    if (\"development\" !== 'production' && config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n        mark(startTag);\n\n        var vnode = vm._render();\n\n        mark(endTag);\n        measure(\"vue \" + name + \" render\", startTag, endTag);\n        mark(startTag);\n\n        vm._update(vnode, hydrating);\n\n        mark(endTag);\n        measure(\"vue \" + name + \" patch\", startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    } // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n\n\n    new Watcher(vm, updateComponent, noop, null, true\n    /* isRenderWatcher */\n    );\n    hydrating = false; // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n\n    return vm;\n  }\n\n  function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n    {\n      isUpdatingChildComponent = true;\n    } // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren\n\n    var hasChildren = !!(renderChildren || // has new static slots\n    vm.$options._renderChildren || // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n    );\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) {\n      // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n\n    vm.$options._renderChildren = renderChildren; // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject; // update props\n\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n\n      toggleObserving(true); // keep a copy of raw propsData\n\n      vm.$options.propsData = propsData;\n    } // update listeners\n\n\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners); // resolve slots + force update if has children\n\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree(vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function activateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    } else if (vm._directInactive) {\n      return;\n    }\n\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent(vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n\n      if (isInInactiveTree(vm)) {\n        return;\n      }\n    }\n\n    if (!vm._inactive) {\n      vm._inactive = true;\n\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook(vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        try {\n          handlers[i].call(vm);\n        } catch (e) {\n          handleError(e, vm, hook + \" hook\");\n        }\n      }\n    }\n\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n\n    popTarget();\n  }\n  /*  */\n\n\n  var MAX_UPDATE_COUNT = 100;\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n  /**\n   * Reset the scheduler's state.\n   */\n\n  function resetSchedulerState() {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n  /**\n   * Flush both queues and run the watchers.\n   */\n\n\n  function flushSchedulerQueue() {\n    flushing = true;\n    var watcher, id; // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n\n    queue.sort(function (a, b) {\n      return a.id - b.id;\n    }); // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      id = watcher.id;\n      has[id] = null;\n      watcher.run(); // in dev build, check and stop circular updates.\n\n      if (\"development\" !== 'production' && has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n          break;\n        }\n      }\n    } // keep copies of post queues before resetting state\n\n\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n    resetSchedulerState(); // call component updated and activated hooks\n\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue); // devtool hook\n\n    /* istanbul ignore if */\n\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks(queue) {\n    var i = queue.length;\n\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n\n      if (vm._watcher === watcher && vm._isMounted) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n\n\n  function queueActivatedComponent(vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks(queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true\n      /* true */\n      );\n    }\n  }\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n\n\n  function queueWatcher(watcher) {\n    var id = watcher.id;\n\n    if (has[id] == null) {\n      has[id] = true;\n\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n\n        queue.splice(i + 1, 0, watcher);\n      } // queue the flush\n\n\n      if (!waiting) {\n        waiting = true;\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n  /*  */\n\n\n  var uid$1 = 0;\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n\n  var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {\n    this.vm = vm;\n\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n\n    vm._watchers.push(this); // options\n\n\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n\n    this.cb = cb;\n    this.id = ++uid$1; // uid for batching\n\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString(); // parse expression for getter\n\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n\n      if (!this.getter) {\n        this.getter = function () {};\n\n        \"development\" !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n      }\n    }\n\n    this.value = this.lazy ? undefined : this.get();\n  };\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n\n  Watcher.prototype.get = function get() {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n      } else {\n        throw e;\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n\n      popTarget();\n      this.cleanupDeps();\n    }\n\n    return value;\n  };\n  /**\n   * Add a dependency to this directive.\n   */\n\n\n  Watcher.prototype.addDep = function addDep(dep) {\n    var id = dep.id;\n\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n  /**\n   * Clean up for dependency collection.\n   */\n\n\n  Watcher.prototype.cleanupDeps = function cleanupDeps() {\n    var this$1 = this;\n    var i = this.deps.length;\n\n    while (i--) {\n      var dep = this$1.deps[i];\n\n      if (!this$1.newDepIds.has(dep.id)) {\n        dep.removeSub(this$1);\n      }\n    }\n\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n\n\n  Watcher.prototype.update = function update() {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n\n\n  Watcher.prototype.run = function run() {\n    if (this.active) {\n      var value = this.get();\n\n      if (value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) || this.deep) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n\n  Watcher.prototype.evaluate = function evaluate() {\n    this.value = this.get();\n    this.dirty = false;\n  };\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n\n  Watcher.prototype.depend = function depend() {\n    var this$1 = this;\n    var i = this.deps.length;\n\n    while (i--) {\n      this$1.deps[i].depend();\n    }\n  };\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n\n\n  Watcher.prototype.teardown = function teardown() {\n    var this$1 = this;\n\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n\n      var i = this.deps.length;\n\n      while (i--) {\n        this$1.deps[i].removeSub(this$1);\n      }\n\n      this.active = false;\n    }\n  };\n  /*  */\n\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy(target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter() {\n      return this[sourceKey][key];\n    };\n\n    sharedPropertyDefinition.set = function proxySetter(val) {\n      this[sourceKey][key] = val;\n    };\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState(vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n\n    if (opts.props) {\n      initProps(vm, opts.props);\n    }\n\n    if (opts.methods) {\n      initMethods(vm, opts.methods);\n    }\n\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true\n      /* asRootData */\n      );\n    }\n\n    if (opts.computed) {\n      initComputed(vm, opts.computed);\n    }\n\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps(vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {}; // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent; // root instance props should be converted\n\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n\n    var loop = function (key) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n\n      {\n        var hyphenatedKey = hyphenate(key);\n\n        if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {\n          warn(\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n        }\n\n        defineReactive(props, key, value, function () {\n          if (vm.$parent && !isUpdatingChildComponent) {\n            warn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n          }\n        });\n      } // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop(key);\n\n    toggleObserving(true);\n  }\n\n  function initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\n    if (!isPlainObject(data)) {\n      data = {};\n      \"development\" !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n    } // proxy data on instance\n\n\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\", vm);\n        }\n      }\n\n      if (props && hasOwn(props, key)) {\n        \"development\" !== 'production' && warn(\"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    } // observe data\n\n\n    observe(data, true\n    /* asRootData */\n    );\n  }\n\n  function getData(data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n\n    try {\n      return data.call(vm, vm);\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {};\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = {\n    lazy: true\n  };\n\n  function initComputed(vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null); // computed properties are just getters during SSR\n\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n\n      if (\"development\" !== 'production' && getter == null) {\n        warn(\"Getter is missing for computed property \\\"\" + key + \"\\\".\", vm);\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n      } // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n\n\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed(target, key, userDef) {\n    var shouldCache = !isServerRendering();\n\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n      sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n    }\n\n    if (\"development\" !== 'production' && sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\", this);\n      };\n    }\n\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter(key) {\n    return function computedGetter() {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n\n        if (Dep.target) {\n          watcher.depend();\n        }\n\n        return watcher.value;\n      }\n    };\n  }\n\n  function initMethods(vm, methods) {\n    var props = vm.$options.props;\n\n    for (var key in methods) {\n      {\n        if (methods[key] == null) {\n          warn(\"Method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n        }\n\n        if (props && hasOwn(props, key)) {\n          warn(\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n        }\n\n        if (key in vm && isReserved(key)) {\n          warn(\"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" + \"Avoid defining component methods that start with _ or $.\");\n        }\n      }\n      vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch(vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher(vm, expOrFn, handler, options) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n\n    return vm.$watch(expOrFn, handler, options);\n  }\n\n  function stateMixin(Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n\n    dataDef.get = function () {\n      return this._data;\n    };\n\n    var propsDef = {};\n\n    propsDef.get = function () {\n      return this._props;\n    };\n\n    {\n      dataDef.set = function (newData) {\n        warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n      };\n\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options);\n      }\n\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n\n      if (options.immediate) {\n        cb.call(vm, watcher.value);\n      }\n\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n  }\n  /*  */\n\n\n  function initProvide(vm) {\n    var provide = vm.$options.provide;\n\n    if (provide) {\n      vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n    }\n  }\n\n  function initInjections(vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive(vm, key, result[key], function () {\n            warn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject(inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {\n        /* istanbul ignore next */\n        return Object.getOwnPropertyDescriptor(inject, key).enumerable;\n      }) : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var provideKey = inject[key].from;\n        var source = vm;\n\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break;\n          }\n\n          source = source.$parent;\n        }\n\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;\n          } else {\n            warn(\"Injection \\\"\" + key + \"\\\" not found\", vm);\n          }\n        }\n      }\n\n      return result;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n\n\n  function renderList(val, render) {\n    var ret, i, l, keys, key;\n\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n\n    if (isDef(ret)) {\n      ret._isVList = true;\n    }\n\n    return ret;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n\n\n  function renderSlot(name, fallback, props, bindObject) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n\n    if (scopedSlotFn) {\n      // scoped slot\n      props = props || {};\n\n      if (bindObject) {\n        if (\"development\" !== 'production' && !isObject(bindObject)) {\n          warn('slot v-bind without argument expects an Object', this);\n        }\n\n        props = extend(extend({}, bindObject), props);\n      }\n\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      var slotNodes = this.$slots[name]; // warn duplicate slot usage\n\n      if (slotNodes) {\n        if (\"development\" !== 'production' && slotNodes._rendered) {\n          warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n        }\n\n        slotNodes._rendered = true;\n      }\n\n      nodes = slotNodes || fallback;\n    }\n\n    var target = props && props.slot;\n\n    if (target) {\n      return this.$createElement('template', {\n        slot: target\n      }, nodes);\n    } else {\n      return nodes;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n\n\n  function resolveFilter(id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity;\n  }\n  /*  */\n\n\n  function isKeyNotMatch(expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1;\n    } else {\n      return expect !== actual;\n    }\n  }\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n\n\n  function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName);\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode);\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key;\n    }\n  }\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n\n\n  function bindObjectProps(data, tag, value, asProp, isSync) {\n    if (value) {\n      if (!isObject(value)) {\n        \"development\" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n\n        var hash;\n\n        var loop = function (key) {\n          if (key === 'class' || key === 'style' || isReservedAttribute(key)) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n          }\n\n          if (!(key in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n\n              on[\"update:\" + key] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop(key);\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n\n\n  function renderStatic(index, isInFor) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index]; // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n\n    if (tree && !isInFor) {\n      return tree;\n    } // otherwise, render a fresh tree.\n\n\n    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, null, this // for render fns generated for functional component templates\n    );\n    markStatic(tree, \"__static__\" + index, false);\n    return tree;\n  }\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n\n\n  function markOnce(tree, index, key) {\n    markStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n    return tree;\n  }\n\n  function markStatic(tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], key + \"_\" + i, isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode(node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n  /*  */\n\n\n  function bindObjectListeners(data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        \"development\" !== 'production' && warn('v-on without argument expects an Object value', this);\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n\n    return data;\n  }\n  /*  */\n\n\n  function installRenderHelpers(target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n  }\n  /*  */\n\n\n  function FunctionalRenderContext(data, props, children, parent, Ctor) {\n    var options = Ctor.options; // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n\n    var contextVm;\n\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent); // $flow-disable-line\n\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent; // $flow-disable-line\n\n      parent = parent._original;\n    }\n\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n\n    this.slots = function () {\n      return resolveSlots(children, parent);\n    }; // support for compiled functional template\n\n\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options; // pre-resolve slots for renderSlot()\n\n      this.$slots = this.slots();\n      this.$scopedSlots = data.scopedSlots || emptyObject;\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n\n        return vnode;\n      };\n    } else {\n      this._c = function (a, b, c, d) {\n        return createElement(contextVm, a, b, c, d, needNormalization);\n      };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) {\n        mergeProps(props, data.attrs);\n      }\n\n      if (isDef(data.props)) {\n        mergeProps(props, data.props);\n      }\n    }\n\n    var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options);\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);\n      }\n\n      return res;\n    }\n  }\n\n  function cloneAndMarkFunctionalResult(vnode, data, contextVm, options) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n\n    return clone;\n  }\n\n  function mergeProps(to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n  /*  */\n  // Register the component hook to weex native render engine.\n  // The hook will be triggered by native, not javascript.\n  // Updates the state of the component to weex native render engine.\n\n  /*  */\n  // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n  // listening on native callback\n\n  /*  */\n\n  /*  */\n  // inline hooks to be invoked on component VNodes during patch\n\n\n  var componentVNodeHooks = {\n    init: function init(vnode, hydrating, parentElm, refElm) {\n      if (vnode.componentInstance && !vnode.componentInstance._isDestroyed && vnode.data.keepAlive) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n    prepatch: function prepatch(oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(child, options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n      );\n    },\n    insert: function insert(vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    },\n    destroy: function destroy(vnode) {\n      var componentInstance = vnode.componentInstance;\n\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true\n          /* direct */\n          );\n        }\n      }\n    }\n  };\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent(Ctor, data, context, children, tag) {\n    if (isUndef(Ctor)) {\n      return;\n    }\n\n    var baseCtor = context.$options._base; // plain options object: turn it into a constructor\n\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    } // if at this stage it's not a constructor or an async component factory,\n    // reject.\n\n\n    if (typeof Ctor !== 'function') {\n      {\n        warn(\"Invalid Component definition: \" + String(Ctor), context);\n      }\n      return;\n    } // async component\n\n\n    var asyncFactory;\n\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(asyncFactory, data, context, children, tag);\n      }\n    }\n\n    data = data || {}; // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n\n    resolveConstructorOptions(Ctor); // transform component v-model data into props & events\n\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    } // extract props\n\n\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag); // functional component\n\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children);\n    } // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n\n\n    var listeners = data.on; // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n      // work around flow\n      var slot = data.slot;\n      data = {};\n\n      if (slot) {\n        data.slot = slot;\n      }\n    } // install component management hooks onto the placeholder node\n\n\n    installComponentHooks(data); // return a placeholder vnode\n\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, {\n      Ctor: Ctor,\n      propsData: propsData,\n      listeners: listeners,\n      tag: tag,\n      children: children\n    }, asyncFactory); // Weex specific: invoke recycle-list optimized @render function for\n    // extracting cell-slot template.\n    // https://github.com/Hanks10100/weex-native-directive/tree/master/component\n\n    /* istanbul ignore if */\n\n    return vnode;\n  }\n\n  function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm, refElm) {\n    var options = {\n      _isComponent: true,\n      parent: parent,\n      _parentVnode: vnode,\n      _parentElm: parentElm || null,\n      _refElm: refElm || null\n    }; // check inline-template render functions\n\n    var inlineTemplate = vnode.data.inlineTemplate;\n\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n\n    return new vnode.componentOptions.Ctor(options);\n  }\n\n  function installComponentHooks(data) {\n    var hooks = data.hook || (data.hook = {});\n\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      hooks[key] = componentVNodeHooks[key];\n    }\n  } // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n\n\n  function transformModel(options, data) {\n    var prop = options.model && options.model.prop || 'value';\n    var event = options.model && options.model.event || 'input';\n    (data.props || (data.props = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n\n    if (isDef(on[event])) {\n      on[event] = [data.model.callback].concat(on[event]);\n    } else {\n      on[event] = data.model.callback;\n    }\n  }\n  /*  */\n\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2; // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n\n  function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n\n    return _createElement(context, tag, data, children, normalizationType);\n  }\n\n  function _createElement(context, tag, data, children, normalizationType) {\n    if (isDef(data) && isDef(data.__ob__)) {\n      \"development\" !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n      return createEmptyVNode();\n    } // object syntax in v-bind\n\n\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode();\n    } // warn against non-primitive key\n\n\n    if (\"development\" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {\n      {\n        warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);\n      }\n    } // support single function children as default scoped slot\n\n\n    if (Array.isArray(children) && typeof children[0] === 'function') {\n      data = data || {};\n      data.scopedSlots = {\n        default: children[0]\n      };\n      children.length = 0;\n    }\n\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n\n    var vnode, ns;\n\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);\n\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n      } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(tag, data, children, undefined, undefined, context);\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n\n    if (Array.isArray(vnode)) {\n      return vnode;\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) {\n        applyNS(vnode, ns);\n      }\n\n      if (isDef(data)) {\n        registerDeepBindings(data);\n      }\n\n      return vnode;\n    } else {\n      return createEmptyVNode();\n    }\n  }\n\n  function applyNS(vnode, ns, force) {\n    vnode.ns = ns;\n\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n\n        if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force) && child.tag !== 'svg')) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  } // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n\n\n  function registerDeepBindings(data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n  /*  */\n\n\n  function initRender(vm) {\n    vm._vnode = null; // the root of the child tree\n\n    vm._staticTrees = null; // v-once cached trees\n\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject; // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n\n    vm._c = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, false);\n    }; // normalization is always applied for the public version, used in\n    // user-written render functions.\n\n\n    vm.$createElement = function (a, b, c, d) {\n      return createElement(vm, a, b, c, d, true);\n    }; // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n\n\n    var parentData = parentVnode && parentVnode.data;\n    /* istanbul ignore else */\n\n    {\n      defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  function renderMixin(Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this);\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode; // reset _rendered flag on slots for duplicate slot check\n\n      {\n        for (var key in vm.$slots) {\n          // $flow-disable-line\n          vm.$slots[key]._rendered = false;\n        }\n      }\n\n      if (_parentVnode) {\n        vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;\n      } // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n\n\n      vm.$vnode = _parentVnode; // render self\n\n      var vnode;\n\n      try {\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\"); // return error render result,\n        // or previous vnode to prevent render error causing blank component\n\n        /* istanbul ignore else */\n\n        {\n          if (vm.$options.renderError) {\n            try {\n              vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n            } catch (e) {\n              handleError(e, vm, \"renderError\");\n              vnode = vm._vnode;\n            }\n          } else {\n            vnode = vm._vnode;\n          }\n        }\n      } // return empty vnode in case the render function errored out\n\n\n      if (!(vnode instanceof VNode)) {\n        if (\"development\" !== 'production' && Array.isArray(vnode)) {\n          warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n        }\n\n        vnode = createEmptyVNode();\n      } // set parent\n\n\n      vnode.parent = _parentVnode;\n      return vnode;\n    };\n  }\n  /*  */\n\n\n  var uid$3 = 0;\n\n  function initMixin(Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this; // a uid\n\n      vm._uid = uid$3++;\n      var startTag, endTag;\n      /* istanbul ignore if */\n\n      if (\"development\" !== 'production' && config.performance && mark) {\n        startTag = \"vue-perf-start:\" + vm._uid;\n        endTag = \"vue-perf-end:\" + vm._uid;\n        mark(startTag);\n      } // a flag to avoid this being observed\n\n\n      vm._isVue = true; // merge options\n\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n      }\n      /* istanbul ignore else */\n\n\n      {\n        initProxy(vm);\n      } // expose real self\n\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n\n      callHook(vm, 'created');\n      /* istanbul ignore if */\n\n      if (\"development\" !== 'production' && config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure(\"vue \" + vm._name + \" init\", startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent(vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options); // doing this because it's faster than dynamic enumeration.\n\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n    opts._parentElm = options._parentElm;\n    opts._refElm = options._refElm;\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions(Ctor) {\n    var options = Ctor.options;\n\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions; // check if there are any late-modified/attached options (#4976)\n\n        var modifiedOptions = resolveModifiedOptions(Ctor); // update base extend options\n\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n\n    return options;\n  }\n\n  function resolveModifiedOptions(Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var extended = Ctor.extendOptions;\n    var sealed = Ctor.sealedOptions;\n\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) {\n          modified = {};\n        }\n\n        modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n      }\n    }\n\n    return modified;\n  }\n\n  function dedupe(latest, extended, sealed) {\n    // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n    // between merges\n    if (Array.isArray(latest)) {\n      var res = [];\n      sealed = Array.isArray(sealed) ? sealed : [sealed];\n      extended = Array.isArray(extended) ? extended : [extended];\n\n      for (var i = 0; i < latest.length; i++) {\n        // push original options and not sealed options to exclude duplicated options\n        if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n          res.push(latest[i]);\n        }\n      }\n\n      return res;\n    } else {\n      return latest;\n    }\n  }\n\n  function Vue(options) {\n    if (\"development\" !== 'production' && !(this instanceof Vue)) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n  /*  */\n\n  function initUse(Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = this._installedPlugins || (this._installedPlugins = []);\n\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this;\n      } // additional parameters\n\n\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n\n      installedPlugins.push(plugin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initMixin$1(Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this;\n    };\n  }\n  /*  */\n\n\n  function initExtend(Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n    /**\n     * Class inheritance\n     */\n\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId];\n      }\n\n      var name = extendOptions.name || Super.options.name;\n\n      if (\"development\" !== 'production' && name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent(options) {\n        this._init(options);\n      };\n\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super; // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      } // allow further extension/mixin/plugin usage\n\n\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use; // create asset registers, so extended classes\n      // can have their private assets too.\n\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      }); // enable recursive self-lookup\n\n      if (name) {\n        Sub.options.components[name] = Sub;\n      } // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n\n\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options); // cache constructor\n\n      cachedCtors[SuperId] = Sub;\n      return Sub;\n    };\n  }\n\n  function initProps$1(Comp) {\n    var props = Comp.options.props;\n\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1(Comp) {\n    var computed = Comp.options.computed;\n\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n  /*  */\n\n\n  function initAssetRegisters(Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if (\"development\" !== 'production' && type === 'component') {\n            validateComponentName(id);\n          }\n\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = {\n              bind: definition,\n              update: definition\n            };\n          }\n\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n  }\n  /*  */\n\n\n  function getComponentName(opts) {\n    return opts && (opts.Ctor.options.name || opts.tag);\n  }\n\n  function matches(pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1;\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1;\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name);\n    }\n    /* istanbul ignore next */\n\n\n    return false;\n  }\n\n  function pruneCache(keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n\n    for (var key in cache) {\n      var cachedNode = cache[key];\n\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry(cache, key, keys, current) {\n    var cached$$1 = cache[key];\n\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n    created: function created() {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n    destroyed: function destroyed() {\n      var this$1 = this;\n\n      for (var key in this$1.cache) {\n        pruneCacheEntry(this$1.cache, key, this$1.keys);\n      }\n    },\n    mounted: function mounted() {\n      var this$1 = this;\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) {\n          return matches(val, name);\n        });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) {\n          return !matches(val, name);\n        });\n      });\n    },\n    render: function render() {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n\n        if ( // not included\n        include && (!name || !matches(include, name)) || // excluded\n        exclude && name && matches(exclude, name)) {\n          return vnode;\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance; // make current key freshest\n\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key); // prune oldest entry\n\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n\n      return vnode || slot && slot[0];\n    }\n  };\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n    /*  */\n\n  };\n\n  function initGlobalAPI(Vue) {\n    // config\n    var configDef = {};\n\n    configDef.get = function () {\n      return config;\n    };\n\n    {\n      configDef.set = function () {\n        warn('Do not replace the Vue.config object, set individual fields instead.');\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef); // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive\n    };\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    }); // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n\n    Vue.options._base = Vue;\n    extend(Vue.options.components, builtInComponents);\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get() {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext;\n    }\n  }); // expose FunctionalRenderContext for ssr runtime helper installation\n\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n  Vue.version = '2.5.17';\n  /*  */\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n\n  var isReservedAttr = makeMap('style,class'); // attributes that should be using props for binding\n\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n\n  var mustUseProp = function (tag, type, attr) {\n    return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n  var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : '';\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false;\n  };\n  /*  */\n\n\n  function genClassForVnode(vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n\n    return renderClass(data.staticClass, data.class);\n  }\n\n  function mergeClassData(child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class) ? [child.class, parent.class] : parent.class\n    };\n  }\n\n  function renderClass(staticClass, dynamicClass) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass));\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function concat(a, b) {\n    return a ? b ? a + ' ' + b : a : b || '';\n  }\n\n  function stringifyClass(value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value);\n    }\n\n    if (isObject(value)) {\n      return stringifyObject(value);\n    }\n\n    if (typeof value === 'string') {\n      return value;\n    }\n    /* istanbul ignore next */\n\n\n    return '';\n  }\n\n  function stringifyArray(value) {\n    var res = '';\n    var stringified;\n\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) {\n          res += ' ';\n        }\n\n        res += stringified;\n      }\n    }\n\n    return res;\n  }\n\n  function stringifyObject(value) {\n    var res = '';\n\n    for (var key in value) {\n      if (value[key]) {\n        if (res) {\n          res += ' ';\n        }\n\n        res += key;\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n  var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot'); // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n\n  var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n  var isPreTag = function (tag) {\n    return tag === 'pre';\n  };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag);\n  };\n\n  function getTagNamespace(tag) {\n    if (isSVG(tag)) {\n      return 'svg';\n    } // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n\n\n    if (tag === 'math') {\n      return 'math';\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n\n  function isUnknownElement(tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true;\n    }\n\n    if (isReservedTag(tag)) {\n      return false;\n    }\n\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag];\n    }\n\n    var el = document.createElement(tag);\n\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n    } else {\n      return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n\n  function query(el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n\n      if (!selected) {\n        \"development\" !== 'production' && warn('Cannot find element: ' + el);\n        return document.createElement('div');\n      }\n\n      return selected;\n    } else {\n      return el;\n    }\n  }\n  /*  */\n\n\n  function createElement$1(tagName, vnode) {\n    var elm = document.createElement(tagName);\n\n    if (tagName !== 'select') {\n      return elm;\n    } // false or null will remove the attribute but undefined will not\n\n\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n\n    return elm;\n  }\n\n  function createElementNS(namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName);\n  }\n\n  function createTextNode(text) {\n    return document.createTextNode(text);\n  }\n\n  function createComment(text) {\n    return document.createComment(text);\n  }\n\n  function insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild(node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild(node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode(node) {\n    return node.parentNode;\n  }\n\n  function nextSibling(node) {\n    return node.nextSibling;\n  }\n\n  function tagName(node) {\n    return node.tagName;\n  }\n\n  function setTextContent(node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope(node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n  /*  */\n\n  var ref = {\n    create: function create(_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update(oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy(vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef(vnode, isRemoval) {\n    var key = vnode.data.ref;\n\n    if (!isDef(key)) {\n      return;\n    }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n\n  var emptyNode = new VNode('', {}, []);\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode(a, b) {\n    return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));\n  }\n\n  function sameInputType(a, b) {\n    if (a.tag !== 'input') {\n      return true;\n    }\n\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);\n  }\n\n  function createKeyToOldIdx(children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n\n      if (isDef(key)) {\n        map[key] = i;\n      }\n    }\n\n    return map;\n  }\n\n  function createPatchFunction(backend) {\n    var i, j;\n    var cbs = {};\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt(elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n    }\n\n    function createRmCb(childElm, listeners) {\n      function remove() {\n        if (--remove.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n\n      remove.listeners = listeners;\n      return remove;\n    }\n\n    function removeNode(el) {\n      var parent = nodeOps.parentNode(el); // element may have already been removed due to v-html / v-text\n\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1(vnode, inVPre) {\n      return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {\n        return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;\n      })) && config.isUnknownElement(vnode.tag);\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return;\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n          }\n        }\n        vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n        /* istanbul ignore if */\n\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (\"development\" !== 'production' && data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false\n          /* hydrating */\n          , parentElm, refElm);\n        } // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n\n\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n\n          return true;\n        }\n      }\n    }\n\n    function initComponent(vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n\n      vnode.elm = vnode.componentInstance.$el;\n\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode); // make sure to invoke the insert hook\n\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i; // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n\n      var innerNode = vnode;\n\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n\n          insertedVnodeQueue.push(innerNode);\n          break;\n        }\n      } // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n\n\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert(parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (ref$$1.parentNode === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren(vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable(vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n\n      return isDef(vnode.tag);\n    }\n\n    function invokeCreateHooks(vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n\n      i = vnode.data.hook; // Reuse variable\n\n      if (isDef(i)) {\n        if (isDef(i.create)) {\n          i.create(emptyNode, vnode);\n        }\n\n        if (isDef(i.insert)) {\n          insertedVnodeQueue.push(vnode);\n        }\n      }\n    } // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n\n\n    function setScope(vnode) {\n      var i;\n\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n\n          ancestor = ancestor.parent;\n        }\n      } // for slot content they should also get the scopeId from the host instance.\n\n\n      if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook(vnode) {\n      var i, j;\n      var data = vnode.data;\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) {\n          i(vnode);\n        }\n\n        for (i = 0; i < cbs.destroy.length; ++i) {\n          cbs.destroy[i](vnode);\n        }\n      }\n\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else {\n            // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook(vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        } // recursively invoke hooks on child component root node\n\n\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm; // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n\n      var canMove = !removeOnly;\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) {\n          // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) {\n          // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) {\n            oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n          }\n\n          idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n\n          if (isUndef(idxInOld)) {\n            // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys(children) {\n      var seenKeys = {};\n\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\", vnode.context);\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld(node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n\n        if (isDef(c) && sameVnode(node, c)) {\n          return i;\n        }\n      }\n    }\n\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n      if (oldVnode === vnode) {\n        return;\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n\n        return;\n      } // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n\n\n      if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return;\n      }\n\n      var i;\n      var data = vnode.data;\n\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) {\n          cbs.update[i](oldVnode, vnode);\n        }\n\n        if (isDef(i = data.hook) && isDef(i = i.update)) {\n          i(oldVnode, vnode);\n        }\n      }\n\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) {\n            updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n          }\n        } else if (isDef(ch)) {\n          if (isDef(oldVnode.text)) {\n            nodeOps.setTextContent(elm, '');\n          }\n\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n          i(oldVnode, vnode);\n        }\n      }\n    }\n\n    function invokeInsertHook(vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false; // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key'); // Note: this is a browser-only function so we can assume elms are DOM nodes.\n\n    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || data && data.pre;\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true;\n      } // assert node match\n\n\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false;\n        }\n      }\n\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) {\n          i(vnode, true\n          /* hydrating */\n          );\n        }\n\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true;\n        }\n      }\n\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (\"development\" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n\n                return false;\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break;\n                }\n\n                childNode = childNode.nextSibling;\n              } // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n\n\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (\"development\" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n\n                return false;\n              }\n            }\n          }\n        }\n\n        if (isDef(data)) {\n          var fullInvoke = false;\n\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break;\n            }\n          }\n\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n\n      return true;\n    }\n\n    function assertNodeMatch(node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3);\n      }\n    }\n\n    return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) {\n          invokeDestroyHook(oldVnode);\n        }\n\n        return;\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode;\n              } else {\n                warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n              }\n            } // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n\n\n            oldVnode = emptyNodeAt(oldVnode);\n          } // replacing existing element\n\n\n          var oldElm = oldVnode.elm;\n          var parentElm$1 = nodeOps.parentNode(oldElm); // create new node\n\n          createElm(vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm)); // update parent placeholder node element, recursively\n\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n\n              ancestor.elm = vnode.elm;\n\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                } // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n\n\n                var insert = ancestor.data.hook.insert;\n\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n\n              ancestor = ancestor.parent;\n            }\n          } // destroy old node\n\n\n          if (isDef(parentElm$1)) {\n            removeVnodes(parentElm$1, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm;\n    };\n  }\n  /*  */\n\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives(vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives(oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update(oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n    var key, oldDir, dir;\n\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        callHook$1(dir, 'update', vnode, oldVnode);\n\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1(dirs, vm) {\n    var res = Object.create(null);\n\n    if (!dirs) {\n      // $flow-disable-line\n      return res;\n    }\n\n    var i, dir;\n\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    } // $flow-disable-line\n\n\n    return res;\n  }\n\n  function getRawDirName(dir) {\n    return dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n  }\n\n  function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n      }\n    }\n  }\n\n  var baseModules = [ref, directives];\n  /*  */\n\n  function updateAttrs(oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return;\n    }\n\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return;\n    }\n\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    } // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n\n    /* istanbul ignore if */\n\n\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr(el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr(el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n\n      /* istanbul ignore if */\n      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n\n        el.addEventListener('input', blocker); // $flow-disable-line\n\n        el.__ieph = true;\n        /* IE placeholder patched */\n      }\n\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n    /*  */\n\n  };\n\n  function updateClass(oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n      return;\n    }\n\n    var cls = genClassForVnode(vnode); // handle transition classes\n\n    var transitionClass = el._transitionClasses;\n\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    } // set the class\n\n\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n    /*  */\n\n  };\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters(exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) {\n          inSingle = false;\n        }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) {\n          inDouble = false;\n        }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) {\n          inTemplateString = false;\n        }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) {\n          inRegex = false;\n        }\n      } else if (c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;\n            break;\n          // \"\n\n          case 0x27:\n            inSingle = true;\n            break;\n          // '\n\n          case 0x60:\n            inTemplateString = true;\n            break;\n          // `\n\n          case 0x28:\n            paren++;\n            break;\n          // (\n\n          case 0x29:\n            paren--;\n            break;\n          // )\n\n          case 0x5B:\n            square++;\n            break;\n          // [\n\n          case 0x5D:\n            square--;\n            break;\n          // ]\n\n          case 0x7B:\n            curly++;\n            break;\n          // {\n\n          case 0x7D:\n            curly--;\n            break;\n          // }\n        }\n\n        if (c === 0x2f) {\n          // /\n          var j = i - 1;\n          var p = void 0; // find first non-whitespace prev char\n\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n\n            if (p !== ' ') {\n              break;\n            }\n          }\n\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter() {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression;\n  }\n\n  function wrapFilter(exp, filter) {\n    var i = filter.indexOf('(');\n\n    if (i < 0) {\n      // _f: resolveFilter\n      return \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return \"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args);\n    }\n  }\n  /*  */\n\n\n  function baseWarn(msg) {\n    console.error(\"[Vue compiler]: \" + msg);\n  }\n\n  function pluckModuleFunction(modules, key) {\n    return modules ? modules.map(function (m) {\n      return m[key];\n    }).filter(function (_) {\n      return _;\n    }) : [];\n  }\n\n  function addProp(el, name, value) {\n    (el.props || (el.props = [])).push({\n      name: name,\n      value: value\n    });\n    el.plain = false;\n  }\n\n  function addAttr(el, name, value) {\n    (el.attrs || (el.attrs = [])).push({\n      name: name,\n      value: value\n    });\n    el.plain = false;\n  } // add a raw attr (use this in preTransforms)\n\n\n  function addRawAttr(el, name, value) {\n    el.attrsMap[name] = value;\n    el.attrsList.push({\n      name: name,\n      value: value\n    });\n  }\n\n  function addDirective(el, name, rawName, value, arg, modifiers) {\n    (el.directives || (el.directives = [])).push({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      modifiers: modifiers\n    });\n    el.plain = false;\n  }\n\n  function addHandler(el, name, value, modifiers, important, warn) {\n    modifiers = modifiers || emptyObject; // warn prevent and passive modifier\n\n    /* istanbul ignore if */\n\n    if (\"development\" !== 'production' && warn && modifiers.prevent && modifiers.passive) {\n      warn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n    } // check capture modifier\n\n\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = '!' + name; // mark the event as captured\n    }\n\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = '~' + name; // mark the event as once\n    }\n    /* istanbul ignore if */\n\n\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = '&' + name; // mark the event as passive\n    } // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n\n\n    if (name === 'click') {\n      if (modifiers.right) {\n        name = 'contextmenu';\n        delete modifiers.right;\n      } else if (modifiers.middle) {\n        name = 'mouseup';\n      }\n    }\n\n    var events;\n\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = {\n      value: value.trim()\n    };\n\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getBindingAttr(el, name, getStatic) {\n    var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue);\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n\n      if (staticValue != null) {\n        return JSON.stringify(staticValue);\n      }\n    }\n  } // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n\n\n  function getAndRemoveAttr(el, name, removeFromMap) {\n    var val;\n\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n\n    return val;\n  }\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n\n\n  function genComponentModel(el, value, modifiers) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n\n    if (trim) {\n      valueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var assignment = genAssignmentCode(value, valueExpression);\n    el.model = {\n      value: \"(\" + value + \")\",\n      expression: \"\\\"\" + value + \"\\\"\",\n      callback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n    };\n  }\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n\n\n  function genAssignmentCode(value, assignment) {\n    var res = parseModel(value);\n\n    if (res.key === null) {\n      return value + \"=\" + assignment;\n    } else {\n      return \"$set(\" + res.exp + \", \" + res.key + \", \" + assignment + \")\";\n    }\n  }\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n\n  var len;\n  var str;\n  var chr;\n  var index$1;\n  var expressionPos;\n  var expressionEndPos;\n\n  function parseModel(val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        };\n      } else {\n        return {\n          exp: val,\n          key: null\n        };\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    };\n  }\n\n  function next() {\n    return str.charCodeAt(++index$1);\n  }\n\n  function eof() {\n    return index$1 >= len;\n  }\n\n  function isStringStart(chr) {\n    return chr === 0x22 || chr === 0x27;\n  }\n\n  function parseBracket(chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n\n    while (!eof()) {\n      chr = next();\n\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue;\n      }\n\n      if (chr === 0x5B) {\n        inBracket++;\n      }\n\n      if (chr === 0x5D) {\n        inBracket--;\n      }\n\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break;\n      }\n    }\n  }\n\n  function parseString(chr) {\n    var stringQuote = chr;\n\n    while (!eof()) {\n      chr = next();\n\n      if (chr === stringQuote) {\n        break;\n      }\n    }\n  }\n  /*  */\n\n\n  var warn$1; // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model(el, dir, _warn) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers); // component v-model doesn't need extra runtime\n\n      return false;\n    } else {\n      warn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n    } // ensure runtime directive metadata\n\n\n    return true;\n  }\n\n  function genCheckboxModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n    addHandler(el, 'change', \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$el.checked){$$i<0&&(\" + genAssignmentCode(value, '$$a.concat([$$v])') + \")}\" + \"else{$$i>-1&&(\" + genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))') + \")}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n  }\n\n  function genRadioModel(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n    addProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect(el, value, modifiers) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + genAssignmentCode(value, assignment);\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel(el, value, modifiers) {\n    var type = el.attrsMap.type; // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" + 'because the latter already expands to a value binding internally');\n      }\n    }\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n    var valueExpression = '$event.target.value';\n\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', \"(\" + value + \")\");\n    addHandler(el, event, code, null, true);\n\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n  /*  */\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n\n\n  function normalizeEvents(on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    } // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n\n    /* istanbul ignore if */\n\n\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler(handler, event, capture) {\n    var _target = target$1; // save current target element in closure\n\n    return function onceHandler() {\n      var res = handler.apply(null, arguments);\n\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    };\n  }\n\n  function add$1(event, handler, once$$1, capture, passive) {\n    handler = withMacroTask(handler);\n\n    if (once$$1) {\n      handler = createOnceHandler(handler, event, capture);\n    }\n\n    target$1.addEventListener(event, handler, supportsPassive ? {\n      capture: capture,\n      passive: passive\n    } : capture);\n  }\n\n  function remove$2(event, handler, capture, _target) {\n    (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);\n  }\n\n  function updateDOMListeners(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return;\n    }\n\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n    /*  */\n\n  };\n\n  function updateDOMProps(oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return;\n    }\n\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {}; // clone observed objects, as the user probably wants to mutate it\n\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (isUndef(props[key])) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key]; // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) {\n          vnode.children.length = 0;\n        }\n\n        if (cur === oldProps[key]) {\n          continue;\n        } // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n\n\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur; // avoid resetting cursor position when value is the same\n\n        var strCur = isUndef(cur) ? '' : String(cur);\n\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else {\n        elm[key] = cur;\n      }\n    }\n  } // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue(elm, checkVal) {\n    return !elm.composing && (elm.tagName === 'OPTION' || isNotInFocusAndDirty(elm, checkVal) || isDirtyWithModifiers(elm, checkVal));\n  }\n\n  function isNotInFocusAndDirty(elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true; // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n\n    try {\n      notInFocus = document.activeElement !== elm;\n    } catch (e) {}\n\n    return notInFocus && elm.value !== checkVal;\n  }\n\n  function isDirtyWithModifiers(elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n\n    if (isDef(modifiers)) {\n      if (modifiers.lazy) {\n        // inputs with lazy should only be updated when not in focus\n        return false;\n      }\n\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal);\n      }\n\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim();\n      }\n    }\n\n    return value !== newVal;\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n    /*  */\n\n  };\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res;\n  }); // merge static and dynamic style data on the same vnode\n\n  function normalizeStyleData(data) {\n    var style = normalizeStyleBinding(data.style); // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n\n    return data.staticStyle ? extend(data.staticStyle, style) : style;\n  } // normalize possible array / string values into Object\n\n\n  function normalizeStyleBinding(bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle);\n    }\n\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle);\n    }\n\n    return bindingStyle;\n  }\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n\n\n  function getStyle(vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n\n        if (childNode && childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if (styleData = normalizeStyleData(vnode.data)) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n\n    while (parentNode = parentNode.parent) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n\n    return res;\n  }\n  /*  */\n\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n\n    if (prop !== 'filter' && prop in emptyStyle) {\n      return prop;\n    }\n\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n\n      if (name in emptyStyle) {\n        return name;\n      }\n    }\n  });\n\n  function updateStyle(oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n      return;\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {}; // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n    var style = normalizeStyleBinding(vnode.data.style) || {}; // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n\n    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n\n    for (name in newStyle) {\n      cur = newStyle[name];\n\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n    /*  */\n\n    /**\n     * Add class with compatibility for SVG since classList is not supported on\n     * SVG elements in IE\n     */\n\n  };\n\n  function addClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.add(c);\n        });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n\n\n  function removeClass(el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(/\\s+/).forEach(function (c) {\n          return el.classList.remove(c);\n        });\n      } else {\n        el.classList.remove(cls);\n      }\n\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n\n      cur = cur.trim();\n\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n  /*  */\n\n\n  function resolveTransition(def) {\n    if (!def) {\n      return;\n    }\n    /* istanbul ignore else */\n\n\n    if (typeof def === 'object') {\n      var res = {};\n\n      if (def.css !== false) {\n        extend(res, autoCssTransition(def.name || 'v'));\n      }\n\n      extend(res, def);\n      return res;\n    } else if (typeof def === 'string') {\n      return autoCssTransition(def);\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: name + \"-enter\",\n      enterToClass: name + \"-enter-to\",\n      enterActiveClass: name + \"-enter-active\",\n      leaveClass: name + \"-leave\",\n      leaveToClass: name + \"-leave-to\",\n      leaveActiveClass: name + \"-leave-active\"\n    };\n  });\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation'; // Transition property/event sniffing\n\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n\n    if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  } // binding to window is necessary to make hot reload work in IE in strict mode\n\n\n  var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout :\n  /* istanbul ignore next */\n  function (fn) {\n    return fn();\n  };\n\n  function nextFrame(fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass(el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass(el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds(el, expectedType, cb) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n\n    if (!type) {\n      return cb();\n    }\n\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo(el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n    var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = styles[animationProp + 'Delay'].split(', ');\n    var animationDurations = styles[animationProp + 'Duration'].split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n    }\n\n    var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    };\n  }\n\n  function getTimeout(delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i]);\n    }));\n  }\n\n  function toMs(s) {\n    return Number(s.slice(0, -1)) * 1000;\n  }\n  /*  */\n\n\n  function enter(vnode, toggleDisplay) {\n    var el = vnode.elm; // call leave callback now\n\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data)) {\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration; // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n\n    while (transitionNode && transitionNode.parent) {\n      transitionNode = transitionNode.parent;\n      context = transitionNode.context;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return;\n    }\n\n    var startClass = isAppear && appearClass ? appearClass : enterClass;\n    var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n    var toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n    var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n    var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n    var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n    var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n    var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n    if (\"development\" !== 'production' && explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\n        if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n          pendingNode.elm._leaveCb();\n        }\n\n        enterHook && enterHook(el, cb);\n      });\n    } // start enter transition\n\n\n    beforeEnterHook && beforeEnterHook(el);\n\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave(vnode, rm) {\n    var el = vnode.elm; // call enter callback now\n\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm();\n    }\n    /* istanbul ignore if */\n\n\n    if (isDef(el._leaveCb)) {\n      return;\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n    var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n    if (\"development\" !== 'production' && isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave() {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return;\n      } // record leaving element\n\n\n      if (!vnode.data.show) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n      }\n\n      beforeLeave && beforeLeave(el);\n\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n\n      leave && leave(el, cb);\n\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  } // only used in dev mode\n\n\n  function checkDuration(val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n    } else if (isNaN(val)) {\n      warn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n    }\n  }\n\n  function isValidDuration(val) {\n    return typeof val === 'number' && !isNaN(val);\n  }\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n\n\n  function getHookArgumentsLength(fn) {\n    if (isUndef(fn)) {\n      return false;\n    }\n\n    var invokerFns = fn.fns;\n\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n    } else {\n      return (fn._length || fn.length) > 1;\n    }\n  }\n\n  function _enter(_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1(vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n  var platformModules = [attrs, klass, events, domProps, style, transition];\n  /*  */\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n\n  var modules = platformModules.concat(baseModules);\n  var patch = createPatchFunction({\n    nodeOps: nodeOps,\n    modules: modules\n  });\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted(el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd); // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n    componentUpdated: function componentUpdated(el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n\n        if (curOptions.some(function (o, i) {\n          return !looseEqual(o, prevOptions[i]);\n        })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple ? binding.value.some(function (v) {\n            return hasNoMatchingOption(v, curOptions);\n          }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected(el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected(el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n\n    if (isMultiple && !Array.isArray(value)) {\n      \"development\" !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n      return;\n    }\n\n    var selected, option;\n\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n\n          return;\n        }\n      }\n    }\n\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption(value, options) {\n    return options.every(function (o) {\n      return !looseEqual(o, value);\n    });\n  }\n\n  function getValue(option) {\n    return '_value' in option ? option._value : option.value;\n  }\n\n  function onCompositionStart(e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd(e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) {\n      return;\n    }\n\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger(el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n  /*  */\n  // recursively search for possible transition defined inside the component root\n\n\n  function locateNode(vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n  }\n\n  var show = {\n    bind: function bind(el, ref, vnode) {\n      var value = ref.value;\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n    update: function update(el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n      /* istanbul ignore if */\n\n      if (!value === !oldValue) {\n        return;\n      }\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n\n      if (transition$$1) {\n        vnode.data.show = true;\n\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n    unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n  var platformDirectives = {\n    model: directive,\n    show: show\n    /*  */\n    // Provides transition support for a single element/component.\n    // supports transition mode (out-in / in-out)\n\n  };\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  }; // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n\n  function getRealChild(vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children));\n    } else {\n      return vnode;\n    }\n  }\n\n  function extractTransitionData(comp) {\n    var data = {};\n    var options = comp.$options; // props\n\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    } // events.\n    // extract listeners and pass them directly to the transition methods\n\n\n    var listeners = options._parentListeners;\n\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n\n    return data;\n  }\n\n  function placeholder(h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      });\n    }\n  }\n\n  function hasParentTransition(vnode) {\n    while (vnode = vnode.parent) {\n      if (vnode.data.transition) {\n        return true;\n      }\n    }\n  }\n\n  function isSameChild(child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag;\n  }\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n    render: function render(h) {\n      var this$1 = this;\n      var children = this.$slots.default;\n\n      if (!children) {\n        return;\n      } // filter out text nodes (possible whitespaces)\n\n\n      children = children.filter(function (c) {\n        return c.tag || isAsyncPlaceholder(c);\n      });\n      /* istanbul ignore if */\n\n      if (!children.length) {\n        return;\n      } // warn multiple elements\n\n\n      if (\"development\" !== 'production' && children.length > 1) {\n        warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n      }\n\n      var mode = this.mode; // warn invalid mode\n\n      if (\"development\" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n        warn('invalid <transition> mode: ' + mode, this.$parent);\n      }\n\n      var rawChild = children[0]; // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild;\n      } // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n\n\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n\n      if (!child) {\n        return rawChild;\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild);\n      } // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n\n\n      var id = \"__transition-\" + this._uid + \"-\";\n      child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild); // mark v-show\n      // so that the transition module can hand over the control to the directive\n\n      if (child.data.directives && child.data.directives.some(function (d) {\n        return d.name === 'show';\n      })) {\n        child.data.show = true;\n      }\n\n      if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) && // #6687 component root is a comment node\n      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data); // handle transition mode\n\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild);\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild;\n          }\n\n          var delayedLeave;\n\n          var performLeave = function () {\n            delayedLeave();\n          };\n\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n            delayedLeave = leave;\n          });\n        }\n      }\n\n      return rawChild;\n    }\n    /*  */\n    // Provides transition support for list items.\n    // supports move transitions using the FLIP technique.\n    // Because the vdom's children update algorithm is \"unstable\" - i.e.\n    // it doesn't guarantee the relative positioning of removed elements,\n    // we force transition-group to update its children into two passes:\n    // in the first pass, we remove all nodes that need to be removed,\n    // triggering their leaving transition; in the second pass, we insert/move\n    // into the final desired state. This way in the second pass removed\n    // nodes will remain where they should be.\n\n  };\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n  delete props.mode;\n  var TransitionGroup = {\n    props: props,\n    render: function render(h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c;\n            (c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n            warn(\"<transition-group> children must be keyed: <\" + name + \">\");\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children);\n    },\n    beforeUpdate: function beforeUpdate() {\n      // force removing pass\n      this.__patch__(this._vnode, this.kept, false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n      );\n\n      this._vnode = this.kept;\n    },\n    updated: function updated() {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || (this.name || 'v') + '-move';\n\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return;\n      } // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n\n\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation); // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n\n      this._reflow = document.body.offsetHeight;\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n    methods: {\n      hasMove: function hasMove(el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false;\n        }\n        /* istanbul ignore if */\n\n\n        if (this._hasMove) {\n          return this._hasMove;\n        } // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n\n\n        var clone = el.cloneNode();\n\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) {\n            removeClass(clone, cls);\n          });\n        }\n\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return this._hasMove = info.hasTransform;\n      }\n    }\n  };\n\n  function callPendingCbs(c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n\n\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition(c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation(c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n    /*  */\n    // install platform specific utils\n\n  };\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement; // install platform runtime directives & components\n\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents); // install platform patch function\n\n  Vue.prototype.__patch__ = inBrowser ? patch : noop; // public mount method\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating);\n  }; // devtools global hook\n\n  /* istanbul ignore next */\n\n\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else if (\"development\" !== 'production' && \"development\" !== 'test' && isChrome) {\n          console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n        }\n      }\n\n      if (\"development\" !== 'production' && \"development\" !== 'test' && config.productionTip !== false && typeof console !== 'undefined') {\n        console[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n      }\n    }, 0);\n  }\n  /*  */\n\n\n  var defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n  });\n\n  function parseText(text, delimiters) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\n    if (!tagRE.test(text)) {\n      return;\n    }\n\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n\n    while (match = tagRE.exec(text)) {\n      index = match.index; // push text token\n\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      } // tag token\n\n\n      var exp = parseFilters(match[1].trim());\n      tokens.push(\"_s(\" + exp + \")\");\n      rawTokens.push({\n        '@binding': exp\n      });\n      lastIndex = index + match[0].length;\n    }\n\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    };\n  }\n  /*  */\n\n\n  function transformNode(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n\n    if (\"development\" !== 'production' && staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n\n      if (res) {\n        warn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n      }\n    }\n\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n\n    var classBinding = getBindingAttr(el, 'class', false\n    /* getStatic */\n    );\n\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData(el) {\n    var data = '';\n\n    if (el.staticClass) {\n      data += \"staticClass:\" + el.staticClass + \",\";\n    }\n\n    if (el.classBinding) {\n      data += \"class:\" + el.classBinding + \",\";\n    }\n\n    return data;\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n    /*  */\n\n  };\n\n  function transformNode$1(el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n\n        if (res) {\n          warn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false\n    /* getStatic */\n    );\n\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1(el) {\n    var data = '';\n\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + el.staticStyle + \",\";\n    }\n\n    if (el.styleBinding) {\n      data += \"style:(\" + el.styleBinding + \"),\";\n    }\n\n    return data;\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n    /*  */\n\n  };\n  var decoder;\n  var he = {\n    decode: function decode(html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent;\n    }\n    /*  */\n\n  };\n  var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr'); // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n\n  var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'); // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\n  var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  /*!\n   * HTML Parser By John Resig (ejohn.org)\n   * Modified by Juriy \"kangax\" Zaytsev\n   * Original code by Erik Arvidsson, Mozilla Public License\n   * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n   */\n  // Regular Expressions for parsing tags and attributes\n\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n  // but for Vue templates we can enforce a simple charset\n\n  var ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp(\"^<\" + qnameCapture);\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp(\"^<\\\\/\" + qnameCapture + \"[^>]*>\");\n  var doctype = /^<!DOCTYPE [^>]+>/i; // #7298: escape - to avoid being pased as HTML comment when inlined in page\n\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/;\n  var IS_REGEX_CAPTURING_BROKEN = false;\n  'x'.replace(/x(.)?/g, function (m, g) {\n    IS_REGEX_CAPTURING_BROKEN = g === '';\n  }); // Special Elements (can contain anything)\n\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t'\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g; // #5992\n\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n\n  var shouldIgnoreFirstNewline = function (tag, html) {\n    return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n';\n  };\n\n  function decodeAttr(value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) {\n      return decodingMap[match];\n    });\n  }\n\n  function parseHTML(html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n\n    while (html) {\n      last = html; // Make sure we're not in a plaintext content element like script/style\n\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('--\x3e');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd));\n              }\n\n              advance(commentEnd + 3);\n              continue;\n            }\n          } // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\n\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue;\n            }\n          } // Doctype:\n\n\n          var doctypeMatch = html.match(doctype);\n\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue;\n          } // End tag:\n\n\n          var endTagMatch = html.match(endTag);\n\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue;\n          } // Start tag:\n\n\n          var startTagMatch = parseStartTag();\n\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n\n            if (shouldIgnoreFirstNewline(lastTag, html)) {\n              advance(1);\n            }\n\n            continue;\n          }\n        }\n\n        var text = void 0,\n            rest = void 0,\n            next = void 0;\n\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n\n          while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n\n            if (next < 0) {\n              break;\n            }\n\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n\n          text = html.substring(0, textEnd);\n          advance(textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n          html = '';\n        }\n\n        if (options.chars && text) {\n          options.chars(text);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text.replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n\n          if (options.chars) {\n            options.chars(text);\n          }\n\n          return '';\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n\n        if (\"development\" !== 'production' && !stack.length && options.warn) {\n          options.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n        }\n\n        break;\n      }\n    } // Clean up any remaining tags\n\n\n    parseEndTag();\n\n    function advance(n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag() {\n      var start = html.match(startTagOpen);\n\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n\n        while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n          advance(attr[0].length);\n          match.attrs.push(attr);\n        }\n\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match;\n        }\n      }\n    }\n\n    function handleStartTag(match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i]; // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n\n        if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n          if (args[3] === '') {\n            delete args[3];\n          }\n\n          if (args[4] === '') {\n            delete args[4];\n          }\n\n          if (args[5] === '') {\n            delete args[5];\n          }\n        }\n\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n      }\n\n      if (!unary) {\n        stack.push({\n          tag: tagName,\n          lowerCasedTag: tagName.toLowerCase(),\n          attrs: attrs\n        });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag(tagName, start, end) {\n      var pos, lowerCasedTagName;\n\n      if (start == null) {\n        start = index;\n      }\n\n      if (end == null) {\n        end = index;\n      }\n\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n      } // Find the closest opened tag of the same type\n\n\n      if (tagName) {\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break;\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (\"development\" !== 'production' && (i > pos || !tagName) && options.warn) {\n            options.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n          }\n\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        } // Remove the open elements from the stack\n\n\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n  /*  */\n\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([^]*?)\\s+(?:in|of)\\s+([^]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^v-bind:/;\n  var modifierRE = /\\.[^.]+/g;\n  var decodeHTMLCached = cached(he.decode); // configurable state\n\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n\n  function createASTElement(tag, attrs, parent) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      parent: parent,\n      children: []\n    };\n  }\n  /**\n   * Convert HTML string to AST.\n   */\n\n\n  function parse(template, options) {\n    warn$2 = options.warn || baseWarn;\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n    delimiters = options.delimiters;\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce(msg) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg);\n      }\n    }\n\n    function closeElement(element) {\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      } // apply post-transforms\n\n\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      start: function start(tag, attrs, unary) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag); // handle IE svg bug\n\n        /* istanbul ignore if */\n\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n\n        if (ns) {\n          element.ns = ns;\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          \"development\" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n        } // apply pre-transforms\n\n\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element); // element-scope stuff\n\n          processElement(element, options);\n        }\n\n        function checkRootConstraints(el) {\n          {\n            if (el.tag === 'slot' || el.tag === 'template') {\n              warnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n            }\n\n            if (el.attrsMap.hasOwnProperty('v-for')) {\n              warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n            }\n          }\n        } // tree management\n\n\n        if (!root) {\n          root = element;\n          checkRootConstraints(root);\n        } else if (!stack.length) {\n          // allow root elements with v-if, v-else-if and v-else\n          if (root.if && (element.elseif || element.else)) {\n            checkRootConstraints(element);\n            addIfCondition(root, {\n              exp: element.elseif,\n              block: element\n            });\n          } else {\n            warnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n          }\n        }\n\n        if (currentParent && !element.forbidden) {\n          if (element.elseif || element.else) {\n            processIfConditions(element, currentParent);\n          } else if (element.slotScope) {\n            // scoped slot\n            currentParent.plain = false;\n            var name = element.slotTarget || '\"default\"';\n            (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          } else {\n            currentParent.children.push(element);\n            element.parent = currentParent;\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n      end: function end() {\n        // remove trailing whitespace\n        var element = stack[stack.length - 1];\n        var lastNode = element.children[element.children.length - 1];\n\n        if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n          element.children.pop();\n        } // pop stack\n\n\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        closeElement(element);\n      },\n      chars: function chars(text) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce('Component template requires a root element, rather than just text.');\n            } else if (text = text.trim()) {\n              warnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n            }\n          }\n          return;\n        } // IE textarea placeholder bug\n\n        /* istanbul ignore if */\n\n\n        if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n          return;\n        }\n\n        var children = currentParent.children;\n        text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text) // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n\n        if (text) {\n          var res;\n\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            children.push({\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            });\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            children.push({\n              type: 3,\n              text: text\n            });\n          }\n        }\n      },\n      comment: function comment(text) {\n        currentParent.children.push({\n          type: 3,\n          text: text,\n          isComment: true\n        });\n      }\n    });\n    return root;\n  }\n\n  function processPre(el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs(el) {\n    var l = el.attrsList.length;\n\n    if (l) {\n      var attrs = el.attrs = new Array(l);\n\n      for (var i = 0; i < l; i++) {\n        attrs[i] = {\n          name: el.attrsList[i].name,\n          value: JSON.stringify(el.attrsList[i].value)\n        };\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement(element, options) {\n    processKey(element); // determine whether this is a plain element after\n    // removing structural attributes\n\n    element.plain = !element.key && !element.attrsList.length;\n    processRef(element);\n    processSlot(element);\n    processComponent(element);\n\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n\n    processAttrs(element);\n  }\n\n  function processKey(el) {\n    var exp = getBindingAttr(el, 'key');\n\n    if (exp) {\n      if (\"development\" !== 'production' && el.tag === 'template') {\n        warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n      }\n\n      el.key = exp;\n    }\n  }\n\n  function processRef(el) {\n    var ref = getBindingAttr(el, 'ref');\n\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor(el) {\n    var exp;\n\n    if (exp = getAndRemoveAttr(el, 'v-for')) {\n      var res = parseFor(exp);\n\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\"Invalid v-for expression: \" + exp);\n      }\n    }\n  }\n\n  function parseFor(exp) {\n    var inMatch = exp.match(forAliasRE);\n\n    if (!inMatch) {\n      return;\n    }\n\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '');\n      res.iterator1 = iteratorMatch[1].trim();\n\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n\n    return res;\n  }\n\n  function processIf(el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions(el, parent) {\n    var prev = findPrevElement(parent.children);\n\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n    }\n  }\n\n  function findPrevElement(children) {\n    var i = children.length;\n\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i];\n      } else {\n        if (\"development\" !== 'production' && children[i].text !== ' ') {\n          warn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n        }\n\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition(el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce(el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  function processSlot(el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n\n      if (\"development\" !== 'production' && el.key) {\n        warn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n      }\n    } else {\n      var slotScope;\n\n      if (el.tag === 'template') {\n        slotScope = getAndRemoveAttr(el, 'scope');\n        /* istanbul ignore if */\n\n        if (\"development\" !== 'production' && slotScope) {\n          warn$2(\"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" + \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" + \"can also be used on plain elements in addition to <template> to \" + \"denote scoped slots.\", true);\n        }\n\n        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n      } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && el.attrsMap['v-for']) {\n          warn$2(\"Ambiguous combined usage of slot-scope and v-for on <\" + el.tag + \"> \" + \"(v-for takes higher priority). Use a wrapper <template> for the \" + \"scoped slot to make it clearer.\", true);\n        }\n\n        el.slotScope = slotScope;\n      }\n\n      var slotTarget = getBindingAttr(el, 'slot');\n\n      if (slotTarget) {\n        el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget; // preserve slot as an attribute for native shadow DOM compat\n        // only for non-scoped slots.\n\n        if (el.tag !== 'template' && !el.slotScope) {\n          addAttr(el, 'slot', slotTarget);\n        }\n      }\n    }\n  }\n\n  function processComponent(el) {\n    var binding;\n\n    if (binding = getBindingAttr(el, 'is')) {\n      el.component = binding;\n    }\n\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs(el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, isProp;\n\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true; // modifiers\n\n        modifiers = parseModifiers(name);\n\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n\n        if (bindRE.test(name)) {\n          // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isProp = false;\n\n          if (modifiers) {\n            if (modifiers.prop) {\n              isProp = true;\n              name = camelize(name);\n\n              if (name === 'innerHtml') {\n                name = 'innerHTML';\n              }\n            }\n\n            if (modifiers.camel) {\n              name = camelize(name);\n            }\n\n            if (modifiers.sync) {\n              addHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n            }\n          }\n\n          if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n            addProp(el, name, value);\n          } else {\n            addAttr(el, name, value);\n          }\n        } else if (onRE.test(name)) {\n          // v-on\n          name = name.replace(onRE, '');\n          addHandler(el, name, value, modifiers, false, warn$2);\n        } else {\n          // normal directives\n          name = name.replace(dirRE, ''); // parse arg\n\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n          }\n\n          addDirective(el, name, rawName, value, arg, modifiers);\n\n          if (\"development\" !== 'production' && name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n\n          if (res) {\n            warn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n          }\n        }\n        addAttr(el, name, JSON.stringify(value)); // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n\n        if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true');\n        }\n      }\n    }\n  }\n\n  function checkInFor(el) {\n    var parent = el;\n\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true;\n      }\n\n      parent = parent.parent;\n    }\n\n    return false;\n  }\n\n  function parseModifiers(name) {\n    var match = name.match(modifierRE);\n\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) {\n        ret[m.slice(1)] = true;\n      });\n      return ret;\n    }\n  }\n\n  function makeAttrsMap(attrs) {\n    var map = {};\n\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\"development\" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n        warn$2('duplicate attribute: ' + attrs[i].name);\n      }\n\n      map[attrs[i].name] = attrs[i].value;\n    }\n\n    return map;\n  } // for script (e.g. type=\"x/template\") or style, do not decode content\n\n\n  function isTextTag(el) {\n    return el.tag === 'script' || el.tag === 'style';\n  }\n\n  function isForbiddenTag(el) {\n    return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n  /* istanbul ignore next */\n\n  function guardIESVGBug(attrs) {\n    var res = [];\n\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n\n    return res;\n  }\n\n  function checkForAliasModel(el, value) {\n    var _el = el;\n\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n      }\n\n      _el = _el.parent;\n    }\n  }\n  /*  */\n\n  /**\n   * Expand input[v-model] with dyanmic type bindings into v-if-else chains\n   * Turn this:\n   *   <input v-model=\"data[type]\" :type=\"type\">\n   * into this:\n   *   <input v-if=\"type === 'checkbox'\" type=\"checkbox\" v-model=\"data[type]\">\n   *   <input v-else-if=\"type === 'radio'\" type=\"radio\" v-model=\"data[type]\">\n   *   <input v-else :type=\"type\" v-model=\"data[type]\">\n   */\n\n\n  function preTransformNode(el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n\n      if (!map['v-model']) {\n        return;\n      }\n\n      var typeBinding;\n\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + map['v-bind'] + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? \"&&(\" + ifCondition + \")\" : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true); // 1. checkbox\n\n        var branch0 = cloneASTElement(el); // process for on the main node\n\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        }); // 2. add radio else-if condition\n\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        }); // 3. other\n\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0;\n      }\n    }\n  }\n\n  function cloneASTElement(el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent);\n  }\n\n  var model$2 = {\n    preTransformNode: preTransformNode\n  };\n  var modules$1 = [klass$1, style$1, model$2];\n  /*  */\n\n  function text(el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n    }\n  }\n  /*  */\n\n\n  function html(el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n    /*  */\n\n  };\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n  var genStaticKeysCached = cached(genStaticKeys$1);\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n\n  function optimize(root, options) {\n    if (!root) {\n      return;\n    }\n\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no; // first pass: mark all non-static nodes.\n\n    markStatic$1(root); // second pass: mark static roots.\n\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1(keys) {\n    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n  }\n\n  function markStatic$1(node) {\n    node.static = isStatic(node);\n\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n        return;\n      }\n\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots(node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      } // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n\n\n      if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n        node.staticRoot = true;\n        return;\n      } else {\n        node.staticRoot = false;\n      }\n\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic(node) {\n    if (node.type === 2) {\n      // expression\n      return false;\n    }\n\n    if (node.type === 3) {\n      // text\n      return true;\n    }\n\n    return !!(node.pre || !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n  }\n\n  function isDirectChildOfTemplateFor(node) {\n    while (node.parent) {\n      node = node.parent;\n\n      if (node.tag !== 'template') {\n        return false;\n      }\n\n      if (node.for) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /*  */\n\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/; // KeyboardEvent.keyCode aliases\n\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  }; // KeyboardEvent.key aliases\n\n  var keyNames = {\n    esc: 'Escape',\n    tab: 'Tab',\n    enter: 'Enter',\n    space: ' ',\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    'delete': ['Backspace', 'Delete']\n  }; // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n\n  var genGuard = function (condition) {\n    return \"if(\" + condition + \")return null;\";\n  };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers(events, isNative, warn) {\n    var res = isNative ? 'nativeOn:{' : 'on:{';\n\n    for (var name in events) {\n      res += \"\\\"\" + name + \"\\\":\" + genHandler(name, events[name]) + \",\";\n    }\n\n    return res.slice(0, -1) + '}';\n  }\n\n  function genHandler(name, handler) {\n    if (!handler) {\n      return 'function(){}';\n    }\n\n    if (Array.isArray(handler)) {\n      return \"[\" + handler.map(function (handler) {\n        return genHandler(name, handler);\n      }).join(',') + \"]\";\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value;\n      }\n      /* istanbul ignore if */\n\n\n      return \"function($event){\" + handler.value + \"}\"; // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key]; // left/right\n\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = handler.modifiers;\n          genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {\n            return !modifiers[keyModifier];\n          }).map(function (keyModifier) {\n            return \"$event.\" + keyModifier + \"Key\";\n          }).join('||'));\n        } else {\n          keys.push(key);\n        }\n      }\n\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      } // Make sure modifiers like prevent and stop get executed after key filtering\n\n\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n\n      var handlerCode = isMethodPath ? \"return \" + handler.value + \"($event)\" : isFunctionExpression ? \"return (\" + handler.value + \")($event)\" : handler.value;\n      /* istanbul ignore if */\n\n      return \"function($event){\" + code + handlerCode + \"}\";\n    }\n  }\n\n  function genKeyFilter(keys) {\n    return \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n  }\n\n  function genFilterCode(key) {\n    var keyVal = parseInt(key, 10);\n\n    if (keyVal) {\n      return \"$event.keyCode!==\" + keyVal;\n    }\n\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return \"_k($event.keyCode,\" + JSON.stringify(key) + \",\" + JSON.stringify(keyCode) + \",\" + \"$event.key,\" + \"\" + JSON.stringify(keyName) + \")\";\n  }\n  /*  */\n\n\n  function on(el, dir) {\n    if (\"development\" !== 'production' && dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n\n    el.wrapListeners = function (code) {\n      return \"_g(\" + code + \",\" + dir.value + \")\";\n    };\n  }\n  /*  */\n\n\n  function bind$1(el, dir) {\n    el.wrapData = function (code) {\n      return \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\";\n    };\n  }\n  /*  */\n\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n    /*  */\n\n  };\n\n  var CodegenState = function CodegenState(options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n\n    this.maybeComponent = function (el) {\n      return !isReservedTag(el.tag);\n    };\n\n    this.onceId = 0;\n    this.staticRenderFns = [];\n  };\n\n  function generate(ast, options) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: \"with(this){return \" + code + \"}\",\n      staticRenderFns: state.staticRenderFns\n    };\n  }\n\n  function genElement(el, state) {\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state);\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state);\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state);\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.tag === 'template' && !el.slotTarget) {\n      return genChildren(el, state) || 'void 0';\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state);\n    } else {\n      // component or element\n      var code;\n\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data = el.plain ? undefined : genData$2(el, state);\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n      } // module transforms\n\n\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n\n      return code;\n    }\n  } // hoist static sub-trees out\n\n\n  function genStatic(el, state) {\n    el.staticProcessed = true;\n    state.staticRenderFns.push(\"with(this){return \" + genElement(el, state) + \"}\");\n    return \"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n  } // v-once\n\n\n  function genOnce(el, state) {\n    el.onceProcessed = true;\n\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state);\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break;\n        }\n\n        parent = parent.parent;\n      }\n\n      if (!key) {\n        \"development\" !== 'production' && state.warn(\"v-once can only be used inside v-for that is keyed. \");\n        return genElement(el, state);\n      }\n\n      return \"_o(\" + genElement(el, state) + \",\" + state.onceId++ + \",\" + key + \")\";\n    } else {\n      return genStatic(el, state);\n    }\n  }\n\n  function genIf(el, state, altGen, altEmpty) {\n    el.ifProcessed = true; // avoid recursion\n\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);\n  }\n\n  function genIfConditions(conditions, state, altGen, altEmpty) {\n    if (!conditions.length) {\n      return altEmpty || '_e()';\n    }\n\n    var condition = conditions.shift();\n\n    if (condition.exp) {\n      return \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions, state, altGen, altEmpty);\n    } else {\n      return \"\" + genTernaryExp(condition.block);\n    } // v-if with v-once should generate code like (a)?_m(0):_m(1)\n\n\n    function genTernaryExp(el) {\n      return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);\n    }\n  }\n\n  function genFor(el, state, altGen, altHelper) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n    if (\"development\" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n      state.warn(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true\n      /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n\n    return (altHelper || '_l') + \"((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + (altGen || genElement)(el, state) + '})';\n  }\n\n  function genData$2(el, state) {\n    var data = '{'; // directives first.\n    // directives may mutate the el's other properties before they are generated.\n\n    var dirs = genDirectives(el, state);\n\n    if (dirs) {\n      data += dirs + ',';\n    } // key\n\n\n    if (el.key) {\n      data += \"key:\" + el.key + \",\";\n    } // ref\n\n\n    if (el.ref) {\n      data += \"ref:\" + el.ref + \",\";\n    }\n\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    } // pre\n\n\n    if (el.pre) {\n      data += \"pre:true,\";\n    } // record original tag name for components using \"is\" attribute\n\n\n    if (el.component) {\n      data += \"tag:\\\"\" + el.tag + \"\\\",\";\n    } // module data generation functions\n\n\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    } // attributes\n\n\n    if (el.attrs) {\n      data += \"attrs:{\" + genProps(el.attrs) + \"},\";\n    } // DOM props\n\n\n    if (el.props) {\n      data += \"domProps:{\" + genProps(el.props) + \"},\";\n    } // event handlers\n\n\n    if (el.events) {\n      data += genHandlers(el.events, false, state.warn) + \",\";\n    }\n\n    if (el.nativeEvents) {\n      data += genHandlers(el.nativeEvents, true, state.warn) + \",\";\n    } // slot target\n    // only for non-scoped slots\n\n\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + el.slotTarget + \",\";\n    } // scoped slots\n\n\n    if (el.scopedSlots) {\n      data += genScopedSlots(el.scopedSlots, state) + \",\";\n    } // component v-model\n\n\n    if (el.model) {\n      data += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n    } // inline-template\n\n\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n\n    data = data.replace(/,$/, '') + '}'; // v-bind data wrap\n\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    } // v-on data wrap\n\n\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n\n    return data;\n  }\n\n  function genDirectives(el, state) {\n    var dirs = el.directives;\n\n    if (!dirs) {\n      return;\n    }\n\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n      }\n    }\n\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']';\n    }\n  }\n\n  function genInlineTemplate(el, state) {\n    var ast = el.children[0];\n\n    if (\"development\" !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {\n      state.warn('Inline-template components must have exactly one child element.');\n    }\n\n    if (ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n        return \"function(){\" + code + \"}\";\n      }).join(',') + \"]}\";\n    }\n  }\n\n  function genScopedSlots(slots, state) {\n    return \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state);\n    }).join(',') + \"])\";\n  }\n\n  function genScopedSlot(key, el, state) {\n    if (el.for && !el.forProcessed) {\n      return genForScopedSlot(key, el, state);\n    }\n\n    var fn = \"function(\" + String(el.slotScope) + \"){\" + \"return \" + (el.tag === 'template' ? el.if ? el.if + \"?\" + (genChildren(el, state) || 'undefined') + \":undefined\" : genChildren(el, state) || 'undefined' : genElement(el, state)) + \"}\";\n    return \"{key:\" + key + \",fn:\" + fn + \"}\";\n  }\n\n  function genForScopedSlot(key, el, state) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n    var iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n    el.forProcessed = true; // avoid recursion\n\n    return \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el, state) + '})';\n  }\n\n  function genChildren(el, state, checkSkip, altGenElement, altGenNode) {\n    var children = el.children;\n\n    if (children.length) {\n      var el$1 = children[0]; // optimize single v-for\n\n      if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n        return (altGenElement || genElement)(el$1, state);\n      }\n\n      var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;\n      var gen = altGenNode || genNode;\n      return \"[\" + children.map(function (c) {\n        return gen(c, state);\n      }).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n    }\n  } // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n\n\n  function getNormalizationType(children, maybeComponent) {\n    var res = 0;\n\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n\n      if (el.type !== 1) {\n        continue;\n      }\n\n      if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return needsNormalization(c.block);\n      })) {\n        res = 2;\n        break;\n      }\n\n      if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n        return maybeComponent(c.block);\n      })) {\n        res = 1;\n      }\n    }\n\n    return res;\n  }\n\n  function needsNormalization(el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n  }\n\n  function genNode(node, state) {\n    if (node.type === 1) {\n      return genElement(node, state);\n    }\n\n    if (node.type === 3 && node.isComment) {\n      return genComment(node);\n    } else {\n      return genText(node);\n    }\n  }\n\n  function genText(text) {\n    return \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n  }\n\n  function genComment(comment) {\n    return \"_e(\" + JSON.stringify(comment.text) + \")\";\n  }\n\n  function genSlot(el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? \",\" + children : '');\n    var attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n      return camelize(a.name) + \":\" + a.value;\n    }).join(',') + \"}\";\n    var bind$$1 = el.attrsMap['v-bind'];\n\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n\n    return res + ')';\n  } // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\n\n  function genComponent(componentName, el, state) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return \"_c(\" + componentName + \",\" + genData$2(el, state) + (children ? \",\" + children : '') + \")\";\n  }\n\n  function genProps(props) {\n    var res = '';\n\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      /* istanbul ignore if */\n\n      {\n        res += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n      }\n    }\n\n    return res.slice(0, -1);\n  } // #3895, #4268\n\n\n  function transformSpecialNewlines(text) {\n    return text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n  }\n  /*  */\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n\n\n  var prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b'); // these unary operators should not be used as property/method names\n\n  var unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)'); // strip strings in expressions\n\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g; // detect problematic expressions in a template\n\n  function detectErrors(ast) {\n    var errors = [];\n\n    if (ast) {\n      checkNode(ast, errors);\n    }\n\n    return errors;\n  }\n\n  function checkNode(node, errors) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n\n          if (value) {\n            if (name === 'v-for') {\n              checkFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n            } else if (onRE.test(name)) {\n              checkEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n            } else {\n              checkExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n            }\n          }\n        }\n      }\n\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], errors);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, errors);\n    }\n  }\n\n  function checkEvent(exp, text, errors) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      errors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n    }\n\n    checkExpression(exp, text, errors);\n  }\n\n  function checkFor(node, text, errors) {\n    checkExpression(node.for || '', text, errors);\n    checkIdentifier(node.alias, 'v-for alias', text, errors);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n  }\n\n  function checkIdentifier(ident, type, text, errors) {\n    if (typeof ident === 'string') {\n      try {\n        new Function(\"var \" + ident + \"=_\");\n      } catch (e) {\n        errors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n      }\n    }\n  }\n\n  function checkExpression(exp, text, errors) {\n    try {\n      new Function(\"return \" + exp);\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\n      if (keywordMatch) {\n        errors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\"\\n  Raw expression: \" + text.trim());\n      } else {\n        errors.push(\"invalid expression: \" + e.message + \" in\\n\\n\" + \"    \" + exp + \"\\n\\n\" + \"  Raw expression: \" + text.trim() + \"\\n\");\n      }\n    }\n  }\n  /*  */\n\n\n  function createFunction(code, errors) {\n    try {\n      return new Function(code);\n    } catch (err) {\n      errors.push({\n        err: err,\n        code: code\n      });\n      return noop;\n    }\n  }\n\n  function createCompileToFunctionFn(compile) {\n    var cache = Object.create(null);\n    return function compileToFunctions(template, options, vm) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n      /* istanbul ignore if */\n\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n          }\n        }\n      } // check cache\n\n      var key = options.delimiters ? String(options.delimiters) + template : template;\n\n      if (cache[key]) {\n        return cache[key];\n      } // compile\n\n\n      var compiled = compile(template, options); // check compilation errors/tips\n\n      {\n        if (compiled.errors && compiled.errors.length) {\n          warn$$1(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n            return \"- \" + e;\n          }).join('\\n') + '\\n', vm);\n        }\n\n        if (compiled.tips && compiled.tips.length) {\n          compiled.tips.forEach(function (msg) {\n            return tip(msg, vm);\n          });\n        }\n      } // turn code into functions\n\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors);\n      }); // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n\n      /* istanbul ignore if */\n\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n            return err.toString() + \" in\\n\\n\" + code + \"\\n\";\n          }).join('\\n'), vm);\n        }\n      }\n      return cache[key] = res;\n    };\n  }\n  /*  */\n\n\n  function createCompilerCreator(baseCompile) {\n    return function createCompiler(baseOptions) {\n      function compile(template, options) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        finalOptions.warn = function (msg, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n          } // merge custom directives\n\n\n          if (options.directives) {\n            finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);\n          } // copy other options\n\n\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        var compiled = baseCompile(template, finalOptions);\n        {\n          errors.push.apply(errors, detectErrors(compiled.ast));\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled;\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      };\n    };\n  }\n  /*  */\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n\n\n  var createCompiler = createCompilerCreator(function baseCompile(template, options) {\n    var ast = parse(template.trim(), options);\n\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    };\n  });\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compileToFunctions = ref$1.compileToFunctions;\n  /*  */\n  // check whether current browser encodes a char inside attribute values\n\n  var div;\n\n  function getShouldDecode(href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0;\n  } // #3663: IE encodes newlines inside attribute values while other browsers don't\n\n\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false; // #6828: chrome encodes content in a[href]\n\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML;\n  });\n  var mount = Vue.prototype.$mount;\n\n  Vue.prototype.$mount = function (el, hydrating) {\n    el = el && query(el);\n    /* istanbul ignore if */\n\n    if (el === document.body || el === document.documentElement) {\n      \"development\" !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n      return this;\n    }\n\n    var options = this.$options; // resolve template/el and convert to render function\n\n    if (!options.render) {\n      var template = options.template;\n\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n\n            if (\"development\" !== 'production' && !template) {\n              warn(\"Template element not found or is empty: \" + options.template, this);\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this;\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n\n      if (template) {\n        /* istanbul ignore if */\n        if (\"development\" !== 'production' && config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n        /* istanbul ignore if */\n\n        if (\"development\" !== 'production' && config.performance && mark) {\n          mark('compile end');\n          measure(\"vue \" + this._name + \" compile\", 'compile', 'compile end');\n        }\n      }\n    }\n\n    return mount.call(this, el, hydrating);\n  };\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n\n\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n  return Vue;\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../node_modules/timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL3Z1ZS5qcz82MjgyIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJtb2R1bGUiLCJleHBvcnRzIiwiZW1wdHlPYmplY3QiLCJPYmplY3QiLCJmcmVlemUiLCJpc1VuZGVmIiwidiIsInVuZGVmaW5lZCIsImlzRGVmIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzUHJpbWl0aXZlIiwidmFsdWUiLCJpc09iamVjdCIsIm9iaiIsIl90b1N0cmluZyIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwidG9SYXdUeXBlIiwiY2FsbCIsInNsaWNlIiwiaXNQbGFpbk9iamVjdCIsImlzUmVnRXhwIiwiaXNWYWxpZEFycmF5SW5kZXgiLCJ2YWwiLCJuIiwicGFyc2VGbG9hdCIsIlN0cmluZyIsIk1hdGgiLCJmbG9vciIsImlzRmluaXRlIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvTnVtYmVyIiwiaXNOYU4iLCJtYWtlTWFwIiwic3RyIiwiZXhwZWN0c0xvd2VyQ2FzZSIsIm1hcCIsImNyZWF0ZSIsImxpc3QiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJ0b0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsImlzUmVzZXJ2ZWRBdHRyaWJ1dGUiLCJyZW1vdmUiLCJhcnIiLCJpdGVtIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiaGFzT3duUHJvcGVydHkiLCJoYXNPd24iLCJrZXkiLCJjYWNoZWQiLCJmbiIsImNhY2hlIiwiY2FjaGVkRm4iLCJoaXQiLCJjYW1lbGl6ZVJFIiwiY2FtZWxpemUiLCJyZXBsYWNlIiwiXyIsImMiLCJ0b1VwcGVyQ2FzZSIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJoeXBoZW5hdGVSRSIsImh5cGhlbmF0ZSIsInBvbHlmaWxsQmluZCIsImN0eCIsImJvdW5kRm4iLCJhIiwibCIsImFyZ3VtZW50cyIsImFwcGx5IiwiX2xlbmd0aCIsIm5hdGl2ZUJpbmQiLCJiaW5kIiwiRnVuY3Rpb24iLCJ0b0FycmF5Iiwic3RhcnQiLCJyZXQiLCJBcnJheSIsImV4dGVuZCIsInRvIiwiX2Zyb20iLCJ0b09iamVjdCIsInJlcyIsIm5vb3AiLCJiIiwibm8iLCJpZGVudGl0eSIsImdlblN0YXRpY0tleXMiLCJtb2R1bGVzIiwicmVkdWNlIiwia2V5cyIsIm0iLCJjb25jYXQiLCJzdGF0aWNLZXlzIiwiam9pbiIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXkiLCJpc0FycmF5QiIsImV2ZXJ5IiwiZSIsImtleXNBIiwia2V5c0IiLCJsb29zZUluZGV4T2YiLCJvbmNlIiwiY2FsbGVkIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsImNvbmZpZyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsInBlcmZvcm1hbmNlIiwiZXJyb3JIYW5kbGVyIiwid2FybkhhbmRsZXIiLCJpZ25vcmVkRWxlbWVudHMiLCJrZXlDb2RlcyIsImlzUmVzZXJ2ZWRUYWciLCJpc1Jlc2VydmVkQXR0ciIsImlzVW5rbm93bkVsZW1lbnQiLCJnZXRUYWdOYW1lc3BhY2UiLCJwYXJzZVBsYXRmb3JtVGFnTmFtZSIsIm11c3RVc2VQcm9wIiwiX2xpZmVjeWNsZUhvb2tzIiwiaXNSZXNlcnZlZCIsImNoYXJDb2RlQXQiLCJkZWYiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydHkiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsImJhaWxSRSIsInBhcnNlUGF0aCIsInBhdGgiLCJ0ZXN0Iiwic2VnbWVudHMiLCJoYXNQcm90byIsImluQnJvd3NlciIsIndpbmRvdyIsImluV2VleCIsIldYRW52aXJvbm1lbnQiLCJwbGF0Zm9ybSIsIndlZXhQbGF0Zm9ybSIsIlVBIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaXNJRSIsImlzSUU5IiwiaXNFZGdlIiwiaXNBbmRyb2lkIiwiaXNJT1MiLCJpc0Nocm9tZSIsIm5hdGl2ZVdhdGNoIiwid2F0Y2giLCJzdXBwb3J0c1Bhc3NpdmUiLCJvcHRzIiwiZ2V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiZW52IiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJzZXQiLCJoYXMiLCJhZGQiLCJjbGVhciIsIndhcm4iLCJ0aXAiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjb25zb2xlIiwiY2xhc3NpZnlSRSIsImNsYXNzaWZ5IiwibXNnIiwidm0iLCJ0cmFjZSIsImVycm9yIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsIm9wdGlvbnMiLCJjaWQiLCJfaXNWdWUiLCIkb3B0aW9ucyIsImNvbnN0cnVjdG9yIiwibmFtZSIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwibWF0Y2giLCJyZXBlYXQiLCIkcGFyZW50IiwidHJlZSIsImN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSIsImxhc3QiLCJwdXNoIiwidWlkIiwiRGVwIiwiaWQiLCJzdWJzIiwiYWRkU3ViIiwic3ViIiwicmVtb3ZlU3ViIiwiZGVwZW5kIiwidGFyZ2V0IiwiYWRkRGVwIiwibm90aWZ5IiwidXBkYXRlIiwidGFyZ2V0U3RhY2siLCJwdXNoVGFyZ2V0IiwiX3RhcmdldCIsInBvcFRhcmdldCIsInBvcCIsIlZOb2RlIiwidGFnIiwiZGF0YSIsImNoaWxkcmVuIiwidGV4dCIsImVsbSIsImNvbnRleHQiLCJjb21wb25lbnRPcHRpb25zIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJjb21wb25lbnRJbnN0YW5jZSIsInBhcmVudCIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJjaGlsZCIsImRlZmluZVByb3BlcnRpZXMiLCJjcmVhdGVFbXB0eVZOb2RlIiwibm9kZSIsImNyZWF0ZVRleHRWTm9kZSIsImNsb25lVk5vZGUiLCJ2bm9kZSIsImNsb25lZCIsImFycmF5UHJvdG8iLCJhcnJheU1ldGhvZHMiLCJtZXRob2RzVG9QYXRjaCIsImZvckVhY2giLCJtZXRob2QiLCJvcmlnaW5hbCIsIm11dGF0b3IiLCJhcmdzIiwibGVuIiwicmVzdWx0Iiwib2IiLCJfX29iX18iLCJpbnNlcnRlZCIsIm9ic2VydmVBcnJheSIsImRlcCIsImFycmF5S2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJzaG91bGRPYnNlcnZlIiwidG9nZ2xlT2JzZXJ2aW5nIiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwiYXVnbWVudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlIiwiaXRlbXMiLCJvYnNlcnZlIiwic3JjIiwiX19wcm90b19fIiwiYXNSb290RGF0YSIsImlzRXh0ZW5zaWJsZSIsImN1c3RvbVNldHRlciIsInNoYWxsb3ciLCJwcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJtYXgiLCJkZWwiLCJzdHJhdHMiLCJlbCIsInByb3BzRGF0YSIsImRlZmF1bHRTdHJhdCIsIm1lcmdlRGF0YSIsImZyb20iLCJ0b1ZhbCIsImZyb21WYWwiLCJtZXJnZURhdGFPckZuIiwicGFyZW50VmFsIiwiY2hpbGRWYWwiLCJtZXJnZWREYXRhRm4iLCJtZXJnZWRJbnN0YW5jZURhdGFGbiIsImluc3RhbmNlRGF0YSIsImRlZmF1bHREYXRhIiwibWVyZ2VIb29rIiwiaG9vayIsIm1lcmdlQXNzZXRzIiwiYXNzZXJ0T2JqZWN0VHlwZSIsInR5cGUiLCJrZXkkMSIsInByb3BzIiwibWV0aG9kcyIsImluamVjdCIsImNvbXB1dGVkIiwicHJvdmlkZSIsImNoZWNrQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJ2YWxpZGF0ZUNvbXBvbmVudE5hbWUiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJtZXJnZU9wdGlvbnMiLCJleHRlbmRzRnJvbSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJwcm9wIiwiYWJzZW50IiwiYm9vbGVhbkluZGV4IiwiZ2V0VHlwZUluZGV4IiwiQm9vbGVhbiIsInN0cmluZ0luZGV4IiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRPYnNlcnZlIiwiYXNzZXJ0UHJvcCIsImRlZmF1bHQiLCJfcHJvcHMiLCJnZXRUeXBlIiwicmVxdWlyZWQiLCJ2YWxpZCIsImV4cGVjdGVkVHlwZXMiLCJhc3NlcnRlZFR5cGUiLCJhc3NlcnRUeXBlIiwiZXhwZWN0ZWRUeXBlIiwidmFsaWRhdG9yIiwic2ltcGxlQ2hlY2tSRSIsInQiLCJpc1NhbWVUeXBlIiwiaGFuZGxlRXJyb3IiLCJlcnIiLCJpbmZvIiwiY3VyIiwiaG9va3MiLCJlcnJvckNhcHR1cmVkIiwiY2FwdHVyZSIsImdsb2JhbEhhbmRsZUVycm9yIiwibG9nRXJyb3IiLCJjYWxsYmFja3MiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJtaWNyb1RpbWVyRnVuYyIsIm1hY3JvVGltZXJGdW5jIiwidXNlTWFjcm9UYXNrIiwic2V0SW1tZWRpYXRlIiwiTWVzc2FnZUNoYW5uZWwiLCJjaGFubmVsIiwicG9ydCIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwb3N0TWVzc2FnZSIsInNldFRpbWVvdXQiLCJQcm9taXNlIiwicCIsInJlc29sdmUiLCJ0aGVuIiwid2l0aE1hY3JvVGFzayIsIl93aXRoVGFzayIsIm5leHRUaWNrIiwiY2IiLCJfcmVzb2x2ZSIsIm1hcmsiLCJtZWFzdXJlIiwicGVyZiIsImNsZWFyTWFya3MiLCJjbGVhck1lYXN1cmVzIiwic3RhcnRUYWciLCJlbmRUYWciLCJpbml0UHJveHkiLCJhbGxvd2VkR2xvYmFscyIsIndhcm5Ob25QcmVzZW50IiwiaGFzUHJveHkiLCJQcm94eSIsImlzQnVpbHRJbk1vZGlmaWVyIiwiaGFzSGFuZGxlciIsImlzQWxsb3dlZCIsImdldEhhbmRsZXIiLCJoYW5kbGVycyIsInJlbmRlciIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJzZWVuT2JqZWN0cyIsInRyYXZlcnNlIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImlzRnJvemVuIiwiZGVwSWQiLCJub3JtYWxpemVFdmVudCIsInBhc3NpdmUiLCJvbmNlJCQxIiwiY3JlYXRlRm5JbnZva2VyIiwiZm5zIiwiaW52b2tlciIsImFyZ3VtZW50cyQxIiwidXBkYXRlTGlzdGVuZXJzIiwib24iLCJvbGRPbiIsInJlbW92ZSQkMSIsIm9sZCIsImV2ZW50IiwicGFyYW1zIiwibWVyZ2VWTm9kZUhvb2siLCJob29rS2V5Iiwib2xkSG9vayIsIndyYXBwZWRIb29rIiwibWVyZ2VkIiwiZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSIsImF0dHJzIiwiYWx0S2V5Iiwia2V5SW5Mb3dlckNhc2UiLCJjaGVja1Byb3AiLCJoYXNoIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsImxhc3RJbmRleCIsInNoaWZ0IiwiX2lzVkxpc3QiLCJlbnN1cmVDdG9yIiwiY29tcCIsImJhc2UiLCJfX2VzTW9kdWxlIiwidG9TdHJpbmdUYWciLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiYmFzZUN0b3IiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsImNvbnRleHRzIiwic3luYyIsImZvcmNlUmVuZGVyIiwiJGZvcmNlVXBkYXRlIiwicmVqZWN0IiwicmVhc29uIiwiY29tcG9uZW50IiwiZGVsYXkiLCJ0aW1lb3V0IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsImxpc3RlbmVycyIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb25jZSIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiVnVlIiwiaG9va1JFIiwidGhpcyQxIiwiY2JzIiwiaSQxIiwiJGVtaXQiLCJsb3dlckNhc2VFdmVudCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwic2xvdCIsIm5hbWUkMSIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJGNoaWxkcmVuIiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3VpZCIsIl9yZW5kZXIiLCJXYXRjaGVyIiwidXBkYXRlQ2hpbGRDb21wb25lbnQiLCJwYXJlbnRWbm9kZSIsInJlbmRlckNoaWxkcmVuIiwiaGFzQ2hpbGRyZW4iLCJfcmVuZGVyQ2hpbGRyZW4iLCJzY29wZWRTbG90cyIsIiRzY29wZWRTbG90cyIsIl9wYXJlbnRWbm9kZSIsIiRhdHRycyIsIiRsaXN0ZW5lcnMiLCJwcm9wS2V5cyIsIl9wcm9wS2V5cyIsIiRzbG90cyIsImlzSW5JbmFjdGl2ZVRyZWUiLCJhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiZGlyZWN0IiwiZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50IiwiaiIsIk1BWF9VUERBVEVfQ09VTlQiLCJxdWV1ZSIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJzb3J0IiwicnVuIiwidXNlciIsImV4cHJlc3Npb24iLCJhY3RpdmF0ZWRRdWV1ZSIsInVwZGF0ZWRRdWV1ZSIsImNhbGxBY3RpdmF0ZWRIb29rcyIsImNhbGxVcGRhdGVkSG9va3MiLCJlbWl0IiwicXVldWVBY3RpdmF0ZWRDb21wb25lbnQiLCJxdWV1ZVdhdGNoZXIiLCJ1aWQkMSIsImV4cE9yRm4iLCJpc1JlbmRlcldhdGNoZXIiLCJkZWVwIiwibGF6eSIsImFjdGl2ZSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJjbGVhbnVwRGVwcyIsInRtcCIsIm9sZFZhbHVlIiwiZXZhbHVhdGUiLCJzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24iLCJwcm94eSIsInNvdXJjZUtleSIsInByb3h5R2V0dGVyIiwicHJveHlTZXR0ZXIiLCJpbml0U3RhdGUiLCJpbml0UHJvcHMiLCJpbml0TWV0aG9kcyIsImluaXREYXRhIiwiaW5pdENvbXB1dGVkIiwiaW5pdFdhdGNoIiwicHJvcHNPcHRpb25zIiwiaXNSb290IiwibG9vcCIsImh5cGhlbmF0ZWRLZXkiLCJnZXREYXRhIiwiY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyIsIndhdGNoZXJzIiwiX2NvbXB1dGVkV2F0Y2hlcnMiLCJpc1NTUiIsInVzZXJEZWYiLCJkZWZpbmVDb21wdXRlZCIsIiRkYXRhIiwic2hvdWxkQ2FjaGUiLCJjcmVhdGVDb21wdXRlZEdldHRlciIsImNvbXB1dGVkR2V0dGVyIiwiaGFuZGxlciIsImNyZWF0ZVdhdGNoZXIiLCIkd2F0Y2giLCJzdGF0ZU1peGluIiwiZGF0YURlZiIsInByb3BzRGVmIiwibmV3RGF0YSIsIiRzZXQiLCIkZGVsZXRlIiwiaW1tZWRpYXRlIiwidW53YXRjaEZuIiwiaW5pdFByb3ZpZGUiLCJfcHJvdmlkZWQiLCJpbml0SW5qZWN0aW9ucyIsInJlc29sdmVJbmplY3QiLCJmaWx0ZXIiLCJwcm92aWRlS2V5Iiwic291cmNlIiwicHJvdmlkZURlZmF1bHQiLCJyZW5kZXJMaXN0IiwicmVuZGVyU2xvdCIsImZhbGxiYWNrIiwiYmluZE9iamVjdCIsInNjb3BlZFNsb3RGbiIsIm5vZGVzIiwic2xvdE5vZGVzIiwiX3JlbmRlcmVkIiwiJGNyZWF0ZUVsZW1lbnQiLCJyZXNvbHZlRmlsdGVyIiwiaXNLZXlOb3RNYXRjaCIsImV4cGVjdCIsImFjdHVhbCIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluS2V5Q29kZSIsImV2ZW50S2V5TmFtZSIsImJ1aWx0SW5LZXlOYW1lIiwibWFwcGVkS2V5Q29kZSIsImJpbmRPYmplY3RQcm9wcyIsImFzUHJvcCIsImlzU3luYyIsImRvbVByb3BzIiwiJGV2ZW50IiwicmVuZGVyU3RhdGljIiwiaXNJbkZvciIsIl9zdGF0aWNUcmVlcyIsInN0YXRpY1JlbmRlckZucyIsIm1hcmtTdGF0aWMiLCJtYXJrT25jZSIsIm1hcmtTdGF0aWNOb2RlIiwiYmluZE9iamVjdExpc3RlbmVycyIsImV4aXN0aW5nIiwib3VycyIsImluc3RhbGxSZW5kZXJIZWxwZXJzIiwiX28iLCJfbiIsIl9zIiwiX2wiLCJfdCIsIl9xIiwiX2kiLCJfbSIsIl9mIiwiX2siLCJfYiIsIl92IiwiX2UiLCJfdSIsIl9nIiwiRnVuY3Rpb25hbFJlbmRlckNvbnRleHQiLCJjb250ZXh0Vm0iLCJfb3JpZ2luYWwiLCJpc0NvbXBpbGVkIiwiX2NvbXBpbGVkIiwibmVlZE5vcm1hbGl6YXRpb24iLCJpbmplY3Rpb25zIiwiX3Njb3BlSWQiLCJfYyIsImQiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCIsInZub2RlcyIsImNsb25lIiwiY29tcG9uZW50Vk5vZGVIb29rcyIsImluaXQiLCJwYXJlbnRFbG0iLCJyZWZFbG0iLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwiY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSIsIiRtb3VudCIsIm9sZFZub2RlIiwiaW5zZXJ0IiwiZGVzdHJveSIsImhvb2tzVG9NZXJnZSIsImNyZWF0ZUNvbXBvbmVudCIsIl9iYXNlIiwicmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyIsIm1vZGVsIiwidHJhbnNmb3JtTW9kZWwiLCJmdW5jdGlvbmFsIiwibmF0aXZlT24iLCJpbnN0YWxsQ29tcG9uZW50SG9va3MiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsImNhbGxiYWNrIiwiU0lNUExFX05PUk1BTElaRSIsIkFMV0FZU19OT1JNQUxJWkUiLCJub3JtYWxpemF0aW9uVHlwZSIsImFsd2F5c05vcm1hbGl6ZSIsIl9jcmVhdGVFbGVtZW50IiwiaXMiLCJhcHBseU5TIiwicmVnaXN0ZXJEZWVwQmluZGluZ3MiLCJmb3JjZSIsInN0eWxlIiwiY2xhc3MiLCJpbml0UmVuZGVyIiwicGFyZW50RGF0YSIsInJlbmRlck1peGluIiwiJG5leHRUaWNrIiwicmVmIiwicmVuZGVyRXJyb3IiLCJ1aWQkMyIsImluaXRNaXhpbiIsIl9pbml0IiwiaW5pdEludGVybmFsQ29tcG9uZW50IiwiX3NlbGYiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJzdXBlciIsInN1cGVyT3B0aW9ucyIsImNhY2hlZFN1cGVyT3B0aW9ucyIsIm1vZGlmaWVkT3B0aW9ucyIsInJlc29sdmVNb2RpZmllZE9wdGlvbnMiLCJleHRlbmRPcHRpb25zIiwibW9kaWZpZWQiLCJsYXRlc3QiLCJleHRlbmRlZCIsInNlYWxlZCIsInNlYWxlZE9wdGlvbnMiLCJkZWR1cGUiLCJpbml0VXNlIiwidXNlIiwicGx1Z2luIiwiaW5zdGFsbGVkUGx1Z2lucyIsIl9pbnN0YWxsZWRQbHVnaW5zIiwidW5zaGlmdCIsImluc3RhbGwiLCJpbml0TWl4aW4kMSIsIm1peGluIiwiaW5pdEV4dGVuZCIsIlN1cGVyIiwiU3VwZXJJZCIsImNhY2hlZEN0b3JzIiwiX0N0b3IiLCJTdWIiLCJWdWVDb21wb25lbnQiLCJpbml0UHJvcHMkMSIsImluaXRDb21wdXRlZCQxIiwiQ29tcCIsImluaXRBc3NldFJlZ2lzdGVycyIsImRlZmluaXRpb24iLCJnZXRDb21wb25lbnROYW1lIiwibWF0Y2hlcyIsInBhdHRlcm4iLCJwcnVuZUNhY2hlIiwia2VlcEFsaXZlSW5zdGFuY2UiLCJjYWNoZWROb2RlIiwicHJ1bmVDYWNoZUVudHJ5IiwiY3VycmVudCIsImNhY2hlZCQkMSIsInBhdHRlcm5UeXBlcyIsIlJlZ0V4cCIsIktlZXBBbGl2ZSIsImluY2x1ZGUiLCJleGNsdWRlIiwiTnVtYmVyIiwiY3JlYXRlZCIsImRlc3Ryb3llZCIsIm1vdW50ZWQiLCJyZWYkMSIsInBhcnNlSW50IiwiYnVpbHRJbkNvbXBvbmVudHMiLCJpbml0R2xvYmFsQVBJIiwiY29uZmlnRGVmIiwidXRpbCIsImRlbGV0ZSIsInNzckNvbnRleHQiLCJ2ZXJzaW9uIiwiYWNjZXB0VmFsdWUiLCJhdHRyIiwiaXNFbnVtZXJhdGVkQXR0ciIsImlzQm9vbGVhbkF0dHIiLCJ4bGlua05TIiwiaXNYbGluayIsImdldFhsaW5rUHJvcCIsImlzRmFsc3lBdHRyVmFsdWUiLCJnZW5DbGFzc0ZvclZub2RlIiwicGFyZW50Tm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImR5bmFtaWNDbGFzcyIsInN0cmluZ2lmeUNsYXNzIiwic3RyaW5naWZ5QXJyYXkiLCJzdHJpbmdpZnlPYmplY3QiLCJzdHJpbmdpZmllZCIsIm5hbWVzcGFjZU1hcCIsInN2ZyIsIm1hdGgiLCJpc0hUTUxUYWciLCJpc1NWRyIsImlzUHJlVGFnIiwidW5rbm93bkVsZW1lbnRDYWNoZSIsImRvY3VtZW50IiwiSFRNTFVua25vd25FbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc1RleHRJbnB1dFR5cGUiLCJxdWVyeSIsInNlbGVjdGVkIiwicXVlcnlTZWxlY3RvciIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJtdWx0aXBsZSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZUVsZW1lbnROUyIsIm5hbWVzcGFjZSIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlQ29tbWVudCIsImluc2VydEJlZm9yZSIsIm5ld05vZGUiLCJyZWZlcmVuY2VOb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsInNldFN0eWxlU2NvcGUiLCJzY29wZUlkIiwibm9kZU9wcyIsInJlZ2lzdGVyUmVmIiwiaXNSZW1vdmFsIiwicmVmcyIsInJlZkluRm9yIiwiZW1wdHlOb2RlIiwic2FtZVZub2RlIiwic2FtZUlucHV0VHlwZSIsInR5cGVBIiwidHlwZUIiLCJjcmVhdGVLZXlUb09sZElkeCIsImJlZ2luSWR4IiwiZW5kSWR4IiwiY3JlYXRlUGF0Y2hGdW5jdGlvbiIsImJhY2tlbmQiLCJlbXB0eU5vZGVBdCIsImNyZWF0ZVJtQ2IiLCJjaGlsZEVsbSIsInJlbW92ZU5vZGUiLCJpc1Vua25vd25FbGVtZW50JCQxIiwiaW5WUHJlIiwic29tZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwib3duZXJBcnJheSIsInByZSIsInNldFNjb3BlIiwiY3JlYXRlQ2hpbGRyZW4iLCJpbnZva2VDcmVhdGVIb29rcyIsImlzUmVhY3RpdmF0ZWQiLCJpbml0Q29tcG9uZW50IiwicmVhY3RpdmF0ZUNvbXBvbmVudCIsInBlbmRpbmdJbnNlcnQiLCJpc1BhdGNoYWJsZSIsImlubmVyTm9kZSIsInRyYW5zaXRpb24iLCJhY3RpdmF0ZSIsInJlZiQkMSIsImNoZWNrRHVwbGljYXRlS2V5cyIsImFuY2VzdG9yIiwiYWRkVm5vZGVzIiwic3RhcnRJZHgiLCJpbnZva2VEZXN0cm95SG9vayIsInJlbW92ZVZub2RlcyIsImNoIiwicmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayIsInJtIiwidXBkYXRlQ2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwicmVtb3ZlT25seSIsIm9sZFN0YXJ0SWR4IiwibmV3U3RhcnRJZHgiLCJvbGRFbmRJZHgiLCJvbGRTdGFydFZub2RlIiwib2xkRW5kVm5vZGUiLCJuZXdFbmRJZHgiLCJuZXdTdGFydFZub2RlIiwibmV3RW5kVm5vZGUiLCJvbGRLZXlUb0lkeCIsImlkeEluT2xkIiwidm5vZGVUb01vdmUiLCJjYW5Nb3ZlIiwicGF0Y2hWbm9kZSIsImZpbmRJZHhJbk9sZCIsInNlZW5LZXlzIiwiZW5kIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJpbm5lckhUTUwiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwibm9kZVR5cGUiLCJwYXRjaCIsImlzSW5pdGlhbFBhdGNoIiwiaXNSZWFsRWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm9sZEVsbSIsInBhcmVudEVsbSQxIiwiX2xlYXZlQ2IiLCJwYXRjaGFibGUiLCJpJDIiLCJ1cGRhdGVEaXJlY3RpdmVzIiwidW5iaW5kRGlyZWN0aXZlcyIsImlzQ3JlYXRlIiwiaXNEZXN0cm95Iiwib2xkRGlycyIsIm5vcm1hbGl6ZURpcmVjdGl2ZXMkMSIsIm5ld0RpcnMiLCJkaXJzV2l0aEluc2VydCIsImRpcnNXaXRoUG9zdHBhdGNoIiwib2xkRGlyIiwiZGlyIiwiY2FsbEhvb2skMSIsImNvbXBvbmVudFVwZGF0ZWQiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsImJhc2VTZXRBdHRyIiwic2V0QXR0cmlidXRlTlMiLCJfX2llcGgiLCJibG9ja2VyIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJ0cmltIiwicHVzaEZpbHRlciIsIndyYXBGaWx0ZXIiLCJiYXNlV2FybiIsInBsdWNrTW9kdWxlRnVuY3Rpb24iLCJhZGRQcm9wIiwicGxhaW4iLCJhZGRBdHRyIiwiYWRkUmF3QXR0ciIsImF0dHJzTWFwIiwiYXR0cnNMaXN0IiwiYWRkRGlyZWN0aXZlIiwiYXJnIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJyaWdodCIsIm1pZGRsZSIsImV2ZW50cyIsIm5hdGl2ZSIsIm5hdGl2ZUV2ZW50cyIsIm5ld0hhbmRsZXIiLCJnZXRCaW5kaW5nQXR0ciIsImdldFN0YXRpYyIsImR5bmFtaWNWYWx1ZSIsImdldEFuZFJlbW92ZUF0dHIiLCJzdGF0aWNWYWx1ZSIsInJlbW92ZUZyb21NYXAiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJuZXh0IiwiaXNTdHJpbmdTdGFydCIsInBhcnNlU3RyaW5nIiwicGFyc2VCcmFja2V0IiwiaW5CcmFja2V0Iiwic3RyaW5nUXVvdGUiLCJ3YXJuJDEiLCJSQU5HRV9UT0tFTiIsIkNIRUNLQk9YX1JBRElPX1RPS0VOIiwiX3dhcm4iLCJnZW5TZWxlY3QiLCJnZW5DaGVja2JveE1vZGVsIiwiZ2VuUmFkaW9Nb2RlbCIsImdlbkRlZmF1bHRNb2RlbCIsInZhbHVlQmluZGluZyIsInRydWVWYWx1ZUJpbmRpbmciLCJmYWxzZVZhbHVlQmluZGluZyIsInNlbGVjdGVkVmFsIiwiY29kZSIsInZhbHVlJDEiLCJ0eXBlQmluZGluZyIsImJpbmRpbmciLCJuZWVkQ29tcG9zaXRpb25HdWFyZCIsIm5vcm1hbGl6ZUV2ZW50cyIsImNoYW5nZSIsInRhcmdldCQxIiwiY3JlYXRlT25jZUhhbmRsZXIiLCJvbmNlSGFuZGxlciIsInJlbW92ZSQyIiwiYWRkJDEiLCJ1cGRhdGVET01MaXN0ZW5lcnMiLCJ1cGRhdGVET01Qcm9wcyIsIm9sZFByb3BzIiwiX3ZhbHVlIiwic3RyQ3VyIiwic2hvdWxkVXBkYXRlVmFsdWUiLCJjaGVja1ZhbCIsImNvbXBvc2luZyIsImlzTm90SW5Gb2N1c0FuZERpcnR5IiwiaXNEaXJ0eVdpdGhNb2RpZmllcnMiLCJub3RJbkZvY3VzIiwiYWN0aXZlRWxlbWVudCIsIl92TW9kaWZpZXJzIiwicGFyc2VTdHlsZVRleHQiLCJjc3NUZXh0IiwibGlzdERlbGltaXRlciIsInByb3BlcnR5RGVsaW1pdGVyIiwibm9ybWFsaXplU3R5bGVEYXRhIiwibm9ybWFsaXplU3R5bGVCaW5kaW5nIiwic3RhdGljU3R5bGUiLCJiaW5kaW5nU3R5bGUiLCJnZXRTdHlsZSIsImNoZWNrQ2hpbGQiLCJzdHlsZURhdGEiLCJjc3NWYXJSRSIsImltcG9ydGFudFJFIiwic2V0UHJvcCIsInNldFByb3BlcnR5Iiwibm9ybWFsaXplZE5hbWUiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsImNsYXNzTGlzdCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJjc3MiLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJzdHlsZXMiLCJnZXRDb21wdXRlZFN0eWxlIiwidHJhbnNpdGlvbkRlbGF5cyIsInRyYW5zaXRpb25EdXJhdGlvbnMiLCJ0cmFuc2l0aW9uVGltZW91dCIsImdldFRpbWVvdXQiLCJhbmltYXRpb25EZWxheXMiLCJhbmltYXRpb25EdXJhdGlvbnMiLCJhbmltYXRpb25UaW1lb3V0IiwiaGFzVHJhbnNmb3JtIiwiZGVsYXlzIiwiZHVyYXRpb25zIiwidG9NcyIsInMiLCJlbnRlciIsInRvZ2dsZURpc3BsYXkiLCJjYW5jZWxsZWQiLCJfZW50ZXJDYiIsImFwcGVhckNsYXNzIiwiYXBwZWFyVG9DbGFzcyIsImFwcGVhckFjdGl2ZUNsYXNzIiwiYmVmb3JlRW50ZXIiLCJhZnRlckVudGVyIiwiZW50ZXJDYW5jZWxsZWQiLCJiZWZvcmVBcHBlYXIiLCJhcHBlYXIiLCJhZnRlckFwcGVhciIsImFwcGVhckNhbmNlbGxlZCIsImR1cmF0aW9uIiwidHJhbnNpdGlvbk5vZGUiLCJpc0FwcGVhciIsInN0YXJ0Q2xhc3MiLCJhY3RpdmVDbGFzcyIsInRvQ2xhc3MiLCJiZWZvcmVFbnRlckhvb2siLCJlbnRlckhvb2siLCJhZnRlckVudGVySG9vayIsImVudGVyQ2FuY2VsbGVkSG9vayIsImV4cGxpY2l0RW50ZXJEdXJhdGlvbiIsImNoZWNrRHVyYXRpb24iLCJleHBlY3RzQ1NTIiwidXNlcldhbnRzQ29udHJvbCIsImdldEhvb2tBcmd1bWVudHNMZW5ndGgiLCJzaG93IiwicGVuZGluZ05vZGUiLCJfcGVuZGluZyIsImlzVmFsaWREdXJhdGlvbiIsImxlYXZlIiwiYmVmb3JlTGVhdmUiLCJhZnRlckxlYXZlIiwibGVhdmVDYW5jZWxsZWQiLCJkZWxheUxlYXZlIiwiZXhwbGljaXRMZWF2ZUR1cmF0aW9uIiwicGVyZm9ybUxlYXZlIiwiaW52b2tlckZucyIsIl9lbnRlciIsInBsYXRmb3JtTW9kdWxlcyIsInZtb2RlbCIsInRyaWdnZXIiLCJkaXJlY3RpdmUiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsImdldFZhbHVlIiwib25Db21wb3NpdGlvblN0YXJ0Iiwib25Db21wb3NpdGlvbkVuZCIsInByZXZPcHRpb25zIiwiY3VyT3B0aW9ucyIsIm8iLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwidW5iaW5kIiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJoIiwicmF3Q2hpbGQiLCJoYXNQYXJlbnRUcmFuc2l0aW9uIiwiaXNTYW1lQ2hpbGQiLCJvbGRDaGlsZCIsIlRyYW5zaXRpb24iLCJfbGVhdmluZyIsIm9sZFJhd0NoaWxkIiwiZGVsYXllZExlYXZlIiwibW92ZUNsYXNzIiwiVHJhbnNpdGlvbkdyb3VwIiwicHJldkNoaWxkcmVuIiwicmF3Q2hpbGRyZW4iLCJ0cmFuc2l0aW9uRGF0YSIsImtlcHQiLCJyZW1vdmVkIiwiYyQxIiwicG9zIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYmVmb3JlVXBkYXRlIiwidXBkYXRlZCIsImhhc01vdmUiLCJjYWxsUGVuZGluZ0NicyIsInJlY29yZFBvc2l0aW9uIiwiYXBwbHlUcmFuc2xhdGlvbiIsIl9yZWZsb3ciLCJib2R5Iiwib2Zmc2V0SGVpZ2h0IiwibW92ZWQiLCJ0cmFuc2Zvcm0iLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZU5vZGUiLCJuZXdQb3MiLCJvbGRQb3MiLCJkeCIsImxlZnQiLCJkeSIsInRvcCIsInBsYXRmb3JtQ29tcG9uZW50cyIsImRlZmF1bHRUYWdSRSIsInJlZ2V4RXNjYXBlUkUiLCJidWlsZFJlZ2V4IiwiZGVsaW1pdGVycyIsIm9wZW4iLCJjbG9zZSIsInBhcnNlVGV4dCIsInRhZ1JFIiwidG9rZW5zIiwicmF3VG9rZW5zIiwidG9rZW5WYWx1ZSIsImV4ZWMiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwiaHRtbCIsImlzVW5hcnlUYWciLCJjYW5CZUxlZnRPcGVuVGFnIiwiaXNOb25QaHJhc2luZ1RhZyIsImF0dHJpYnV0ZSIsIm5jbmFtZSIsInFuYW1lQ2FwdHVyZSIsInN0YXJ0VGFnT3BlbiIsInN0YXJ0VGFnQ2xvc2UiLCJkb2N0eXBlIiwiY29tbWVudCIsImNvbmRpdGlvbmFsQ29tbWVudCIsIklTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4iLCJnIiwiaXNQbGFpblRleHRFbGVtZW50IiwicmVDYWNoZSIsImRlY29kaW5nTWFwIiwiZW5jb2RlZEF0dHIiLCJlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyIsImlzSWdub3JlTmV3bGluZVRhZyIsInNob3VsZElnbm9yZUZpcnN0TmV3bGluZSIsImRlY29kZUF0dHIiLCJzaG91bGREZWNvZGVOZXdsaW5lcyIsInJlIiwicGFyc2VIVE1MIiwic3RhY2siLCJleHBlY3RIVE1MIiwiaXNVbmFyeVRhZyQkMSIsImNhbkJlTGVmdE9wZW5UYWckJDEiLCJsYXN0VGFnIiwidGV4dEVuZCIsImNvbW1lbnRFbmQiLCJzaG91bGRLZWVwQ29tbWVudCIsInN1YnN0cmluZyIsImFkdmFuY2UiLCJjb25kaXRpb25hbEVuZCIsImRvY3R5cGVNYXRjaCIsImVuZFRhZ01hdGNoIiwiY3VySW5kZXgiLCJwYXJzZUVuZFRhZyIsInN0YXJ0VGFnTWF0Y2giLCJwYXJzZVN0YXJ0VGFnIiwiaGFuZGxlU3RhcnRUYWciLCJyZXN0IiwiY2hhcnMiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwiYWxsIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInBhcnNlIiwicHJlc2VydmVXaGl0ZXNwYWNlIiwicm9vdCIsImN1cnJlbnRQYXJlbnQiLCJpblByZSIsIndhcm5lZCIsIndhcm5PbmNlIiwiY2xvc2VFbGVtZW50IiwiZWxlbWVudCIsImNvbW1lbnRzIiwiZ3VhcmRJRVNWR0J1ZyIsImlzRm9yYmlkZGVuVGFnIiwiZm9yYmlkZGVuIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NlZCIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsInByb2Nlc3NFbGVtZW50IiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsImJsb2NrIiwicHJvY2Vzc0lmQ29uZGl0aW9ucyIsInNsb3RTY29wZSIsInNsb3RUYXJnZXQiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsInByb2Nlc3NLZXkiLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tJbkZvciIsInBhcnNlRm9yIiwiaW5NYXRjaCIsImZvciIsImFsaWFzIiwiaXRlcmF0b3JNYXRjaCIsIml0ZXJhdG9yMSIsIml0ZXJhdG9yMiIsImZpbmRQcmV2RWxlbWVudCIsImNvbmRpdGlvbiIsImlmQ29uZGl0aW9ucyIsInNsb3ROYW1lIiwiaXNQcm9wIiwiaGFzQmluZGluZ3MiLCJwYXJzZU1vZGlmaWVycyIsImNhbWVsIiwiYXJnTWF0Y2giLCJjaGVja0ZvckFsaWFzTW9kZWwiLCJpZU5TQnVnIiwiaWVOU1ByZWZpeCIsIl9lbCIsInByZVRyYW5zZm9ybU5vZGUiLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImJyYW5jaDEiLCJicmFuY2gyIiwibW9kZWwkMiIsIm1vZHVsZXMkMSIsImRpcmVjdGl2ZXMkMSIsImJhc2VPcHRpb25zIiwiaXNTdGF0aWNLZXkiLCJpc1BsYXRmb3JtUmVzZXJ2ZWRUYWciLCJnZW5TdGF0aWNLZXlzQ2FjaGVkIiwiZ2VuU3RhdGljS2V5cyQxIiwib3B0aW1pemUiLCJtYXJrU3RhdGljJDEiLCJtYXJrU3RhdGljUm9vdHMiLCJzdGF0aWMiLCJsJDEiLCJzdGF0aWNJbkZvciIsInN0YXRpY1Jvb3QiLCJpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciIsImZuRXhwUkUiLCJzaW1wbGVQYXRoUkUiLCJlc2MiLCJ0YWIiLCJzcGFjZSIsInVwIiwiZG93biIsImtleU5hbWVzIiwiZ2VuR3VhcmQiLCJtb2RpZmllckNvZGUiLCJzdG9wIiwic2VsZiIsImN0cmwiLCJhbHQiLCJtZXRhIiwiZ2VuSGFuZGxlcnMiLCJnZW5IYW5kbGVyIiwiaXNNZXRob2RQYXRoIiwiaXNGdW5jdGlvbkV4cHJlc3Npb24iLCJnZW5Nb2RpZmllckNvZGUiLCJrZXlNb2RpZmllciIsImdlbktleUZpbHRlciIsImhhbmRsZXJDb2RlIiwiZ2VuRmlsdGVyQ29kZSIsImtleVZhbCIsImtleUNvZGUiLCJrZXlOYW1lIiwid3JhcExpc3RlbmVycyIsImJpbmQkMSIsIndyYXBEYXRhIiwiYmFzZURpcmVjdGl2ZXMiLCJjbG9hayIsIkNvZGVnZW5TdGF0ZSIsImRhdGFHZW5GbnMiLCJtYXliZUNvbXBvbmVudCIsIm9uY2VJZCIsImdlbmVyYXRlIiwiYXN0Iiwic3RhdGUiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJnZW4iLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90IiwiZ2VuRm9yU2NvcGVkU2xvdCIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJtZXNzYWdlIiwiY3JlYXRlRnVuY3Rpb24iLCJjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIiwiY29tcGlsZSIsImNvbXBpbGVUb0Z1bmN0aW9ucyIsIndhcm4kJDEiLCJjb21waWxlZCIsInRpcHMiLCJmbkdlbkVycm9ycyIsImNyZWF0ZUNvbXBpbGVyQ3JlYXRvciIsImJhc2VDb21waWxlIiwiY3JlYXRlQ29tcGlsZXIiLCJmaW5hbE9wdGlvbnMiLCJkaXYiLCJnZXRTaG91bGREZWNvZGUiLCJocmVmIiwiaWRUb1RlbXBsYXRlIiwibW91bnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRPdXRlckhUTUwiLCJvdXRlckhUTUwiLCJjb250YWluZXIiXSwibWFwcGluZ3MiOiJBQUFBOzs7OztBQUtDLFdBQVVBLE1BQVYsRUFBa0JDLE9BQWxCLEVBQTJCO0FBQzNCLFVBQStEQyxNQUFNLENBQUNDLE9BQVAsR0FBaUJGLE9BQU8sRUFBdkYsR0FDQSxTQURBO0FBR0EsQ0FKQSxFQUlDLElBSkQsRUFJUSxZQUFZO0FBQUU7QUFFdkI7O0FBRUEsTUFBSUcsV0FBVyxHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLENBQWxCLENBSnFCLENBTXJCO0FBQ0E7O0FBQ0EsV0FBU0MsT0FBVCxDQUFrQkMsQ0FBbEIsRUFBcUI7QUFDbkIsV0FBT0EsQ0FBQyxLQUFLQyxTQUFOLElBQW1CRCxDQUFDLEtBQUssSUFBaEM7QUFDRDs7QUFFRCxXQUFTRSxLQUFULENBQWdCRixDQUFoQixFQUFtQjtBQUNqQixXQUFPQSxDQUFDLEtBQUtDLFNBQU4sSUFBbUJELENBQUMsS0FBSyxJQUFoQztBQUNEOztBQUVELFdBQVNHLE1BQVQsQ0FBaUJILENBQWpCLEVBQW9CO0FBQ2xCLFdBQU9BLENBQUMsS0FBSyxJQUFiO0FBQ0Q7O0FBRUQsV0FBU0ksT0FBVCxDQUFrQkosQ0FBbEIsRUFBcUI7QUFDbkIsV0FBT0EsQ0FBQyxLQUFLLEtBQWI7QUFDRDtBQUVEOzs7OztBQUdBLFdBQVNLLFdBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCO0FBQzNCLFdBQ0UsT0FBT0EsS0FBUCxLQUFpQixRQUFqQixJQUNBLE9BQU9BLEtBQVAsS0FBaUIsUUFEakIsSUFFQTtBQUNBLFdBQU9BLEtBQVAsS0FBaUIsUUFIakIsSUFJQSxPQUFPQSxLQUFQLEtBQWlCLFNBTG5CO0FBT0Q7QUFFRDs7Ozs7OztBQUtBLFdBQVNDLFFBQVQsQ0FBbUJDLEdBQW5CLEVBQXdCO0FBQ3RCLFdBQU9BLEdBQUcsS0FBSyxJQUFSLElBQWdCLE9BQU9BLEdBQVAsS0FBZSxRQUF0QztBQUNEO0FBRUQ7Ozs7O0FBR0EsTUFBSUMsU0FBUyxHQUFHWixNQUFNLENBQUNhLFNBQVAsQ0FBaUJDLFFBQWpDOztBQUVBLFdBQVNDLFNBQVQsQ0FBb0JOLEtBQXBCLEVBQTJCO0FBQ3pCLFdBQU9HLFNBQVMsQ0FBQ0ksSUFBVixDQUFlUCxLQUFmLEVBQXNCUSxLQUF0QixDQUE0QixDQUE1QixFQUErQixDQUFDLENBQWhDLENBQVA7QUFDRDtBQUVEOzs7Ozs7QUFJQSxXQUFTQyxhQUFULENBQXdCUCxHQUF4QixFQUE2QjtBQUMzQixXQUFPQyxTQUFTLENBQUNJLElBQVYsQ0FBZUwsR0FBZixNQUF3QixpQkFBL0I7QUFDRDs7QUFFRCxXQUFTUSxRQUFULENBQW1CaEIsQ0FBbkIsRUFBc0I7QUFDcEIsV0FBT1MsU0FBUyxDQUFDSSxJQUFWLENBQWViLENBQWYsTUFBc0IsaUJBQTdCO0FBQ0Q7QUFFRDs7Ozs7QUFHQSxXQUFTaUIsaUJBQVQsQ0FBNEJDLEdBQTVCLEVBQWlDO0FBQy9CLFFBQUlDLENBQUMsR0FBR0MsVUFBVSxDQUFDQyxNQUFNLENBQUNILEdBQUQsQ0FBUCxDQUFsQjtBQUNBLFdBQU9DLENBQUMsSUFBSSxDQUFMLElBQVVHLElBQUksQ0FBQ0MsS0FBTCxDQUFXSixDQUFYLE1BQWtCQSxDQUE1QixJQUFpQ0ssUUFBUSxDQUFDTixHQUFELENBQWhEO0FBQ0Q7QUFFRDs7Ozs7QUFHQSxXQUFTUCxRQUFULENBQW1CTyxHQUFuQixFQUF3QjtBQUN0QixXQUFPQSxHQUFHLElBQUksSUFBUCxHQUNILEVBREcsR0FFSCxPQUFPQSxHQUFQLEtBQWUsUUFBZixHQUNFTyxJQUFJLENBQUNDLFNBQUwsQ0FBZVIsR0FBZixFQUFvQixJQUFwQixFQUEwQixDQUExQixDQURGLEdBRUVHLE1BQU0sQ0FBQ0gsR0FBRCxDQUpaO0FBS0Q7QUFFRDs7Ozs7O0FBSUEsV0FBU1MsUUFBVCxDQUFtQlQsR0FBbkIsRUFBd0I7QUFDdEIsUUFBSUMsQ0FBQyxHQUFHQyxVQUFVLENBQUNGLEdBQUQsQ0FBbEI7QUFDQSxXQUFPVSxLQUFLLENBQUNULENBQUQsQ0FBTCxHQUFXRCxHQUFYLEdBQWlCQyxDQUF4QjtBQUNEO0FBRUQ7Ozs7OztBQUlBLFdBQVNVLE9BQVQsQ0FDRUMsR0FERixFQUVFQyxnQkFGRixFQUdFO0FBQ0EsUUFBSUMsR0FBRyxHQUFHbkMsTUFBTSxDQUFDb0MsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLFFBQUlDLElBQUksR0FBR0osR0FBRyxDQUFDSyxLQUFKLENBQVUsR0FBVixDQUFYOztBQUNBLFNBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0YsSUFBSSxDQUFDRyxNQUF6QixFQUFpQ0QsQ0FBQyxFQUFsQyxFQUFzQztBQUNwQ0osU0FBRyxDQUFDRSxJQUFJLENBQUNFLENBQUQsQ0FBTCxDQUFILEdBQWUsSUFBZjtBQUNEOztBQUNELFdBQU9MLGdCQUFnQixHQUNuQixVQUFVYixHQUFWLEVBQWU7QUFBRSxhQUFPYyxHQUFHLENBQUNkLEdBQUcsQ0FBQ29CLFdBQUosRUFBRCxDQUFWO0FBQWdDLEtBRDlCLEdBRW5CLFVBQVVwQixHQUFWLEVBQWU7QUFBRSxhQUFPYyxHQUFHLENBQUNkLEdBQUQsQ0FBVjtBQUFrQixLQUZ2QztBQUdEO0FBRUQ7Ozs7O0FBR0EsTUFBSXFCLFlBQVksR0FBR1YsT0FBTyxDQUFDLGdCQUFELEVBQW1CLElBQW5CLENBQTFCO0FBRUE7Ozs7QUFHQSxNQUFJVyxtQkFBbUIsR0FBR1gsT0FBTyxDQUFDLDRCQUFELENBQWpDO0FBRUE7Ozs7QUFHQSxXQUFTWSxNQUFULENBQWlCQyxHQUFqQixFQUFzQkMsSUFBdEIsRUFBNEI7QUFDMUIsUUFBSUQsR0FBRyxDQUFDTCxNQUFSLEVBQWdCO0FBQ2QsVUFBSU8sS0FBSyxHQUFHRixHQUFHLENBQUNHLE9BQUosQ0FBWUYsSUFBWixDQUFaOztBQUNBLFVBQUlDLEtBQUssR0FBRyxDQUFDLENBQWIsRUFBZ0I7QUFDZCxlQUFPRixHQUFHLENBQUNJLE1BQUosQ0FBV0YsS0FBWCxFQUFrQixDQUFsQixDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBRUQ7Ozs7O0FBR0EsTUFBSUcsY0FBYyxHQUFHbEQsTUFBTSxDQUFDYSxTQUFQLENBQWlCcUMsY0FBdEM7O0FBQ0EsV0FBU0MsTUFBVCxDQUFpQnhDLEdBQWpCLEVBQXNCeUMsR0FBdEIsRUFBMkI7QUFDekIsV0FBT0YsY0FBYyxDQUFDbEMsSUFBZixDQUFvQkwsR0FBcEIsRUFBeUJ5QyxHQUF6QixDQUFQO0FBQ0Q7QUFFRDs7Ozs7QUFHQSxXQUFTQyxNQUFULENBQWlCQyxFQUFqQixFQUFxQjtBQUNuQixRQUFJQyxLQUFLLEdBQUd2RCxNQUFNLENBQUNvQyxNQUFQLENBQWMsSUFBZCxDQUFaO0FBQ0EsV0FBUSxTQUFTb0IsUUFBVCxDQUFtQnZCLEdBQW5CLEVBQXdCO0FBQzlCLFVBQUl3QixHQUFHLEdBQUdGLEtBQUssQ0FBQ3RCLEdBQUQsQ0FBZjtBQUNBLGFBQU93QixHQUFHLEtBQUtGLEtBQUssQ0FBQ3RCLEdBQUQsQ0FBTCxHQUFhcUIsRUFBRSxDQUFDckIsR0FBRCxDQUFwQixDQUFWO0FBQ0QsS0FIRDtBQUlEO0FBRUQ7Ozs7O0FBR0EsTUFBSXlCLFVBQVUsR0FBRyxRQUFqQjtBQUNBLE1BQUlDLFFBQVEsR0FBR04sTUFBTSxDQUFDLFVBQVVwQixHQUFWLEVBQWU7QUFDbkMsV0FBT0EsR0FBRyxDQUFDMkIsT0FBSixDQUFZRixVQUFaLEVBQXdCLFVBQVVHLENBQVYsRUFBYUMsQ0FBYixFQUFnQjtBQUFFLGFBQU9BLENBQUMsR0FBR0EsQ0FBQyxDQUFDQyxXQUFGLEVBQUgsR0FBcUIsRUFBN0I7QUFBa0MsS0FBNUUsQ0FBUDtBQUNELEdBRm9CLENBQXJCO0FBSUE7Ozs7QUFHQSxNQUFJQyxVQUFVLEdBQUdYLE1BQU0sQ0FBQyxVQUFVcEIsR0FBVixFQUFlO0FBQ3JDLFdBQU9BLEdBQUcsQ0FBQ2dDLE1BQUosQ0FBVyxDQUFYLEVBQWNGLFdBQWQsS0FBOEI5QixHQUFHLENBQUNoQixLQUFKLENBQVUsQ0FBVixDQUFyQztBQUNELEdBRnNCLENBQXZCO0FBSUE7Ozs7QUFHQSxNQUFJaUQsV0FBVyxHQUFHLFlBQWxCO0FBQ0EsTUFBSUMsU0FBUyxHQUFHZCxNQUFNLENBQUMsVUFBVXBCLEdBQVYsRUFBZTtBQUNwQyxXQUFPQSxHQUFHLENBQUMyQixPQUFKLENBQVlNLFdBQVosRUFBeUIsS0FBekIsRUFBZ0N6QixXQUFoQyxFQUFQO0FBQ0QsR0FGcUIsQ0FBdEI7QUFJQTs7Ozs7Ozs7QUFRQTs7QUFDQSxXQUFTMkIsWUFBVCxDQUF1QmQsRUFBdkIsRUFBMkJlLEdBQTNCLEVBQWdDO0FBQzlCLGFBQVNDLE9BQVQsQ0FBa0JDLENBQWxCLEVBQXFCO0FBQ25CLFVBQUlDLENBQUMsR0FBR0MsU0FBUyxDQUFDakMsTUFBbEI7QUFDQSxhQUFPZ0MsQ0FBQyxHQUNKQSxDQUFDLEdBQUcsQ0FBSixHQUNFbEIsRUFBRSxDQUFDb0IsS0FBSCxDQUFTTCxHQUFULEVBQWNJLFNBQWQsQ0FERixHQUVFbkIsRUFBRSxDQUFDdEMsSUFBSCxDQUFRcUQsR0FBUixFQUFhRSxDQUFiLENBSEUsR0FJSmpCLEVBQUUsQ0FBQ3RDLElBQUgsQ0FBUXFELEdBQVIsQ0FKSjtBQUtEOztBQUVEQyxXQUFPLENBQUNLLE9BQVIsR0FBa0JyQixFQUFFLENBQUNkLE1BQXJCO0FBQ0EsV0FBTzhCLE9BQVA7QUFDRDs7QUFFRCxXQUFTTSxVQUFULENBQXFCdEIsRUFBckIsRUFBeUJlLEdBQXpCLEVBQThCO0FBQzVCLFdBQU9mLEVBQUUsQ0FBQ3VCLElBQUgsQ0FBUVIsR0FBUixDQUFQO0FBQ0Q7O0FBRUQsTUFBSVEsSUFBSSxHQUFHQyxRQUFRLENBQUNqRSxTQUFULENBQW1CZ0UsSUFBbkIsR0FDUEQsVUFETyxHQUVQUixZQUZKO0FBSUE7Ozs7QUFHQSxXQUFTVyxPQUFULENBQWtCMUMsSUFBbEIsRUFBd0IyQyxLQUF4QixFQUErQjtBQUM3QkEsU0FBSyxHQUFHQSxLQUFLLElBQUksQ0FBakI7QUFDQSxRQUFJekMsQ0FBQyxHQUFHRixJQUFJLENBQUNHLE1BQUwsR0FBY3dDLEtBQXRCO0FBQ0EsUUFBSUMsR0FBRyxHQUFHLElBQUlDLEtBQUosQ0FBVTNDLENBQVYsQ0FBVjs7QUFDQSxXQUFPQSxDQUFDLEVBQVIsRUFBWTtBQUNWMEMsU0FBRyxDQUFDMUMsQ0FBRCxDQUFILEdBQVNGLElBQUksQ0FBQ0UsQ0FBQyxHQUFHeUMsS0FBTCxDQUFiO0FBQ0Q7O0FBQ0QsV0FBT0MsR0FBUDtBQUNEO0FBRUQ7Ozs7O0FBR0EsV0FBU0UsTUFBVCxDQUFpQkMsRUFBakIsRUFBcUJDLEtBQXJCLEVBQTRCO0FBQzFCLFNBQUssSUFBSWpDLEdBQVQsSUFBZ0JpQyxLQUFoQixFQUF1QjtBQUNyQkQsUUFBRSxDQUFDaEMsR0FBRCxDQUFGLEdBQVVpQyxLQUFLLENBQUNqQyxHQUFELENBQWY7QUFDRDs7QUFDRCxXQUFPZ0MsRUFBUDtBQUNEO0FBRUQ7Ozs7O0FBR0EsV0FBU0UsUUFBVCxDQUFtQnpDLEdBQW5CLEVBQXdCO0FBQ3RCLFFBQUkwQyxHQUFHLEdBQUcsRUFBVjs7QUFDQSxTQUFLLElBQUloRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHTSxHQUFHLENBQUNMLE1BQXhCLEVBQWdDRCxDQUFDLEVBQWpDLEVBQXFDO0FBQ25DLFVBQUlNLEdBQUcsQ0FBQ04sQ0FBRCxDQUFQLEVBQVk7QUFDVjRDLGNBQU0sQ0FBQ0ksR0FBRCxFQUFNMUMsR0FBRyxDQUFDTixDQUFELENBQVQsQ0FBTjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT2dELEdBQVA7QUFDRDtBQUVEOzs7Ozs7O0FBS0EsV0FBU0MsSUFBVCxDQUFlakIsQ0FBZixFQUFrQmtCLENBQWxCLEVBQXFCM0IsQ0FBckIsRUFBd0IsQ0FBRTtBQUUxQjs7Ozs7QUFHQSxNQUFJNEIsRUFBRSxHQUFHLFVBQVVuQixDQUFWLEVBQWFrQixDQUFiLEVBQWdCM0IsQ0FBaEIsRUFBbUI7QUFBRSxXQUFPLEtBQVA7QUFBZSxHQUE3QztBQUVBOzs7OztBQUdBLE1BQUk2QixRQUFRLEdBQUcsVUFBVTlCLENBQVYsRUFBYTtBQUFFLFdBQU9BLENBQVA7QUFBVyxHQUF6QztBQUVBOzs7OztBQUdBLFdBQVMrQixhQUFULENBQXdCQyxPQUF4QixFQUFpQztBQUMvQixXQUFPQSxPQUFPLENBQUNDLE1BQVIsQ0FBZSxVQUFVQyxJQUFWLEVBQWdCQyxDQUFoQixFQUFtQjtBQUN2QyxhQUFPRCxJQUFJLENBQUNFLE1BQUwsQ0FBWUQsQ0FBQyxDQUFDRSxVQUFGLElBQWdCLEVBQTVCLENBQVA7QUFDRCxLQUZNLEVBRUosRUFGSSxFQUVBQyxJQUZBLENBRUssR0FGTCxDQUFQO0FBR0Q7QUFFRDs7Ozs7O0FBSUEsV0FBU0MsVUFBVCxDQUFxQjdCLENBQXJCLEVBQXdCa0IsQ0FBeEIsRUFBMkI7QUFDekIsUUFBSWxCLENBQUMsS0FBS2tCLENBQVYsRUFBYTtBQUFFLGFBQU8sSUFBUDtBQUFhOztBQUM1QixRQUFJWSxTQUFTLEdBQUczRixRQUFRLENBQUM2RCxDQUFELENBQXhCO0FBQ0EsUUFBSStCLFNBQVMsR0FBRzVGLFFBQVEsQ0FBQytFLENBQUQsQ0FBeEI7O0FBQ0EsUUFBSVksU0FBUyxJQUFJQyxTQUFqQixFQUE0QjtBQUMxQixVQUFJO0FBQ0YsWUFBSUMsUUFBUSxHQUFHckIsS0FBSyxDQUFDc0IsT0FBTixDQUFjakMsQ0FBZCxDQUFmO0FBQ0EsWUFBSWtDLFFBQVEsR0FBR3ZCLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY2YsQ0FBZCxDQUFmOztBQUNBLFlBQUljLFFBQVEsSUFBSUUsUUFBaEIsRUFBMEI7QUFDeEIsaUJBQU9sQyxDQUFDLENBQUMvQixNQUFGLEtBQWFpRCxDQUFDLENBQUNqRCxNQUFmLElBQXlCK0IsQ0FBQyxDQUFDbUMsS0FBRixDQUFRLFVBQVVDLENBQVYsRUFBYXBFLENBQWIsRUFBZ0I7QUFDdEQsbUJBQU82RCxVQUFVLENBQUNPLENBQUQsRUFBSWxCLENBQUMsQ0FBQ2xELENBQUQsQ0FBTCxDQUFqQjtBQUNELFdBRitCLENBQWhDO0FBR0QsU0FKRCxNQUlPLElBQUksQ0FBQ2dFLFFBQUQsSUFBYSxDQUFDRSxRQUFsQixFQUE0QjtBQUNqQyxjQUFJRyxLQUFLLEdBQUc1RyxNQUFNLENBQUMrRixJQUFQLENBQVl4QixDQUFaLENBQVo7QUFDQSxjQUFJc0MsS0FBSyxHQUFHN0csTUFBTSxDQUFDK0YsSUFBUCxDQUFZTixDQUFaLENBQVo7QUFDQSxpQkFBT21CLEtBQUssQ0FBQ3BFLE1BQU4sS0FBaUJxRSxLQUFLLENBQUNyRSxNQUF2QixJQUFpQ29FLEtBQUssQ0FBQ0YsS0FBTixDQUFZLFVBQVV0RCxHQUFWLEVBQWU7QUFDakUsbUJBQU9nRCxVQUFVLENBQUM3QixDQUFDLENBQUNuQixHQUFELENBQUYsRUFBU3FDLENBQUMsQ0FBQ3JDLEdBQUQsQ0FBVixDQUFqQjtBQUNELFdBRnVDLENBQXhDO0FBR0QsU0FOTSxNQU1BO0FBQ0w7QUFDQSxpQkFBTyxLQUFQO0FBQ0Q7QUFDRixPQWpCRCxDQWlCRSxPQUFPdUQsQ0FBUCxFQUFVO0FBQ1Y7QUFDQSxlQUFPLEtBQVA7QUFDRDtBQUNGLEtBdEJELE1Bc0JPLElBQUksQ0FBQ04sU0FBRCxJQUFjLENBQUNDLFNBQW5CLEVBQThCO0FBQ25DLGFBQU85RSxNQUFNLENBQUMrQyxDQUFELENBQU4sS0FBYy9DLE1BQU0sQ0FBQ2lFLENBQUQsQ0FBM0I7QUFDRCxLQUZNLE1BRUE7QUFDTCxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVELFdBQVNxQixZQUFULENBQXVCakUsR0FBdkIsRUFBNEJ4QixHQUE1QixFQUFpQztBQUMvQixTQUFLLElBQUlrQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHTSxHQUFHLENBQUNMLE1BQXhCLEVBQWdDRCxDQUFDLEVBQWpDLEVBQXFDO0FBQ25DLFVBQUk2RCxVQUFVLENBQUN2RCxHQUFHLENBQUNOLENBQUQsQ0FBSixFQUFTbEIsR0FBVCxDQUFkLEVBQTZCO0FBQUUsZUFBT2tCLENBQVA7QUFBVTtBQUMxQzs7QUFDRCxXQUFPLENBQUMsQ0FBUjtBQUNEO0FBRUQ7Ozs7O0FBR0EsV0FBU3dFLElBQVQsQ0FBZXpELEVBQWYsRUFBbUI7QUFDakIsUUFBSTBELE1BQU0sR0FBRyxLQUFiO0FBQ0EsV0FBTyxZQUFZO0FBQ2pCLFVBQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQ1hBLGNBQU0sR0FBRyxJQUFUO0FBQ0ExRCxVQUFFLENBQUNvQixLQUFILENBQVMsSUFBVCxFQUFlRCxTQUFmO0FBQ0Q7QUFDRixLQUxEO0FBTUQ7O0FBRUQsTUFBSXdDLFFBQVEsR0FBRyxzQkFBZjtBQUVBLE1BQUlDLFdBQVcsR0FBRyxDQUNoQixXQURnQixFQUVoQixXQUZnQixFQUdoQixRQUhnQixDQUFsQjtBQU1BLE1BQUlDLGVBQWUsR0FBRyxDQUNwQixjQURvQixFQUVwQixTQUZvQixFQUdwQixhQUhvQixFQUlwQixTQUpvQixFQUtwQixjQUxvQixFQU1wQixTQU5vQixFQU9wQixlQVBvQixFQVFwQixXQVJvQixFQVNwQixXQVRvQixFQVVwQixhQVZvQixFQVdwQixlQVhvQixDQUF0QjtBQWNBOztBQUVBLE1BQUlDLE1BQU0sR0FBSTtBQUNaOzs7QUFHQTtBQUNBQyx5QkFBcUIsRUFBRXJILE1BQU0sQ0FBQ29DLE1BQVAsQ0FBYyxJQUFkLENBTFg7O0FBT1o7OztBQUdBa0YsVUFBTSxFQUFFLEtBVkk7O0FBWVo7OztBQUdBQyxpQkFBYSxFQUFFLGtCQUFrQixZQWZyQjs7QUFpQlo7OztBQUdBQyxZQUFRLEVBQUUsa0JBQWtCLFlBcEJoQjs7QUFzQlo7OztBQUdBQyxlQUFXLEVBQUUsS0F6QkQ7O0FBMkJaOzs7QUFHQUMsZ0JBQVksRUFBRSxJQTlCRjs7QUFnQ1o7OztBQUdBQyxlQUFXLEVBQUUsSUFuQ0Q7O0FBcUNaOzs7QUFHQUMsbUJBQWUsRUFBRSxFQXhDTDs7QUEwQ1o7OztBQUdBO0FBQ0FDLFlBQVEsRUFBRTdILE1BQU0sQ0FBQ29DLE1BQVAsQ0FBYyxJQUFkLENBOUNFOztBQWdEWjs7OztBQUlBMEYsaUJBQWEsRUFBRXBDLEVBcERIOztBQXNEWjs7OztBQUlBcUMsa0JBQWMsRUFBRXJDLEVBMURKOztBQTREWjs7OztBQUlBc0Msb0JBQWdCLEVBQUV0QyxFQWhFTjs7QUFrRVo7OztBQUdBdUMsbUJBQWUsRUFBRXpDLElBckVMOztBQXVFWjs7O0FBR0EwQyx3QkFBb0IsRUFBRXZDLFFBMUVWOztBQTRFWjs7OztBQUlBd0MsZUFBVyxFQUFFekMsRUFoRkQ7O0FBa0ZaOzs7QUFHQTBDLG1CQUFlLEVBQUVqQjtBQXJGTCxHQUFkO0FBd0ZBOztBQUVBOzs7O0FBR0EsV0FBU2tCLFVBQVQsQ0FBcUJwRyxHQUFyQixFQUEwQjtBQUN4QixRQUFJNkIsQ0FBQyxHQUFHLENBQUM3QixHQUFHLEdBQUcsRUFBUCxFQUFXcUcsVUFBWCxDQUFzQixDQUF0QixDQUFSO0FBQ0EsV0FBT3hFLENBQUMsS0FBSyxJQUFOLElBQWNBLENBQUMsS0FBSyxJQUEzQjtBQUNEO0FBRUQ7Ozs7O0FBR0EsV0FBU3lFLEdBQVQsQ0FBYzVILEdBQWQsRUFBbUJ5QyxHQUFuQixFQUF3Qi9CLEdBQXhCLEVBQTZCbUgsVUFBN0IsRUFBeUM7QUFDdkN4SSxVQUFNLENBQUN5SSxjQUFQLENBQXNCOUgsR0FBdEIsRUFBMkJ5QyxHQUEzQixFQUFnQztBQUM5QjNDLFdBQUssRUFBRVksR0FEdUI7QUFFOUJtSCxnQkFBVSxFQUFFLENBQUMsQ0FBQ0EsVUFGZ0I7QUFHOUJFLGNBQVEsRUFBRSxJQUhvQjtBQUk5QkMsa0JBQVksRUFBRTtBQUpnQixLQUFoQztBQU1EO0FBRUQ7Ozs7O0FBR0EsTUFBSUMsTUFBTSxHQUFHLFNBQWI7O0FBQ0EsV0FBU0MsU0FBVCxDQUFvQkMsSUFBcEIsRUFBMEI7QUFDeEIsUUFBSUYsTUFBTSxDQUFDRyxJQUFQLENBQVlELElBQVosQ0FBSixFQUF1QjtBQUNyQjtBQUNEOztBQUNELFFBQUlFLFFBQVEsR0FBR0YsSUFBSSxDQUFDeEcsS0FBTCxDQUFXLEdBQVgsQ0FBZjtBQUNBLFdBQU8sVUFBVTNCLEdBQVYsRUFBZTtBQUNwQixXQUFLLElBQUk0QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeUcsUUFBUSxDQUFDeEcsTUFBN0IsRUFBcUNELENBQUMsRUFBdEMsRUFBMEM7QUFDeEMsWUFBSSxDQUFDNUIsR0FBTCxFQUFVO0FBQUU7QUFBUTs7QUFDcEJBLFdBQUcsR0FBR0EsR0FBRyxDQUFDcUksUUFBUSxDQUFDekcsQ0FBRCxDQUFULENBQVQ7QUFDRDs7QUFDRCxhQUFPNUIsR0FBUDtBQUNELEtBTkQ7QUFPRDtBQUVEO0FBRUE7OztBQUNBLE1BQUlzSSxRQUFRLEdBQUcsZUFBZSxFQUE5QixDQWxlcUIsQ0FvZXJCOztBQUNBLE1BQUlDLFNBQVMsR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWxDO0FBQ0EsTUFBSUMsTUFBTSxHQUFHLE9BQU9DLGFBQVAsS0FBeUIsV0FBekIsSUFBd0MsQ0FBQyxDQUFDQSxhQUFhLENBQUNDLFFBQXJFO0FBQ0EsTUFBSUMsWUFBWSxHQUFHSCxNQUFNLElBQUlDLGFBQWEsQ0FBQ0MsUUFBZCxDQUF1QjdHLFdBQXZCLEVBQTdCO0FBQ0EsTUFBSStHLEVBQUUsR0FBR04sU0FBUyxJQUFJQyxNQUFNLENBQUNNLFNBQVAsQ0FBaUJDLFNBQWpCLENBQTJCakgsV0FBM0IsRUFBdEI7QUFDQSxNQUFJa0gsSUFBSSxHQUFHSCxFQUFFLElBQUksZUFBZVQsSUFBZixDQUFvQlMsRUFBcEIsQ0FBakI7QUFDQSxNQUFJSSxLQUFLLEdBQUdKLEVBQUUsSUFBSUEsRUFBRSxDQUFDeEcsT0FBSCxDQUFXLFVBQVgsSUFBeUIsQ0FBM0M7QUFDQSxNQUFJNkcsTUFBTSxHQUFHTCxFQUFFLElBQUlBLEVBQUUsQ0FBQ3hHLE9BQUgsQ0FBVyxPQUFYLElBQXNCLENBQXpDO0FBQ0EsTUFBSThHLFNBQVMsR0FBSU4sRUFBRSxJQUFJQSxFQUFFLENBQUN4RyxPQUFILENBQVcsU0FBWCxJQUF3QixDQUEvQixJQUFzQ3VHLFlBQVksS0FBSyxTQUF2RTtBQUNBLE1BQUlRLEtBQUssR0FBSVAsRUFBRSxJQUFJLHVCQUF1QlQsSUFBdkIsQ0FBNEJTLEVBQTVCLENBQVAsSUFBNENELFlBQVksS0FBSyxLQUF6RTtBQUNBLE1BQUlTLFFBQVEsR0FBR1IsRUFBRSxJQUFJLGNBQWNULElBQWQsQ0FBbUJTLEVBQW5CLENBQU4sSUFBZ0MsQ0FBQ0ssTUFBaEQsQ0E5ZXFCLENBZ2ZyQjs7QUFDQSxNQUFJSSxXQUFXLEdBQUksRUFBRCxDQUFLQyxLQUF2QjtBQUVBLE1BQUlDLGVBQWUsR0FBRyxLQUF0Qjs7QUFDQSxNQUFJakIsU0FBSixFQUFlO0FBQ2IsUUFBSTtBQUNGLFVBQUlrQixJQUFJLEdBQUcsRUFBWDtBQUNBcEssWUFBTSxDQUFDeUksY0FBUCxDQUFzQjJCLElBQXRCLEVBQTRCLFNBQTVCLEVBQXdDO0FBQ3RDQyxXQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFnQjtBQUNuQjtBQUNBRix5QkFBZSxHQUFHLElBQWxCO0FBQ0Q7QUFKcUMsT0FBeEMsRUFGRSxDQU9HOztBQUNMaEIsWUFBTSxDQUFDbUIsZ0JBQVAsQ0FBd0IsY0FBeEIsRUFBd0MsSUFBeEMsRUFBOENGLElBQTlDO0FBQ0QsS0FURCxDQVNFLE9BQU96RCxDQUFQLEVBQVUsQ0FBRTtBQUNmLEdBL2ZvQixDQWlnQnJCO0FBQ0E7OztBQUNBLE1BQUk0RCxTQUFKOztBQUNBLE1BQUlDLGlCQUFpQixHQUFHLFlBQVk7QUFDbEMsUUFBSUQsU0FBUyxLQUFLbkssU0FBbEIsRUFBNkI7QUFDM0I7QUFDQSxVQUFJLENBQUM4SSxTQUFELElBQWMsQ0FBQ0UsTUFBZixJQUF5QixPQUFPekosTUFBUCxLQUFrQixXQUEvQyxFQUE0RDtBQUMxRDtBQUNBO0FBQ0E0SyxpQkFBUyxHQUFHNUssTUFBTSxDQUFDLFNBQUQsQ0FBTixDQUFrQjhLLEdBQWxCLENBQXNCQyxPQUF0QixLQUFrQyxRQUE5QztBQUNELE9BSkQsTUFJTztBQUNMSCxpQkFBUyxHQUFHLEtBQVo7QUFDRDtBQUNGOztBQUNELFdBQU9BLFNBQVA7QUFDRCxHQVpELENBcGdCcUIsQ0FraEJyQjs7O0FBQ0EsTUFBSS9DLFFBQVEsR0FBRzBCLFNBQVMsSUFBSUMsTUFBTSxDQUFDd0IsNEJBQW5DO0FBRUE7O0FBQ0EsV0FBU0MsUUFBVCxDQUFtQkMsSUFBbkIsRUFBeUI7QUFDdkIsV0FBTyxPQUFPQSxJQUFQLEtBQWdCLFVBQWhCLElBQThCLGNBQWM5QixJQUFkLENBQW1COEIsSUFBSSxDQUFDL0osUUFBTCxFQUFuQixDQUFyQztBQUNEOztBQUVELE1BQUlnSyxTQUFTLEdBQ1gsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0gsUUFBUSxDQUFDRyxNQUFELENBQXpDLElBQ0EsT0FBT0MsT0FBUCxLQUFtQixXQURuQixJQUNrQ0osUUFBUSxDQUFDSSxPQUFPLENBQUNDLE9BQVQsQ0FGNUM7O0FBSUEsTUFBSUMsSUFBSjtBQUNBO0FBQXlCOzs7QUFDekIsTUFBSSxPQUFPQyxHQUFQLEtBQWUsV0FBZixJQUE4QlAsUUFBUSxDQUFDTyxHQUFELENBQTFDLEVBQWlEO0FBQy9DO0FBQ0FELFFBQUksR0FBR0MsR0FBUDtBQUNELEdBSEQsTUFHTztBQUNMO0FBQ0FELFFBQUksR0FBSSxZQUFZO0FBQ2xCLGVBQVNDLEdBQVQsR0FBZ0I7QUFDZCxhQUFLQyxHQUFMLEdBQVdwTCxNQUFNLENBQUNvQyxNQUFQLENBQWMsSUFBZCxDQUFYO0FBQ0Q7O0FBQ0QrSSxTQUFHLENBQUN0SyxTQUFKLENBQWN3SyxHQUFkLEdBQW9CLFNBQVNBLEdBQVQsQ0FBY2pJLEdBQWQsRUFBbUI7QUFDckMsZUFBTyxLQUFLZ0ksR0FBTCxDQUFTaEksR0FBVCxNQUFrQixJQUF6QjtBQUNELE9BRkQ7O0FBR0ErSCxTQUFHLENBQUN0SyxTQUFKLENBQWN5SyxHQUFkLEdBQW9CLFNBQVNBLEdBQVQsQ0FBY2xJLEdBQWQsRUFBbUI7QUFDckMsYUFBS2dJLEdBQUwsQ0FBU2hJLEdBQVQsSUFBZ0IsSUFBaEI7QUFDRCxPQUZEOztBQUdBK0gsU0FBRyxDQUFDdEssU0FBSixDQUFjMEssS0FBZCxHQUFzQixTQUFTQSxLQUFULEdBQWtCO0FBQ3RDLGFBQUtILEdBQUwsR0FBV3BMLE1BQU0sQ0FBQ29DLE1BQVAsQ0FBYyxJQUFkLENBQVg7QUFDRCxPQUZEOztBQUlBLGFBQU8rSSxHQUFQO0FBQ0QsS0FmTyxFQUFSO0FBZ0JEO0FBRUQ7OztBQUVBLE1BQUlLLElBQUksR0FBR2hHLElBQVg7QUFDQSxNQUFJaUcsR0FBRyxHQUFHakcsSUFBVjtBQUNBLE1BQUlrRyxzQkFBc0IsR0FBSWxHLElBQTlCLENBM2pCcUIsQ0EyakJnQjs7QUFDckMsTUFBSW1HLG1CQUFtQixHQUFJbkcsSUFBM0I7QUFFQTtBQUNFLFFBQUlvRyxVQUFVLEdBQUcsT0FBT0MsT0FBUCxLQUFtQixXQUFwQztBQUNBLFFBQUlDLFVBQVUsR0FBRyxpQkFBakI7O0FBQ0EsUUFBSUMsUUFBUSxHQUFHLFVBQVU5SixHQUFWLEVBQWU7QUFBRSxhQUFPQSxHQUFHLENBQ3ZDMkIsT0FEb0MsQ0FDNUJrSSxVQUQ0QixFQUNoQixVQUFVaEksQ0FBVixFQUFhO0FBQUUsZUFBT0EsQ0FBQyxDQUFDQyxXQUFGLEVBQVA7QUFBeUIsT0FEeEIsRUFFcENILE9BRm9DLENBRTVCLE9BRjRCLEVBRW5CLEVBRm1CLENBQVA7QUFFTixLQUYxQjs7QUFJQTRILFFBQUksR0FBRyxVQUFVUSxHQUFWLEVBQWVDLEVBQWYsRUFBbUI7QUFDeEIsVUFBSUMsS0FBSyxHQUFHRCxFQUFFLEdBQUdQLHNCQUFzQixDQUFDTyxFQUFELENBQXpCLEdBQWdDLEVBQTlDOztBQUVBLFVBQUk3RSxNQUFNLENBQUNPLFdBQVgsRUFBd0I7QUFDdEJQLGNBQU0sQ0FBQ08sV0FBUCxDQUFtQjNHLElBQW5CLENBQXdCLElBQXhCLEVBQThCZ0wsR0FBOUIsRUFBbUNDLEVBQW5DLEVBQXVDQyxLQUF2QztBQUNELE9BRkQsTUFFTyxJQUFJTixVQUFVLElBQUssQ0FBQ3hFLE1BQU0sQ0FBQ0UsTUFBM0IsRUFBb0M7QUFDekN1RSxlQUFPLENBQUNNLEtBQVIsQ0FBZSxpQkFBaUJILEdBQWpCLEdBQXVCRSxLQUF0QztBQUNEO0FBQ0YsS0FSRDs7QUFVQVQsT0FBRyxHQUFHLFVBQVVPLEdBQVYsRUFBZUMsRUFBZixFQUFtQjtBQUN2QixVQUFJTCxVQUFVLElBQUssQ0FBQ3hFLE1BQU0sQ0FBQ0UsTUFBM0IsRUFBb0M7QUFDbEN1RSxlQUFPLENBQUNMLElBQVIsQ0FBYSxnQkFBZ0JRLEdBQWhCLElBQ1hDLEVBQUUsR0FBR1Asc0JBQXNCLENBQUNPLEVBQUQsQ0FBekIsR0FBZ0MsRUFEdkIsQ0FBYjtBQUdEO0FBQ0YsS0FORDs7QUFRQU4sdUJBQW1CLEdBQUcsVUFBVU0sRUFBVixFQUFjRyxXQUFkLEVBQTJCO0FBQy9DLFVBQUlILEVBQUUsQ0FBQ0ksS0FBSCxLQUFhSixFQUFqQixFQUFxQjtBQUNuQixlQUFPLFFBQVA7QUFDRDs7QUFDRCxVQUFJSyxPQUFPLEdBQUcsT0FBT0wsRUFBUCxLQUFjLFVBQWQsSUFBNEJBLEVBQUUsQ0FBQ00sR0FBSCxJQUFVLElBQXRDLEdBQ1ZOLEVBQUUsQ0FBQ0ssT0FETyxHQUVWTCxFQUFFLENBQUNPLE1BQUgsR0FDRVAsRUFBRSxDQUFDUSxRQUFILElBQWVSLEVBQUUsQ0FBQ1MsV0FBSCxDQUFlSixPQURoQyxHQUVFTCxFQUFFLElBQUksRUFKWjtBQUtBLFVBQUlVLElBQUksR0FBR0wsT0FBTyxDQUFDSyxJQUFSLElBQWdCTCxPQUFPLENBQUNNLGFBQW5DO0FBQ0EsVUFBSUMsSUFBSSxHQUFHUCxPQUFPLENBQUNRLE1BQW5COztBQUNBLFVBQUksQ0FBQ0gsSUFBRCxJQUFTRSxJQUFiLEVBQW1CO0FBQ2pCLFlBQUlFLEtBQUssR0FBR0YsSUFBSSxDQUFDRSxLQUFMLENBQVcsaUJBQVgsQ0FBWjtBQUNBSixZQUFJLEdBQUdJLEtBQUssSUFBSUEsS0FBSyxDQUFDLENBQUQsQ0FBckI7QUFDRDs7QUFFRCxhQUNFLENBQUNKLElBQUksR0FBSSxNQUFPWixRQUFRLENBQUNZLElBQUQsQ0FBZixHQUF5QixHQUE3QixHQUFvQyxhQUF6QyxLQUNDRSxJQUFJLElBQUlULFdBQVcsS0FBSyxLQUF4QixHQUFpQyxTQUFTUyxJQUExQyxHQUFrRCxFQURuRCxDQURGO0FBSUQsS0FwQkQ7O0FBc0JBLFFBQUlHLE1BQU0sR0FBRyxVQUFVL0ssR0FBVixFQUFlWCxDQUFmLEVBQWtCO0FBQzdCLFVBQUlpRSxHQUFHLEdBQUcsRUFBVjs7QUFDQSxhQUFPakUsQ0FBUCxFQUFVO0FBQ1IsWUFBSUEsQ0FBQyxHQUFHLENBQUosS0FBVSxDQUFkLEVBQWlCO0FBQUVpRSxhQUFHLElBQUl0RCxHQUFQO0FBQWE7O0FBQ2hDLFlBQUlYLENBQUMsR0FBRyxDQUFSLEVBQVc7QUFBRVcsYUFBRyxJQUFJQSxHQUFQO0FBQWE7O0FBQzFCWCxTQUFDLEtBQUssQ0FBTjtBQUNEOztBQUNELGFBQU9pRSxHQUFQO0FBQ0QsS0FSRDs7QUFVQW1HLDBCQUFzQixHQUFHLFVBQVVPLEVBQVYsRUFBYztBQUNyQyxVQUFJQSxFQUFFLENBQUNPLE1BQUgsSUFBYVAsRUFBRSxDQUFDZ0IsT0FBcEIsRUFBNkI7QUFDM0IsWUFBSUMsSUFBSSxHQUFHLEVBQVg7QUFDQSxZQUFJQyx3QkFBd0IsR0FBRyxDQUEvQjs7QUFDQSxlQUFPbEIsRUFBUCxFQUFXO0FBQ1QsY0FBSWlCLElBQUksQ0FBQzFLLE1BQUwsR0FBYyxDQUFsQixFQUFxQjtBQUNuQixnQkFBSTRLLElBQUksR0FBR0YsSUFBSSxDQUFDQSxJQUFJLENBQUMxSyxNQUFMLEdBQWMsQ0FBZixDQUFmOztBQUNBLGdCQUFJNEssSUFBSSxDQUFDVixXQUFMLEtBQXFCVCxFQUFFLENBQUNTLFdBQTVCLEVBQXlDO0FBQ3ZDUyxzQ0FBd0I7QUFDeEJsQixnQkFBRSxHQUFHQSxFQUFFLENBQUNnQixPQUFSO0FBQ0E7QUFDRCxhQUpELE1BSU8sSUFBSUUsd0JBQXdCLEdBQUcsQ0FBL0IsRUFBa0M7QUFDdkNELGtCQUFJLENBQUNBLElBQUksQ0FBQzFLLE1BQUwsR0FBYyxDQUFmLENBQUosR0FBd0IsQ0FBQzRLLElBQUQsRUFBT0Qsd0JBQVAsQ0FBeEI7QUFDQUEsc0NBQXdCLEdBQUcsQ0FBM0I7QUFDRDtBQUNGOztBQUNERCxjQUFJLENBQUNHLElBQUwsQ0FBVXBCLEVBQVY7QUFDQUEsWUFBRSxHQUFHQSxFQUFFLENBQUNnQixPQUFSO0FBQ0Q7O0FBQ0QsZUFBTyxxQkFBcUJDLElBQUksQ0FDN0IvSyxHQUR5QixDQUNyQixVQUFVOEosRUFBVixFQUFjMUosQ0FBZCxFQUFpQjtBQUFFLGlCQUFRLE1BQU1BLENBQUMsS0FBSyxDQUFOLEdBQVUsT0FBVixHQUFvQnlLLE1BQU0sQ0FBQyxHQUFELEVBQU0sSUFBSXpLLENBQUMsR0FBRyxDQUFkLENBQWhDLEtBQXFEMkMsS0FBSyxDQUFDc0IsT0FBTixDQUFjeUYsRUFBZCxJQUM3RU4sbUJBQW1CLENBQUNNLEVBQUUsQ0FBQyxDQUFELENBQUgsQ0FBcEIsR0FBK0IsT0FBL0IsR0FBMENBLEVBQUUsQ0FBQyxDQUFELENBQTVDLEdBQW1ELG1CQUQyQixHQUUvRU4sbUJBQW1CLENBQUNNLEVBQUQsQ0FGTyxDQUFSO0FBRVUsU0FIUixFQUl6QjlGLElBSnlCLENBSXBCLElBSm9CLENBQTVCO0FBS0QsT0F2QkQsTUF1Qk87QUFDTCxlQUFRLG1CQUFvQndGLG1CQUFtQixDQUFDTSxFQUFELENBQXZDLEdBQStDLEdBQXZEO0FBQ0Q7QUFDRixLQTNCRDtBQTRCRDtBQUVEOztBQUdBLE1BQUlxQixHQUFHLEdBQUcsQ0FBVjtBQUVBOzs7OztBQUlBLE1BQUlDLEdBQUcsR0FBRyxTQUFTQSxHQUFULEdBQWdCO0FBQ3hCLFNBQUtDLEVBQUwsR0FBVUYsR0FBRyxFQUFiO0FBQ0EsU0FBS0csSUFBTCxHQUFZLEVBQVo7QUFDRCxHQUhEOztBQUtBRixLQUFHLENBQUMxTSxTQUFKLENBQWM2TSxNQUFkLEdBQXVCLFNBQVNBLE1BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQzNDLFNBQUtGLElBQUwsQ0FBVUosSUFBVixDQUFlTSxHQUFmO0FBQ0QsR0FGRDs7QUFJQUosS0FBRyxDQUFDMU0sU0FBSixDQUFjK00sU0FBZCxHQUEwQixTQUFTQSxTQUFULENBQW9CRCxHQUFwQixFQUF5QjtBQUNqRC9LLFVBQU0sQ0FBQyxLQUFLNkssSUFBTixFQUFZRSxHQUFaLENBQU47QUFDRCxHQUZEOztBQUlBSixLQUFHLENBQUMxTSxTQUFKLENBQWNnTixNQUFkLEdBQXVCLFNBQVNBLE1BQVQsR0FBbUI7QUFDeEMsUUFBSU4sR0FBRyxDQUFDTyxNQUFSLEVBQWdCO0FBQ2RQLFNBQUcsQ0FBQ08sTUFBSixDQUFXQyxNQUFYLENBQWtCLElBQWxCO0FBQ0Q7QUFDRixHQUpEOztBQU1BUixLQUFHLENBQUMxTSxTQUFKLENBQWNtTixNQUFkLEdBQXVCLFNBQVNBLE1BQVQsR0FBbUI7QUFDeEM7QUFDQSxRQUFJUCxJQUFJLEdBQUcsS0FBS0EsSUFBTCxDQUFVeE0sS0FBVixFQUFYOztBQUNBLFNBQUssSUFBSXNCLENBQUMsR0FBRyxDQUFSLEVBQVdpQyxDQUFDLEdBQUdpSixJQUFJLENBQUNqTCxNQUF6QixFQUFpQ0QsQ0FBQyxHQUFHaUMsQ0FBckMsRUFBd0NqQyxDQUFDLEVBQXpDLEVBQTZDO0FBQzNDa0wsVUFBSSxDQUFDbEwsQ0FBRCxDQUFKLENBQVEwTCxNQUFSO0FBQ0Q7QUFDRixHQU5ELENBanJCcUIsQ0F5ckJyQjtBQUNBO0FBQ0E7OztBQUNBVixLQUFHLENBQUNPLE1BQUosR0FBYSxJQUFiO0FBQ0EsTUFBSUksV0FBVyxHQUFHLEVBQWxCOztBQUVBLFdBQVNDLFVBQVQsQ0FBcUJDLE9BQXJCLEVBQThCO0FBQzVCLFFBQUliLEdBQUcsQ0FBQ08sTUFBUixFQUFnQjtBQUFFSSxpQkFBVyxDQUFDYixJQUFaLENBQWlCRSxHQUFHLENBQUNPLE1BQXJCO0FBQStCOztBQUNqRFAsT0FBRyxDQUFDTyxNQUFKLEdBQWFNLE9BQWI7QUFDRDs7QUFFRCxXQUFTQyxTQUFULEdBQXNCO0FBQ3BCZCxPQUFHLENBQUNPLE1BQUosR0FBYUksV0FBVyxDQUFDSSxHQUFaLEVBQWI7QUFDRDtBQUVEOzs7QUFFQSxNQUFJQyxLQUFLLEdBQUcsU0FBU0EsS0FBVCxDQUNWQyxHQURVLEVBRVZDLElBRlUsRUFHVkMsUUFIVSxFQUlWQyxJQUpVLEVBS1ZDLEdBTFUsRUFNVkMsT0FOVSxFQU9WQyxnQkFQVSxFQVFWQyxZQVJVLEVBU1Y7QUFDQSxTQUFLUCxHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLQyxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLFNBQUtDLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtDLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUtJLEVBQUwsR0FBVTVPLFNBQVY7QUFDQSxTQUFLeU8sT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS0ksU0FBTCxHQUFpQjdPLFNBQWpCO0FBQ0EsU0FBSzhPLFNBQUwsR0FBaUI5TyxTQUFqQjtBQUNBLFNBQUsrTyxTQUFMLEdBQWlCL08sU0FBakI7QUFDQSxTQUFLZ0QsR0FBTCxHQUFXcUwsSUFBSSxJQUFJQSxJQUFJLENBQUNyTCxHQUF4QjtBQUNBLFNBQUswTCxnQkFBTCxHQUF3QkEsZ0JBQXhCO0FBQ0EsU0FBS00saUJBQUwsR0FBeUJoUCxTQUF6QjtBQUNBLFNBQUtpUCxNQUFMLEdBQWNqUCxTQUFkO0FBQ0EsU0FBS2tQLEdBQUwsR0FBVyxLQUFYO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixLQUFoQjtBQUNBLFNBQUtDLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixLQUFoQjtBQUNBLFNBQUtDLE1BQUwsR0FBYyxLQUFkO0FBQ0EsU0FBS1osWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxTQUFLYSxTQUFMLEdBQWlCeFAsU0FBakI7QUFDQSxTQUFLeVAsa0JBQUwsR0FBMEIsS0FBMUI7QUFDRCxHQWpDRDs7QUFtQ0EsTUFBSUMsa0JBQWtCLEdBQUc7QUFBRUMsU0FBSyxFQUFFO0FBQUVwSCxrQkFBWSxFQUFFO0FBQWhCO0FBQVQsR0FBekIsQ0E3dUJxQixDQSt1QnJCOztBQUNBOztBQUNBbUgsb0JBQWtCLENBQUNDLEtBQW5CLENBQXlCMUYsR0FBekIsR0FBK0IsWUFBWTtBQUN6QyxXQUFPLEtBQUsrRSxpQkFBWjtBQUNELEdBRkQ7O0FBSUFwUCxRQUFNLENBQUNnUSxnQkFBUCxDQUF5QnpCLEtBQUssQ0FBQzFOLFNBQS9CLEVBQTBDaVAsa0JBQTFDOztBQUVBLE1BQUlHLGdCQUFnQixHQUFHLFVBQVV0QixJQUFWLEVBQWdCO0FBQ3JDLFFBQUtBLElBQUksS0FBSyxLQUFLLENBQW5CLEVBQXVCQSxJQUFJLEdBQUcsRUFBUDtBQUV2QixRQUFJdUIsSUFBSSxHQUFHLElBQUkzQixLQUFKLEVBQVg7QUFDQTJCLFFBQUksQ0FBQ3ZCLElBQUwsR0FBWUEsSUFBWjtBQUNBdUIsUUFBSSxDQUFDVCxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsV0FBT1MsSUFBUDtBQUNELEdBUEQ7O0FBU0EsV0FBU0MsZUFBVCxDQUEwQjlPLEdBQTFCLEVBQStCO0FBQzdCLFdBQU8sSUFBSWtOLEtBQUosQ0FBVW5PLFNBQVYsRUFBcUJBLFNBQXJCLEVBQWdDQSxTQUFoQyxFQUEyQ29CLE1BQU0sQ0FBQ0gsR0FBRCxDQUFqRCxDQUFQO0FBQ0QsR0Fsd0JvQixDQW93QnJCO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTK08sVUFBVCxDQUFxQkMsS0FBckIsRUFBNEI7QUFDMUIsUUFBSUMsTUFBTSxHQUFHLElBQUkvQixLQUFKLENBQ1g4QixLQUFLLENBQUM3QixHQURLLEVBRVg2QixLQUFLLENBQUM1QixJQUZLLEVBR1g0QixLQUFLLENBQUMzQixRQUhLLEVBSVgyQixLQUFLLENBQUMxQixJQUpLLEVBS1gwQixLQUFLLENBQUN6QixHQUxLLEVBTVh5QixLQUFLLENBQUN4QixPQU5LLEVBT1h3QixLQUFLLENBQUN2QixnQkFQSyxFQVFYdUIsS0FBSyxDQUFDdEIsWUFSSyxDQUFiO0FBVUF1QixVQUFNLENBQUN0QixFQUFQLEdBQVlxQixLQUFLLENBQUNyQixFQUFsQjtBQUNBc0IsVUFBTSxDQUFDZixRQUFQLEdBQWtCYyxLQUFLLENBQUNkLFFBQXhCO0FBQ0FlLFVBQU0sQ0FBQ2xOLEdBQVAsR0FBYWlOLEtBQUssQ0FBQ2pOLEdBQW5CO0FBQ0FrTixVQUFNLENBQUNiLFNBQVAsR0FBbUJZLEtBQUssQ0FBQ1osU0FBekI7QUFDQWEsVUFBTSxDQUFDckIsU0FBUCxHQUFtQm9CLEtBQUssQ0FBQ3BCLFNBQXpCO0FBQ0FxQixVQUFNLENBQUNwQixTQUFQLEdBQW1CbUIsS0FBSyxDQUFDbkIsU0FBekI7QUFDQW9CLFVBQU0sQ0FBQ25CLFNBQVAsR0FBbUJrQixLQUFLLENBQUNsQixTQUF6QjtBQUNBbUIsVUFBTSxDQUFDWixRQUFQLEdBQWtCLElBQWxCO0FBQ0EsV0FBT1ksTUFBUDtBQUNEO0FBRUQ7Ozs7OztBQUtBLE1BQUlDLFVBQVUsR0FBR3JMLEtBQUssQ0FBQ3JFLFNBQXZCO0FBQ0EsTUFBSTJQLFlBQVksR0FBR3hRLE1BQU0sQ0FBQ29DLE1BQVAsQ0FBY21PLFVBQWQsQ0FBbkI7QUFFQSxNQUFJRSxjQUFjLEdBQUcsQ0FDbkIsTUFEbUIsRUFFbkIsS0FGbUIsRUFHbkIsT0FIbUIsRUFJbkIsU0FKbUIsRUFLbkIsUUFMbUIsRUFNbkIsTUFObUIsRUFPbkIsU0FQbUIsQ0FBckI7QUFVQTs7OztBQUdBQSxnQkFBYyxDQUFDQyxPQUFmLENBQXVCLFVBQVVDLE1BQVYsRUFBa0I7QUFDdkM7QUFDQSxRQUFJQyxRQUFRLEdBQUdMLFVBQVUsQ0FBQ0ksTUFBRCxDQUF6QjtBQUNBcEksT0FBRyxDQUFDaUksWUFBRCxFQUFlRyxNQUFmLEVBQXVCLFNBQVNFLE9BQVQsR0FBb0I7QUFDNUMsVUFBSUMsSUFBSSxHQUFHLEVBQVg7QUFBQSxVQUFlQyxHQUFHLEdBQUd0TSxTQUFTLENBQUNqQyxNQUEvQjs7QUFDQSxhQUFRdU8sR0FBRyxFQUFYLEVBQWdCRCxJQUFJLENBQUVDLEdBQUYsQ0FBSixHQUFjdE0sU0FBUyxDQUFFc00sR0FBRixDQUF2Qjs7QUFFaEIsVUFBSUMsTUFBTSxHQUFHSixRQUFRLENBQUNsTSxLQUFULENBQWUsSUFBZixFQUFxQm9NLElBQXJCLENBQWI7QUFDQSxVQUFJRyxFQUFFLEdBQUcsS0FBS0MsTUFBZDtBQUNBLFVBQUlDLFFBQUo7O0FBQ0EsY0FBUVIsTUFBUjtBQUNFLGFBQUssTUFBTDtBQUNBLGFBQUssU0FBTDtBQUNFUSxrQkFBUSxHQUFHTCxJQUFYO0FBQ0E7O0FBQ0YsYUFBSyxRQUFMO0FBQ0VLLGtCQUFRLEdBQUdMLElBQUksQ0FBQzdQLEtBQUwsQ0FBVyxDQUFYLENBQVg7QUFDQTtBQVBKOztBQVNBLFVBQUlrUSxRQUFKLEVBQWM7QUFBRUYsVUFBRSxDQUFDRyxZQUFILENBQWdCRCxRQUFoQjtBQUE0QixPQWhCQSxDQWlCNUM7OztBQUNBRixRQUFFLENBQUNJLEdBQUgsQ0FBT3JELE1BQVA7QUFDQSxhQUFPZ0QsTUFBUDtBQUNELEtBcEJFLENBQUg7QUFxQkQsR0F4QkQ7QUEwQkE7O0FBRUEsTUFBSU0sU0FBUyxHQUFHdFIsTUFBTSxDQUFDdVIsbUJBQVAsQ0FBMkJmLFlBQTNCLENBQWhCO0FBRUE7Ozs7O0FBSUEsTUFBSWdCLGFBQWEsR0FBRyxJQUFwQjs7QUFFQSxXQUFTQyxlQUFULENBQTBCaFIsS0FBMUIsRUFBaUM7QUFDL0IrUSxpQkFBYSxHQUFHL1EsS0FBaEI7QUFDRDtBQUVEOzs7Ozs7OztBQU1BLE1BQUlpUixRQUFRLEdBQUcsU0FBU0EsUUFBVCxDQUFtQmpSLEtBQW5CLEVBQTBCO0FBQ3ZDLFNBQUtBLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUs0USxHQUFMLEdBQVcsSUFBSTlELEdBQUosRUFBWDtBQUNBLFNBQUtvRSxPQUFMLEdBQWUsQ0FBZjtBQUNBcEosT0FBRyxDQUFDOUgsS0FBRCxFQUFRLFFBQVIsRUFBa0IsSUFBbEIsQ0FBSDs7QUFDQSxRQUFJeUUsS0FBSyxDQUFDc0IsT0FBTixDQUFjL0YsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCLFVBQUltUixPQUFPLEdBQUczSSxRQUFRLEdBQ2xCNEksWUFEa0IsR0FFbEJDLFdBRko7QUFHQUYsYUFBTyxDQUFDblIsS0FBRCxFQUFRK1AsWUFBUixFQUFzQmMsU0FBdEIsQ0FBUDtBQUNBLFdBQUtGLFlBQUwsQ0FBa0IzUSxLQUFsQjtBQUNELEtBTkQsTUFNTztBQUNMLFdBQUtzUixJQUFMLENBQVV0UixLQUFWO0FBQ0Q7QUFDRixHQWREO0FBZ0JBOzs7Ozs7O0FBS0FpUixVQUFRLENBQUM3USxTQUFULENBQW1Ca1IsSUFBbkIsR0FBMEIsU0FBU0EsSUFBVCxDQUFlcFIsR0FBZixFQUFvQjtBQUM1QyxRQUFJb0YsSUFBSSxHQUFHL0YsTUFBTSxDQUFDK0YsSUFBUCxDQUFZcEYsR0FBWixDQUFYOztBQUNBLFNBQUssSUFBSTRCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd3RCxJQUFJLENBQUN2RCxNQUF6QixFQUFpQ0QsQ0FBQyxFQUFsQyxFQUFzQztBQUNwQ3lQLG9CQUFjLENBQUNyUixHQUFELEVBQU1vRixJQUFJLENBQUN4RCxDQUFELENBQVYsQ0FBZDtBQUNEO0FBQ0YsR0FMRDtBQU9BOzs7OztBQUdBbVAsVUFBUSxDQUFDN1EsU0FBVCxDQUFtQnVRLFlBQW5CLEdBQWtDLFNBQVNBLFlBQVQsQ0FBdUJhLEtBQXZCLEVBQThCO0FBQzlELFNBQUssSUFBSTFQLENBQUMsR0FBRyxDQUFSLEVBQVdpQyxDQUFDLEdBQUd5TixLQUFLLENBQUN6UCxNQUExQixFQUFrQ0QsQ0FBQyxHQUFHaUMsQ0FBdEMsRUFBeUNqQyxDQUFDLEVBQTFDLEVBQThDO0FBQzVDMlAsYUFBTyxDQUFDRCxLQUFLLENBQUMxUCxDQUFELENBQU4sQ0FBUDtBQUNEO0FBQ0YsR0FKRCxDQWg0QnFCLENBczRCckI7O0FBRUE7Ozs7OztBQUlBLFdBQVNzUCxZQUFULENBQXVCL0QsTUFBdkIsRUFBK0JxRSxHQUEvQixFQUFvQ3BNLElBQXBDLEVBQTBDO0FBQ3hDO0FBQ0ErSCxVQUFNLENBQUNzRSxTQUFQLEdBQW1CRCxHQUFuQjtBQUNBO0FBQ0Q7QUFFRDs7Ozs7QUFJQTs7O0FBQ0EsV0FBU0wsV0FBVCxDQUFzQmhFLE1BQXRCLEVBQThCcUUsR0FBOUIsRUFBbUNwTSxJQUFuQyxFQUF5QztBQUN2QyxTQUFLLElBQUl4RCxDQUFDLEdBQUcsQ0FBUixFQUFXaUMsQ0FBQyxHQUFHdUIsSUFBSSxDQUFDdkQsTUFBekIsRUFBaUNELENBQUMsR0FBR2lDLENBQXJDLEVBQXdDakMsQ0FBQyxFQUF6QyxFQUE2QztBQUMzQyxVQUFJYSxHQUFHLEdBQUcyQyxJQUFJLENBQUN4RCxDQUFELENBQWQ7QUFDQWdHLFNBQUcsQ0FBQ3VGLE1BQUQsRUFBUzFLLEdBQVQsRUFBYytPLEdBQUcsQ0FBQy9PLEdBQUQsQ0FBakIsQ0FBSDtBQUNEO0FBQ0Y7QUFFRDs7Ozs7OztBQUtBLFdBQVM4TyxPQUFULENBQWtCelIsS0FBbEIsRUFBeUI0UixVQUF6QixFQUFxQztBQUNuQyxRQUFJLENBQUMzUixRQUFRLENBQUNELEtBQUQsQ0FBVCxJQUFvQkEsS0FBSyxZQUFZOE4sS0FBekMsRUFBZ0Q7QUFDOUM7QUFDRDs7QUFDRCxRQUFJMEMsRUFBSjs7QUFDQSxRQUFJOU4sTUFBTSxDQUFDMUMsS0FBRCxFQUFRLFFBQVIsQ0FBTixJQUEyQkEsS0FBSyxDQUFDeVEsTUFBTixZQUF3QlEsUUFBdkQsRUFBaUU7QUFDL0RULFFBQUUsR0FBR3hRLEtBQUssQ0FBQ3lRLE1BQVg7QUFDRCxLQUZELE1BRU8sSUFDTE0sYUFBYSxJQUNiLENBQUNoSCxpQkFBaUIsRUFEbEIsS0FFQ3RGLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBYy9GLEtBQWQsS0FBd0JTLGFBQWEsQ0FBQ1QsS0FBRCxDQUZ0QyxLQUdBVCxNQUFNLENBQUNzUyxZQUFQLENBQW9CN1IsS0FBcEIsQ0FIQSxJQUlBLENBQUNBLEtBQUssQ0FBQytMLE1BTEYsRUFNTDtBQUNBeUUsUUFBRSxHQUFHLElBQUlTLFFBQUosQ0FBYWpSLEtBQWIsQ0FBTDtBQUNEOztBQUNELFFBQUk0UixVQUFVLElBQUlwQixFQUFsQixFQUFzQjtBQUNwQkEsUUFBRSxDQUFDVSxPQUFIO0FBQ0Q7O0FBQ0QsV0FBT1YsRUFBUDtBQUNEO0FBRUQ7Ozs7O0FBR0EsV0FBU2UsY0FBVCxDQUNFclIsR0FERixFQUVFeUMsR0FGRixFQUdFL0IsR0FIRixFQUlFa1IsWUFKRixFQUtFQyxPQUxGLEVBTUU7QUFDQSxRQUFJbkIsR0FBRyxHQUFHLElBQUk5RCxHQUFKLEVBQVY7QUFFQSxRQUFJa0YsUUFBUSxHQUFHelMsTUFBTSxDQUFDMFMsd0JBQVAsQ0FBZ0MvUixHQUFoQyxFQUFxQ3lDLEdBQXJDLENBQWY7O0FBQ0EsUUFBSXFQLFFBQVEsSUFBSUEsUUFBUSxDQUFDOUosWUFBVCxLQUEwQixLQUExQyxFQUFpRDtBQUMvQztBQUNELEtBTkQsQ0FRQTs7O0FBQ0EsUUFBSWdLLE1BQU0sR0FBR0YsUUFBUSxJQUFJQSxRQUFRLENBQUNwSSxHQUFsQzs7QUFDQSxRQUFJLENBQUNzSSxNQUFELElBQVdsTyxTQUFTLENBQUNqQyxNQUFWLEtBQXFCLENBQXBDLEVBQXVDO0FBQ3JDbkIsU0FBRyxHQUFHVixHQUFHLENBQUN5QyxHQUFELENBQVQ7QUFDRDs7QUFDRCxRQUFJd1AsTUFBTSxHQUFHSCxRQUFRLElBQUlBLFFBQVEsQ0FBQ3JILEdBQWxDO0FBRUEsUUFBSXlILE9BQU8sR0FBRyxDQUFDTCxPQUFELElBQVlOLE9BQU8sQ0FBQzdRLEdBQUQsQ0FBakM7QUFDQXJCLFVBQU0sQ0FBQ3lJLGNBQVAsQ0FBc0I5SCxHQUF0QixFQUEyQnlDLEdBQTNCLEVBQWdDO0FBQzlCb0YsZ0JBQVUsRUFBRSxJQURrQjtBQUU5Qkcsa0JBQVksRUFBRSxJQUZnQjtBQUc5QjBCLFNBQUcsRUFBRSxTQUFTeUksY0FBVCxHQUEyQjtBQUM5QixZQUFJclMsS0FBSyxHQUFHa1MsTUFBTSxHQUFHQSxNQUFNLENBQUMzUixJQUFQLENBQVlMLEdBQVosQ0FBSCxHQUFzQlUsR0FBeEM7O0FBQ0EsWUFBSWtNLEdBQUcsQ0FBQ08sTUFBUixFQUFnQjtBQUNkdUQsYUFBRyxDQUFDeEQsTUFBSjs7QUFDQSxjQUFJZ0YsT0FBSixFQUFhO0FBQ1hBLG1CQUFPLENBQUN4QixHQUFSLENBQVl4RCxNQUFaOztBQUNBLGdCQUFJM0ksS0FBSyxDQUFDc0IsT0FBTixDQUFjL0YsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCc1MseUJBQVcsQ0FBQ3RTLEtBQUQsQ0FBWDtBQUNEO0FBQ0Y7QUFDRjs7QUFDRCxlQUFPQSxLQUFQO0FBQ0QsT0FmNkI7QUFnQjlCMkssU0FBRyxFQUFFLFNBQVM0SCxjQUFULENBQXlCQyxNQUF6QixFQUFpQztBQUNwQyxZQUFJeFMsS0FBSyxHQUFHa1MsTUFBTSxHQUFHQSxNQUFNLENBQUMzUixJQUFQLENBQVlMLEdBQVosQ0FBSCxHQUFzQlUsR0FBeEM7QUFDQTs7QUFDQSxZQUFJNFIsTUFBTSxLQUFLeFMsS0FBWCxJQUFxQndTLE1BQU0sS0FBS0EsTUFBWCxJQUFxQnhTLEtBQUssS0FBS0EsS0FBeEQsRUFBZ0U7QUFDOUQ7QUFDRDtBQUNEOzs7QUFDQSxZQUFJLGtCQUFrQixZQUFsQixJQUFrQzhSLFlBQXRDLEVBQW9EO0FBQ2xEQSxzQkFBWTtBQUNiOztBQUNELFlBQUlLLE1BQUosRUFBWTtBQUNWQSxnQkFBTSxDQUFDNVIsSUFBUCxDQUFZTCxHQUFaLEVBQWlCc1MsTUFBakI7QUFDRCxTQUZELE1BRU87QUFDTDVSLGFBQUcsR0FBRzRSLE1BQU47QUFDRDs7QUFDREosZUFBTyxHQUFHLENBQUNMLE9BQUQsSUFBWU4sT0FBTyxDQUFDZSxNQUFELENBQTdCO0FBQ0E1QixXQUFHLENBQUNyRCxNQUFKO0FBQ0Q7QUFqQzZCLEtBQWhDO0FBbUNEO0FBRUQ7Ozs7Ozs7QUFLQSxXQUFTNUMsR0FBVCxDQUFjMEMsTUFBZCxFQUFzQjFLLEdBQXRCLEVBQTJCL0IsR0FBM0IsRUFBZ0M7QUFDOUIsUUFBSSxrQkFBa0IsWUFBbEIsS0FDRG5CLE9BQU8sQ0FBQzROLE1BQUQsQ0FBUCxJQUFtQnROLFdBQVcsQ0FBQ3NOLE1BQUQsQ0FEN0IsQ0FBSixFQUVFO0FBQ0F0QyxVQUFJLENBQUUsMEVBQTRFc0MsTUFBOUUsQ0FBSjtBQUNEOztBQUNELFFBQUk1SSxLQUFLLENBQUNzQixPQUFOLENBQWNzSCxNQUFkLEtBQXlCMU0saUJBQWlCLENBQUNnQyxHQUFELENBQTlDLEVBQXFEO0FBQ25EMEssWUFBTSxDQUFDdEwsTUFBUCxHQUFnQmYsSUFBSSxDQUFDeVIsR0FBTCxDQUFTcEYsTUFBTSxDQUFDdEwsTUFBaEIsRUFBd0JZLEdBQXhCLENBQWhCO0FBQ0EwSyxZQUFNLENBQUM3SyxNQUFQLENBQWNHLEdBQWQsRUFBbUIsQ0FBbkIsRUFBc0IvQixHQUF0QjtBQUNBLGFBQU9BLEdBQVA7QUFDRDs7QUFDRCxRQUFJK0IsR0FBRyxJQUFJMEssTUFBUCxJQUFpQixFQUFFMUssR0FBRyxJQUFJcEQsTUFBTSxDQUFDYSxTQUFoQixDQUFyQixFQUFpRDtBQUMvQ2lOLFlBQU0sQ0FBQzFLLEdBQUQsQ0FBTixHQUFjL0IsR0FBZDtBQUNBLGFBQU9BLEdBQVA7QUFDRDs7QUFDRCxRQUFJNFAsRUFBRSxHQUFJbkQsTUFBRCxDQUFTb0QsTUFBbEI7O0FBQ0EsUUFBSXBELE1BQU0sQ0FBQ3RCLE1BQVAsSUFBa0J5RSxFQUFFLElBQUlBLEVBQUUsQ0FBQ1UsT0FBL0IsRUFBeUM7QUFDdkMsd0JBQWtCLFlBQWxCLElBQWtDbkcsSUFBSSxDQUNwQywwRUFDQSxxREFGb0MsQ0FBdEM7QUFJQSxhQUFPbkssR0FBUDtBQUNEOztBQUNELFFBQUksQ0FBQzRQLEVBQUwsRUFBUztBQUNQbkQsWUFBTSxDQUFDMUssR0FBRCxDQUFOLEdBQWMvQixHQUFkO0FBQ0EsYUFBT0EsR0FBUDtBQUNEOztBQUNEMlEsa0JBQWMsQ0FBQ2YsRUFBRSxDQUFDeFEsS0FBSixFQUFXMkMsR0FBWCxFQUFnQi9CLEdBQWhCLENBQWQ7QUFDQTRQLE1BQUUsQ0FBQ0ksR0FBSCxDQUFPckQsTUFBUDtBQUNBLFdBQU8zTSxHQUFQO0FBQ0Q7QUFFRDs7Ozs7QUFHQSxXQUFTOFIsR0FBVCxDQUFjckYsTUFBZCxFQUFzQjFLLEdBQXRCLEVBQTJCO0FBQ3pCLFFBQUksa0JBQWtCLFlBQWxCLEtBQ0RsRCxPQUFPLENBQUM0TixNQUFELENBQVAsSUFBbUJ0TixXQUFXLENBQUNzTixNQUFELENBRDdCLENBQUosRUFFRTtBQUNBdEMsVUFBSSxDQUFFLDZFQUErRXNDLE1BQWpGLENBQUo7QUFDRDs7QUFDRCxRQUFJNUksS0FBSyxDQUFDc0IsT0FBTixDQUFjc0gsTUFBZCxLQUF5QjFNLGlCQUFpQixDQUFDZ0MsR0FBRCxDQUE5QyxFQUFxRDtBQUNuRDBLLFlBQU0sQ0FBQzdLLE1BQVAsQ0FBY0csR0FBZCxFQUFtQixDQUFuQjtBQUNBO0FBQ0Q7O0FBQ0QsUUFBSTZOLEVBQUUsR0FBSW5ELE1BQUQsQ0FBU29ELE1BQWxCOztBQUNBLFFBQUlwRCxNQUFNLENBQUN0QixNQUFQLElBQWtCeUUsRUFBRSxJQUFJQSxFQUFFLENBQUNVLE9BQS9CLEVBQXlDO0FBQ3ZDLHdCQUFrQixZQUFsQixJQUFrQ25HLElBQUksQ0FDcEMsbUVBQ0Esd0JBRm9DLENBQXRDO0FBSUE7QUFDRDs7QUFDRCxRQUFJLENBQUNySSxNQUFNLENBQUMySyxNQUFELEVBQVMxSyxHQUFULENBQVgsRUFBMEI7QUFDeEI7QUFDRDs7QUFDRCxXQUFPMEssTUFBTSxDQUFDMUssR0FBRCxDQUFiOztBQUNBLFFBQUksQ0FBQzZOLEVBQUwsRUFBUztBQUNQO0FBQ0Q7O0FBQ0RBLE1BQUUsQ0FBQ0ksR0FBSCxDQUFPckQsTUFBUDtBQUNEO0FBRUQ7Ozs7OztBQUlBLFdBQVMrRSxXQUFULENBQXNCdFMsS0FBdEIsRUFBNkI7QUFDM0IsU0FBSyxJQUFJa0csQ0FBQyxHQUFJLEtBQUssQ0FBZCxFQUFrQnBFLENBQUMsR0FBRyxDQUF0QixFQUF5QmlDLENBQUMsR0FBRy9ELEtBQUssQ0FBQytCLE1BQXhDLEVBQWdERCxDQUFDLEdBQUdpQyxDQUFwRCxFQUF1RGpDLENBQUMsRUFBeEQsRUFBNEQ7QUFDMURvRSxPQUFDLEdBQUdsRyxLQUFLLENBQUM4QixDQUFELENBQVQ7QUFDQW9FLE9BQUMsSUFBSUEsQ0FBQyxDQUFDdUssTUFBUCxJQUFpQnZLLENBQUMsQ0FBQ3VLLE1BQUYsQ0FBU0csR0FBVCxDQUFheEQsTUFBYixFQUFqQjs7QUFDQSxVQUFJM0ksS0FBSyxDQUFDc0IsT0FBTixDQUFjRyxDQUFkLENBQUosRUFBc0I7QUFDcEJvTSxtQkFBVyxDQUFDcE0sQ0FBRCxDQUFYO0FBQ0Q7QUFDRjtBQUNGO0FBRUQ7O0FBRUE7Ozs7Ozs7QUFLQSxNQUFJeU0sTUFBTSxHQUFHaE0sTUFBTSxDQUFDQyxxQkFBcEI7QUFFQTs7OztBQUdBO0FBQ0UrTCxVQUFNLENBQUNDLEVBQVAsR0FBWUQsTUFBTSxDQUFDRSxTQUFQLEdBQW1CLFVBQVVqRSxNQUFWLEVBQWtCVSxLQUFsQixFQUF5QjlELEVBQXpCLEVBQTZCN0ksR0FBN0IsRUFBa0M7QUFDL0QsVUFBSSxDQUFDNkksRUFBTCxFQUFTO0FBQ1BULFlBQUksQ0FDRixjQUFjcEksR0FBZCxHQUFvQixzQ0FBcEIsR0FDQSxrQ0FGRSxDQUFKO0FBSUQ7O0FBQ0QsYUFBT21RLFlBQVksQ0FBQ2xFLE1BQUQsRUFBU1UsS0FBVCxDQUFuQjtBQUNELEtBUkQ7QUFTRDtBQUVEOzs7O0FBR0EsV0FBU3lELFNBQVQsQ0FBb0JwTyxFQUFwQixFQUF3QnFPLElBQXhCLEVBQThCO0FBQzVCLFFBQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQUUsYUFBT3JPLEVBQVA7QUFBVzs7QUFDeEIsUUFBSWhDLEdBQUosRUFBU3NRLEtBQVQsRUFBZ0JDLE9BQWhCO0FBQ0EsUUFBSTVOLElBQUksR0FBRy9GLE1BQU0sQ0FBQytGLElBQVAsQ0FBWTBOLElBQVosQ0FBWDs7QUFDQSxTQUFLLElBQUlsUixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHd0QsSUFBSSxDQUFDdkQsTUFBekIsRUFBaUNELENBQUMsRUFBbEMsRUFBc0M7QUFDcENhLFNBQUcsR0FBRzJDLElBQUksQ0FBQ3hELENBQUQsQ0FBVjtBQUNBbVIsV0FBSyxHQUFHdE8sRUFBRSxDQUFDaEMsR0FBRCxDQUFWO0FBQ0F1USxhQUFPLEdBQUdGLElBQUksQ0FBQ3JRLEdBQUQsQ0FBZDs7QUFDQSxVQUFJLENBQUNELE1BQU0sQ0FBQ2lDLEVBQUQsRUFBS2hDLEdBQUwsQ0FBWCxFQUFzQjtBQUNwQmdJLFdBQUcsQ0FBQ2hHLEVBQUQsRUFBS2hDLEdBQUwsRUFBVXVRLE9BQVYsQ0FBSDtBQUNELE9BRkQsTUFFTyxJQUFJelMsYUFBYSxDQUFDd1MsS0FBRCxDQUFiLElBQXdCeFMsYUFBYSxDQUFDeVMsT0FBRCxDQUF6QyxFQUFvRDtBQUN6REgsaUJBQVMsQ0FBQ0UsS0FBRCxFQUFRQyxPQUFSLENBQVQ7QUFDRDtBQUNGOztBQUNELFdBQU92TyxFQUFQO0FBQ0Q7QUFFRDs7Ozs7QUFHQSxXQUFTd08sYUFBVCxDQUNFQyxTQURGLEVBRUVDLFFBRkYsRUFHRTdILEVBSEYsRUFJRTtBQUNBLFFBQUksQ0FBQ0EsRUFBTCxFQUFTO0FBQ1A7QUFDQSxVQUFJLENBQUM2SCxRQUFMLEVBQWU7QUFDYixlQUFPRCxTQUFQO0FBQ0Q7O0FBQ0QsVUFBSSxDQUFDQSxTQUFMLEVBQWdCO0FBQ2QsZUFBT0MsUUFBUDtBQUNELE9BUE0sQ0FRUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxhQUFPLFNBQVNDLFlBQVQsR0FBeUI7QUFDOUIsZUFBT1AsU0FBUyxDQUNkLE9BQU9NLFFBQVAsS0FBb0IsVUFBcEIsR0FBaUNBLFFBQVEsQ0FBQzlTLElBQVQsQ0FBYyxJQUFkLEVBQW9CLElBQXBCLENBQWpDLEdBQTZEOFMsUUFEL0MsRUFFZCxPQUFPRCxTQUFQLEtBQXFCLFVBQXJCLEdBQWtDQSxTQUFTLENBQUM3UyxJQUFWLENBQWUsSUFBZixFQUFxQixJQUFyQixDQUFsQyxHQUErRDZTLFNBRmpELENBQWhCO0FBSUQsT0FMRDtBQU1ELEtBbkJELE1BbUJPO0FBQ0wsYUFBTyxTQUFTRyxvQkFBVCxHQUFpQztBQUN0QztBQUNBLFlBQUlDLFlBQVksR0FBRyxPQUFPSCxRQUFQLEtBQW9CLFVBQXBCLEdBQ2ZBLFFBQVEsQ0FBQzlTLElBQVQsQ0FBY2lMLEVBQWQsRUFBa0JBLEVBQWxCLENBRGUsR0FFZjZILFFBRko7QUFHQSxZQUFJSSxXQUFXLEdBQUcsT0FBT0wsU0FBUCxLQUFxQixVQUFyQixHQUNkQSxTQUFTLENBQUM3UyxJQUFWLENBQWVpTCxFQUFmLEVBQW1CQSxFQUFuQixDQURjLEdBRWQ0SCxTQUZKOztBQUdBLFlBQUlJLFlBQUosRUFBa0I7QUFDaEIsaUJBQU9ULFNBQVMsQ0FBQ1MsWUFBRCxFQUFlQyxXQUFmLENBQWhCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU9BLFdBQVA7QUFDRDtBQUNGLE9BYkQ7QUFjRDtBQUNGOztBQUVEZCxRQUFNLENBQUMzRSxJQUFQLEdBQWMsVUFDWm9GLFNBRFksRUFFWkMsUUFGWSxFQUdaN0gsRUFIWSxFQUlaO0FBQ0EsUUFBSSxDQUFDQSxFQUFMLEVBQVM7QUFDUCxVQUFJNkgsUUFBUSxJQUFJLE9BQU9BLFFBQVAsS0FBb0IsVUFBcEMsRUFBZ0Q7QUFDOUMsMEJBQWtCLFlBQWxCLElBQWtDdEksSUFBSSxDQUNwQyw0Q0FDQSxpREFEQSxHQUVBLGNBSG9DLEVBSXBDUyxFQUpvQyxDQUF0QztBQU9BLGVBQU80SCxTQUFQO0FBQ0Q7O0FBQ0QsYUFBT0QsYUFBYSxDQUFDQyxTQUFELEVBQVlDLFFBQVosQ0FBcEI7QUFDRDs7QUFFRCxXQUFPRixhQUFhLENBQUNDLFNBQUQsRUFBWUMsUUFBWixFQUFzQjdILEVBQXRCLENBQXBCO0FBQ0QsR0FwQkQ7QUFzQkE7Ozs7O0FBR0EsV0FBU2tJLFNBQVQsQ0FDRU4sU0FERixFQUVFQyxRQUZGLEVBR0U7QUFDQSxXQUFPQSxRQUFRLEdBQ1hELFNBQVMsR0FDUEEsU0FBUyxDQUFDNU4sTUFBVixDQUFpQjZOLFFBQWpCLENBRE8sR0FFUDVPLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY3NOLFFBQWQsSUFDRUEsUUFERixHQUVFLENBQUNBLFFBQUQsQ0FMTyxHQU1YRCxTQU5KO0FBT0Q7O0FBRUQxTSxpQkFBZSxDQUFDdUosT0FBaEIsQ0FBd0IsVUFBVTBELElBQVYsRUFBZ0I7QUFDdENoQixVQUFNLENBQUNnQixJQUFELENBQU4sR0FBZUQsU0FBZjtBQUNELEdBRkQ7QUFJQTs7Ozs7Ozs7QUFPQSxXQUFTRSxXQUFULENBQ0VSLFNBREYsRUFFRUMsUUFGRixFQUdFN0gsRUFIRixFQUlFN0ksR0FKRixFQUtFO0FBQ0EsUUFBSW1DLEdBQUcsR0FBR3ZGLE1BQU0sQ0FBQ29DLE1BQVAsQ0FBY3lSLFNBQVMsSUFBSSxJQUEzQixDQUFWOztBQUNBLFFBQUlDLFFBQUosRUFBYztBQUNaLHdCQUFrQixZQUFsQixJQUFrQ1EsZ0JBQWdCLENBQUNsUixHQUFELEVBQU0wUSxRQUFOLEVBQWdCN0gsRUFBaEIsQ0FBbEQ7QUFDQSxhQUFPOUcsTUFBTSxDQUFDSSxHQUFELEVBQU11TyxRQUFOLENBQWI7QUFDRCxLQUhELE1BR087QUFDTCxhQUFPdk8sR0FBUDtBQUNEO0FBQ0Y7O0FBRUQyQixhQUFXLENBQUN3SixPQUFaLENBQW9CLFVBQVU2RCxJQUFWLEVBQWdCO0FBQ2xDbkIsVUFBTSxDQUFDbUIsSUFBSSxHQUFHLEdBQVIsQ0FBTixHQUFxQkYsV0FBckI7QUFDRCxHQUZEO0FBSUE7Ozs7Ozs7QUFNQWpCLFFBQU0sQ0FBQ2xKLEtBQVAsR0FBZSxVQUNiMkosU0FEYSxFQUViQyxRQUZhLEVBR2I3SCxFQUhhLEVBSWI3SSxHQUphLEVBS2I7QUFDQTtBQUNBLFFBQUl5USxTQUFTLEtBQUs1SixXQUFsQixFQUErQjtBQUFFNEosZUFBUyxHQUFHelQsU0FBWjtBQUF3Qjs7QUFDekQsUUFBSTBULFFBQVEsS0FBSzdKLFdBQWpCLEVBQThCO0FBQUU2SixjQUFRLEdBQUcxVCxTQUFYO0FBQXVCO0FBQ3ZEOzs7QUFDQSxRQUFJLENBQUMwVCxRQUFMLEVBQWU7QUFBRSxhQUFPOVQsTUFBTSxDQUFDb0MsTUFBUCxDQUFjeVIsU0FBUyxJQUFJLElBQTNCLENBQVA7QUFBeUM7O0FBQzFEO0FBQ0VTLHNCQUFnQixDQUFDbFIsR0FBRCxFQUFNMFEsUUFBTixFQUFnQjdILEVBQWhCLENBQWhCO0FBQ0Q7O0FBQ0QsUUFBSSxDQUFDNEgsU0FBTCxFQUFnQjtBQUFFLGFBQU9DLFFBQVA7QUFBaUI7O0FBQ25DLFFBQUk3TyxHQUFHLEdBQUcsRUFBVjtBQUNBRSxVQUFNLENBQUNGLEdBQUQsRUFBTTRPLFNBQU4sQ0FBTjs7QUFDQSxTQUFLLElBQUlXLEtBQVQsSUFBa0JWLFFBQWxCLEVBQTRCO0FBQzFCLFVBQUl6RSxNQUFNLEdBQUdwSyxHQUFHLENBQUN1UCxLQUFELENBQWhCO0FBQ0EsVUFBSXpFLEtBQUssR0FBRytELFFBQVEsQ0FBQ1UsS0FBRCxDQUFwQjs7QUFDQSxVQUFJbkYsTUFBTSxJQUFJLENBQUNuSyxLQUFLLENBQUNzQixPQUFOLENBQWM2SSxNQUFkLENBQWYsRUFBc0M7QUFDcENBLGNBQU0sR0FBRyxDQUFDQSxNQUFELENBQVQ7QUFDRDs7QUFDRHBLLFNBQUcsQ0FBQ3VQLEtBQUQsQ0FBSCxHQUFhbkYsTUFBTSxHQUNmQSxNQUFNLENBQUNwSixNQUFQLENBQWM4SixLQUFkLENBRGUsR0FFZjdLLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY3VKLEtBQWQsSUFBdUJBLEtBQXZCLEdBQStCLENBQUNBLEtBQUQsQ0FGbkM7QUFHRDs7QUFDRCxXQUFPOUssR0FBUDtBQUNELEdBNUJEO0FBOEJBOzs7OztBQUdBbU8sUUFBTSxDQUFDcUIsS0FBUCxHQUNBckIsTUFBTSxDQUFDc0IsT0FBUCxHQUNBdEIsTUFBTSxDQUFDdUIsTUFBUCxHQUNBdkIsTUFBTSxDQUFDd0IsUUFBUCxHQUFrQixVQUNoQmYsU0FEZ0IsRUFFaEJDLFFBRmdCLEVBR2hCN0gsRUFIZ0IsRUFJaEI3SSxHQUpnQixFQUtoQjtBQUNBLFFBQUkwUSxRQUFRLElBQUksa0JBQWtCLFlBQWxDLEVBQWdEO0FBQzlDUSxzQkFBZ0IsQ0FBQ2xSLEdBQUQsRUFBTTBRLFFBQU4sRUFBZ0I3SCxFQUFoQixDQUFoQjtBQUNEOztBQUNELFFBQUksQ0FBQzRILFNBQUwsRUFBZ0I7QUFBRSxhQUFPQyxRQUFQO0FBQWlCOztBQUNuQyxRQUFJN08sR0FBRyxHQUFHakYsTUFBTSxDQUFDb0MsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBK0MsVUFBTSxDQUFDRixHQUFELEVBQU00TyxTQUFOLENBQU47O0FBQ0EsUUFBSUMsUUFBSixFQUFjO0FBQUUzTyxZQUFNLENBQUNGLEdBQUQsRUFBTTZPLFFBQU4sQ0FBTjtBQUF3Qjs7QUFDeEMsV0FBTzdPLEdBQVA7QUFDRCxHQWpCRDs7QUFrQkFtTyxRQUFNLENBQUN5QixPQUFQLEdBQWlCakIsYUFBakI7QUFFQTs7OztBQUdBLE1BQUlMLFlBQVksR0FBRyxVQUFVTSxTQUFWLEVBQXFCQyxRQUFyQixFQUErQjtBQUNoRCxXQUFPQSxRQUFRLEtBQUsxVCxTQUFiLEdBQ0h5VCxTQURHLEdBRUhDLFFBRko7QUFHRCxHQUpEO0FBTUE7Ozs7O0FBR0EsV0FBU2dCLGVBQVQsQ0FBMEJ4SSxPQUExQixFQUFtQztBQUNqQyxTQUFLLElBQUlsSixHQUFULElBQWdCa0osT0FBTyxDQUFDeUksVUFBeEIsRUFBb0M7QUFDbENDLDJCQUFxQixDQUFDNVIsR0FBRCxDQUFyQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBUzRSLHFCQUFULENBQWdDckksSUFBaEMsRUFBc0M7QUFDcEMsUUFBSSxDQUFDLG1CQUFtQjVELElBQW5CLENBQXdCNEQsSUFBeEIsQ0FBTCxFQUFvQztBQUNsQ25CLFVBQUksQ0FDRiw4QkFBOEJtQixJQUE5QixHQUFxQyxxQkFBckMsR0FDQSwyREFEQSxHQUVBLCtCQUhFLENBQUo7QUFLRDs7QUFDRCxRQUFJakssWUFBWSxDQUFDaUssSUFBRCxDQUFaLElBQXNCdkYsTUFBTSxDQUFDVSxhQUFQLENBQXFCNkUsSUFBckIsQ0FBMUIsRUFBc0Q7QUFDcERuQixVQUFJLENBQ0YsZ0VBQ0EsTUFEQSxHQUNTbUIsSUFGUCxDQUFKO0FBSUQ7QUFDRjtBQUVEOzs7Ozs7QUFJQSxXQUFTc0ksY0FBVCxDQUF5QjNJLE9BQXpCLEVBQWtDTCxFQUFsQyxFQUFzQztBQUNwQyxRQUFJd0ksS0FBSyxHQUFHbkksT0FBTyxDQUFDbUksS0FBcEI7O0FBQ0EsUUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFBRTtBQUFROztBQUN0QixRQUFJbFAsR0FBRyxHQUFHLEVBQVY7QUFDQSxRQUFJaEQsQ0FBSixFQUFPbEIsR0FBUCxFQUFZc0wsSUFBWjs7QUFDQSxRQUFJekgsS0FBSyxDQUFDc0IsT0FBTixDQUFjaU8sS0FBZCxDQUFKLEVBQTBCO0FBQ3hCbFMsT0FBQyxHQUFHa1MsS0FBSyxDQUFDalMsTUFBVjs7QUFDQSxhQUFPRCxDQUFDLEVBQVIsRUFBWTtBQUNWbEIsV0FBRyxHQUFHb1QsS0FBSyxDQUFDbFMsQ0FBRCxDQUFYOztBQUNBLFlBQUksT0FBT2xCLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQnNMLGNBQUksR0FBR2hKLFFBQVEsQ0FBQ3RDLEdBQUQsQ0FBZjtBQUNBa0UsYUFBRyxDQUFDb0gsSUFBRCxDQUFILEdBQVk7QUFBRTRILGdCQUFJLEVBQUU7QUFBUixXQUFaO0FBQ0QsU0FIRCxNQUdPO0FBQ0wvSSxjQUFJLENBQUMsZ0RBQUQsQ0FBSjtBQUNEO0FBQ0Y7QUFDRixLQVhELE1BV08sSUFBSXRLLGFBQWEsQ0FBQ3VULEtBQUQsQ0FBakIsRUFBMEI7QUFDL0IsV0FBSyxJQUFJclIsR0FBVCxJQUFnQnFSLEtBQWhCLEVBQXVCO0FBQ3JCcFQsV0FBRyxHQUFHb1QsS0FBSyxDQUFDclIsR0FBRCxDQUFYO0FBQ0F1SixZQUFJLEdBQUdoSixRQUFRLENBQUNQLEdBQUQsQ0FBZjtBQUNBbUMsV0FBRyxDQUFDb0gsSUFBRCxDQUFILEdBQVl6TCxhQUFhLENBQUNHLEdBQUQsQ0FBYixHQUNSQSxHQURRLEdBRVI7QUFBRWtULGNBQUksRUFBRWxUO0FBQVIsU0FGSjtBQUdEO0FBQ0YsS0FSTSxNQVFBO0FBQ0xtSyxVQUFJLENBQ0YseUVBQ0EsVUFEQSxHQUNjekssU0FBUyxDQUFDMFQsS0FBRCxDQUR2QixHQUNrQyxHQUZoQyxFQUdGeEksRUFIRSxDQUFKO0FBS0Q7O0FBQ0RLLFdBQU8sQ0FBQ21JLEtBQVIsR0FBZ0JsUCxHQUFoQjtBQUNEO0FBRUQ7Ozs7O0FBR0EsV0FBUzJQLGVBQVQsQ0FBMEI1SSxPQUExQixFQUFtQ0wsRUFBbkMsRUFBdUM7QUFDckMsUUFBSTBJLE1BQU0sR0FBR3JJLE9BQU8sQ0FBQ3FJLE1BQXJCOztBQUNBLFFBQUksQ0FBQ0EsTUFBTCxFQUFhO0FBQUU7QUFBUTs7QUFDdkIsUUFBSVEsVUFBVSxHQUFHN0ksT0FBTyxDQUFDcUksTUFBUixHQUFpQixFQUFsQzs7QUFDQSxRQUFJelAsS0FBSyxDQUFDc0IsT0FBTixDQUFjbU8sTUFBZCxDQUFKLEVBQTJCO0FBQ3pCLFdBQUssSUFBSXBTLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvUyxNQUFNLENBQUNuUyxNQUEzQixFQUFtQ0QsQ0FBQyxFQUFwQyxFQUF3QztBQUN0QzRTLGtCQUFVLENBQUNSLE1BQU0sQ0FBQ3BTLENBQUQsQ0FBUCxDQUFWLEdBQXdCO0FBQUVrUixjQUFJLEVBQUVrQixNQUFNLENBQUNwUyxDQUFEO0FBQWQsU0FBeEI7QUFDRDtBQUNGLEtBSkQsTUFJTyxJQUFJckIsYUFBYSxDQUFDeVQsTUFBRCxDQUFqQixFQUEyQjtBQUNoQyxXQUFLLElBQUl2UixHQUFULElBQWdCdVIsTUFBaEIsRUFBd0I7QUFDdEIsWUFBSXRULEdBQUcsR0FBR3NULE1BQU0sQ0FBQ3ZSLEdBQUQsQ0FBaEI7QUFDQStSLGtCQUFVLENBQUMvUixHQUFELENBQVYsR0FBa0JsQyxhQUFhLENBQUNHLEdBQUQsQ0FBYixHQUNkOEQsTUFBTSxDQUFDO0FBQUVzTyxjQUFJLEVBQUVyUTtBQUFSLFNBQUQsRUFBZ0IvQixHQUFoQixDQURRLEdBRWQ7QUFBRW9TLGNBQUksRUFBRXBTO0FBQVIsU0FGSjtBQUdEO0FBQ0YsS0FQTSxNQU9BO0FBQ0xtSyxVQUFJLENBQ0YsMEVBQ0EsVUFEQSxHQUNjekssU0FBUyxDQUFDNFQsTUFBRCxDQUR2QixHQUNtQyxHQUZqQyxFQUdGMUksRUFIRSxDQUFKO0FBS0Q7QUFDRjtBQUVEOzs7OztBQUdBLFdBQVNtSixtQkFBVCxDQUE4QjlJLE9BQTlCLEVBQXVDO0FBQ3JDLFFBQUkrSSxJQUFJLEdBQUcvSSxPQUFPLENBQUNnSixVQUFuQjs7QUFDQSxRQUFJRCxJQUFKLEVBQVU7QUFDUixXQUFLLElBQUlqUyxHQUFULElBQWdCaVMsSUFBaEIsRUFBc0I7QUFDcEIsWUFBSTlNLEdBQUcsR0FBRzhNLElBQUksQ0FBQ2pTLEdBQUQsQ0FBZDs7QUFDQSxZQUFJLE9BQU9tRixHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDN0I4TSxjQUFJLENBQUNqUyxHQUFELENBQUosR0FBWTtBQUFFeUIsZ0JBQUksRUFBRTBELEdBQVI7QUFBYTBGLGtCQUFNLEVBQUUxRjtBQUFyQixXQUFaO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBUytMLGdCQUFULENBQTJCM0gsSUFBM0IsRUFBaUNsTSxLQUFqQyxFQUF3Q3dMLEVBQXhDLEVBQTRDO0FBQzFDLFFBQUksQ0FBQy9LLGFBQWEsQ0FBQ1QsS0FBRCxDQUFsQixFQUEyQjtBQUN6QitLLFVBQUksQ0FDRixnQ0FBZ0NtQixJQUFoQyxHQUF1QywwQkFBdkMsR0FDQSxVQURBLEdBQ2M1TCxTQUFTLENBQUNOLEtBQUQsQ0FEdkIsR0FDa0MsR0FGaEMsRUFHRndMLEVBSEUsQ0FBSjtBQUtEO0FBQ0Y7QUFFRDs7Ozs7O0FBSUEsV0FBU3NKLFlBQVQsQ0FDRWxHLE1BREYsRUFFRVUsS0FGRixFQUdFOUQsRUFIRixFQUlFO0FBQ0E7QUFDRTZJLHFCQUFlLENBQUMvRSxLQUFELENBQWY7QUFDRDs7QUFFRCxRQUFJLE9BQU9BLEtBQVAsS0FBaUIsVUFBckIsRUFBaUM7QUFDL0JBLFdBQUssR0FBR0EsS0FBSyxDQUFDekQsT0FBZDtBQUNEOztBQUVEMkksa0JBQWMsQ0FBQ2xGLEtBQUQsRUFBUTlELEVBQVIsQ0FBZDtBQUNBaUosbUJBQWUsQ0FBQ25GLEtBQUQsRUFBUTlELEVBQVIsQ0FBZjtBQUNBbUosdUJBQW1CLENBQUNyRixLQUFELENBQW5CO0FBQ0EsUUFBSXlGLFdBQVcsR0FBR3pGLEtBQUssQ0FBQzBGLE9BQXhCOztBQUNBLFFBQUlELFdBQUosRUFBaUI7QUFDZm5HLFlBQU0sR0FBR2tHLFlBQVksQ0FBQ2xHLE1BQUQsRUFBU21HLFdBQVQsRUFBc0J2SixFQUF0QixDQUFyQjtBQUNEOztBQUNELFFBQUk4RCxLQUFLLENBQUMyRixNQUFWLEVBQWtCO0FBQ2hCLFdBQUssSUFBSW5ULENBQUMsR0FBRyxDQUFSLEVBQVdpQyxDQUFDLEdBQUd1TCxLQUFLLENBQUMyRixNQUFOLENBQWFsVCxNQUFqQyxFQUF5Q0QsQ0FBQyxHQUFHaUMsQ0FBN0MsRUFBZ0RqQyxDQUFDLEVBQWpELEVBQXFEO0FBQ25EOE0sY0FBTSxHQUFHa0csWUFBWSxDQUFDbEcsTUFBRCxFQUFTVSxLQUFLLENBQUMyRixNQUFOLENBQWFuVCxDQUFiLENBQVQsRUFBMEIwSixFQUExQixDQUFyQjtBQUNEO0FBQ0Y7O0FBQ0QsUUFBSUssT0FBTyxHQUFHLEVBQWQ7QUFDQSxRQUFJbEosR0FBSjs7QUFDQSxTQUFLQSxHQUFMLElBQVlpTSxNQUFaLEVBQW9CO0FBQ2xCc0csZ0JBQVUsQ0FBQ3ZTLEdBQUQsQ0FBVjtBQUNEOztBQUNELFNBQUtBLEdBQUwsSUFBWTJNLEtBQVosRUFBbUI7QUFDakIsVUFBSSxDQUFDNU0sTUFBTSxDQUFDa00sTUFBRCxFQUFTak0sR0FBVCxDQUFYLEVBQTBCO0FBQ3hCdVMsa0JBQVUsQ0FBQ3ZTLEdBQUQsQ0FBVjtBQUNEO0FBQ0Y7O0FBQ0QsYUFBU3VTLFVBQVQsQ0FBcUJ2UyxHQUFyQixFQUEwQjtBQUN4QixVQUFJd1MsS0FBSyxHQUFHeEMsTUFBTSxDQUFDaFEsR0FBRCxDQUFOLElBQWVtUSxZQUEzQjtBQUNBakgsYUFBTyxDQUFDbEosR0FBRCxDQUFQLEdBQWV3UyxLQUFLLENBQUN2RyxNQUFNLENBQUNqTSxHQUFELENBQVAsRUFBYzJNLEtBQUssQ0FBQzNNLEdBQUQsQ0FBbkIsRUFBMEI2SSxFQUExQixFQUE4QjdJLEdBQTlCLENBQXBCO0FBQ0Q7O0FBQ0QsV0FBT2tKLE9BQVA7QUFDRDtBQUVEOzs7Ozs7O0FBS0EsV0FBU3VKLFlBQVQsQ0FDRXZKLE9BREYsRUFFRWlJLElBRkYsRUFHRS9HLEVBSEYsRUFJRXNJLFdBSkYsRUFLRTtBQUNBO0FBQ0EsUUFBSSxPQUFPdEksRUFBUCxLQUFjLFFBQWxCLEVBQTRCO0FBQzFCO0FBQ0Q7O0FBQ0QsUUFBSXVJLE1BQU0sR0FBR3pKLE9BQU8sQ0FBQ2lJLElBQUQsQ0FBcEIsQ0FMQSxDQU1BOztBQUNBLFFBQUlwUixNQUFNLENBQUM0UyxNQUFELEVBQVN2SSxFQUFULENBQVYsRUFBd0I7QUFBRSxhQUFPdUksTUFBTSxDQUFDdkksRUFBRCxDQUFiO0FBQW1COztBQUM3QyxRQUFJd0ksV0FBVyxHQUFHclMsUUFBUSxDQUFDNkosRUFBRCxDQUExQjs7QUFDQSxRQUFJckssTUFBTSxDQUFDNFMsTUFBRCxFQUFTQyxXQUFULENBQVYsRUFBaUM7QUFBRSxhQUFPRCxNQUFNLENBQUNDLFdBQUQsQ0FBYjtBQUE0Qjs7QUFDL0QsUUFBSUMsWUFBWSxHQUFHalMsVUFBVSxDQUFDZ1MsV0FBRCxDQUE3Qjs7QUFDQSxRQUFJN1MsTUFBTSxDQUFDNFMsTUFBRCxFQUFTRSxZQUFULENBQVYsRUFBa0M7QUFBRSxhQUFPRixNQUFNLENBQUNFLFlBQUQsQ0FBYjtBQUE2QixLQVhqRSxDQVlBOzs7QUFDQSxRQUFJMVEsR0FBRyxHQUFHd1EsTUFBTSxDQUFDdkksRUFBRCxDQUFOLElBQWN1SSxNQUFNLENBQUNDLFdBQUQsQ0FBcEIsSUFBcUNELE1BQU0sQ0FBQ0UsWUFBRCxDQUFyRDs7QUFDQSxRQUFJLGtCQUFrQixZQUFsQixJQUFrQ0gsV0FBbEMsSUFBaUQsQ0FBQ3ZRLEdBQXRELEVBQTJEO0FBQ3pEaUcsVUFBSSxDQUNGLHVCQUF1QitJLElBQUksQ0FBQ3RULEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBQyxDQUFmLENBQXZCLEdBQTJDLElBQTNDLEdBQWtEdU0sRUFEaEQsRUFFRmxCLE9BRkUsQ0FBSjtBQUlEOztBQUNELFdBQU8vRyxHQUFQO0FBQ0Q7QUFFRDs7O0FBRUEsV0FBUzJRLFlBQVQsQ0FDRTlTLEdBREYsRUFFRStTLFdBRkYsRUFHRTdDLFNBSEYsRUFJRXJILEVBSkYsRUFLRTtBQUNBLFFBQUltSyxJQUFJLEdBQUdELFdBQVcsQ0FBQy9TLEdBQUQsQ0FBdEI7QUFDQSxRQUFJaVQsTUFBTSxHQUFHLENBQUNsVCxNQUFNLENBQUNtUSxTQUFELEVBQVlsUSxHQUFaLENBQXBCO0FBQ0EsUUFBSTNDLEtBQUssR0FBRzZTLFNBQVMsQ0FBQ2xRLEdBQUQsQ0FBckIsQ0FIQSxDQUlBOztBQUNBLFFBQUlrVCxZQUFZLEdBQUdDLFlBQVksQ0FBQ0MsT0FBRCxFQUFVSixJQUFJLENBQUM3QixJQUFmLENBQS9COztBQUNBLFFBQUkrQixZQUFZLEdBQUcsQ0FBQyxDQUFwQixFQUF1QjtBQUNyQixVQUFJRCxNQUFNLElBQUksQ0FBQ2xULE1BQU0sQ0FBQ2lULElBQUQsRUFBTyxTQUFQLENBQXJCLEVBQXdDO0FBQ3RDM1YsYUFBSyxHQUFHLEtBQVI7QUFDRCxPQUZELE1BRU8sSUFBSUEsS0FBSyxLQUFLLEVBQVYsSUFBZ0JBLEtBQUssS0FBSzBELFNBQVMsQ0FBQ2YsR0FBRCxDQUF2QyxFQUE4QztBQUNuRDtBQUNBO0FBQ0EsWUFBSXFULFdBQVcsR0FBR0YsWUFBWSxDQUFDL1UsTUFBRCxFQUFTNFUsSUFBSSxDQUFDN0IsSUFBZCxDQUE5Qjs7QUFDQSxZQUFJa0MsV0FBVyxHQUFHLENBQWQsSUFBbUJILFlBQVksR0FBR0csV0FBdEMsRUFBbUQ7QUFDakRoVyxlQUFLLEdBQUcsSUFBUjtBQUNEO0FBQ0Y7QUFDRixLQWpCRCxDQWtCQTs7O0FBQ0EsUUFBSUEsS0FBSyxLQUFLTCxTQUFkLEVBQXlCO0FBQ3ZCSyxXQUFLLEdBQUdpVyxtQkFBbUIsQ0FBQ3pLLEVBQUQsRUFBS21LLElBQUwsRUFBV2hULEdBQVgsQ0FBM0IsQ0FEdUIsQ0FFdkI7QUFDQTs7QUFDQSxVQUFJdVQsaUJBQWlCLEdBQUduRixhQUF4QjtBQUNBQyxxQkFBZSxDQUFDLElBQUQsQ0FBZjtBQUNBUyxhQUFPLENBQUN6UixLQUFELENBQVA7QUFDQWdSLHFCQUFlLENBQUNrRixpQkFBRCxDQUFmO0FBQ0Q7O0FBQ0Q7QUFDRUMsZ0JBQVUsQ0FBQ1IsSUFBRCxFQUFPaFQsR0FBUCxFQUFZM0MsS0FBWixFQUFtQndMLEVBQW5CLEVBQXVCb0ssTUFBdkIsQ0FBVjtBQUNEO0FBQ0QsV0FBTzVWLEtBQVA7QUFDRDtBQUVEOzs7OztBQUdBLFdBQVNpVyxtQkFBVCxDQUE4QnpLLEVBQTlCLEVBQWtDbUssSUFBbEMsRUFBd0NoVCxHQUF4QyxFQUE2QztBQUMzQztBQUNBLFFBQUksQ0FBQ0QsTUFBTSxDQUFDaVQsSUFBRCxFQUFPLFNBQVAsQ0FBWCxFQUE4QjtBQUM1QixhQUFPaFcsU0FBUDtBQUNEOztBQUNELFFBQUltSSxHQUFHLEdBQUc2TixJQUFJLENBQUNTLE9BQWYsQ0FMMkMsQ0FNM0M7O0FBQ0EsUUFBSSxrQkFBa0IsWUFBbEIsSUFBa0NuVyxRQUFRLENBQUM2SCxHQUFELENBQTlDLEVBQXFEO0FBQ25EaUQsVUFBSSxDQUNGLHFDQUFxQ3BJLEdBQXJDLEdBQTJDLEtBQTNDLEdBQ0EsMkRBREEsR0FFQSw4QkFIRSxFQUlGNkksRUFKRSxDQUFKO0FBTUQsS0FkMEMsQ0FlM0M7QUFDQTs7O0FBQ0EsUUFBSUEsRUFBRSxJQUFJQSxFQUFFLENBQUNRLFFBQUgsQ0FBWTZHLFNBQWxCLElBQ0ZySCxFQUFFLENBQUNRLFFBQUgsQ0FBWTZHLFNBQVosQ0FBc0JsUSxHQUF0QixNQUErQmhELFNBRDdCLElBRUY2TCxFQUFFLENBQUM2SyxNQUFILENBQVUxVCxHQUFWLE1BQW1CaEQsU0FGckIsRUFHRTtBQUNBLGFBQU82TCxFQUFFLENBQUM2SyxNQUFILENBQVUxVCxHQUFWLENBQVA7QUFDRCxLQXRCMEMsQ0F1QjNDO0FBQ0E7OztBQUNBLFdBQU8sT0FBT21GLEdBQVAsS0FBZSxVQUFmLElBQTZCd08sT0FBTyxDQUFDWCxJQUFJLENBQUM3QixJQUFOLENBQVAsS0FBdUIsVUFBcEQsR0FDSGhNLEdBQUcsQ0FBQ3ZILElBQUosQ0FBU2lMLEVBQVQsQ0FERyxHQUVIMUQsR0FGSjtBQUdEO0FBRUQ7Ozs7O0FBR0EsV0FBU3FPLFVBQVQsQ0FDRVIsSUFERixFQUVFekosSUFGRixFQUdFbE0sS0FIRixFQUlFd0wsRUFKRixFQUtFb0ssTUFMRixFQU1FO0FBQ0EsUUFBSUQsSUFBSSxDQUFDWSxRQUFMLElBQWlCWCxNQUFyQixFQUE2QjtBQUMzQjdLLFVBQUksQ0FDRiw2QkFBNkJtQixJQUE3QixHQUFvQyxHQURsQyxFQUVGVixFQUZFLENBQUo7QUFJQTtBQUNEOztBQUNELFFBQUl4TCxLQUFLLElBQUksSUFBVCxJQUFpQixDQUFDMlYsSUFBSSxDQUFDWSxRQUEzQixFQUFxQztBQUNuQztBQUNEOztBQUNELFFBQUl6QyxJQUFJLEdBQUc2QixJQUFJLENBQUM3QixJQUFoQjtBQUNBLFFBQUkwQyxLQUFLLEdBQUcsQ0FBQzFDLElBQUQsSUFBU0EsSUFBSSxLQUFLLElBQTlCO0FBQ0EsUUFBSTJDLGFBQWEsR0FBRyxFQUFwQjs7QUFDQSxRQUFJM0MsSUFBSixFQUFVO0FBQ1IsVUFBSSxDQUFDclAsS0FBSyxDQUFDc0IsT0FBTixDQUFjK04sSUFBZCxDQUFMLEVBQTBCO0FBQ3hCQSxZQUFJLEdBQUcsQ0FBQ0EsSUFBRCxDQUFQO0FBQ0Q7O0FBQ0QsV0FBSyxJQUFJaFMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2dTLElBQUksQ0FBQy9SLE1BQVQsSUFBbUIsQ0FBQ3lVLEtBQXBDLEVBQTJDMVUsQ0FBQyxFQUE1QyxFQUFnRDtBQUM5QyxZQUFJNFUsWUFBWSxHQUFHQyxVQUFVLENBQUMzVyxLQUFELEVBQVE4VCxJQUFJLENBQUNoUyxDQUFELENBQVosQ0FBN0I7QUFDQTJVLHFCQUFhLENBQUM3SixJQUFkLENBQW1COEosWUFBWSxDQUFDRSxZQUFiLElBQTZCLEVBQWhEO0FBQ0FKLGFBQUssR0FBR0UsWUFBWSxDQUFDRixLQUFyQjtBQUNEO0FBQ0Y7O0FBQ0QsUUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDVnpMLFVBQUksQ0FDRixnREFBZ0RtQixJQUFoRCxHQUF1RCxLQUF2RCxHQUNBLFlBREEsR0FDZ0J1SyxhQUFhLENBQUMvVSxHQUFkLENBQWtCNkIsVUFBbEIsRUFBOEJtQyxJQUE5QixDQUFtQyxJQUFuQyxDQURoQixHQUVBLFFBRkEsR0FFWXBGLFNBQVMsQ0FBQ04sS0FBRCxDQUZyQixHQUVnQyxHQUg5QixFQUlGd0wsRUFKRSxDQUFKO0FBTUE7QUFDRDs7QUFDRCxRQUFJcUwsU0FBUyxHQUFHbEIsSUFBSSxDQUFDa0IsU0FBckI7O0FBQ0EsUUFBSUEsU0FBSixFQUFlO0FBQ2IsVUFBSSxDQUFDQSxTQUFTLENBQUM3VyxLQUFELENBQWQsRUFBdUI7QUFDckIrSyxZQUFJLENBQ0YsMkRBQTJEbUIsSUFBM0QsR0FBa0UsSUFEaEUsRUFFRlYsRUFGRSxDQUFKO0FBSUQ7QUFDRjtBQUNGOztBQUVELE1BQUlzTCxhQUFhLEdBQUcsMkNBQXBCOztBQUVBLFdBQVNILFVBQVQsQ0FBcUIzVyxLQUFyQixFQUE0QjhULElBQTVCLEVBQWtDO0FBQ2hDLFFBQUkwQyxLQUFKO0FBQ0EsUUFBSUksWUFBWSxHQUFHTixPQUFPLENBQUN4QyxJQUFELENBQTFCOztBQUNBLFFBQUlnRCxhQUFhLENBQUN4TyxJQUFkLENBQW1Cc08sWUFBbkIsQ0FBSixFQUFzQztBQUNwQyxVQUFJRyxDQUFDLEdBQUcsT0FBTy9XLEtBQWY7QUFDQXdXLFdBQUssR0FBR08sQ0FBQyxLQUFLSCxZQUFZLENBQUM1VSxXQUFiLEVBQWQsQ0FGb0MsQ0FHcEM7O0FBQ0EsVUFBSSxDQUFDd1UsS0FBRCxJQUFVTyxDQUFDLEtBQUssUUFBcEIsRUFBOEI7QUFDNUJQLGFBQUssR0FBR3hXLEtBQUssWUFBWThULElBQXpCO0FBQ0Q7QUFDRixLQVBELE1BT08sSUFBSThDLFlBQVksS0FBSyxRQUFyQixFQUErQjtBQUNwQ0osV0FBSyxHQUFHL1YsYUFBYSxDQUFDVCxLQUFELENBQXJCO0FBQ0QsS0FGTSxNQUVBLElBQUk0VyxZQUFZLEtBQUssT0FBckIsRUFBOEI7QUFDbkNKLFdBQUssR0FBRy9SLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBYy9GLEtBQWQsQ0FBUjtBQUNELEtBRk0sTUFFQTtBQUNMd1csV0FBSyxHQUFHeFcsS0FBSyxZQUFZOFQsSUFBekI7QUFDRDs7QUFDRCxXQUFPO0FBQ0wwQyxXQUFLLEVBQUVBLEtBREY7QUFFTEksa0JBQVksRUFBRUE7QUFGVCxLQUFQO0FBSUQ7QUFFRDs7Ozs7OztBQUtBLFdBQVNOLE9BQVQsQ0FBa0J6VCxFQUFsQixFQUFzQjtBQUNwQixRQUFJeUosS0FBSyxHQUFHekosRUFBRSxJQUFJQSxFQUFFLENBQUN4QyxRQUFILEdBQWNpTSxLQUFkLENBQW9CLG9CQUFwQixDQUFsQjtBQUNBLFdBQU9BLEtBQUssR0FBR0EsS0FBSyxDQUFDLENBQUQsQ0FBUixHQUFjLEVBQTFCO0FBQ0Q7O0FBRUQsV0FBUzBLLFVBQVQsQ0FBcUJsVCxDQUFyQixFQUF3QmtCLENBQXhCLEVBQTJCO0FBQ3pCLFdBQU9zUixPQUFPLENBQUN4UyxDQUFELENBQVAsS0FBZXdTLE9BQU8sQ0FBQ3RSLENBQUQsQ0FBN0I7QUFDRDs7QUFFRCxXQUFTOFEsWUFBVCxDQUF1QmhDLElBQXZCLEVBQTZCMkMsYUFBN0IsRUFBNEM7QUFDMUMsUUFBSSxDQUFDaFMsS0FBSyxDQUFDc0IsT0FBTixDQUFjMFEsYUFBZCxDQUFMLEVBQW1DO0FBQ2pDLGFBQU9PLFVBQVUsQ0FBQ1AsYUFBRCxFQUFnQjNDLElBQWhCLENBQVYsR0FBa0MsQ0FBbEMsR0FBc0MsQ0FBQyxDQUE5QztBQUNEOztBQUNELFNBQUssSUFBSWhTLENBQUMsR0FBRyxDQUFSLEVBQVd3TyxHQUFHLEdBQUdtRyxhQUFhLENBQUMxVSxNQUFwQyxFQUE0Q0QsQ0FBQyxHQUFHd08sR0FBaEQsRUFBcUR4TyxDQUFDLEVBQXRELEVBQTBEO0FBQ3hELFVBQUlrVixVQUFVLENBQUNQLGFBQWEsQ0FBQzNVLENBQUQsQ0FBZCxFQUFtQmdTLElBQW5CLENBQWQsRUFBd0M7QUFDdEMsZUFBT2hTLENBQVA7QUFDRDtBQUNGOztBQUNELFdBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFFRDs7O0FBRUEsV0FBU21WLFdBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCMUwsRUFBM0IsRUFBK0IyTCxJQUEvQixFQUFxQztBQUNuQyxRQUFJM0wsRUFBSixFQUFRO0FBQ04sVUFBSTRMLEdBQUcsR0FBRzVMLEVBQVY7O0FBQ0EsYUFBUTRMLEdBQUcsR0FBR0EsR0FBRyxDQUFDNUssT0FBbEIsRUFBNEI7QUFDMUIsWUFBSTZLLEtBQUssR0FBR0QsR0FBRyxDQUFDcEwsUUFBSixDQUFhc0wsYUFBekI7O0FBQ0EsWUFBSUQsS0FBSixFQUFXO0FBQ1QsZUFBSyxJQUFJdlYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VWLEtBQUssQ0FBQ3RWLE1BQTFCLEVBQWtDRCxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLGdCQUFJO0FBQ0Ysa0JBQUl5VixPQUFPLEdBQUdGLEtBQUssQ0FBQ3ZWLENBQUQsQ0FBTCxDQUFTdkIsSUFBVCxDQUFjNlcsR0FBZCxFQUFtQkYsR0FBbkIsRUFBd0IxTCxFQUF4QixFQUE0QjJMLElBQTVCLE1BQXNDLEtBQXBEOztBQUNBLGtCQUFJSSxPQUFKLEVBQWE7QUFBRTtBQUFRO0FBQ3hCLGFBSEQsQ0FHRSxPQUFPclIsQ0FBUCxFQUFVO0FBQ1ZzUiwrQkFBaUIsQ0FBQ3RSLENBQUQsRUFBSWtSLEdBQUosRUFBUyxvQkFBVCxDQUFqQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBQ0RJLHFCQUFpQixDQUFDTixHQUFELEVBQU0xTCxFQUFOLEVBQVUyTCxJQUFWLENBQWpCO0FBQ0Q7O0FBRUQsV0FBU0ssaUJBQVQsQ0FBNEJOLEdBQTVCLEVBQWlDMUwsRUFBakMsRUFBcUMyTCxJQUFyQyxFQUEyQztBQUN6QyxRQUFJeFEsTUFBTSxDQUFDTSxZQUFYLEVBQXlCO0FBQ3ZCLFVBQUk7QUFDRixlQUFPTixNQUFNLENBQUNNLFlBQVAsQ0FBb0IxRyxJQUFwQixDQUF5QixJQUF6QixFQUErQjJXLEdBQS9CLEVBQW9DMUwsRUFBcEMsRUFBd0MyTCxJQUF4QyxDQUFQO0FBQ0QsT0FGRCxDQUVFLE9BQU9qUixDQUFQLEVBQVU7QUFDVnVSLGdCQUFRLENBQUN2UixDQUFELEVBQUksSUFBSixFQUFVLHFCQUFWLENBQVI7QUFDRDtBQUNGOztBQUNEdVIsWUFBUSxDQUFDUCxHQUFELEVBQU0xTCxFQUFOLEVBQVUyTCxJQUFWLENBQVI7QUFDRDs7QUFFRCxXQUFTTSxRQUFULENBQW1CUCxHQUFuQixFQUF3QjFMLEVBQXhCLEVBQTRCMkwsSUFBNUIsRUFBa0M7QUFDaEM7QUFDRXBNLFVBQUksQ0FBRSxjQUFjb00sSUFBZCxHQUFxQixNQUFyQixHQUErQkQsR0FBRyxDQUFDN1csUUFBSixFQUEvQixHQUFpRCxJQUFuRCxFQUEwRG1MLEVBQTFELENBQUo7QUFDRDtBQUNEOztBQUNBLFFBQUksQ0FBQy9DLFNBQVMsSUFBSUUsTUFBZCxLQUF5QixPQUFPeUMsT0FBUCxLQUFtQixXQUFoRCxFQUE2RDtBQUMzREEsYUFBTyxDQUFDTSxLQUFSLENBQWN3TCxHQUFkO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsWUFBTUEsR0FBTjtBQUNEO0FBQ0Y7QUFFRDs7QUFDQTs7O0FBRUEsTUFBSVEsU0FBUyxHQUFHLEVBQWhCO0FBQ0EsTUFBSUMsT0FBTyxHQUFHLEtBQWQ7O0FBRUEsV0FBU0MsY0FBVCxHQUEyQjtBQUN6QkQsV0FBTyxHQUFHLEtBQVY7QUFDQSxRQUFJRSxNQUFNLEdBQUdILFNBQVMsQ0FBQ2xYLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBYjtBQUNBa1gsYUFBUyxDQUFDM1YsTUFBVixHQUFtQixDQUFuQjs7QUFDQSxTQUFLLElBQUlELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcrVixNQUFNLENBQUM5VixNQUEzQixFQUFtQ0QsQ0FBQyxFQUFwQyxFQUF3QztBQUN0QytWLFlBQU0sQ0FBQy9WLENBQUQsQ0FBTjtBQUNEO0FBQ0YsR0F4dERvQixDQTB0RHJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQUlnVyxjQUFKO0FBQ0EsTUFBSUMsY0FBSjtBQUNBLE1BQUlDLFlBQVksR0FBRyxLQUFuQixDQXB1RHFCLENBc3VEckI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0EsTUFBSSxPQUFPQyxZQUFQLEtBQXdCLFdBQXhCLElBQXVDOU4sUUFBUSxDQUFDOE4sWUFBRCxDQUFuRCxFQUFtRTtBQUNqRUYsa0JBQWMsR0FBRyxZQUFZO0FBQzNCRSxrQkFBWSxDQUFDTCxjQUFELENBQVo7QUFDRCxLQUZEO0FBR0QsR0FKRCxNQUlPLElBQUksT0FBT00sY0FBUCxLQUEwQixXQUExQixLQUNUL04sUUFBUSxDQUFDK04sY0FBRCxDQUFSLElBQ0E7QUFDQUEsZ0JBQWMsQ0FBQzdYLFFBQWYsT0FBOEIsb0NBSHJCLENBQUosRUFJSjtBQUNELFFBQUk4WCxPQUFPLEdBQUcsSUFBSUQsY0FBSixFQUFkO0FBQ0EsUUFBSUUsSUFBSSxHQUFHRCxPQUFPLENBQUNFLEtBQW5CO0FBQ0FGLFdBQU8sQ0FBQ0csS0FBUixDQUFjQyxTQUFkLEdBQTBCWCxjQUExQjs7QUFDQUcsa0JBQWMsR0FBRyxZQUFZO0FBQzNCSyxVQUFJLENBQUNJLFdBQUwsQ0FBaUIsQ0FBakI7QUFDRCxLQUZEO0FBR0QsR0FYTSxNQVdBO0FBQ0w7QUFDQVQsa0JBQWMsR0FBRyxZQUFZO0FBQzNCVSxnQkFBVSxDQUFDYixjQUFELEVBQWlCLENBQWpCLENBQVY7QUFDRCxLQUZEO0FBR0QsR0EvdkRvQixDQWl3RHJCOztBQUNBOzs7QUFDQSxNQUFJLE9BQU9jLE9BQVAsS0FBbUIsV0FBbkIsSUFBa0N2TyxRQUFRLENBQUN1TyxPQUFELENBQTlDLEVBQXlEO0FBQ3ZELFFBQUlDLENBQUMsR0FBR0QsT0FBTyxDQUFDRSxPQUFSLEVBQVI7O0FBQ0FkLGtCQUFjLEdBQUcsWUFBWTtBQUMzQmEsT0FBQyxDQUFDRSxJQUFGLENBQU9qQixjQUFQLEVBRDJCLENBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBSXRPLEtBQUosRUFBVztBQUFFbVAsa0JBQVUsQ0FBQzFULElBQUQsQ0FBVjtBQUFtQjtBQUNqQyxLQVJEO0FBU0QsR0FYRCxNQVdPO0FBQ0w7QUFDQStTLGtCQUFjLEdBQUdDLGNBQWpCO0FBQ0Q7QUFFRDs7Ozs7O0FBSUEsV0FBU2UsYUFBVCxDQUF3QmpXLEVBQXhCLEVBQTRCO0FBQzFCLFdBQU9BLEVBQUUsQ0FBQ2tXLFNBQUgsS0FBaUJsVyxFQUFFLENBQUNrVyxTQUFILEdBQWUsWUFBWTtBQUNqRGYsa0JBQVksR0FBRyxJQUFmO0FBQ0EsVUFBSWxULEdBQUcsR0FBR2pDLEVBQUUsQ0FBQ29CLEtBQUgsQ0FBUyxJQUFULEVBQWVELFNBQWYsQ0FBVjtBQUNBZ1Usa0JBQVksR0FBRyxLQUFmO0FBQ0EsYUFBT2xULEdBQVA7QUFDRCxLQUxNLENBQVA7QUFNRDs7QUFFRCxXQUFTa1UsUUFBVCxDQUFtQkMsRUFBbkIsRUFBdUJyVixHQUF2QixFQUE0QjtBQUMxQixRQUFJc1YsUUFBSjs7QUFDQXhCLGFBQVMsQ0FBQzlLLElBQVYsQ0FBZSxZQUFZO0FBQ3pCLFVBQUlxTSxFQUFKLEVBQVE7QUFDTixZQUFJO0FBQ0ZBLFlBQUUsQ0FBQzFZLElBQUgsQ0FBUXFELEdBQVI7QUFDRCxTQUZELENBRUUsT0FBT3NDLENBQVAsRUFBVTtBQUNWK1EscUJBQVcsQ0FBQy9RLENBQUQsRUFBSXRDLEdBQUosRUFBUyxVQUFULENBQVg7QUFDRDtBQUNGLE9BTkQsTUFNTyxJQUFJc1YsUUFBSixFQUFjO0FBQ25CQSxnQkFBUSxDQUFDdFYsR0FBRCxDQUFSO0FBQ0Q7QUFDRixLQVZEOztBQVdBLFFBQUksQ0FBQytULE9BQUwsRUFBYztBQUNaQSxhQUFPLEdBQUcsSUFBVjs7QUFDQSxVQUFJSyxZQUFKLEVBQWtCO0FBQ2hCRCxzQkFBYztBQUNmLE9BRkQsTUFFTztBQUNMRCxzQkFBYztBQUNmO0FBQ0YsS0FwQnlCLENBcUIxQjs7O0FBQ0EsUUFBSSxDQUFDbUIsRUFBRCxJQUFPLE9BQU9QLE9BQVAsS0FBbUIsV0FBOUIsRUFBMkM7QUFDekMsYUFBTyxJQUFJQSxPQUFKLENBQVksVUFBVUUsT0FBVixFQUFtQjtBQUNwQ00sZ0JBQVEsR0FBR04sT0FBWDtBQUNELE9BRk0sQ0FBUDtBQUdEO0FBQ0Y7QUFFRDs7O0FBRUEsTUFBSU8sSUFBSjtBQUNBLE1BQUlDLE9BQUo7QUFFQTtBQUNFLFFBQUlDLElBQUksR0FBRzVRLFNBQVMsSUFBSUMsTUFBTSxDQUFDMUIsV0FBL0I7QUFDQTs7QUFDQSxRQUNFcVMsSUFBSSxJQUNKQSxJQUFJLENBQUNGLElBREwsSUFFQUUsSUFBSSxDQUFDRCxPQUZMLElBR0FDLElBQUksQ0FBQ0MsVUFITCxJQUlBRCxJQUFJLENBQUNFLGFBTFAsRUFNRTtBQUNBSixVQUFJLEdBQUcsVUFBVXBMLEdBQVYsRUFBZTtBQUFFLGVBQU9zTCxJQUFJLENBQUNGLElBQUwsQ0FBVXBMLEdBQVYsQ0FBUDtBQUF3QixPQUFoRDs7QUFDQXFMLGFBQU8sR0FBRyxVQUFVbE4sSUFBVixFQUFnQnNOLFFBQWhCLEVBQTBCQyxNQUExQixFQUFrQztBQUMxQ0osWUFBSSxDQUFDRCxPQUFMLENBQWFsTixJQUFiLEVBQW1Cc04sUUFBbkIsRUFBNkJDLE1BQTdCO0FBQ0FKLFlBQUksQ0FBQ0MsVUFBTCxDQUFnQkUsUUFBaEI7QUFDQUgsWUFBSSxDQUFDQyxVQUFMLENBQWdCRyxNQUFoQjtBQUNBSixZQUFJLENBQUNFLGFBQUwsQ0FBbUJyTixJQUFuQjtBQUNELE9BTEQ7QUFNRDtBQUNGO0FBRUQ7O0FBRUEsTUFBSXdOLFNBQUo7QUFFQTtBQUNFLFFBQUlDLGNBQWMsR0FBR3BZLE9BQU8sQ0FDMUIsMkNBQ0EsZ0ZBREEsR0FFQSx3RUFGQSxHQUdBLFNBSjBCLENBSWhCO0FBSmdCLEtBQTVCOztBQU9BLFFBQUlxWSxjQUFjLEdBQUcsVUFBVXZNLE1BQVYsRUFBa0IxSyxHQUFsQixFQUF1QjtBQUMxQ29JLFVBQUksQ0FDRiwwQkFBMEJwSSxHQUExQixHQUFnQyx3Q0FBaEMsR0FDQSxzRUFEQSxHQUVBLCtEQUZBLEdBR0EsNkJBSEEsR0FJQSxnRkFMRSxFQU1GMEssTUFORSxDQUFKO0FBUUQsS0FURDs7QUFXQSxRQUFJd00sUUFBUSxHQUNWLE9BQU9DLEtBQVAsS0FBaUIsV0FBakIsSUFBZ0MzUCxRQUFRLENBQUMyUCxLQUFELENBRDFDOztBQUdBLFFBQUlELFFBQUosRUFBYztBQUNaLFVBQUlFLGlCQUFpQixHQUFHeFksT0FBTyxDQUFDLDZDQUFELENBQS9CO0FBQ0FvRixZQUFNLENBQUNTLFFBQVAsR0FBa0IsSUFBSTBTLEtBQUosQ0FBVW5ULE1BQU0sQ0FBQ1MsUUFBakIsRUFBMkI7QUFDM0N1RCxXQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFjMEMsTUFBZCxFQUFzQjFLLEdBQXRCLEVBQTJCM0MsS0FBM0IsRUFBa0M7QUFDckMsY0FBSStaLGlCQUFpQixDQUFDcFgsR0FBRCxDQUFyQixFQUE0QjtBQUMxQm9JLGdCQUFJLENBQUUsOERBQThEcEksR0FBaEUsQ0FBSjtBQUNBLG1CQUFPLEtBQVA7QUFDRCxXQUhELE1BR087QUFDTDBLLGtCQUFNLENBQUMxSyxHQUFELENBQU4sR0FBYzNDLEtBQWQ7QUFDQSxtQkFBTyxJQUFQO0FBQ0Q7QUFDRjtBQVQwQyxPQUEzQixDQUFsQjtBQVdEOztBQUVELFFBQUlnYSxVQUFVLEdBQUc7QUFDZnBQLFNBQUcsRUFBRSxTQUFTQSxHQUFULENBQWN5QyxNQUFkLEVBQXNCMUssR0FBdEIsRUFBMkI7QUFDOUIsWUFBSWlJLEdBQUcsR0FBR2pJLEdBQUcsSUFBSTBLLE1BQWpCO0FBQ0EsWUFBSTRNLFNBQVMsR0FBR04sY0FBYyxDQUFDaFgsR0FBRCxDQUFkLElBQXVCQSxHQUFHLENBQUNhLE1BQUosQ0FBVyxDQUFYLE1BQWtCLEdBQXpEOztBQUNBLFlBQUksQ0FBQ29ILEdBQUQsSUFBUSxDQUFDcVAsU0FBYixFQUF3QjtBQUN0Qkwsd0JBQWMsQ0FBQ3ZNLE1BQUQsRUFBUzFLLEdBQVQsQ0FBZDtBQUNEOztBQUNELGVBQU9pSSxHQUFHLElBQUksQ0FBQ3FQLFNBQWY7QUFDRDtBQVJjLEtBQWpCO0FBV0EsUUFBSUMsVUFBVSxHQUFHO0FBQ2Z0USxTQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFjeUQsTUFBZCxFQUFzQjFLLEdBQXRCLEVBQTJCO0FBQzlCLFlBQUksT0FBT0EsR0FBUCxLQUFlLFFBQWYsSUFBMkIsRUFBRUEsR0FBRyxJQUFJMEssTUFBVCxDQUEvQixFQUFpRDtBQUMvQ3VNLHdCQUFjLENBQUN2TSxNQUFELEVBQVMxSyxHQUFULENBQWQ7QUFDRDs7QUFDRCxlQUFPMEssTUFBTSxDQUFDMUssR0FBRCxDQUFiO0FBQ0Q7QUFOYyxLQUFqQjs7QUFTQStXLGFBQVMsR0FBRyxTQUFTQSxTQUFULENBQW9CbE8sRUFBcEIsRUFBd0I7QUFDbEMsVUFBSXFPLFFBQUosRUFBYztBQUNaO0FBQ0EsWUFBSWhPLE9BQU8sR0FBR0wsRUFBRSxDQUFDUSxRQUFqQjtBQUNBLFlBQUltTyxRQUFRLEdBQUd0TyxPQUFPLENBQUN1TyxNQUFSLElBQWtCdk8sT0FBTyxDQUFDdU8sTUFBUixDQUFlQyxhQUFqQyxHQUNYSCxVQURXLEdBRVhGLFVBRko7QUFHQXhPLFVBQUUsQ0FBQzhPLFlBQUgsR0FBa0IsSUFBSVIsS0FBSixDQUFVdE8sRUFBVixFQUFjMk8sUUFBZCxDQUFsQjtBQUNELE9BUEQsTUFPTztBQUNMM08sVUFBRSxDQUFDOE8sWUFBSCxHQUFrQjlPLEVBQWxCO0FBQ0Q7QUFDRixLQVhEO0FBWUQ7QUFFRDs7QUFFQSxNQUFJK08sV0FBVyxHQUFHLElBQUk5UCxJQUFKLEVBQWxCO0FBRUE7Ozs7OztBQUtBLFdBQVMrUCxRQUFULENBQW1CNVosR0FBbkIsRUFBd0I7QUFDdEI2WixhQUFTLENBQUM3WixHQUFELEVBQU0yWixXQUFOLENBQVQ7O0FBQ0FBLGVBQVcsQ0FBQ3pQLEtBQVo7QUFDRDs7QUFFRCxXQUFTMlAsU0FBVCxDQUFvQjdaLEdBQXBCLEVBQXlCOFosSUFBekIsRUFBK0I7QUFDN0IsUUFBSTVZLENBQUosRUFBT3dELElBQVA7QUFDQSxRQUFJcVYsR0FBRyxHQUFHbFcsS0FBSyxDQUFDc0IsT0FBTixDQUFjbkYsR0FBZCxDQUFWOztBQUNBLFFBQUssQ0FBQytaLEdBQUQsSUFBUSxDQUFDMWEsUUFBUSxDQUFDVyxHQUFELENBQWxCLElBQTRCckIsTUFBTSxDQUFDcWIsUUFBUCxDQUFnQmhhLEdBQWhCLENBQTVCLElBQW9EQSxHQUFHLFlBQVlrTixLQUF2RSxFQUE4RTtBQUM1RTtBQUNEOztBQUNELFFBQUlsTixHQUFHLENBQUM2UCxNQUFSLEVBQWdCO0FBQ2QsVUFBSW9LLEtBQUssR0FBR2phLEdBQUcsQ0FBQzZQLE1BQUosQ0FBV0csR0FBWCxDQUFlN0QsRUFBM0I7O0FBQ0EsVUFBSTJOLElBQUksQ0FBQzlQLEdBQUwsQ0FBU2lRLEtBQVQsQ0FBSixFQUFxQjtBQUNuQjtBQUNEOztBQUNESCxVQUFJLENBQUM3UCxHQUFMLENBQVNnUSxLQUFUO0FBQ0Q7O0FBQ0QsUUFBSUYsR0FBSixFQUFTO0FBQ1A3WSxPQUFDLEdBQUdsQixHQUFHLENBQUNtQixNQUFSOztBQUNBLGFBQU9ELENBQUMsRUFBUixFQUFZO0FBQUUyWSxpQkFBUyxDQUFDN1osR0FBRyxDQUFDa0IsQ0FBRCxDQUFKLEVBQVM0WSxJQUFULENBQVQ7QUFBMEI7QUFDekMsS0FIRCxNQUdPO0FBQ0xwVixVQUFJLEdBQUcvRixNQUFNLENBQUMrRixJQUFQLENBQVkxRSxHQUFaLENBQVA7QUFDQWtCLE9BQUMsR0FBR3dELElBQUksQ0FBQ3ZELE1BQVQ7O0FBQ0EsYUFBT0QsQ0FBQyxFQUFSLEVBQVk7QUFBRTJZLGlCQUFTLENBQUM3WixHQUFHLENBQUMwRSxJQUFJLENBQUN4RCxDQUFELENBQUwsQ0FBSixFQUFlNFksSUFBZixDQUFUO0FBQWdDO0FBQy9DO0FBQ0Y7QUFFRDs7O0FBRUEsTUFBSUksY0FBYyxHQUFHbFksTUFBTSxDQUFDLFVBQVVzSixJQUFWLEVBQWdCO0FBQzFDLFFBQUk2TyxPQUFPLEdBQUc3TyxJQUFJLENBQUMxSSxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFqQztBQUNBMEksUUFBSSxHQUFHNk8sT0FBTyxHQUFHN08sSUFBSSxDQUFDMUwsS0FBTCxDQUFXLENBQVgsQ0FBSCxHQUFtQjBMLElBQWpDO0FBQ0EsUUFBSThPLE9BQU8sR0FBRzlPLElBQUksQ0FBQzFJLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQWpDLENBSDBDLENBR0o7O0FBQ3RDMEksUUFBSSxHQUFHOE8sT0FBTyxHQUFHOU8sSUFBSSxDQUFDMUwsS0FBTCxDQUFXLENBQVgsQ0FBSCxHQUFtQjBMLElBQWpDO0FBQ0EsUUFBSXFMLE9BQU8sR0FBR3JMLElBQUksQ0FBQzFJLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQWpDO0FBQ0EwSSxRQUFJLEdBQUdxTCxPQUFPLEdBQUdyTCxJQUFJLENBQUMxTCxLQUFMLENBQVcsQ0FBWCxDQUFILEdBQW1CMEwsSUFBakM7QUFDQSxXQUFPO0FBQ0xBLFVBQUksRUFBRUEsSUFERDtBQUVMNUYsVUFBSSxFQUFFMFUsT0FGRDtBQUdMekQsYUFBTyxFQUFFQSxPQUhKO0FBSUx3RCxhQUFPLEVBQUVBO0FBSkosS0FBUDtBQU1ELEdBYjBCLENBQTNCOztBQWVBLFdBQVNFLGVBQVQsQ0FBMEJDLEdBQTFCLEVBQStCO0FBQzdCLGFBQVNDLE9BQVQsR0FBb0I7QUFDbEIsVUFBSUMsV0FBVyxHQUFHcFgsU0FBbEI7QUFFQSxVQUFJa1gsR0FBRyxHQUFHQyxPQUFPLENBQUNELEdBQWxCOztBQUNBLFVBQUl6VyxLQUFLLENBQUNzQixPQUFOLENBQWNtVixHQUFkLENBQUosRUFBd0I7QUFDdEIsWUFBSXJMLE1BQU0sR0FBR3FMLEdBQUcsQ0FBQzFhLEtBQUosRUFBYjs7QUFDQSxhQUFLLElBQUlzQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK04sTUFBTSxDQUFDOU4sTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7QUFDdEMrTixnQkFBTSxDQUFDL04sQ0FBRCxDQUFOLENBQVVtQyxLQUFWLENBQWdCLElBQWhCLEVBQXNCbVgsV0FBdEI7QUFDRDtBQUNGLE9BTEQsTUFLTztBQUNMO0FBQ0EsZUFBT0YsR0FBRyxDQUFDalgsS0FBSixDQUFVLElBQVYsRUFBZ0JELFNBQWhCLENBQVA7QUFDRDtBQUNGOztBQUNEbVgsV0FBTyxDQUFDRCxHQUFSLEdBQWNBLEdBQWQ7QUFDQSxXQUFPQyxPQUFQO0FBQ0Q7O0FBRUQsV0FBU0UsZUFBVCxDQUNFQyxFQURGLEVBRUVDLEtBRkYsRUFHRTFRLEdBSEYsRUFJRTJRLFNBSkYsRUFLRWhRLEVBTEYsRUFNRTtBQUNBLFFBQUlVLElBQUosRUFBVXBFLEdBQVYsRUFBZXNQLEdBQWYsRUFBb0JxRSxHQUFwQixFQUF5QkMsS0FBekI7O0FBQ0EsU0FBS3hQLElBQUwsSUFBYW9QLEVBQWIsRUFBaUI7QUFDZnhULFNBQUcsR0FBR3NQLEdBQUcsR0FBR2tFLEVBQUUsQ0FBQ3BQLElBQUQsQ0FBZDtBQUNBdVAsU0FBRyxHQUFHRixLQUFLLENBQUNyUCxJQUFELENBQVg7QUFDQXdQLFdBQUssR0FBR1osY0FBYyxDQUFDNU8sSUFBRCxDQUF0QjtBQUNBOztBQUNBLFVBQUl6TSxPQUFPLENBQUMyWCxHQUFELENBQVgsRUFBa0I7QUFDaEIsMEJBQWtCLFlBQWxCLElBQWtDck0sSUFBSSxDQUNwQyxpQ0FBa0MyUSxLQUFLLENBQUN4UCxJQUF4QyxHQUFnRCxVQUFoRCxHQUE2RG5MLE1BQU0sQ0FBQ3FXLEdBQUQsQ0FEL0IsRUFFcEM1TCxFQUZvQyxDQUF0QztBQUlELE9BTEQsTUFLTyxJQUFJL0wsT0FBTyxDQUFDZ2MsR0FBRCxDQUFYLEVBQWtCO0FBQ3ZCLFlBQUloYyxPQUFPLENBQUMyWCxHQUFHLENBQUM4RCxHQUFMLENBQVgsRUFBc0I7QUFDcEI5RCxhQUFHLEdBQUdrRSxFQUFFLENBQUNwUCxJQUFELENBQUYsR0FBVytPLGVBQWUsQ0FBQzdELEdBQUQsQ0FBaEM7QUFDRDs7QUFDRHZNLFdBQUcsQ0FBQzZRLEtBQUssQ0FBQ3hQLElBQVAsRUFBYWtMLEdBQWIsRUFBa0JzRSxLQUFLLENBQUNwVixJQUF4QixFQUE4Qm9WLEtBQUssQ0FBQ25FLE9BQXBDLEVBQTZDbUUsS0FBSyxDQUFDWCxPQUFuRCxFQUE0RFcsS0FBSyxDQUFDQyxNQUFsRSxDQUFIO0FBQ0QsT0FMTSxNQUtBLElBQUl2RSxHQUFHLEtBQUtxRSxHQUFaLEVBQWlCO0FBQ3RCQSxXQUFHLENBQUNQLEdBQUosR0FBVTlELEdBQVY7QUFDQWtFLFVBQUUsQ0FBQ3BQLElBQUQsQ0FBRixHQUFXdVAsR0FBWDtBQUNEO0FBQ0Y7O0FBQ0QsU0FBS3ZQLElBQUwsSUFBYXFQLEtBQWIsRUFBb0I7QUFDbEIsVUFBSTliLE9BQU8sQ0FBQzZiLEVBQUUsQ0FBQ3BQLElBQUQsQ0FBSCxDQUFYLEVBQXVCO0FBQ3JCd1AsYUFBSyxHQUFHWixjQUFjLENBQUM1TyxJQUFELENBQXRCO0FBQ0FzUCxpQkFBUyxDQUFDRSxLQUFLLENBQUN4UCxJQUFQLEVBQWFxUCxLQUFLLENBQUNyUCxJQUFELENBQWxCLEVBQTBCd1AsS0FBSyxDQUFDbkUsT0FBaEMsQ0FBVDtBQUNEO0FBQ0Y7QUFDRjtBQUVEOzs7QUFFQSxXQUFTcUUsY0FBVCxDQUF5QjlULEdBQXpCLEVBQThCK1QsT0FBOUIsRUFBdUNsSSxJQUF2QyxFQUE2QztBQUMzQyxRQUFJN0wsR0FBRyxZQUFZZ0csS0FBbkIsRUFBMEI7QUFDeEJoRyxTQUFHLEdBQUdBLEdBQUcsQ0FBQ2tHLElBQUosQ0FBUzJGLElBQVQsS0FBa0I3TCxHQUFHLENBQUNrRyxJQUFKLENBQVMyRixJQUFULEdBQWdCLEVBQWxDLENBQU47QUFDRDs7QUFDRCxRQUFJd0gsT0FBSjtBQUNBLFFBQUlXLE9BQU8sR0FBR2hVLEdBQUcsQ0FBQytULE9BQUQsQ0FBakI7O0FBRUEsYUFBU0UsV0FBVCxHQUF3QjtBQUN0QnBJLFVBQUksQ0FBQzFQLEtBQUwsQ0FBVyxJQUFYLEVBQWlCRCxTQUFqQixFQURzQixDQUV0QjtBQUNBOztBQUNBN0IsWUFBTSxDQUFDZ1osT0FBTyxDQUFDRCxHQUFULEVBQWNhLFdBQWQsQ0FBTjtBQUNEOztBQUVELFFBQUl0YyxPQUFPLENBQUNxYyxPQUFELENBQVgsRUFBc0I7QUFDcEI7QUFDQVgsYUFBTyxHQUFHRixlQUFlLENBQUMsQ0FBQ2MsV0FBRCxDQUFELENBQXpCO0FBQ0QsS0FIRCxNQUdPO0FBQ0w7QUFDQSxVQUFJbmMsS0FBSyxDQUFDa2MsT0FBTyxDQUFDWixHQUFULENBQUwsSUFBc0JyYixNQUFNLENBQUNpYyxPQUFPLENBQUNFLE1BQVQsQ0FBaEMsRUFBa0Q7QUFDaEQ7QUFDQWIsZUFBTyxHQUFHVyxPQUFWO0FBQ0FYLGVBQU8sQ0FBQ0QsR0FBUixDQUFZdE8sSUFBWixDQUFpQm1QLFdBQWpCO0FBQ0QsT0FKRCxNQUlPO0FBQ0w7QUFDQVosZUFBTyxHQUFHRixlQUFlLENBQUMsQ0FBQ2EsT0FBRCxFQUFVQyxXQUFWLENBQUQsQ0FBekI7QUFDRDtBQUNGOztBQUVEWixXQUFPLENBQUNhLE1BQVIsR0FBaUIsSUFBakI7QUFDQWxVLE9BQUcsQ0FBQytULE9BQUQsQ0FBSCxHQUFlVixPQUFmO0FBQ0Q7QUFFRDs7O0FBRUEsV0FBU2MseUJBQVQsQ0FDRWpPLElBREYsRUFFRTVELElBRkYsRUFHRTJELEdBSEYsRUFJRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUkySCxXQUFXLEdBQUd0TCxJQUFJLENBQUN5QixPQUFMLENBQWFtSSxLQUEvQjs7QUFDQSxRQUFJdlUsT0FBTyxDQUFDaVcsV0FBRCxDQUFYLEVBQTBCO0FBQ3hCO0FBQ0Q7O0FBQ0QsUUFBSTVRLEdBQUcsR0FBRyxFQUFWO0FBQ0EsUUFBSW9YLEtBQUssR0FBR2xPLElBQUksQ0FBQ2tPLEtBQWpCO0FBQ0EsUUFBSWxJLEtBQUssR0FBR2hHLElBQUksQ0FBQ2dHLEtBQWpCOztBQUNBLFFBQUlwVSxLQUFLLENBQUNzYyxLQUFELENBQUwsSUFBZ0J0YyxLQUFLLENBQUNvVSxLQUFELENBQXpCLEVBQWtDO0FBQ2hDLFdBQUssSUFBSXJSLEdBQVQsSUFBZ0IrUyxXQUFoQixFQUE2QjtBQUMzQixZQUFJeUcsTUFBTSxHQUFHelksU0FBUyxDQUFDZixHQUFELENBQXRCO0FBQ0E7QUFDRSxjQUFJeVosY0FBYyxHQUFHelosR0FBRyxDQUFDWCxXQUFKLEVBQXJCOztBQUNBLGNBQ0VXLEdBQUcsS0FBS3laLGNBQVIsSUFDQUYsS0FEQSxJQUNTeFosTUFBTSxDQUFDd1osS0FBRCxFQUFRRSxjQUFSLENBRmpCLEVBR0U7QUFDQXBSLGVBQUcsQ0FDRCxZQUFZb1IsY0FBWixHQUE2Qiw0QkFBN0IsR0FDQ2xSLG1CQUFtQixDQUFDNkMsR0FBRyxJQUFJM0QsSUFBUixDQURwQixHQUNxQyxpQ0FEckMsR0FFQSxLQUZBLEdBRVF6SCxHQUZSLEdBRWMsTUFGZCxHQUdBLGdFQUhBLEdBSUEsbUVBSkEsR0FLQSx1Q0FMQSxHQUswQ3daLE1BTDFDLEdBS21ELGtCQUxuRCxHQUt3RXhaLEdBTHhFLEdBSzhFLEtBTjdFLENBQUg7QUFRRDtBQUNGO0FBQ0QwWixpQkFBUyxDQUFDdlgsR0FBRCxFQUFNa1AsS0FBTixFQUFhclIsR0FBYixFQUFrQndaLE1BQWxCLEVBQTBCLElBQTFCLENBQVQsSUFDQUUsU0FBUyxDQUFDdlgsR0FBRCxFQUFNb1gsS0FBTixFQUFhdlosR0FBYixFQUFrQndaLE1BQWxCLEVBQTBCLEtBQTFCLENBRFQ7QUFFRDtBQUNGOztBQUNELFdBQU9yWCxHQUFQO0FBQ0Q7O0FBRUQsV0FBU3VYLFNBQVQsQ0FDRXZYLEdBREYsRUFFRXdYLElBRkYsRUFHRTNaLEdBSEYsRUFJRXdaLE1BSkYsRUFLRUksUUFMRixFQU1FO0FBQ0EsUUFBSTNjLEtBQUssQ0FBQzBjLElBQUQsQ0FBVCxFQUFpQjtBQUNmLFVBQUk1WixNQUFNLENBQUM0WixJQUFELEVBQU8zWixHQUFQLENBQVYsRUFBdUI7QUFDckJtQyxXQUFHLENBQUNuQyxHQUFELENBQUgsR0FBVzJaLElBQUksQ0FBQzNaLEdBQUQsQ0FBZjs7QUFDQSxZQUFJLENBQUM0WixRQUFMLEVBQWU7QUFDYixpQkFBT0QsSUFBSSxDQUFDM1osR0FBRCxDQUFYO0FBQ0Q7O0FBQ0QsZUFBTyxJQUFQO0FBQ0QsT0FORCxNQU1PLElBQUlELE1BQU0sQ0FBQzRaLElBQUQsRUFBT0gsTUFBUCxDQUFWLEVBQTBCO0FBQy9CclgsV0FBRyxDQUFDbkMsR0FBRCxDQUFILEdBQVcyWixJQUFJLENBQUNILE1BQUQsQ0FBZjs7QUFDQSxZQUFJLENBQUNJLFFBQUwsRUFBZTtBQUNiLGlCQUFPRCxJQUFJLENBQUNILE1BQUQsQ0FBWDtBQUNEOztBQUNELGVBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBTyxLQUFQO0FBQ0Q7QUFFRDtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVNLLHVCQUFULENBQWtDdk8sUUFBbEMsRUFBNEM7QUFDMUMsU0FBSyxJQUFJbk0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21NLFFBQVEsQ0FBQ2xNLE1BQTdCLEVBQXFDRCxDQUFDLEVBQXRDLEVBQTBDO0FBQ3hDLFVBQUkyQyxLQUFLLENBQUNzQixPQUFOLENBQWNrSSxRQUFRLENBQUNuTSxDQUFELENBQXRCLENBQUosRUFBZ0M7QUFDOUIsZUFBTzJDLEtBQUssQ0FBQ3JFLFNBQU4sQ0FBZ0JvRixNQUFoQixDQUF1QnZCLEtBQXZCLENBQTZCLEVBQTdCLEVBQWlDZ0ssUUFBakMsQ0FBUDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT0EsUUFBUDtBQUNELEdBMW9Fb0IsQ0E0b0VyQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU3dPLGlCQUFULENBQTRCeE8sUUFBNUIsRUFBc0M7QUFDcEMsV0FBT2xPLFdBQVcsQ0FBQ2tPLFFBQUQsQ0FBWCxHQUNILENBQUN5QixlQUFlLENBQUN6QixRQUFELENBQWhCLENBREcsR0FFSHhKLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY2tJLFFBQWQsSUFDRXlPLHNCQUFzQixDQUFDek8sUUFBRCxDQUR4QixHQUVFdE8sU0FKTjtBQUtEOztBQUVELFdBQVNnZCxVQUFULENBQXFCbE4sSUFBckIsRUFBMkI7QUFDekIsV0FBTzdQLEtBQUssQ0FBQzZQLElBQUQsQ0FBTCxJQUFlN1AsS0FBSyxDQUFDNlAsSUFBSSxDQUFDdkIsSUFBTixDQUFwQixJQUFtQ3BPLE9BQU8sQ0FBQzJQLElBQUksQ0FBQ1QsU0FBTixDQUFqRDtBQUNEOztBQUVELFdBQVMwTixzQkFBVCxDQUFpQ3pPLFFBQWpDLEVBQTJDMk8sV0FBM0MsRUFBd0Q7QUFDdEQsUUFBSTlYLEdBQUcsR0FBRyxFQUFWO0FBQ0EsUUFBSWhELENBQUosRUFBT3VCLENBQVAsRUFBVXdaLFNBQVYsRUFBcUJsUSxJQUFyQjs7QUFDQSxTQUFLN0ssQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHbU0sUUFBUSxDQUFDbE0sTUFBekIsRUFBaUNELENBQUMsRUFBbEMsRUFBc0M7QUFDcEN1QixPQUFDLEdBQUc0SyxRQUFRLENBQUNuTSxDQUFELENBQVo7O0FBQ0EsVUFBSXJDLE9BQU8sQ0FBQzRELENBQUQsQ0FBUCxJQUFjLE9BQU9BLENBQVAsS0FBYSxTQUEvQixFQUEwQztBQUFFO0FBQVU7O0FBQ3REd1osZUFBUyxHQUFHL1gsR0FBRyxDQUFDL0MsTUFBSixHQUFhLENBQXpCO0FBQ0E0SyxVQUFJLEdBQUc3SCxHQUFHLENBQUMrWCxTQUFELENBQVYsQ0FKb0MsQ0FLcEM7O0FBQ0EsVUFBSXBZLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBYzFDLENBQWQsQ0FBSixFQUFzQjtBQUNwQixZQUFJQSxDQUFDLENBQUN0QixNQUFGLEdBQVcsQ0FBZixFQUFrQjtBQUNoQnNCLFdBQUMsR0FBR3FaLHNCQUFzQixDQUFDclosQ0FBRCxFQUFLLENBQUN1WixXQUFXLElBQUksRUFBaEIsSUFBc0IsR0FBdEIsR0FBNEI5YSxDQUFqQyxDQUExQixDQURnQixDQUVoQjs7QUFDQSxjQUFJNmEsVUFBVSxDQUFDdFosQ0FBQyxDQUFDLENBQUQsQ0FBRixDQUFWLElBQW9Cc1osVUFBVSxDQUFDaFEsSUFBRCxDQUFsQyxFQUEwQztBQUN4QzdILGVBQUcsQ0FBQytYLFNBQUQsQ0FBSCxHQUFpQm5OLGVBQWUsQ0FBQy9DLElBQUksQ0FBQ3VCLElBQUwsR0FBYTdLLENBQUMsQ0FBQyxDQUFELENBQUYsQ0FBTzZLLElBQXBCLENBQWhDO0FBQ0E3SyxhQUFDLENBQUN5WixLQUFGO0FBQ0Q7O0FBQ0RoWSxhQUFHLENBQUM4SCxJQUFKLENBQVMzSSxLQUFULENBQWVhLEdBQWYsRUFBb0J6QixDQUFwQjtBQUNEO0FBQ0YsT0FWRCxNQVVPLElBQUl0RCxXQUFXLENBQUNzRCxDQUFELENBQWYsRUFBb0I7QUFDekIsWUFBSXNaLFVBQVUsQ0FBQ2hRLElBQUQsQ0FBZCxFQUFzQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTdILGFBQUcsQ0FBQytYLFNBQUQsQ0FBSCxHQUFpQm5OLGVBQWUsQ0FBQy9DLElBQUksQ0FBQ3VCLElBQUwsR0FBWTdLLENBQWIsQ0FBaEM7QUFDRCxTQUxELE1BS08sSUFBSUEsQ0FBQyxLQUFLLEVBQVYsRUFBYztBQUNuQjtBQUNBeUIsYUFBRyxDQUFDOEgsSUFBSixDQUFTOEMsZUFBZSxDQUFDck0sQ0FBRCxDQUF4QjtBQUNEO0FBQ0YsT0FWTSxNQVVBO0FBQ0wsWUFBSXNaLFVBQVUsQ0FBQ3RaLENBQUQsQ0FBVixJQUFpQnNaLFVBQVUsQ0FBQ2hRLElBQUQsQ0FBL0IsRUFBdUM7QUFDckM7QUFDQTdILGFBQUcsQ0FBQytYLFNBQUQsQ0FBSCxHQUFpQm5OLGVBQWUsQ0FBQy9DLElBQUksQ0FBQ3VCLElBQUwsR0FBWTdLLENBQUMsQ0FBQzZLLElBQWYsQ0FBaEM7QUFDRCxTQUhELE1BR087QUFDTDtBQUNBLGNBQUlyTyxNQUFNLENBQUNvTyxRQUFRLENBQUM4TyxRQUFWLENBQU4sSUFDRm5kLEtBQUssQ0FBQ3lELENBQUMsQ0FBQzBLLEdBQUgsQ0FESCxJQUVGdE8sT0FBTyxDQUFDNEQsQ0FBQyxDQUFDVixHQUFILENBRkwsSUFHRi9DLEtBQUssQ0FBQ2dkLFdBQUQsQ0FIUCxFQUdzQjtBQUNwQnZaLGFBQUMsQ0FBQ1YsR0FBRixHQUFRLFlBQVlpYSxXQUFaLEdBQTBCLEdBQTFCLEdBQWdDOWEsQ0FBaEMsR0FBb0MsSUFBNUM7QUFDRDs7QUFDRGdELGFBQUcsQ0FBQzhILElBQUosQ0FBU3ZKLENBQVQ7QUFDRDtBQUNGO0FBQ0Y7O0FBQ0QsV0FBT3lCLEdBQVA7QUFDRDtBQUVEOzs7QUFFQSxXQUFTa1ksVUFBVCxDQUFxQkMsSUFBckIsRUFBMkJDLElBQTNCLEVBQWlDO0FBQy9CLFFBQ0VELElBQUksQ0FBQ0UsVUFBTCxJQUNDOVMsU0FBUyxJQUFJNFMsSUFBSSxDQUFDM1MsTUFBTSxDQUFDOFMsV0FBUixDQUFKLEtBQTZCLFFBRjdDLEVBR0U7QUFDQUgsVUFBSSxHQUFHQSxJQUFJLENBQUM3RyxPQUFaO0FBQ0Q7O0FBQ0QsV0FBT25XLFFBQVEsQ0FBQ2dkLElBQUQsQ0FBUixHQUNIQyxJQUFJLENBQUN4WSxNQUFMLENBQVl1WSxJQUFaLENBREcsR0FFSEEsSUFGSjtBQUdEOztBQUVELFdBQVNJLHNCQUFULENBQ0VsZSxPQURGLEVBRUU2TyxJQUZGLEVBR0VJLE9BSEYsRUFJRUgsUUFKRixFQUtFRixHQUxGLEVBTUU7QUFDQSxRQUFJMEIsSUFBSSxHQUFHRCxnQkFBZ0IsRUFBM0I7QUFDQUMsUUFBSSxDQUFDbkIsWUFBTCxHQUFvQm5QLE9BQXBCO0FBQ0FzUSxRQUFJLENBQUNOLFNBQUwsR0FBaUI7QUFBRW5CLFVBQUksRUFBRUEsSUFBUjtBQUFjSSxhQUFPLEVBQUVBLE9BQXZCO0FBQWdDSCxjQUFRLEVBQUVBLFFBQTFDO0FBQW9ERixTQUFHLEVBQUVBO0FBQXpELEtBQWpCO0FBQ0EsV0FBTzBCLElBQVA7QUFDRDs7QUFFRCxXQUFTNk4scUJBQVQsQ0FDRW5lLE9BREYsRUFFRW9lLFFBRkYsRUFHRW5QLE9BSEYsRUFJRTtBQUNBLFFBQUl2TyxNQUFNLENBQUNWLE9BQU8sQ0FBQ3VNLEtBQVQsQ0FBTixJQUF5QjlMLEtBQUssQ0FBQ1QsT0FBTyxDQUFDcWUsU0FBVCxDQUFsQyxFQUF1RDtBQUNyRCxhQUFPcmUsT0FBTyxDQUFDcWUsU0FBZjtBQUNEOztBQUVELFFBQUk1ZCxLQUFLLENBQUNULE9BQU8sQ0FBQ3NlLFFBQVQsQ0FBVCxFQUE2QjtBQUMzQixhQUFPdGUsT0FBTyxDQUFDc2UsUUFBZjtBQUNEOztBQUVELFFBQUk1ZCxNQUFNLENBQUNWLE9BQU8sQ0FBQ3VlLE9BQVQsQ0FBTixJQUEyQjlkLEtBQUssQ0FBQ1QsT0FBTyxDQUFDd2UsV0FBVCxDQUFwQyxFQUEyRDtBQUN6RCxhQUFPeGUsT0FBTyxDQUFDd2UsV0FBZjtBQUNEOztBQUVELFFBQUkvZCxLQUFLLENBQUNULE9BQU8sQ0FBQ3llLFFBQVQsQ0FBVCxFQUE2QjtBQUMzQjtBQUNBemUsYUFBTyxDQUFDeWUsUUFBUixDQUFpQmhSLElBQWpCLENBQXNCd0IsT0FBdEI7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJd1AsUUFBUSxHQUFHemUsT0FBTyxDQUFDeWUsUUFBUixHQUFtQixDQUFDeFAsT0FBRCxDQUFsQztBQUNBLFVBQUl5UCxJQUFJLEdBQUcsSUFBWDs7QUFFQSxVQUFJQyxXQUFXLEdBQUcsWUFBWTtBQUM1QixhQUFLLElBQUloYyxDQUFDLEdBQUcsQ0FBUixFQUFXaUMsQ0FBQyxHQUFHNlosUUFBUSxDQUFDN2IsTUFBN0IsRUFBcUNELENBQUMsR0FBR2lDLENBQXpDLEVBQTRDakMsQ0FBQyxFQUE3QyxFQUFpRDtBQUMvQzhiLGtCQUFRLENBQUM5YixDQUFELENBQVIsQ0FBWWljLFlBQVo7QUFDRDtBQUNGLE9BSkQ7O0FBTUEsVUFBSW5GLE9BQU8sR0FBR3RTLElBQUksQ0FBQyxVQUFVeEIsR0FBVixFQUFlO0FBQ2hDO0FBQ0EzRixlQUFPLENBQUNzZSxRQUFSLEdBQW1CVCxVQUFVLENBQUNsWSxHQUFELEVBQU15WSxRQUFOLENBQTdCLENBRmdDLENBR2hDO0FBQ0E7O0FBQ0EsWUFBSSxDQUFDTSxJQUFMLEVBQVc7QUFDVEMscUJBQVc7QUFDWjtBQUNGLE9BUmlCLENBQWxCO0FBVUEsVUFBSUUsTUFBTSxHQUFHMVgsSUFBSSxDQUFDLFVBQVUyWCxNQUFWLEVBQWtCO0FBQ2xDLDBCQUFrQixZQUFsQixJQUFrQ2xULElBQUksQ0FDcEMsd0NBQXlDaEssTUFBTSxDQUFDNUIsT0FBRCxDQUEvQyxJQUNDOGUsTUFBTSxHQUFJLGVBQWVBLE1BQW5CLEdBQTZCLEVBRHBDLENBRG9DLENBQXRDOztBQUlBLFlBQUlyZSxLQUFLLENBQUNULE9BQU8sQ0FBQ3FlLFNBQVQsQ0FBVCxFQUE4QjtBQUM1QnJlLGlCQUFPLENBQUN1TSxLQUFSLEdBQWdCLElBQWhCO0FBQ0FvUyxxQkFBVztBQUNaO0FBQ0YsT0FUZ0IsQ0FBakI7QUFXQSxVQUFJaFosR0FBRyxHQUFHM0YsT0FBTyxDQUFDeVosT0FBRCxFQUFVb0YsTUFBVixDQUFqQjs7QUFFQSxVQUFJL2QsUUFBUSxDQUFDNkUsR0FBRCxDQUFaLEVBQW1CO0FBQ2pCLFlBQUksT0FBT0EsR0FBRyxDQUFDK1QsSUFBWCxLQUFvQixVQUF4QixFQUFvQztBQUNsQztBQUNBLGNBQUlwWixPQUFPLENBQUNOLE9BQU8sQ0FBQ3NlLFFBQVQsQ0FBWCxFQUErQjtBQUM3QjNZLGVBQUcsQ0FBQytULElBQUosQ0FBU0QsT0FBVCxFQUFrQm9GLE1BQWxCO0FBQ0Q7QUFDRixTQUxELE1BS08sSUFBSXBlLEtBQUssQ0FBQ2tGLEdBQUcsQ0FBQ29aLFNBQUwsQ0FBTCxJQUF3QixPQUFPcFosR0FBRyxDQUFDb1osU0FBSixDQUFjckYsSUFBckIsS0FBOEIsVUFBMUQsRUFBc0U7QUFDM0UvVCxhQUFHLENBQUNvWixTQUFKLENBQWNyRixJQUFkLENBQW1CRCxPQUFuQixFQUE0Qm9GLE1BQTVCOztBQUVBLGNBQUlwZSxLQUFLLENBQUNrRixHQUFHLENBQUM0RyxLQUFMLENBQVQsRUFBc0I7QUFDcEJ2TSxtQkFBTyxDQUFDcWUsU0FBUixHQUFvQlIsVUFBVSxDQUFDbFksR0FBRyxDQUFDNEcsS0FBTCxFQUFZNlIsUUFBWixDQUE5QjtBQUNEOztBQUVELGNBQUkzZCxLQUFLLENBQUNrRixHQUFHLENBQUM0WSxPQUFMLENBQVQsRUFBd0I7QUFDdEJ2ZSxtQkFBTyxDQUFDd2UsV0FBUixHQUFzQlgsVUFBVSxDQUFDbFksR0FBRyxDQUFDNFksT0FBTCxFQUFjSCxRQUFkLENBQWhDOztBQUNBLGdCQUFJelksR0FBRyxDQUFDcVosS0FBSixLQUFjLENBQWxCLEVBQXFCO0FBQ25CaGYscUJBQU8sQ0FBQ3VlLE9BQVIsR0FBa0IsSUFBbEI7QUFDRCxhQUZELE1BRU87QUFDTGpGLHdCQUFVLENBQUMsWUFBWTtBQUNyQixvQkFBSWhaLE9BQU8sQ0FBQ04sT0FBTyxDQUFDc2UsUUFBVCxDQUFQLElBQTZCaGUsT0FBTyxDQUFDTixPQUFPLENBQUN1TSxLQUFULENBQXhDLEVBQXlEO0FBQ3ZEdk0seUJBQU8sQ0FBQ3VlLE9BQVIsR0FBa0IsSUFBbEI7QUFDQUksNkJBQVc7QUFDWjtBQUNGLGVBTFMsRUFLUGhaLEdBQUcsQ0FBQ3FaLEtBQUosSUFBYSxHQUxOLENBQVY7QUFNRDtBQUNGOztBQUVELGNBQUl2ZSxLQUFLLENBQUNrRixHQUFHLENBQUNzWixPQUFMLENBQVQsRUFBd0I7QUFDdEIzRixzQkFBVSxDQUFDLFlBQVk7QUFDckIsa0JBQUloWixPQUFPLENBQUNOLE9BQU8sQ0FBQ3NlLFFBQVQsQ0FBWCxFQUErQjtBQUM3Qk8sc0JBQU0sQ0FDSixjQUFlbFosR0FBRyxDQUFDc1osT0FBbkIsR0FBOEIsS0FEMUIsQ0FBTjtBQUdEO0FBQ0YsYUFOUyxFQU1QdFosR0FBRyxDQUFDc1osT0FORyxDQUFWO0FBT0Q7QUFDRjtBQUNGOztBQUVEUCxVQUFJLEdBQUcsS0FBUCxDQXhFSyxDQXlFTDs7QUFDQSxhQUFPMWUsT0FBTyxDQUFDdWUsT0FBUixHQUNIdmUsT0FBTyxDQUFDd2UsV0FETCxHQUVIeGUsT0FBTyxDQUFDc2UsUUFGWjtBQUdEO0FBQ0Y7QUFFRDs7O0FBRUEsV0FBU3JPLGtCQUFULENBQTZCSyxJQUE3QixFQUFtQztBQUNqQyxXQUFPQSxJQUFJLENBQUNULFNBQUwsSUFBa0JTLElBQUksQ0FBQ25CLFlBQTlCO0FBQ0Q7QUFFRDs7O0FBRUEsV0FBUytQLHNCQUFULENBQWlDcFEsUUFBakMsRUFBMkM7QUFDekMsUUFBSXhKLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY2tJLFFBQWQsQ0FBSixFQUE2QjtBQUMzQixXQUFLLElBQUluTSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbU0sUUFBUSxDQUFDbE0sTUFBN0IsRUFBcUNELENBQUMsRUFBdEMsRUFBMEM7QUFDeEMsWUFBSXVCLENBQUMsR0FBRzRLLFFBQVEsQ0FBQ25NLENBQUQsQ0FBaEI7O0FBQ0EsWUFBSWxDLEtBQUssQ0FBQ3lELENBQUQsQ0FBTCxLQUFhekQsS0FBSyxDQUFDeUQsQ0FBQyxDQUFDZ0wsZ0JBQUgsQ0FBTCxJQUE2QmUsa0JBQWtCLENBQUMvTCxDQUFELENBQTVELENBQUosRUFBc0U7QUFDcEUsaUJBQU9BLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUVEOztBQUVBOzs7QUFFQSxXQUFTaWIsVUFBVCxDQUFxQjlTLEVBQXJCLEVBQXlCO0FBQ3ZCQSxNQUFFLENBQUMrUyxPQUFILEdBQWFoZixNQUFNLENBQUNvQyxNQUFQLENBQWMsSUFBZCxDQUFiO0FBQ0E2SixNQUFFLENBQUNnVCxhQUFILEdBQW1CLEtBQW5CLENBRnVCLENBR3ZCOztBQUNBLFFBQUlDLFNBQVMsR0FBR2pULEVBQUUsQ0FBQ1EsUUFBSCxDQUFZMFMsZ0JBQTVCOztBQUNBLFFBQUlELFNBQUosRUFBZTtBQUNiRSw4QkFBd0IsQ0FBQ25ULEVBQUQsRUFBS2lULFNBQUwsQ0FBeEI7QUFDRDtBQUNGOztBQUVELE1BQUlwUixNQUFKOztBQUVBLFdBQVN4QyxHQUFULENBQWM2USxLQUFkLEVBQXFCN1ksRUFBckIsRUFBeUJ5RCxJQUF6QixFQUErQjtBQUM3QixRQUFJQSxJQUFKLEVBQVU7QUFDUitHLFlBQU0sQ0FBQ3VSLEtBQVAsQ0FBYWxELEtBQWIsRUFBb0I3WSxFQUFwQjtBQUNELEtBRkQsTUFFTztBQUNMd0ssWUFBTSxDQUFDd1IsR0FBUCxDQUFXbkQsS0FBWCxFQUFrQjdZLEVBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTaWMsUUFBVCxDQUFtQnBELEtBQW5CLEVBQTBCN1ksRUFBMUIsRUFBOEI7QUFDNUJ3SyxVQUFNLENBQUMwUixJQUFQLENBQVlyRCxLQUFaLEVBQW1CN1ksRUFBbkI7QUFDRDs7QUFFRCxXQUFTOGIsd0JBQVQsQ0FDRW5ULEVBREYsRUFFRWlULFNBRkYsRUFHRU8sWUFIRixFQUlFO0FBQ0EzUixVQUFNLEdBQUc3QixFQUFUO0FBQ0E2UCxtQkFBZSxDQUFDb0QsU0FBRCxFQUFZTyxZQUFZLElBQUksRUFBNUIsRUFBZ0NuVSxHQUFoQyxFQUFxQ2lVLFFBQXJDLEVBQStDdFQsRUFBL0MsQ0FBZjtBQUNBNkIsVUFBTSxHQUFHMU4sU0FBVDtBQUNEOztBQUVELFdBQVNzZixXQUFULENBQXNCQyxHQUF0QixFQUEyQjtBQUN6QixRQUFJQyxNQUFNLEdBQUcsUUFBYjs7QUFDQUQsT0FBRyxDQUFDOWUsU0FBSixDQUFjeWUsR0FBZCxHQUFvQixVQUFVbkQsS0FBVixFQUFpQjdZLEVBQWpCLEVBQXFCO0FBQ3ZDLFVBQUl1YyxNQUFNLEdBQUcsSUFBYjtBQUVBLFVBQUk1VCxFQUFFLEdBQUcsSUFBVDs7QUFDQSxVQUFJL0csS0FBSyxDQUFDc0IsT0FBTixDQUFjMlYsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCLGFBQUssSUFBSTVaLENBQUMsR0FBRyxDQUFSLEVBQVdpQyxDQUFDLEdBQUcyWCxLQUFLLENBQUMzWixNQUExQixFQUFrQ0QsQ0FBQyxHQUFHaUMsQ0FBdEMsRUFBeUNqQyxDQUFDLEVBQTFDLEVBQThDO0FBQzVDc2QsZ0JBQU0sQ0FBQ1AsR0FBUCxDQUFXbkQsS0FBSyxDQUFDNVosQ0FBRCxDQUFoQixFQUFxQmUsRUFBckI7QUFDRDtBQUNGLE9BSkQsTUFJTztBQUNMLFNBQUMySSxFQUFFLENBQUMrUyxPQUFILENBQVc3QyxLQUFYLE1BQXNCbFEsRUFBRSxDQUFDK1MsT0FBSCxDQUFXN0MsS0FBWCxJQUFvQixFQUExQyxDQUFELEVBQWdEOU8sSUFBaEQsQ0FBcUQvSixFQUFyRCxFQURLLENBRUw7QUFDQTs7QUFDQSxZQUFJc2MsTUFBTSxDQUFDN1csSUFBUCxDQUFZb1QsS0FBWixDQUFKLEVBQXdCO0FBQ3RCbFEsWUFBRSxDQUFDZ1QsYUFBSCxHQUFtQixJQUFuQjtBQUNEO0FBQ0Y7O0FBQ0QsYUFBT2hULEVBQVA7QUFDRCxLQWpCRDs7QUFtQkEwVCxPQUFHLENBQUM5ZSxTQUFKLENBQWN3ZSxLQUFkLEdBQXNCLFVBQVVsRCxLQUFWLEVBQWlCN1ksRUFBakIsRUFBcUI7QUFDekMsVUFBSTJJLEVBQUUsR0FBRyxJQUFUOztBQUNBLGVBQVM4UCxFQUFULEdBQWU7QUFDYjlQLFVBQUUsQ0FBQ3VULElBQUgsQ0FBUXJELEtBQVIsRUFBZUosRUFBZjtBQUNBelksVUFBRSxDQUFDb0IsS0FBSCxDQUFTdUgsRUFBVCxFQUFheEgsU0FBYjtBQUNEOztBQUNEc1gsUUFBRSxDQUFDelksRUFBSCxHQUFRQSxFQUFSO0FBQ0EySSxRQUFFLENBQUNxVCxHQUFILENBQU9uRCxLQUFQLEVBQWNKLEVBQWQ7QUFDQSxhQUFPOVAsRUFBUDtBQUNELEtBVEQ7O0FBV0EwVCxPQUFHLENBQUM5ZSxTQUFKLENBQWMyZSxJQUFkLEdBQXFCLFVBQVVyRCxLQUFWLEVBQWlCN1ksRUFBakIsRUFBcUI7QUFDeEMsVUFBSXVjLE1BQU0sR0FBRyxJQUFiO0FBRUEsVUFBSTVULEVBQUUsR0FBRyxJQUFULENBSHdDLENBSXhDOztBQUNBLFVBQUksQ0FBQ3hILFNBQVMsQ0FBQ2pDLE1BQWYsRUFBdUI7QUFDckJ5SixVQUFFLENBQUMrUyxPQUFILEdBQWFoZixNQUFNLENBQUNvQyxNQUFQLENBQWMsSUFBZCxDQUFiO0FBQ0EsZUFBTzZKLEVBQVA7QUFDRCxPQVJ1QyxDQVN4Qzs7O0FBQ0EsVUFBSS9HLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBYzJWLEtBQWQsQ0FBSixFQUEwQjtBQUN4QixhQUFLLElBQUk1WixDQUFDLEdBQUcsQ0FBUixFQUFXaUMsQ0FBQyxHQUFHMlgsS0FBSyxDQUFDM1osTUFBMUIsRUFBa0NELENBQUMsR0FBR2lDLENBQXRDLEVBQXlDakMsQ0FBQyxFQUExQyxFQUE4QztBQUM1Q3NkLGdCQUFNLENBQUNMLElBQVAsQ0FBWXJELEtBQUssQ0FBQzVaLENBQUQsQ0FBakIsRUFBc0JlLEVBQXRCO0FBQ0Q7O0FBQ0QsZUFBTzJJLEVBQVA7QUFDRCxPQWZ1QyxDQWdCeEM7OztBQUNBLFVBQUk2VCxHQUFHLEdBQUc3VCxFQUFFLENBQUMrUyxPQUFILENBQVc3QyxLQUFYLENBQVY7O0FBQ0EsVUFBSSxDQUFDMkQsR0FBTCxFQUFVO0FBQ1IsZUFBTzdULEVBQVA7QUFDRDs7QUFDRCxVQUFJLENBQUMzSSxFQUFMLEVBQVM7QUFDUDJJLFVBQUUsQ0FBQytTLE9BQUgsQ0FBVzdDLEtBQVgsSUFBb0IsSUFBcEI7QUFDQSxlQUFPbFEsRUFBUDtBQUNEOztBQUNELFVBQUkzSSxFQUFKLEVBQVE7QUFDTjtBQUNBLFlBQUlvVyxFQUFKO0FBQ0EsWUFBSXFHLEdBQUcsR0FBR0QsR0FBRyxDQUFDdGQsTUFBZDs7QUFDQSxlQUFPdWQsR0FBRyxFQUFWLEVBQWM7QUFDWnJHLFlBQUUsR0FBR29HLEdBQUcsQ0FBQ0MsR0FBRCxDQUFSOztBQUNBLGNBQUlyRyxFQUFFLEtBQUtwVyxFQUFQLElBQWFvVyxFQUFFLENBQUNwVyxFQUFILEtBQVVBLEVBQTNCLEVBQStCO0FBQzdCd2MsZUFBRyxDQUFDN2MsTUFBSixDQUFXOGMsR0FBWCxFQUFnQixDQUFoQjtBQUNBO0FBQ0Q7QUFDRjtBQUNGOztBQUNELGFBQU85VCxFQUFQO0FBQ0QsS0F0Q0Q7O0FBd0NBMFQsT0FBRyxDQUFDOWUsU0FBSixDQUFjbWYsS0FBZCxHQUFzQixVQUFVN0QsS0FBVixFQUFpQjtBQUNyQyxVQUFJbFEsRUFBRSxHQUFHLElBQVQ7QUFDQTtBQUNFLFlBQUlnVSxjQUFjLEdBQUc5RCxLQUFLLENBQUMxWixXQUFOLEVBQXJCOztBQUNBLFlBQUl3ZCxjQUFjLEtBQUs5RCxLQUFuQixJQUE0QmxRLEVBQUUsQ0FBQytTLE9BQUgsQ0FBV2lCLGNBQVgsQ0FBaEMsRUFBNEQ7QUFDMUR4VSxhQUFHLENBQ0QsYUFBYXdVLGNBQWIsR0FBOEIsNkJBQTlCLEdBQ0N0VSxtQkFBbUIsQ0FBQ00sRUFBRCxDQURwQixHQUM0Qix1Q0FENUIsR0FDc0VrUSxLQUR0RSxHQUM4RSxNQUQ5RSxHQUVBLG9FQUZBLEdBR0Esa0VBSEEsR0FJQSw0QkFKQSxHQUlnQ2hZLFNBQVMsQ0FBQ2dZLEtBQUQsQ0FKekMsR0FJb0Qsa0JBSnBELEdBSXlFQSxLQUp6RSxHQUlpRixLQUxoRixDQUFIO0FBT0Q7QUFDRjtBQUNELFVBQUkyRCxHQUFHLEdBQUc3VCxFQUFFLENBQUMrUyxPQUFILENBQVc3QyxLQUFYLENBQVY7O0FBQ0EsVUFBSTJELEdBQUosRUFBUztBQUNQQSxXQUFHLEdBQUdBLEdBQUcsQ0FBQ3RkLE1BQUosR0FBYSxDQUFiLEdBQWlCdUMsT0FBTyxDQUFDK2EsR0FBRCxDQUF4QixHQUFnQ0EsR0FBdEM7QUFDQSxZQUFJaFAsSUFBSSxHQUFHL0wsT0FBTyxDQUFDTixTQUFELEVBQVksQ0FBWixDQUFsQjs7QUFDQSxhQUFLLElBQUlsQyxDQUFDLEdBQUcsQ0FBUixFQUFXaUMsQ0FBQyxHQUFHc2IsR0FBRyxDQUFDdGQsTUFBeEIsRUFBZ0NELENBQUMsR0FBR2lDLENBQXBDLEVBQXVDakMsQ0FBQyxFQUF4QyxFQUE0QztBQUMxQyxjQUFJO0FBQ0Z1ZCxlQUFHLENBQUN2ZCxDQUFELENBQUgsQ0FBT21DLEtBQVAsQ0FBYXVILEVBQWIsRUFBaUI2RSxJQUFqQjtBQUNELFdBRkQsQ0FFRSxPQUFPbkssQ0FBUCxFQUFVO0FBQ1YrUSx1QkFBVyxDQUFDL1EsQ0FBRCxFQUFJc0YsRUFBSixFQUFTLHlCQUF5QmtRLEtBQXpCLEdBQWlDLElBQTFDLENBQVg7QUFDRDtBQUNGO0FBQ0Y7O0FBQ0QsYUFBT2xRLEVBQVA7QUFDRCxLQTNCRDtBQTRCRDtBQUVEOztBQUlBOzs7OztBQUdBLFdBQVNpVSxZQUFULENBQ0V4UixRQURGLEVBRUVHLE9BRkYsRUFHRTtBQUNBLFFBQUlzUixLQUFLLEdBQUcsRUFBWjs7QUFDQSxRQUFJLENBQUN6UixRQUFMLEVBQWU7QUFDYixhQUFPeVIsS0FBUDtBQUNEOztBQUNELFNBQUssSUFBSTVkLENBQUMsR0FBRyxDQUFSLEVBQVdpQyxDQUFDLEdBQUdrSyxRQUFRLENBQUNsTSxNQUE3QixFQUFxQ0QsQ0FBQyxHQUFHaUMsQ0FBekMsRUFBNENqQyxDQUFDLEVBQTdDLEVBQWlEO0FBQy9DLFVBQUl3TixLQUFLLEdBQUdyQixRQUFRLENBQUNuTSxDQUFELENBQXBCO0FBQ0EsVUFBSWtNLElBQUksR0FBR3NCLEtBQUssQ0FBQ3RCLElBQWpCLENBRitDLENBRy9DOztBQUNBLFVBQUlBLElBQUksSUFBSUEsSUFBSSxDQUFDa08sS0FBYixJQUFzQmxPLElBQUksQ0FBQ2tPLEtBQUwsQ0FBV3lELElBQXJDLEVBQTJDO0FBQ3pDLGVBQU8zUixJQUFJLENBQUNrTyxLQUFMLENBQVd5RCxJQUFsQjtBQUNELE9BTjhDLENBTy9DO0FBQ0E7OztBQUNBLFVBQUksQ0FBQ3JRLEtBQUssQ0FBQ2xCLE9BQU4sS0FBa0JBLE9BQWxCLElBQTZCa0IsS0FBSyxDQUFDZCxTQUFOLEtBQW9CSixPQUFsRCxLQUNGSixJQURFLElBQ01BLElBQUksQ0FBQzJSLElBQUwsSUFBYSxJQUR2QixFQUVFO0FBQ0EsWUFBSXpULElBQUksR0FBRzhCLElBQUksQ0FBQzJSLElBQWhCO0FBQ0EsWUFBSUEsSUFBSSxHQUFJRCxLQUFLLENBQUN4VCxJQUFELENBQUwsS0FBZ0J3VCxLQUFLLENBQUN4VCxJQUFELENBQUwsR0FBYyxFQUE5QixDQUFaOztBQUNBLFlBQUlvRCxLQUFLLENBQUN2QixHQUFOLEtBQWMsVUFBbEIsRUFBOEI7QUFDNUI0UixjQUFJLENBQUMvUyxJQUFMLENBQVUzSSxLQUFWLENBQWdCMGIsSUFBaEIsRUFBc0JyUSxLQUFLLENBQUNyQixRQUFOLElBQWtCLEVBQXhDO0FBQ0QsU0FGRCxNQUVPO0FBQ0wwUixjQUFJLENBQUMvUyxJQUFMLENBQVUwQyxLQUFWO0FBQ0Q7QUFDRixPQVZELE1BVU87QUFDTCxTQUFDb1EsS0FBSyxDQUFDdEosT0FBTixLQUFrQnNKLEtBQUssQ0FBQ3RKLE9BQU4sR0FBZ0IsRUFBbEMsQ0FBRCxFQUF3Q3hKLElBQXhDLENBQTZDMEMsS0FBN0M7QUFDRDtBQUNGLEtBM0JELENBNEJBOzs7QUFDQSxTQUFLLElBQUlzUSxNQUFULElBQW1CRixLQUFuQixFQUEwQjtBQUN4QixVQUFJQSxLQUFLLENBQUNFLE1BQUQsQ0FBTCxDQUFjM1osS0FBZCxDQUFvQjRaLFlBQXBCLENBQUosRUFBdUM7QUFDckMsZUFBT0gsS0FBSyxDQUFDRSxNQUFELENBQVo7QUFDRDtBQUNGOztBQUNELFdBQU9GLEtBQVA7QUFDRDs7QUFFRCxXQUFTRyxZQUFULENBQXVCcFEsSUFBdkIsRUFBNkI7QUFDM0IsV0FBUUEsSUFBSSxDQUFDVCxTQUFMLElBQWtCLENBQUNTLElBQUksQ0FBQ25CLFlBQXpCLElBQTBDbUIsSUFBSSxDQUFDdkIsSUFBTCxLQUFjLEdBQS9EO0FBQ0Q7O0FBRUQsV0FBUzRSLGtCQUFULENBQ0U1RSxHQURGLEVBQ087QUFDTHBXLEtBRkYsRUFHRTtBQUNBQSxPQUFHLEdBQUdBLEdBQUcsSUFBSSxFQUFiOztBQUNBLFNBQUssSUFBSWhELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvWixHQUFHLENBQUNuWixNQUF4QixFQUFnQ0QsQ0FBQyxFQUFqQyxFQUFxQztBQUNuQyxVQUFJMkMsS0FBSyxDQUFDc0IsT0FBTixDQUFjbVYsR0FBRyxDQUFDcFosQ0FBRCxDQUFqQixDQUFKLEVBQTJCO0FBQ3pCZ2UsMEJBQWtCLENBQUM1RSxHQUFHLENBQUNwWixDQUFELENBQUosRUFBU2dELEdBQVQsQ0FBbEI7QUFDRCxPQUZELE1BRU87QUFDTEEsV0FBRyxDQUFDb1csR0FBRyxDQUFDcFosQ0FBRCxDQUFILENBQU9hLEdBQVIsQ0FBSCxHQUFrQnVZLEdBQUcsQ0FBQ3BaLENBQUQsQ0FBSCxDQUFPZSxFQUF6QjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT2lDLEdBQVA7QUFDRDtBQUVEOzs7QUFFQSxNQUFJaWIsY0FBYyxHQUFHLElBQXJCO0FBQ0EsTUFBSUMsd0JBQXdCLEdBQUcsS0FBL0I7O0FBRUEsV0FBU0MsYUFBVCxDQUF3QnpVLEVBQXhCLEVBQTRCO0FBQzFCLFFBQUlLLE9BQU8sR0FBR0wsRUFBRSxDQUFDUSxRQUFqQixDQUQwQixDQUcxQjs7QUFDQSxRQUFJNEMsTUFBTSxHQUFHL0MsT0FBTyxDQUFDK0MsTUFBckI7O0FBQ0EsUUFBSUEsTUFBTSxJQUFJLENBQUMvQyxPQUFPLENBQUNxVSxRQUF2QixFQUFpQztBQUMvQixhQUFPdFIsTUFBTSxDQUFDNUMsUUFBUCxDQUFnQmtVLFFBQWhCLElBQTRCdFIsTUFBTSxDQUFDcEMsT0FBMUMsRUFBbUQ7QUFDakRvQyxjQUFNLEdBQUdBLE1BQU0sQ0FBQ3BDLE9BQWhCO0FBQ0Q7O0FBQ0RvQyxZQUFNLENBQUN1UixTQUFQLENBQWlCdlQsSUFBakIsQ0FBc0JwQixFQUF0QjtBQUNEOztBQUVEQSxNQUFFLENBQUNnQixPQUFILEdBQWFvQyxNQUFiO0FBQ0FwRCxNQUFFLENBQUNJLEtBQUgsR0FBV2dELE1BQU0sR0FBR0EsTUFBTSxDQUFDaEQsS0FBVixHQUFrQkosRUFBbkM7QUFFQUEsTUFBRSxDQUFDMlUsU0FBSCxHQUFlLEVBQWY7QUFDQTNVLE1BQUUsQ0FBQzRVLEtBQUgsR0FBVyxFQUFYO0FBRUE1VSxNQUFFLENBQUM2VSxRQUFILEdBQWMsSUFBZDtBQUNBN1UsTUFBRSxDQUFDOFUsU0FBSCxHQUFlLElBQWY7QUFDQTlVLE1BQUUsQ0FBQytVLGVBQUgsR0FBcUIsS0FBckI7QUFDQS9VLE1BQUUsQ0FBQ2dWLFVBQUgsR0FBZ0IsS0FBaEI7QUFDQWhWLE1BQUUsQ0FBQ2lWLFlBQUgsR0FBa0IsS0FBbEI7QUFDQWpWLE1BQUUsQ0FBQ2tWLGlCQUFILEdBQXVCLEtBQXZCO0FBQ0Q7O0FBRUQsV0FBU0MsY0FBVCxDQUF5QnpCLEdBQXpCLEVBQThCO0FBQzVCQSxPQUFHLENBQUM5ZSxTQUFKLENBQWN3Z0IsT0FBZCxHQUF3QixVQUFVaFIsS0FBVixFQUFpQmlSLFNBQWpCLEVBQTRCO0FBQ2xELFVBQUlyVixFQUFFLEdBQUcsSUFBVDs7QUFDQSxVQUFJQSxFQUFFLENBQUNnVixVQUFQLEVBQW1CO0FBQ2pCTSxnQkFBUSxDQUFDdFYsRUFBRCxFQUFLLGNBQUwsQ0FBUjtBQUNEOztBQUNELFVBQUl1VixNQUFNLEdBQUd2VixFQUFFLENBQUN3VixHQUFoQjtBQUNBLFVBQUlDLFNBQVMsR0FBR3pWLEVBQUUsQ0FBQzBWLE1BQW5CO0FBQ0EsVUFBSUMsa0JBQWtCLEdBQUdwQixjQUF6QjtBQUNBQSxvQkFBYyxHQUFHdlUsRUFBakI7QUFDQUEsUUFBRSxDQUFDMFYsTUFBSCxHQUFZdFIsS0FBWixDQVRrRCxDQVVsRDtBQUNBOztBQUNBLFVBQUksQ0FBQ3FSLFNBQUwsRUFBZ0I7QUFDZDtBQUNBelYsVUFBRSxDQUFDd1YsR0FBSCxHQUFTeFYsRUFBRSxDQUFDNFYsU0FBSCxDQUNQNVYsRUFBRSxDQUFDd1YsR0FESSxFQUNDcFIsS0FERCxFQUNRaVIsU0FEUixFQUNtQjtBQUFNO0FBRHpCLFVBRVByVixFQUFFLENBQUNRLFFBQUgsQ0FBWXFWLFVBRkwsRUFHUDdWLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZc1YsT0FITCxDQUFULENBRmMsQ0FPZDtBQUNBOztBQUNBOVYsVUFBRSxDQUFDUSxRQUFILENBQVlxVixVQUFaLEdBQXlCN1YsRUFBRSxDQUFDUSxRQUFILENBQVlzVixPQUFaLEdBQXNCLElBQS9DO0FBQ0QsT0FWRCxNQVVPO0FBQ0w7QUFDQTlWLFVBQUUsQ0FBQ3dWLEdBQUgsR0FBU3hWLEVBQUUsQ0FBQzRWLFNBQUgsQ0FBYUgsU0FBYixFQUF3QnJSLEtBQXhCLENBQVQ7QUFDRDs7QUFDRG1RLG9CQUFjLEdBQUdvQixrQkFBakIsQ0ExQmtELENBMkJsRDs7QUFDQSxVQUFJSixNQUFKLEVBQVk7QUFDVkEsY0FBTSxDQUFDUSxPQUFQLEdBQWlCLElBQWpCO0FBQ0Q7O0FBQ0QsVUFBSS9WLEVBQUUsQ0FBQ3dWLEdBQVAsRUFBWTtBQUNWeFYsVUFBRSxDQUFDd1YsR0FBSCxDQUFPTyxPQUFQLEdBQWlCL1YsRUFBakI7QUFDRCxPQWpDaUQsQ0FrQ2xEOzs7QUFDQSxVQUFJQSxFQUFFLENBQUNnVyxNQUFILElBQWFoVyxFQUFFLENBQUNnQixPQUFoQixJQUEyQmhCLEVBQUUsQ0FBQ2dXLE1BQUgsS0FBY2hXLEVBQUUsQ0FBQ2dCLE9BQUgsQ0FBVzBVLE1BQXhELEVBQWdFO0FBQzlEMVYsVUFBRSxDQUFDZ0IsT0FBSCxDQUFXd1UsR0FBWCxHQUFpQnhWLEVBQUUsQ0FBQ3dWLEdBQXBCO0FBQ0QsT0FyQ2lELENBc0NsRDtBQUNBOztBQUNELEtBeENEOztBQTBDQTlCLE9BQUcsQ0FBQzllLFNBQUosQ0FBYzJkLFlBQWQsR0FBNkIsWUFBWTtBQUN2QyxVQUFJdlMsRUFBRSxHQUFHLElBQVQ7O0FBQ0EsVUFBSUEsRUFBRSxDQUFDNlUsUUFBUCxFQUFpQjtBQUNmN1UsVUFBRSxDQUFDNlUsUUFBSCxDQUFZN1MsTUFBWjtBQUNEO0FBQ0YsS0FMRDs7QUFPQTBSLE9BQUcsQ0FBQzllLFNBQUosQ0FBY3FoQixRQUFkLEdBQXlCLFlBQVk7QUFDbkMsVUFBSWpXLEVBQUUsR0FBRyxJQUFUOztBQUNBLFVBQUlBLEVBQUUsQ0FBQ2tWLGlCQUFQLEVBQTBCO0FBQ3hCO0FBQ0Q7O0FBQ0RJLGNBQVEsQ0FBQ3RWLEVBQUQsRUFBSyxlQUFMLENBQVI7QUFDQUEsUUFBRSxDQUFDa1YsaUJBQUgsR0FBdUIsSUFBdkIsQ0FObUMsQ0FPbkM7O0FBQ0EsVUFBSTlSLE1BQU0sR0FBR3BELEVBQUUsQ0FBQ2dCLE9BQWhCOztBQUNBLFVBQUlvQyxNQUFNLElBQUksQ0FBQ0EsTUFBTSxDQUFDOFIsaUJBQWxCLElBQXVDLENBQUNsVixFQUFFLENBQUNRLFFBQUgsQ0FBWWtVLFFBQXhELEVBQWtFO0FBQ2hFL2QsY0FBTSxDQUFDeU0sTUFBTSxDQUFDdVIsU0FBUixFQUFtQjNVLEVBQW5CLENBQU47QUFDRCxPQVhrQyxDQVluQzs7O0FBQ0EsVUFBSUEsRUFBRSxDQUFDNlUsUUFBUCxFQUFpQjtBQUNmN1UsVUFBRSxDQUFDNlUsUUFBSCxDQUFZcUIsUUFBWjtBQUNEOztBQUNELFVBQUk1ZixDQUFDLEdBQUcwSixFQUFFLENBQUNtVyxTQUFILENBQWE1ZixNQUFyQjs7QUFDQSxhQUFPRCxDQUFDLEVBQVIsRUFBWTtBQUNWMEosVUFBRSxDQUFDbVcsU0FBSCxDQUFhN2YsQ0FBYixFQUFnQjRmLFFBQWhCO0FBQ0QsT0FuQmtDLENBb0JuQztBQUNBOzs7QUFDQSxVQUFJbFcsRUFBRSxDQUFDb1csS0FBSCxDQUFTblIsTUFBYixFQUFxQjtBQUNuQmpGLFVBQUUsQ0FBQ29XLEtBQUgsQ0FBU25SLE1BQVQsQ0FBZ0JTLE9BQWhCO0FBQ0QsT0F4QmtDLENBeUJuQzs7O0FBQ0ExRixRQUFFLENBQUNpVixZQUFILEdBQWtCLElBQWxCLENBMUJtQyxDQTJCbkM7O0FBQ0FqVixRQUFFLENBQUM0VixTQUFILENBQWE1VixFQUFFLENBQUMwVixNQUFoQixFQUF3QixJQUF4QixFQTVCbUMsQ0E2Qm5DOzs7QUFDQUosY0FBUSxDQUFDdFYsRUFBRCxFQUFLLFdBQUwsQ0FBUixDQTlCbUMsQ0ErQm5DOztBQUNBQSxRQUFFLENBQUN1VCxJQUFILEdBaENtQyxDQWlDbkM7O0FBQ0EsVUFBSXZULEVBQUUsQ0FBQ3dWLEdBQVAsRUFBWTtBQUNWeFYsVUFBRSxDQUFDd1YsR0FBSCxDQUFPTyxPQUFQLEdBQWlCLElBQWpCO0FBQ0QsT0FwQ2tDLENBcUNuQzs7O0FBQ0EsVUFBSS9WLEVBQUUsQ0FBQ2dXLE1BQVAsRUFBZTtBQUNiaFcsVUFBRSxDQUFDZ1csTUFBSCxDQUFVNVMsTUFBVixHQUFtQixJQUFuQjtBQUNEO0FBQ0YsS0F6Q0Q7QUEwQ0Q7O0FBRUQsV0FBU2lULGNBQVQsQ0FDRXJXLEVBREYsRUFFRW9ILEVBRkYsRUFHRWlPLFNBSEYsRUFJRTtBQUNBclYsTUFBRSxDQUFDd1YsR0FBSCxHQUFTcE8sRUFBVDs7QUFDQSxRQUFJLENBQUNwSCxFQUFFLENBQUNRLFFBQUgsQ0FBWW9PLE1BQWpCLEVBQXlCO0FBQ3ZCNU8sUUFBRSxDQUFDUSxRQUFILENBQVlvTyxNQUFaLEdBQXFCNUssZ0JBQXJCO0FBQ0E7QUFDRTtBQUNBLFlBQUtoRSxFQUFFLENBQUNRLFFBQUgsQ0FBWThWLFFBQVosSUFBd0J0VyxFQUFFLENBQUNRLFFBQUgsQ0FBWThWLFFBQVosQ0FBcUJ0ZSxNQUFyQixDQUE0QixDQUE1QixNQUFtQyxHQUE1RCxJQUNGZ0ksRUFBRSxDQUFDUSxRQUFILENBQVk0RyxFQURWLElBQ2dCQSxFQURwQixFQUN3QjtBQUN0QjdILGNBQUksQ0FDRixvRUFDQSxtRUFEQSxHQUVBLHVEQUhFLEVBSUZTLEVBSkUsQ0FBSjtBQU1ELFNBUkQsTUFRTztBQUNMVCxjQUFJLENBQ0YscUVBREUsRUFFRlMsRUFGRSxDQUFKO0FBSUQ7QUFDRjtBQUNGOztBQUNEc1YsWUFBUSxDQUFDdFYsRUFBRCxFQUFLLGFBQUwsQ0FBUjtBQUVBLFFBQUl1VyxlQUFKO0FBQ0E7O0FBQ0EsUUFBSSxrQkFBa0IsWUFBbEIsSUFBa0NwYixNQUFNLENBQUNLLFdBQXpDLElBQXdEbVMsSUFBNUQsRUFBa0U7QUFDaEU0SSxxQkFBZSxHQUFHLFlBQVk7QUFDNUIsWUFBSTdWLElBQUksR0FBR1YsRUFBRSxDQUFDd1csS0FBZDtBQUNBLFlBQUlqVixFQUFFLEdBQUd2QixFQUFFLENBQUN5VyxJQUFaO0FBQ0EsWUFBSXpJLFFBQVEsR0FBRyxvQkFBb0J6TSxFQUFuQztBQUNBLFlBQUkwTSxNQUFNLEdBQUcsa0JBQWtCMU0sRUFBL0I7QUFFQW9NLFlBQUksQ0FBQ0ssUUFBRCxDQUFKOztBQUNBLFlBQUk1SixLQUFLLEdBQUdwRSxFQUFFLENBQUMwVyxPQUFILEVBQVo7O0FBQ0EvSSxZQUFJLENBQUNNLE1BQUQsQ0FBSjtBQUNBTCxlQUFPLENBQUUsU0FBU2xOLElBQVQsR0FBZ0IsU0FBbEIsRUFBOEJzTixRQUE5QixFQUF3Q0MsTUFBeEMsQ0FBUDtBQUVBTixZQUFJLENBQUNLLFFBQUQsQ0FBSjs7QUFDQWhPLFVBQUUsQ0FBQ29WLE9BQUgsQ0FBV2hSLEtBQVgsRUFBa0JpUixTQUFsQjs7QUFDQTFILFlBQUksQ0FBQ00sTUFBRCxDQUFKO0FBQ0FMLGVBQU8sQ0FBRSxTQUFTbE4sSUFBVCxHQUFnQixRQUFsQixFQUE2QnNOLFFBQTdCLEVBQXVDQyxNQUF2QyxDQUFQO0FBQ0QsT0FmRDtBQWdCRCxLQWpCRCxNQWlCTztBQUNMc0kscUJBQWUsR0FBRyxZQUFZO0FBQzVCdlcsVUFBRSxDQUFDb1YsT0FBSCxDQUFXcFYsRUFBRSxDQUFDMFcsT0FBSCxFQUFYLEVBQXlCckIsU0FBekI7QUFDRCxPQUZEO0FBR0QsS0EvQ0QsQ0FpREE7QUFDQTtBQUNBOzs7QUFDQSxRQUFJc0IsT0FBSixDQUFZM1csRUFBWixFQUFnQnVXLGVBQWhCLEVBQWlDaGQsSUFBakMsRUFBdUMsSUFBdkMsRUFBNkM7QUFBSztBQUFsRDtBQUNBOGIsYUFBUyxHQUFHLEtBQVosQ0FyREEsQ0F1REE7QUFDQTs7QUFDQSxRQUFJclYsRUFBRSxDQUFDZ1csTUFBSCxJQUFhLElBQWpCLEVBQXVCO0FBQ3JCaFcsUUFBRSxDQUFDZ1YsVUFBSCxHQUFnQixJQUFoQjtBQUNBTSxjQUFRLENBQUN0VixFQUFELEVBQUssU0FBTCxDQUFSO0FBQ0Q7O0FBQ0QsV0FBT0EsRUFBUDtBQUNEOztBQUVELFdBQVM0VyxvQkFBVCxDQUNFNVcsRUFERixFQUVFcUgsU0FGRixFQUdFNEwsU0FIRixFQUlFNEQsV0FKRixFQUtFQyxjQUxGLEVBTUU7QUFDQTtBQUNFdEMsOEJBQXdCLEdBQUcsSUFBM0I7QUFDRCxLQUhELENBS0E7QUFDQTs7QUFDQSxRQUFJdUMsV0FBVyxHQUFHLENBQUMsRUFDakJELGNBQWMsSUFBa0I7QUFDaEM5VyxNQUFFLENBQUNRLFFBQUgsQ0FBWXdXLGVBRFosSUFDZ0M7QUFDaENILGVBQVcsQ0FBQ3JVLElBQVosQ0FBaUJ5VSxXQUZqQixJQUVnQztBQUNoQ2pYLE1BQUUsQ0FBQ2tYLFlBQUgsS0FBb0JwakIsV0FKSCxDQUllO0FBSmYsS0FBbkI7QUFPQWtNLE1BQUUsQ0FBQ1EsUUFBSCxDQUFZMlcsWUFBWixHQUEyQk4sV0FBM0I7QUFDQTdXLE1BQUUsQ0FBQ2dXLE1BQUgsR0FBWWEsV0FBWixDQWZBLENBZXlCOztBQUV6QixRQUFJN1csRUFBRSxDQUFDMFYsTUFBUCxFQUFlO0FBQUU7QUFDZjFWLFFBQUUsQ0FBQzBWLE1BQUgsQ0FBVXRTLE1BQVYsR0FBbUJ5VCxXQUFuQjtBQUNEOztBQUNEN1csTUFBRSxDQUFDUSxRQUFILENBQVl3VyxlQUFaLEdBQThCRixjQUE5QixDQXBCQSxDQXNCQTtBQUNBO0FBQ0E7O0FBQ0E5VyxNQUFFLENBQUNvWCxNQUFILEdBQVlQLFdBQVcsQ0FBQ3JVLElBQVosQ0FBaUJrTyxLQUFqQixJQUEwQjVjLFdBQXRDO0FBQ0FrTSxNQUFFLENBQUNxWCxVQUFILEdBQWdCcEUsU0FBUyxJQUFJbmYsV0FBN0IsQ0ExQkEsQ0E0QkE7O0FBQ0EsUUFBSXVULFNBQVMsSUFBSXJILEVBQUUsQ0FBQ1EsUUFBSCxDQUFZZ0ksS0FBN0IsRUFBb0M7QUFDbENoRCxxQkFBZSxDQUFDLEtBQUQsQ0FBZjtBQUNBLFVBQUlnRCxLQUFLLEdBQUd4SSxFQUFFLENBQUM2SyxNQUFmO0FBQ0EsVUFBSXlNLFFBQVEsR0FBR3RYLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZK1csU0FBWixJQUF5QixFQUF4Qzs7QUFDQSxXQUFLLElBQUlqaEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2doQixRQUFRLENBQUMvZ0IsTUFBN0IsRUFBcUNELENBQUMsRUFBdEMsRUFBMEM7QUFDeEMsWUFBSWEsR0FBRyxHQUFHbWdCLFFBQVEsQ0FBQ2hoQixDQUFELENBQWxCO0FBQ0EsWUFBSTRULFdBQVcsR0FBR2xLLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZZ0ksS0FBOUIsQ0FGd0MsQ0FFSDs7QUFDckNBLGFBQUssQ0FBQ3JSLEdBQUQsQ0FBTCxHQUFhOFMsWUFBWSxDQUFDOVMsR0FBRCxFQUFNK1MsV0FBTixFQUFtQjdDLFNBQW5CLEVBQThCckgsRUFBOUIsQ0FBekI7QUFDRDs7QUFDRHdGLHFCQUFlLENBQUMsSUFBRCxDQUFmLENBVGtDLENBVWxDOztBQUNBeEYsUUFBRSxDQUFDUSxRQUFILENBQVk2RyxTQUFaLEdBQXdCQSxTQUF4QjtBQUNELEtBekNELENBMkNBOzs7QUFDQTRMLGFBQVMsR0FBR0EsU0FBUyxJQUFJbmYsV0FBekI7QUFDQSxRQUFJMGYsWUFBWSxHQUFHeFQsRUFBRSxDQUFDUSxRQUFILENBQVkwUyxnQkFBL0I7QUFDQWxULE1BQUUsQ0FBQ1EsUUFBSCxDQUFZMFMsZ0JBQVosR0FBK0JELFNBQS9CO0FBQ0FFLDRCQUF3QixDQUFDblQsRUFBRCxFQUFLaVQsU0FBTCxFQUFnQk8sWUFBaEIsQ0FBeEIsQ0EvQ0EsQ0FpREE7O0FBQ0EsUUFBSXVELFdBQUosRUFBaUI7QUFDZi9XLFFBQUUsQ0FBQ3dYLE1BQUgsR0FBWXZELFlBQVksQ0FBQzZDLGNBQUQsRUFBaUJELFdBQVcsQ0FBQ2pVLE9BQTdCLENBQXhCO0FBQ0E1QyxRQUFFLENBQUN1UyxZQUFIO0FBQ0Q7O0FBRUQ7QUFDRWlDLDhCQUF3QixHQUFHLEtBQTNCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTaUQsZ0JBQVQsQ0FBMkJ6WCxFQUEzQixFQUErQjtBQUM3QixXQUFPQSxFQUFFLEtBQUtBLEVBQUUsR0FBR0EsRUFBRSxDQUFDZ0IsT0FBYixDQUFULEVBQWdDO0FBQzlCLFVBQUloQixFQUFFLENBQUM4VSxTQUFQLEVBQWtCO0FBQUUsZUFBTyxJQUFQO0FBQWE7QUFDbEM7O0FBQ0QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsV0FBUzRDLHNCQUFULENBQWlDMVgsRUFBakMsRUFBcUMyWCxNQUFyQyxFQUE2QztBQUMzQyxRQUFJQSxNQUFKLEVBQVk7QUFDVjNYLFFBQUUsQ0FBQytVLGVBQUgsR0FBcUIsS0FBckI7O0FBQ0EsVUFBSTBDLGdCQUFnQixDQUFDelgsRUFBRCxDQUFwQixFQUEwQjtBQUN4QjtBQUNEO0FBQ0YsS0FMRCxNQUtPLElBQUlBLEVBQUUsQ0FBQytVLGVBQVAsRUFBd0I7QUFDN0I7QUFDRDs7QUFDRCxRQUFJL1UsRUFBRSxDQUFDOFUsU0FBSCxJQUFnQjlVLEVBQUUsQ0FBQzhVLFNBQUgsS0FBaUIsSUFBckMsRUFBMkM7QUFDekM5VSxRQUFFLENBQUM4VSxTQUFILEdBQWUsS0FBZjs7QUFDQSxXQUFLLElBQUl4ZSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMEosRUFBRSxDQUFDMlUsU0FBSCxDQUFhcGUsTUFBakMsRUFBeUNELENBQUMsRUFBMUMsRUFBOEM7QUFDNUNvaEIsOEJBQXNCLENBQUMxWCxFQUFFLENBQUMyVSxTQUFILENBQWFyZSxDQUFiLENBQUQsQ0FBdEI7QUFDRDs7QUFDRGdmLGNBQVEsQ0FBQ3RWLEVBQUQsRUFBSyxXQUFMLENBQVI7QUFDRDtBQUNGOztBQUVELFdBQVM0WCx3QkFBVCxDQUFtQzVYLEVBQW5DLEVBQXVDMlgsTUFBdkMsRUFBK0M7QUFDN0MsUUFBSUEsTUFBSixFQUFZO0FBQ1YzWCxRQUFFLENBQUMrVSxlQUFILEdBQXFCLElBQXJCOztBQUNBLFVBQUkwQyxnQkFBZ0IsQ0FBQ3pYLEVBQUQsQ0FBcEIsRUFBMEI7QUFDeEI7QUFDRDtBQUNGOztBQUNELFFBQUksQ0FBQ0EsRUFBRSxDQUFDOFUsU0FBUixFQUFtQjtBQUNqQjlVLFFBQUUsQ0FBQzhVLFNBQUgsR0FBZSxJQUFmOztBQUNBLFdBQUssSUFBSXhlLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwSixFQUFFLENBQUMyVSxTQUFILENBQWFwZSxNQUFqQyxFQUF5Q0QsQ0FBQyxFQUExQyxFQUE4QztBQUM1Q3NoQixnQ0FBd0IsQ0FBQzVYLEVBQUUsQ0FBQzJVLFNBQUgsQ0FBYXJlLENBQWIsQ0FBRCxDQUF4QjtBQUNEOztBQUNEZ2YsY0FBUSxDQUFDdFYsRUFBRCxFQUFLLGFBQUwsQ0FBUjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU3NWLFFBQVQsQ0FBbUJ0VixFQUFuQixFQUF1Qm1JLElBQXZCLEVBQTZCO0FBQzNCO0FBQ0FqRyxjQUFVO0FBQ1YsUUFBSXlNLFFBQVEsR0FBRzNPLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZMkgsSUFBWixDQUFmOztBQUNBLFFBQUl3RyxRQUFKLEVBQWM7QUFDWixXQUFLLElBQUlyWSxDQUFDLEdBQUcsQ0FBUixFQUFXdWhCLENBQUMsR0FBR2xKLFFBQVEsQ0FBQ3BZLE1BQTdCLEVBQXFDRCxDQUFDLEdBQUd1aEIsQ0FBekMsRUFBNEN2aEIsQ0FBQyxFQUE3QyxFQUFpRDtBQUMvQyxZQUFJO0FBQ0ZxWSxrQkFBUSxDQUFDclksQ0FBRCxDQUFSLENBQVl2QixJQUFaLENBQWlCaUwsRUFBakI7QUFDRCxTQUZELENBRUUsT0FBT3RGLENBQVAsRUFBVTtBQUNWK1EscUJBQVcsQ0FBQy9RLENBQUQsRUFBSXNGLEVBQUosRUFBU21JLElBQUksR0FBRyxPQUFoQixDQUFYO0FBQ0Q7QUFDRjtBQUNGOztBQUNELFFBQUluSSxFQUFFLENBQUNnVCxhQUFQLEVBQXNCO0FBQ3BCaFQsUUFBRSxDQUFDK1QsS0FBSCxDQUFTLFVBQVU1TCxJQUFuQjtBQUNEOztBQUNEL0YsYUFBUztBQUNWO0FBRUQ7OztBQUdBLE1BQUkwVixnQkFBZ0IsR0FBRyxHQUF2QjtBQUVBLE1BQUlDLEtBQUssR0FBRyxFQUFaO0FBQ0EsTUFBSUMsaUJBQWlCLEdBQUcsRUFBeEI7QUFDQSxNQUFJNVksR0FBRyxHQUFHLEVBQVY7QUFDQSxNQUFJNlksUUFBUSxHQUFHLEVBQWY7QUFDQSxNQUFJQyxPQUFPLEdBQUcsS0FBZDtBQUNBLE1BQUlDLFFBQVEsR0FBRyxLQUFmO0FBQ0EsTUFBSXJoQixLQUFLLEdBQUcsQ0FBWjtBQUVBOzs7O0FBR0EsV0FBU3NoQixtQkFBVCxHQUFnQztBQUM5QnRoQixTQUFLLEdBQUdpaEIsS0FBSyxDQUFDeGhCLE1BQU4sR0FBZXloQixpQkFBaUIsQ0FBQ3poQixNQUFsQixHQUEyQixDQUFsRDtBQUNBNkksT0FBRyxHQUFHLEVBQU47QUFDQTtBQUNFNlksY0FBUSxHQUFHLEVBQVg7QUFDRDtBQUNEQyxXQUFPLEdBQUdDLFFBQVEsR0FBRyxLQUFyQjtBQUNEO0FBRUQ7Ozs7O0FBR0EsV0FBU0UsbUJBQVQsR0FBZ0M7QUFDOUJGLFlBQVEsR0FBRyxJQUFYO0FBQ0EsUUFBSUcsT0FBSixFQUFhL1csRUFBYixDQUY4QixDQUk5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBd1csU0FBSyxDQUFDUSxJQUFOLENBQVcsVUFBVWpnQixDQUFWLEVBQWFrQixDQUFiLEVBQWdCO0FBQUUsYUFBT2xCLENBQUMsQ0FBQ2lKLEVBQUYsR0FBTy9ILENBQUMsQ0FBQytILEVBQWhCO0FBQXFCLEtBQWxELEVBWjhCLENBYzlCO0FBQ0E7O0FBQ0EsU0FBS3pLLEtBQUssR0FBRyxDQUFiLEVBQWdCQSxLQUFLLEdBQUdpaEIsS0FBSyxDQUFDeGhCLE1BQTlCLEVBQXNDTyxLQUFLLEVBQTNDLEVBQStDO0FBQzdDd2hCLGFBQU8sR0FBR1AsS0FBSyxDQUFDamhCLEtBQUQsQ0FBZjtBQUNBeUssUUFBRSxHQUFHK1csT0FBTyxDQUFDL1csRUFBYjtBQUNBbkMsU0FBRyxDQUFDbUMsRUFBRCxDQUFILEdBQVUsSUFBVjtBQUNBK1csYUFBTyxDQUFDRSxHQUFSLEdBSjZDLENBSzdDOztBQUNBLFVBQUksa0JBQWtCLFlBQWxCLElBQWtDcFosR0FBRyxDQUFDbUMsRUFBRCxDQUFILElBQVcsSUFBakQsRUFBdUQ7QUFDckQwVyxnQkFBUSxDQUFDMVcsRUFBRCxDQUFSLEdBQWUsQ0FBQzBXLFFBQVEsQ0FBQzFXLEVBQUQsQ0FBUixJQUFnQixDQUFqQixJQUFzQixDQUFyQzs7QUFDQSxZQUFJMFcsUUFBUSxDQUFDMVcsRUFBRCxDQUFSLEdBQWV1VyxnQkFBbkIsRUFBcUM7QUFDbkN2WSxjQUFJLENBQ0YsMkNBQ0UrWSxPQUFPLENBQUNHLElBQVIsR0FDSyxrQ0FBbUNILE9BQU8sQ0FBQ0ksVUFBM0MsR0FBeUQsSUFEOUQsR0FFSSxpQ0FITixDQURFLEVBTUZKLE9BQU8sQ0FBQ3RZLEVBTk4sQ0FBSjtBQVFBO0FBQ0Q7QUFDRjtBQUNGLEtBcEM2QixDQXNDOUI7OztBQUNBLFFBQUkyWSxjQUFjLEdBQUdYLGlCQUFpQixDQUFDaGpCLEtBQWxCLEVBQXJCO0FBQ0EsUUFBSTRqQixZQUFZLEdBQUdiLEtBQUssQ0FBQy9pQixLQUFOLEVBQW5CO0FBRUFvakIsdUJBQW1CLEdBMUNXLENBNEM5Qjs7QUFDQVMsc0JBQWtCLENBQUNGLGNBQUQsQ0FBbEI7QUFDQUcsb0JBQWdCLENBQUNGLFlBQUQsQ0FBaEIsQ0E5QzhCLENBZ0Q5Qjs7QUFDQTs7QUFDQSxRQUFJcmQsUUFBUSxJQUFJSixNQUFNLENBQUNJLFFBQXZCLEVBQWlDO0FBQy9CQSxjQUFRLENBQUN3ZCxJQUFULENBQWMsT0FBZDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU0QsZ0JBQVQsQ0FBMkJmLEtBQTNCLEVBQWtDO0FBQ2hDLFFBQUl6aEIsQ0FBQyxHQUFHeWhCLEtBQUssQ0FBQ3hoQixNQUFkOztBQUNBLFdBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YsVUFBSWdpQixPQUFPLEdBQUdQLEtBQUssQ0FBQ3poQixDQUFELENBQW5CO0FBQ0EsVUFBSTBKLEVBQUUsR0FBR3NZLE9BQU8sQ0FBQ3RZLEVBQWpCOztBQUNBLFVBQUlBLEVBQUUsQ0FBQzZVLFFBQUgsS0FBZ0J5RCxPQUFoQixJQUEyQnRZLEVBQUUsQ0FBQ2dWLFVBQWxDLEVBQThDO0FBQzVDTSxnQkFBUSxDQUFDdFYsRUFBRCxFQUFLLFNBQUwsQ0FBUjtBQUNEO0FBQ0Y7QUFDRjtBQUVEOzs7Ozs7QUFJQSxXQUFTZ1osdUJBQVQsQ0FBa0NoWixFQUFsQyxFQUFzQztBQUNwQztBQUNBO0FBQ0FBLE1BQUUsQ0FBQzhVLFNBQUgsR0FBZSxLQUFmO0FBQ0FrRCxxQkFBaUIsQ0FBQzVXLElBQWxCLENBQXVCcEIsRUFBdkI7QUFDRDs7QUFFRCxXQUFTNlksa0JBQVQsQ0FBNkJkLEtBQTdCLEVBQW9DO0FBQ2xDLFNBQUssSUFBSXpoQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeWhCLEtBQUssQ0FBQ3hoQixNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQ3loQixXQUFLLENBQUN6aEIsQ0FBRCxDQUFMLENBQVN3ZSxTQUFULEdBQXFCLElBQXJCO0FBQ0E0Qyw0QkFBc0IsQ0FBQ0ssS0FBSyxDQUFDemhCLENBQUQsQ0FBTixFQUFXO0FBQUs7QUFBaEIsT0FBdEI7QUFDRDtBQUNGO0FBRUQ7Ozs7Ozs7QUFLQSxXQUFTMmlCLFlBQVQsQ0FBdUJYLE9BQXZCLEVBQWdDO0FBQzlCLFFBQUkvVyxFQUFFLEdBQUcrVyxPQUFPLENBQUMvVyxFQUFqQjs7QUFDQSxRQUFJbkMsR0FBRyxDQUFDbUMsRUFBRCxDQUFILElBQVcsSUFBZixFQUFxQjtBQUNuQm5DLFNBQUcsQ0FBQ21DLEVBQUQsQ0FBSCxHQUFVLElBQVY7O0FBQ0EsVUFBSSxDQUFDNFcsUUFBTCxFQUFlO0FBQ2JKLGFBQUssQ0FBQzNXLElBQU4sQ0FBV2tYLE9BQVg7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBO0FBQ0EsWUFBSWhpQixDQUFDLEdBQUd5aEIsS0FBSyxDQUFDeGhCLE1BQU4sR0FBZSxDQUF2Qjs7QUFDQSxlQUFPRCxDQUFDLEdBQUdRLEtBQUosSUFBYWloQixLQUFLLENBQUN6aEIsQ0FBRCxDQUFMLENBQVNpTCxFQUFULEdBQWMrVyxPQUFPLENBQUMvVyxFQUExQyxFQUE4QztBQUM1Q2pMLFdBQUM7QUFDRjs7QUFDRHloQixhQUFLLENBQUMvZ0IsTUFBTixDQUFhVixDQUFDLEdBQUcsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUJnaUIsT0FBdkI7QUFDRCxPQVprQixDQWFuQjs7O0FBQ0EsVUFBSSxDQUFDSixPQUFMLEVBQWM7QUFDWkEsZUFBTyxHQUFHLElBQVY7QUFDQTFLLGdCQUFRLENBQUM2SyxtQkFBRCxDQUFSO0FBQ0Q7QUFDRjtBQUNGO0FBRUQ7OztBQUVBLE1BQUlhLEtBQUssR0FBRyxDQUFaO0FBRUE7Ozs7OztBQUtBLE1BQUl2QyxPQUFPLEdBQUcsU0FBU0EsT0FBVCxDQUNaM1csRUFEWSxFQUVabVosT0FGWSxFQUdaMUwsRUFIWSxFQUlacE4sT0FKWSxFQUtaK1ksZUFMWSxFQU1aO0FBQ0EsU0FBS3BaLEVBQUwsR0FBVUEsRUFBVjs7QUFDQSxRQUFJb1osZUFBSixFQUFxQjtBQUNuQnBaLFFBQUUsQ0FBQzZVLFFBQUgsR0FBYyxJQUFkO0FBQ0Q7O0FBQ0Q3VSxNQUFFLENBQUNtVyxTQUFILENBQWEvVSxJQUFiLENBQWtCLElBQWxCLEVBTEEsQ0FNQTs7O0FBQ0EsUUFBSWYsT0FBSixFQUFhO0FBQ1gsV0FBS2daLElBQUwsR0FBWSxDQUFDLENBQUNoWixPQUFPLENBQUNnWixJQUF0QjtBQUNBLFdBQUtaLElBQUwsR0FBWSxDQUFDLENBQUNwWSxPQUFPLENBQUNvWSxJQUF0QjtBQUNBLFdBQUthLElBQUwsR0FBWSxDQUFDLENBQUNqWixPQUFPLENBQUNpWixJQUF0QjtBQUNBLFdBQUtqSCxJQUFMLEdBQVksQ0FBQyxDQUFDaFMsT0FBTyxDQUFDZ1MsSUFBdEI7QUFDRCxLQUxELE1BS087QUFDTCxXQUFLZ0gsSUFBTCxHQUFZLEtBQUtaLElBQUwsR0FBWSxLQUFLYSxJQUFMLEdBQVksS0FBS2pILElBQUwsR0FBWSxLQUFoRDtBQUNEOztBQUNELFNBQUs1RSxFQUFMLEdBQVVBLEVBQVY7QUFDQSxTQUFLbE0sRUFBTCxHQUFVLEVBQUUyWCxLQUFaLENBaEJBLENBZ0JtQjs7QUFDbkIsU0FBS0ssTUFBTCxHQUFjLElBQWQ7QUFDQSxTQUFLQyxLQUFMLEdBQWEsS0FBS0YsSUFBbEIsQ0FsQkEsQ0FrQndCOztBQUN4QixTQUFLRyxJQUFMLEdBQVksRUFBWjtBQUNBLFNBQUtDLE9BQUwsR0FBZSxFQUFmO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLElBQUkxYSxJQUFKLEVBQWQ7QUFDQSxTQUFLMmEsU0FBTCxHQUFpQixJQUFJM2EsSUFBSixFQUFqQjtBQUNBLFNBQUt5WixVQUFMLEdBQWtCUyxPQUFPLENBQUN0a0IsUUFBUixFQUFsQixDQXZCQSxDQXdCQTs7QUFDQSxRQUFJLE9BQU9za0IsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQyxXQUFLelMsTUFBTCxHQUFjeVMsT0FBZDtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUt6UyxNQUFMLEdBQWM5SixTQUFTLENBQUN1YyxPQUFELENBQXZCOztBQUNBLFVBQUksQ0FBQyxLQUFLelMsTUFBVixFQUFrQjtBQUNoQixhQUFLQSxNQUFMLEdBQWMsWUFBWSxDQUFFLENBQTVCOztBQUNBLDBCQUFrQixZQUFsQixJQUFrQ25ILElBQUksQ0FDcEMsNkJBQTZCNFosT0FBN0IsR0FBdUMsS0FBdkMsR0FDQSxtREFEQSxHQUVBLDJDQUhvQyxFQUlwQ25aLEVBSm9DLENBQXRDO0FBTUQ7QUFDRjs7QUFDRCxTQUFLeEwsS0FBTCxHQUFhLEtBQUs4a0IsSUFBTCxHQUNUbmxCLFNBRFMsR0FFVCxLQUFLaUssR0FBTCxFQUZKO0FBR0QsR0FoREQ7QUFrREE7Ozs7O0FBR0F1WSxTQUFPLENBQUMvaEIsU0FBUixDQUFrQndKLEdBQWxCLEdBQXdCLFNBQVNBLEdBQVQsR0FBZ0I7QUFDdEM4RCxjQUFVLENBQUMsSUFBRCxDQUFWO0FBQ0EsUUFBSTFOLEtBQUo7QUFDQSxRQUFJd0wsRUFBRSxHQUFHLEtBQUtBLEVBQWQ7O0FBQ0EsUUFBSTtBQUNGeEwsV0FBSyxHQUFHLEtBQUtrUyxNQUFMLENBQVkzUixJQUFaLENBQWlCaUwsRUFBakIsRUFBcUJBLEVBQXJCLENBQVI7QUFDRCxLQUZELENBRUUsT0FBT3RGLENBQVAsRUFBVTtBQUNWLFVBQUksS0FBSytkLElBQVQsRUFBZTtBQUNiaE4sbUJBQVcsQ0FBQy9RLENBQUQsRUFBSXNGLEVBQUosRUFBUywwQkFBMkIsS0FBSzBZLFVBQWhDLEdBQThDLElBQXZELENBQVg7QUFDRCxPQUZELE1BRU87QUFDTCxjQUFNaGUsQ0FBTjtBQUNEO0FBQ0YsS0FSRCxTQVFVO0FBQ1I7QUFDQTtBQUNBLFVBQUksS0FBSzJlLElBQVQsRUFBZTtBQUNickssZ0JBQVEsQ0FBQ3hhLEtBQUQsQ0FBUjtBQUNEOztBQUNENE4sZUFBUztBQUNULFdBQUt5WCxXQUFMO0FBQ0Q7O0FBQ0QsV0FBT3JsQixLQUFQO0FBQ0QsR0F0QkQ7QUF3QkE7Ozs7O0FBR0FtaUIsU0FBTyxDQUFDL2hCLFNBQVIsQ0FBa0JrTixNQUFsQixHQUEyQixTQUFTQSxNQUFULENBQWlCc0QsR0FBakIsRUFBc0I7QUFDL0MsUUFBSTdELEVBQUUsR0FBRzZELEdBQUcsQ0FBQzdELEVBQWI7O0FBQ0EsUUFBSSxDQUFDLEtBQUtxWSxTQUFMLENBQWV4YSxHQUFmLENBQW1CbUMsRUFBbkIsQ0FBTCxFQUE2QjtBQUMzQixXQUFLcVksU0FBTCxDQUFldmEsR0FBZixDQUFtQmtDLEVBQW5CO0FBQ0EsV0FBS21ZLE9BQUwsQ0FBYXRZLElBQWIsQ0FBa0JnRSxHQUFsQjs7QUFDQSxVQUFJLENBQUMsS0FBS3VVLE1BQUwsQ0FBWXZhLEdBQVosQ0FBZ0JtQyxFQUFoQixDQUFMLEVBQTBCO0FBQ3hCNkQsV0FBRyxDQUFDM0QsTUFBSixDQUFXLElBQVg7QUFDRDtBQUNGO0FBQ0YsR0FURDtBQVdBOzs7OztBQUdBa1YsU0FBTyxDQUFDL2hCLFNBQVIsQ0FBa0JpbEIsV0FBbEIsR0FBZ0MsU0FBU0EsV0FBVCxHQUF3QjtBQUNwRCxRQUFJakcsTUFBTSxHQUFHLElBQWI7QUFFRixRQUFJdGQsQ0FBQyxHQUFHLEtBQUttakIsSUFBTCxDQUFVbGpCLE1BQWxCOztBQUNBLFdBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1YsVUFBSThPLEdBQUcsR0FBR3dPLE1BQU0sQ0FBQzZGLElBQVAsQ0FBWW5qQixDQUFaLENBQVY7O0FBQ0EsVUFBSSxDQUFDc2QsTUFBTSxDQUFDZ0csU0FBUCxDQUFpQnhhLEdBQWpCLENBQXFCZ0csR0FBRyxDQUFDN0QsRUFBekIsQ0FBTCxFQUFtQztBQUNqQzZELFdBQUcsQ0FBQ3pELFNBQUosQ0FBY2lTLE1BQWQ7QUFDRDtBQUNGOztBQUNELFFBQUlrRyxHQUFHLEdBQUcsS0FBS0gsTUFBZjtBQUNBLFNBQUtBLE1BQUwsR0FBYyxLQUFLQyxTQUFuQjtBQUNBLFNBQUtBLFNBQUwsR0FBaUJFLEdBQWpCO0FBQ0EsU0FBS0YsU0FBTCxDQUFldGEsS0FBZjtBQUNBd2EsT0FBRyxHQUFHLEtBQUtMLElBQVg7QUFDQSxTQUFLQSxJQUFMLEdBQVksS0FBS0MsT0FBakI7QUFDQSxTQUFLQSxPQUFMLEdBQWVJLEdBQWY7QUFDQSxTQUFLSixPQUFMLENBQWFuakIsTUFBYixHQUFzQixDQUF0QjtBQUNELEdBbEJEO0FBb0JBOzs7Ozs7QUFJQW9nQixTQUFPLENBQUMvaEIsU0FBUixDQUFrQm9OLE1BQWxCLEdBQTJCLFNBQVNBLE1BQVQsR0FBbUI7QUFDNUM7QUFDQSxRQUFJLEtBQUtzWCxJQUFULEVBQWU7QUFDYixXQUFLRSxLQUFMLEdBQWEsSUFBYjtBQUNELEtBRkQsTUFFTyxJQUFJLEtBQUtuSCxJQUFULEVBQWU7QUFDcEIsV0FBS21HLEdBQUw7QUFDRCxLQUZNLE1BRUE7QUFDTFMsa0JBQVksQ0FBQyxJQUFELENBQVo7QUFDRDtBQUNGLEdBVEQ7QUFXQTs7Ozs7O0FBSUF0QyxTQUFPLENBQUMvaEIsU0FBUixDQUFrQjRqQixHQUFsQixHQUF3QixTQUFTQSxHQUFULEdBQWdCO0FBQ3RDLFFBQUksS0FBS2UsTUFBVCxFQUFpQjtBQUNmLFVBQUkva0IsS0FBSyxHQUFHLEtBQUs0SixHQUFMLEVBQVo7O0FBQ0EsVUFDRTVKLEtBQUssS0FBSyxLQUFLQSxLQUFmLElBQ0E7QUFDQTtBQUNBO0FBQ0FDLGNBQVEsQ0FBQ0QsS0FBRCxDQUpSLElBS0EsS0FBSzZrQixJQU5QLEVBT0U7QUFDQTtBQUNBLFlBQUlVLFFBQVEsR0FBRyxLQUFLdmxCLEtBQXBCO0FBQ0EsYUFBS0EsS0FBTCxHQUFhQSxLQUFiOztBQUNBLFlBQUksS0FBS2lrQixJQUFULEVBQWU7QUFDYixjQUFJO0FBQ0YsaUJBQUtoTCxFQUFMLENBQVExWSxJQUFSLENBQWEsS0FBS2lMLEVBQWxCLEVBQXNCeEwsS0FBdEIsRUFBNkJ1bEIsUUFBN0I7QUFDRCxXQUZELENBRUUsT0FBT3JmLENBQVAsRUFBVTtBQUNWK1EsdUJBQVcsQ0FBQy9RLENBQUQsRUFBSSxLQUFLc0YsRUFBVCxFQUFjLDRCQUE2QixLQUFLMFksVUFBbEMsR0FBZ0QsSUFBOUQsQ0FBWDtBQUNEO0FBQ0YsU0FORCxNQU1PO0FBQ0wsZUFBS2pMLEVBQUwsQ0FBUTFZLElBQVIsQ0FBYSxLQUFLaUwsRUFBbEIsRUFBc0J4TCxLQUF0QixFQUE2QnVsQixRQUE3QjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBekJEO0FBMkJBOzs7Ozs7QUFJQXBELFNBQU8sQ0FBQy9oQixTQUFSLENBQWtCb2xCLFFBQWxCLEdBQTZCLFNBQVNBLFFBQVQsR0FBcUI7QUFDaEQsU0FBS3hsQixLQUFMLEdBQWEsS0FBSzRKLEdBQUwsRUFBYjtBQUNBLFNBQUtvYixLQUFMLEdBQWEsS0FBYjtBQUNELEdBSEQ7QUFLQTs7Ozs7QUFHQTdDLFNBQU8sQ0FBQy9oQixTQUFSLENBQWtCZ04sTUFBbEIsR0FBMkIsU0FBU0EsTUFBVCxHQUFtQjtBQUMxQyxRQUFJZ1MsTUFBTSxHQUFHLElBQWI7QUFFRixRQUFJdGQsQ0FBQyxHQUFHLEtBQUttakIsSUFBTCxDQUFVbGpCLE1BQWxCOztBQUNBLFdBQU9ELENBQUMsRUFBUixFQUFZO0FBQ1ZzZCxZQUFNLENBQUM2RixJQUFQLENBQVluakIsQ0FBWixFQUFlc0wsTUFBZjtBQUNEO0FBQ0YsR0FQRDtBQVNBOzs7OztBQUdBK1UsU0FBTyxDQUFDL2hCLFNBQVIsQ0FBa0JzaEIsUUFBbEIsR0FBNkIsU0FBU0EsUUFBVCxHQUFxQjtBQUM5QyxRQUFJdEMsTUFBTSxHQUFHLElBQWI7O0FBRUYsUUFBSSxLQUFLMkYsTUFBVCxFQUFpQjtBQUNmO0FBQ0E7QUFDQTtBQUNBLFVBQUksQ0FBQyxLQUFLdlosRUFBTCxDQUFRa1YsaUJBQWIsRUFBZ0M7QUFDOUJ2ZSxjQUFNLENBQUMsS0FBS3FKLEVBQUwsQ0FBUW1XLFNBQVQsRUFBb0IsSUFBcEIsQ0FBTjtBQUNEOztBQUNELFVBQUk3ZixDQUFDLEdBQUcsS0FBS21qQixJQUFMLENBQVVsakIsTUFBbEI7O0FBQ0EsYUFBT0QsQ0FBQyxFQUFSLEVBQVk7QUFDVnNkLGNBQU0sQ0FBQzZGLElBQVAsQ0FBWW5qQixDQUFaLEVBQWVxTCxTQUFmLENBQXlCaVMsTUFBekI7QUFDRDs7QUFDRCxXQUFLMkYsTUFBTCxHQUFjLEtBQWQ7QUFDRDtBQUNGLEdBaEJEO0FBa0JBOzs7QUFFQSxNQUFJVSx3QkFBd0IsR0FBRztBQUM3QjFkLGNBQVUsRUFBRSxJQURpQjtBQUU3QkcsZ0JBQVksRUFBRSxJQUZlO0FBRzdCMEIsT0FBRyxFQUFFN0UsSUFId0I7QUFJN0I0RixPQUFHLEVBQUU1RjtBQUp3QixHQUEvQjs7QUFPQSxXQUFTMmdCLEtBQVQsQ0FBZ0JyWSxNQUFoQixFQUF3QnNZLFNBQXhCLEVBQW1DaGpCLEdBQW5DLEVBQXdDO0FBQ3RDOGlCLDRCQUF3QixDQUFDN2IsR0FBekIsR0FBK0IsU0FBU2djLFdBQVQsR0FBd0I7QUFDckQsYUFBTyxLQUFLRCxTQUFMLEVBQWdCaGpCLEdBQWhCLENBQVA7QUFDRCxLQUZEOztBQUdBOGlCLDRCQUF3QixDQUFDOWEsR0FBekIsR0FBK0IsU0FBU2tiLFdBQVQsQ0FBc0JqbEIsR0FBdEIsRUFBMkI7QUFDeEQsV0FBSytrQixTQUFMLEVBQWdCaGpCLEdBQWhCLElBQXVCL0IsR0FBdkI7QUFDRCxLQUZEOztBQUdBckIsVUFBTSxDQUFDeUksY0FBUCxDQUFzQnFGLE1BQXRCLEVBQThCMUssR0FBOUIsRUFBbUM4aUIsd0JBQW5DO0FBQ0Q7O0FBRUQsV0FBU0ssU0FBVCxDQUFvQnRhLEVBQXBCLEVBQXdCO0FBQ3RCQSxNQUFFLENBQUNtVyxTQUFILEdBQWUsRUFBZjtBQUNBLFFBQUloWSxJQUFJLEdBQUc2QixFQUFFLENBQUNRLFFBQWQ7O0FBQ0EsUUFBSXJDLElBQUksQ0FBQ3FLLEtBQVQsRUFBZ0I7QUFBRStSLGVBQVMsQ0FBQ3ZhLEVBQUQsRUFBSzdCLElBQUksQ0FBQ3FLLEtBQVYsQ0FBVDtBQUE0Qjs7QUFDOUMsUUFBSXJLLElBQUksQ0FBQ3NLLE9BQVQsRUFBa0I7QUFBRStSLGlCQUFXLENBQUN4YSxFQUFELEVBQUs3QixJQUFJLENBQUNzSyxPQUFWLENBQVg7QUFBZ0M7O0FBQ3BELFFBQUl0SyxJQUFJLENBQUNxRSxJQUFULEVBQWU7QUFDYmlZLGNBQVEsQ0FBQ3phLEVBQUQsQ0FBUjtBQUNELEtBRkQsTUFFTztBQUNMaUcsYUFBTyxDQUFDakcsRUFBRSxDQUFDb1csS0FBSCxHQUFXLEVBQVosRUFBZ0I7QUFBSztBQUFyQixPQUFQO0FBQ0Q7O0FBQ0QsUUFBSWpZLElBQUksQ0FBQ3dLLFFBQVQsRUFBbUI7QUFBRStSLGtCQUFZLENBQUMxYSxFQUFELEVBQUs3QixJQUFJLENBQUN3SyxRQUFWLENBQVo7QUFBa0M7O0FBQ3ZELFFBQUl4SyxJQUFJLENBQUNGLEtBQUwsSUFBY0UsSUFBSSxDQUFDRixLQUFMLEtBQWVELFdBQWpDLEVBQThDO0FBQzVDMmMsZUFBUyxDQUFDM2EsRUFBRCxFQUFLN0IsSUFBSSxDQUFDRixLQUFWLENBQVQ7QUFDRDtBQUNGOztBQUVELFdBQVNzYyxTQUFULENBQW9CdmEsRUFBcEIsRUFBd0I0YSxZQUF4QixFQUFzQztBQUNwQyxRQUFJdlQsU0FBUyxHQUFHckgsRUFBRSxDQUFDUSxRQUFILENBQVk2RyxTQUFaLElBQXlCLEVBQXpDO0FBQ0EsUUFBSW1CLEtBQUssR0FBR3hJLEVBQUUsQ0FBQzZLLE1BQUgsR0FBWSxFQUF4QixDQUZvQyxDQUdwQztBQUNBOztBQUNBLFFBQUkvUSxJQUFJLEdBQUdrRyxFQUFFLENBQUNRLFFBQUgsQ0FBWStXLFNBQVosR0FBd0IsRUFBbkM7QUFDQSxRQUFJc0QsTUFBTSxHQUFHLENBQUM3YSxFQUFFLENBQUNnQixPQUFqQixDQU5vQyxDQU9wQzs7QUFDQSxRQUFJLENBQUM2WixNQUFMLEVBQWE7QUFDWHJWLHFCQUFlLENBQUMsS0FBRCxDQUFmO0FBQ0Q7O0FBQ0QsUUFBSXNWLElBQUksR0FBRyxVQUFXM2pCLEdBQVgsRUFBaUI7QUFDMUIyQyxVQUFJLENBQUNzSCxJQUFMLENBQVVqSyxHQUFWO0FBQ0EsVUFBSTNDLEtBQUssR0FBR3lWLFlBQVksQ0FBQzlTLEdBQUQsRUFBTXlqQixZQUFOLEVBQW9CdlQsU0FBcEIsRUFBK0JySCxFQUEvQixDQUF4QjtBQUNBOztBQUNBO0FBQ0UsWUFBSSthLGFBQWEsR0FBRzdpQixTQUFTLENBQUNmLEdBQUQsQ0FBN0I7O0FBQ0EsWUFBSVQsbUJBQW1CLENBQUNxa0IsYUFBRCxDQUFuQixJQUNBNWYsTUFBTSxDQUFDVyxjQUFQLENBQXNCaWYsYUFBdEIsQ0FESixFQUMwQztBQUN4Q3hiLGNBQUksQ0FDRCxPQUFPd2IsYUFBUCxHQUF1QixrRUFEdEIsRUFFRi9hLEVBRkUsQ0FBSjtBQUlEOztBQUNEK0Ysc0JBQWMsQ0FBQ3lDLEtBQUQsRUFBUXJSLEdBQVIsRUFBYTNDLEtBQWIsRUFBb0IsWUFBWTtBQUM1QyxjQUFJd0wsRUFBRSxDQUFDZ0IsT0FBSCxJQUFjLENBQUN3VCx3QkFBbkIsRUFBNkM7QUFDM0NqVixnQkFBSSxDQUNGLDREQUNBLHdEQURBLEdBRUEsK0RBRkEsR0FHQSwrQkFIQSxHQUdrQ3BJLEdBSGxDLEdBR3dDLElBSnRDLEVBS0Y2SSxFQUxFLENBQUo7QUFPRDtBQUNGLFNBVmEsQ0FBZDtBQVdELE9BeEJ5QixDQXlCMUI7QUFDQTtBQUNBOztBQUNBLFVBQUksRUFBRTdJLEdBQUcsSUFBSTZJLEVBQVQsQ0FBSixFQUFrQjtBQUNoQmthLGFBQUssQ0FBQ2xhLEVBQUQsRUFBSyxRQUFMLEVBQWU3SSxHQUFmLENBQUw7QUFDRDtBQUNGLEtBL0JEOztBQWlDQSxTQUFLLElBQUlBLEdBQVQsSUFBZ0J5akIsWUFBaEIsRUFBOEJFLElBQUksQ0FBRTNqQixHQUFGLENBQUo7O0FBQzlCcU8sbUJBQWUsQ0FBQyxJQUFELENBQWY7QUFDRDs7QUFFRCxXQUFTaVYsUUFBVCxDQUFtQnphLEVBQW5CLEVBQXVCO0FBQ3JCLFFBQUl3QyxJQUFJLEdBQUd4QyxFQUFFLENBQUNRLFFBQUgsQ0FBWWdDLElBQXZCO0FBQ0FBLFFBQUksR0FBR3hDLEVBQUUsQ0FBQ29XLEtBQUgsR0FBVyxPQUFPNVQsSUFBUCxLQUFnQixVQUFoQixHQUNkd1ksT0FBTyxDQUFDeFksSUFBRCxFQUFPeEMsRUFBUCxDQURPLEdBRWR3QyxJQUFJLElBQUksRUFGWjs7QUFHQSxRQUFJLENBQUN2TixhQUFhLENBQUN1TixJQUFELENBQWxCLEVBQTBCO0FBQ3hCQSxVQUFJLEdBQUcsRUFBUDtBQUNBLHdCQUFrQixZQUFsQixJQUFrQ2pELElBQUksQ0FDcEMsOENBQ0Esb0VBRm9DLEVBR3BDUyxFQUhvQyxDQUF0QztBQUtELEtBWm9CLENBYXJCOzs7QUFDQSxRQUFJbEcsSUFBSSxHQUFHL0YsTUFBTSxDQUFDK0YsSUFBUCxDQUFZMEksSUFBWixDQUFYO0FBQ0EsUUFBSWdHLEtBQUssR0FBR3hJLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZZ0ksS0FBeEI7QUFDQSxRQUFJQyxPQUFPLEdBQUd6SSxFQUFFLENBQUNRLFFBQUgsQ0FBWWlJLE9BQTFCO0FBQ0EsUUFBSW5TLENBQUMsR0FBR3dELElBQUksQ0FBQ3ZELE1BQWI7O0FBQ0EsV0FBT0QsQ0FBQyxFQUFSLEVBQVk7QUFDVixVQUFJYSxHQUFHLEdBQUcyQyxJQUFJLENBQUN4RCxDQUFELENBQWQ7QUFDQTtBQUNFLFlBQUltUyxPQUFPLElBQUl2UixNQUFNLENBQUN1UixPQUFELEVBQVV0UixHQUFWLENBQXJCLEVBQXFDO0FBQ25Db0ksY0FBSSxDQUNELGNBQWNwSSxHQUFkLEdBQW9CLGlEQURuQixFQUVGNkksRUFGRSxDQUFKO0FBSUQ7QUFDRjs7QUFDRCxVQUFJd0ksS0FBSyxJQUFJdFIsTUFBTSxDQUFDc1IsS0FBRCxFQUFRclIsR0FBUixDQUFuQixFQUFpQztBQUMvQiwwQkFBa0IsWUFBbEIsSUFBa0NvSSxJQUFJLENBQ3BDLHlCQUF5QnBJLEdBQXpCLEdBQStCLG9DQUEvQixHQUNBLGlDQUZvQyxFQUdwQzZJLEVBSG9DLENBQXRDO0FBS0QsT0FORCxNQU1PLElBQUksQ0FBQzVELFVBQVUsQ0FBQ2pGLEdBQUQsQ0FBZixFQUFzQjtBQUMzQitpQixhQUFLLENBQUNsYSxFQUFELEVBQUssT0FBTCxFQUFjN0ksR0FBZCxDQUFMO0FBQ0Q7QUFDRixLQXJDb0IsQ0FzQ3JCOzs7QUFDQThPLFdBQU8sQ0FBQ3pELElBQUQsRUFBTztBQUFLO0FBQVosS0FBUDtBQUNEOztBQUVELFdBQVN3WSxPQUFULENBQWtCeFksSUFBbEIsRUFBd0J4QyxFQUF4QixFQUE0QjtBQUMxQjtBQUNBa0MsY0FBVTs7QUFDVixRQUFJO0FBQ0YsYUFBT00sSUFBSSxDQUFDek4sSUFBTCxDQUFVaUwsRUFBVixFQUFjQSxFQUFkLENBQVA7QUFDRCxLQUZELENBRUUsT0FBT3RGLENBQVAsRUFBVTtBQUNWK1EsaUJBQVcsQ0FBQy9RLENBQUQsRUFBSXNGLEVBQUosRUFBUSxRQUFSLENBQVg7QUFDQSxhQUFPLEVBQVA7QUFDRCxLQUxELFNBS1U7QUFDUm9DLGVBQVM7QUFDVjtBQUNGOztBQUVELE1BQUk2WSxzQkFBc0IsR0FBRztBQUFFM0IsUUFBSSxFQUFFO0FBQVIsR0FBN0I7O0FBRUEsV0FBU29CLFlBQVQsQ0FBdUIxYSxFQUF2QixFQUEyQjJJLFFBQTNCLEVBQXFDO0FBQ25DO0FBQ0EsUUFBSXVTLFFBQVEsR0FBR2xiLEVBQUUsQ0FBQ21iLGlCQUFILEdBQXVCcG5CLE1BQU0sQ0FBQ29DLE1BQVAsQ0FBYyxJQUFkLENBQXRDLENBRm1DLENBR25DOztBQUNBLFFBQUlpbEIsS0FBSyxHQUFHN2MsaUJBQWlCLEVBQTdCOztBQUVBLFNBQUssSUFBSXBILEdBQVQsSUFBZ0J3UixRQUFoQixFQUEwQjtBQUN4QixVQUFJMFMsT0FBTyxHQUFHMVMsUUFBUSxDQUFDeFIsR0FBRCxDQUF0QjtBQUNBLFVBQUl1UCxNQUFNLEdBQUcsT0FBTzJVLE9BQVAsS0FBbUIsVUFBbkIsR0FBZ0NBLE9BQWhDLEdBQTBDQSxPQUFPLENBQUNqZCxHQUEvRDs7QUFDQSxVQUFJLGtCQUFrQixZQUFsQixJQUFrQ3NJLE1BQU0sSUFBSSxJQUFoRCxFQUFzRDtBQUNwRG5ILFlBQUksQ0FDRCwrQ0FBK0NwSSxHQUEvQyxHQUFxRCxLQURwRCxFQUVGNkksRUFGRSxDQUFKO0FBSUQ7O0FBRUQsVUFBSSxDQUFDb2IsS0FBTCxFQUFZO0FBQ1Y7QUFDQUYsZ0JBQVEsQ0FBQy9qQixHQUFELENBQVIsR0FBZ0IsSUFBSXdmLE9BQUosQ0FDZDNXLEVBRGMsRUFFZDBHLE1BQU0sSUFBSW5OLElBRkksRUFHZEEsSUFIYyxFQUlkMGhCLHNCQUpjLENBQWhCO0FBTUQsT0FsQnVCLENBb0J4QjtBQUNBO0FBQ0E7OztBQUNBLFVBQUksRUFBRTlqQixHQUFHLElBQUk2SSxFQUFULENBQUosRUFBa0I7QUFDaEJzYixzQkFBYyxDQUFDdGIsRUFBRCxFQUFLN0ksR0FBTCxFQUFVa2tCLE9BQVYsQ0FBZDtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUlsa0IsR0FBRyxJQUFJNkksRUFBRSxDQUFDdWIsS0FBZCxFQUFxQjtBQUNuQmhjLGNBQUksQ0FBRSw2QkFBNkJwSSxHQUE3QixHQUFtQyxnQ0FBckMsRUFBd0U2SSxFQUF4RSxDQUFKO0FBQ0QsU0FGRCxNQUVPLElBQUlBLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZZ0ksS0FBWixJQUFxQnJSLEdBQUcsSUFBSTZJLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZZ0ksS0FBNUMsRUFBbUQ7QUFDeERqSixjQUFJLENBQUUsNkJBQTZCcEksR0FBN0IsR0FBbUMsa0NBQXJDLEVBQTBFNkksRUFBMUUsQ0FBSjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFdBQVNzYixjQUFULENBQ0V6WixNQURGLEVBRUUxSyxHQUZGLEVBR0Vra0IsT0FIRixFQUlFO0FBQ0EsUUFBSUcsV0FBVyxHQUFHLENBQUNqZCxpQkFBaUIsRUFBcEM7O0FBQ0EsUUFBSSxPQUFPOGMsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ3BCLDhCQUF3QixDQUFDN2IsR0FBekIsR0FBK0JvZCxXQUFXLEdBQ3RDQyxvQkFBb0IsQ0FBQ3RrQixHQUFELENBRGtCLEdBRXRDa2tCLE9BRko7QUFHQXBCLDhCQUF3QixDQUFDOWEsR0FBekIsR0FBK0I1RixJQUEvQjtBQUNELEtBTEQsTUFLTztBQUNMMGdCLDhCQUF3QixDQUFDN2IsR0FBekIsR0FBK0JpZCxPQUFPLENBQUNqZCxHQUFSLEdBQzNCb2QsV0FBVyxJQUFJSCxPQUFPLENBQUMvakIsS0FBUixLQUFrQixLQUFqQyxHQUNFbWtCLG9CQUFvQixDQUFDdGtCLEdBQUQsQ0FEdEIsR0FFRWtrQixPQUFPLENBQUNqZCxHQUhpQixHQUkzQjdFLElBSko7QUFLQTBnQiw4QkFBd0IsQ0FBQzlhLEdBQXpCLEdBQStCa2MsT0FBTyxDQUFDbGMsR0FBUixHQUMzQmtjLE9BQU8sQ0FBQ2xjLEdBRG1CLEdBRTNCNUYsSUFGSjtBQUdEOztBQUNELFFBQUksa0JBQWtCLFlBQWxCLElBQ0EwZ0Isd0JBQXdCLENBQUM5YSxHQUF6QixLQUFpQzVGLElBRHJDLEVBQzJDO0FBQ3pDMGdCLDhCQUF3QixDQUFDOWEsR0FBekIsR0FBK0IsWUFBWTtBQUN6Q0ksWUFBSSxDQUNELHlCQUF5QnBJLEdBQXpCLEdBQStCLDBDQUQ5QixFQUVGLElBRkUsQ0FBSjtBQUlELE9BTEQ7QUFNRDs7QUFDRHBELFVBQU0sQ0FBQ3lJLGNBQVAsQ0FBc0JxRixNQUF0QixFQUE4QjFLLEdBQTlCLEVBQW1DOGlCLHdCQUFuQztBQUNEOztBQUVELFdBQVN3QixvQkFBVCxDQUErQnRrQixHQUEvQixFQUFvQztBQUNsQyxXQUFPLFNBQVN1a0IsY0FBVCxHQUEyQjtBQUNoQyxVQUFJcEQsT0FBTyxHQUFHLEtBQUs2QyxpQkFBTCxJQUEwQixLQUFLQSxpQkFBTCxDQUF1QmhrQixHQUF2QixDQUF4Qzs7QUFDQSxVQUFJbWhCLE9BQUosRUFBYTtBQUNYLFlBQUlBLE9BQU8sQ0FBQ2tCLEtBQVosRUFBbUI7QUFDakJsQixpQkFBTyxDQUFDMEIsUUFBUjtBQUNEOztBQUNELFlBQUkxWSxHQUFHLENBQUNPLE1BQVIsRUFBZ0I7QUFDZHlXLGlCQUFPLENBQUMxVyxNQUFSO0FBQ0Q7O0FBQ0QsZUFBTzBXLE9BQU8sQ0FBQzlqQixLQUFmO0FBQ0Q7QUFDRixLQVhEO0FBWUQ7O0FBRUQsV0FBU2dtQixXQUFULENBQXNCeGEsRUFBdEIsRUFBMEJ5SSxPQUExQixFQUFtQztBQUNqQyxRQUFJRCxLQUFLLEdBQUd4SSxFQUFFLENBQUNRLFFBQUgsQ0FBWWdJLEtBQXhCOztBQUNBLFNBQUssSUFBSXJSLEdBQVQsSUFBZ0JzUixPQUFoQixFQUF5QjtBQUN2QjtBQUNFLFlBQUlBLE9BQU8sQ0FBQ3RSLEdBQUQsQ0FBUCxJQUFnQixJQUFwQixFQUEwQjtBQUN4Qm9JLGNBQUksQ0FDRixjQUFjcEksR0FBZCxHQUFvQix5REFBcEIsR0FDQSwyQ0FGRSxFQUdGNkksRUFIRSxDQUFKO0FBS0Q7O0FBQ0QsWUFBSXdJLEtBQUssSUFBSXRSLE1BQU0sQ0FBQ3NSLEtBQUQsRUFBUXJSLEdBQVIsQ0FBbkIsRUFBaUM7QUFDL0JvSSxjQUFJLENBQ0QsY0FBY3BJLEdBQWQsR0FBb0Isd0NBRG5CLEVBRUY2SSxFQUZFLENBQUo7QUFJRDs7QUFDRCxZQUFLN0ksR0FBRyxJQUFJNkksRUFBUixJQUFlNUQsVUFBVSxDQUFDakYsR0FBRCxDQUE3QixFQUFvQztBQUNsQ29JLGNBQUksQ0FDRixjQUFjcEksR0FBZCxHQUFvQixxREFBcEIsR0FDQSwwREFGRSxDQUFKO0FBSUQ7QUFDRjtBQUNENkksUUFBRSxDQUFDN0ksR0FBRCxDQUFGLEdBQVVzUixPQUFPLENBQUN0UixHQUFELENBQVAsSUFBZ0IsSUFBaEIsR0FBdUJvQyxJQUF2QixHQUE4QlgsSUFBSSxDQUFDNlAsT0FBTyxDQUFDdFIsR0FBRCxDQUFSLEVBQWU2SSxFQUFmLENBQTVDO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTMmEsU0FBVCxDQUFvQjNhLEVBQXBCLEVBQXdCL0IsS0FBeEIsRUFBK0I7QUFDN0IsU0FBSyxJQUFJOUcsR0FBVCxJQUFnQjhHLEtBQWhCLEVBQXVCO0FBQ3JCLFVBQUkwZCxPQUFPLEdBQUcxZCxLQUFLLENBQUM5RyxHQUFELENBQW5COztBQUNBLFVBQUk4QixLQUFLLENBQUNzQixPQUFOLENBQWNvaEIsT0FBZCxDQUFKLEVBQTRCO0FBQzFCLGFBQUssSUFBSXJsQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcWxCLE9BQU8sQ0FBQ3BsQixNQUE1QixFQUFvQ0QsQ0FBQyxFQUFyQyxFQUF5QztBQUN2Q3NsQix1QkFBYSxDQUFDNWIsRUFBRCxFQUFLN0ksR0FBTCxFQUFVd2tCLE9BQU8sQ0FBQ3JsQixDQUFELENBQWpCLENBQWI7QUFDRDtBQUNGLE9BSkQsTUFJTztBQUNMc2xCLHFCQUFhLENBQUM1YixFQUFELEVBQUs3SSxHQUFMLEVBQVV3a0IsT0FBVixDQUFiO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVNDLGFBQVQsQ0FDRTViLEVBREYsRUFFRW1aLE9BRkYsRUFHRXdDLE9BSEYsRUFJRXRiLE9BSkYsRUFLRTtBQUNBLFFBQUlwTCxhQUFhLENBQUMwbUIsT0FBRCxDQUFqQixFQUE0QjtBQUMxQnRiLGFBQU8sR0FBR3NiLE9BQVY7QUFDQUEsYUFBTyxHQUFHQSxPQUFPLENBQUNBLE9BQWxCO0FBQ0Q7O0FBQ0QsUUFBSSxPQUFPQSxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CQSxhQUFPLEdBQUczYixFQUFFLENBQUMyYixPQUFELENBQVo7QUFDRDs7QUFDRCxXQUFPM2IsRUFBRSxDQUFDNmIsTUFBSCxDQUFVMUMsT0FBVixFQUFtQndDLE9BQW5CLEVBQTRCdGIsT0FBNUIsQ0FBUDtBQUNEOztBQUVELFdBQVN5YixVQUFULENBQXFCcEksR0FBckIsRUFBMEI7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsUUFBSXFJLE9BQU8sR0FBRyxFQUFkOztBQUNBQSxXQUFPLENBQUMzZCxHQUFSLEdBQWMsWUFBWTtBQUFFLGFBQU8sS0FBS2dZLEtBQVo7QUFBbUIsS0FBL0M7O0FBQ0EsUUFBSTRGLFFBQVEsR0FBRyxFQUFmOztBQUNBQSxZQUFRLENBQUM1ZCxHQUFULEdBQWUsWUFBWTtBQUFFLGFBQU8sS0FBS3lNLE1BQVo7QUFBb0IsS0FBakQ7O0FBQ0E7QUFDRWtSLGFBQU8sQ0FBQzVjLEdBQVIsR0FBYyxVQUFVOGMsT0FBVixFQUFtQjtBQUMvQjFjLFlBQUksQ0FDRiwwQ0FDQSxxQ0FGRSxFQUdGLElBSEUsQ0FBSjtBQUtELE9BTkQ7O0FBT0F5YyxjQUFRLENBQUM3YyxHQUFULEdBQWUsWUFBWTtBQUN6QkksWUFBSSxDQUFDLHFCQUFELEVBQXdCLElBQXhCLENBQUo7QUFDRCxPQUZEO0FBR0Q7QUFDRHhMLFVBQU0sQ0FBQ3lJLGNBQVAsQ0FBc0JrWCxHQUFHLENBQUM5ZSxTQUExQixFQUFxQyxPQUFyQyxFQUE4Q21uQixPQUE5QztBQUNBaG9CLFVBQU0sQ0FBQ3lJLGNBQVAsQ0FBc0JrWCxHQUFHLENBQUM5ZSxTQUExQixFQUFxQyxRQUFyQyxFQUErQ29uQixRQUEvQztBQUVBdEksT0FBRyxDQUFDOWUsU0FBSixDQUFjc25CLElBQWQsR0FBcUIvYyxHQUFyQjtBQUNBdVUsT0FBRyxDQUFDOWUsU0FBSixDQUFjdW5CLE9BQWQsR0FBd0JqVixHQUF4Qjs7QUFFQXdNLE9BQUcsQ0FBQzllLFNBQUosQ0FBY2luQixNQUFkLEdBQXVCLFVBQ3JCMUMsT0FEcUIsRUFFckIxTCxFQUZxQixFQUdyQnBOLE9BSHFCLEVBSXJCO0FBQ0EsVUFBSUwsRUFBRSxHQUFHLElBQVQ7O0FBQ0EsVUFBSS9LLGFBQWEsQ0FBQ3dZLEVBQUQsQ0FBakIsRUFBdUI7QUFDckIsZUFBT21PLGFBQWEsQ0FBQzViLEVBQUQsRUFBS21aLE9BQUwsRUFBYzFMLEVBQWQsRUFBa0JwTixPQUFsQixDQUFwQjtBQUNEOztBQUNEQSxhQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFyQjtBQUNBQSxhQUFPLENBQUNvWSxJQUFSLEdBQWUsSUFBZjtBQUNBLFVBQUlILE9BQU8sR0FBRyxJQUFJM0IsT0FBSixDQUFZM1csRUFBWixFQUFnQm1aLE9BQWhCLEVBQXlCMUwsRUFBekIsRUFBNkJwTixPQUE3QixDQUFkOztBQUNBLFVBQUlBLE9BQU8sQ0FBQytiLFNBQVosRUFBdUI7QUFDckIzTyxVQUFFLENBQUMxWSxJQUFILENBQVFpTCxFQUFSLEVBQVlzWSxPQUFPLENBQUM5akIsS0FBcEI7QUFDRDs7QUFDRCxhQUFPLFNBQVM2bkIsU0FBVCxHQUFzQjtBQUMzQi9ELGVBQU8sQ0FBQ3BDLFFBQVI7QUFDRCxPQUZEO0FBR0QsS0FsQkQ7QUFtQkQ7QUFFRDs7O0FBRUEsV0FBU29HLFdBQVQsQ0FBc0J0YyxFQUF0QixFQUEwQjtBQUN4QixRQUFJNEksT0FBTyxHQUFHNUksRUFBRSxDQUFDUSxRQUFILENBQVlvSSxPQUExQjs7QUFDQSxRQUFJQSxPQUFKLEVBQWE7QUFDWDVJLFFBQUUsQ0FBQ3VjLFNBQUgsR0FBZSxPQUFPM1QsT0FBUCxLQUFtQixVQUFuQixHQUNYQSxPQUFPLENBQUM3VCxJQUFSLENBQWFpTCxFQUFiLENBRFcsR0FFWDRJLE9BRko7QUFHRDtBQUNGOztBQUVELFdBQVM0VCxjQUFULENBQXlCeGMsRUFBekIsRUFBNkI7QUFDM0IsUUFBSStFLE1BQU0sR0FBRzBYLGFBQWEsQ0FBQ3pjLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZa0ksTUFBYixFQUFxQjFJLEVBQXJCLENBQTFCOztBQUNBLFFBQUkrRSxNQUFKLEVBQVk7QUFDVlMscUJBQWUsQ0FBQyxLQUFELENBQWY7QUFDQXpSLFlBQU0sQ0FBQytGLElBQVAsQ0FBWWlMLE1BQVosRUFBb0JOLE9BQXBCLENBQTRCLFVBQVV0TixHQUFWLEVBQWU7QUFDekM7QUFDQTtBQUNFNE8sd0JBQWMsQ0FBQy9GLEVBQUQsRUFBSzdJLEdBQUwsRUFBVTROLE1BQU0sQ0FBQzVOLEdBQUQsQ0FBaEIsRUFBdUIsWUFBWTtBQUMvQ29JLGdCQUFJLENBQ0YseUVBQ0EsMERBREEsR0FFQSw2QkFGQSxHQUVnQ3BJLEdBRmhDLEdBRXNDLElBSHBDLEVBSUY2SSxFQUpFLENBQUo7QUFNRCxXQVBhLENBQWQ7QUFRRDtBQUNGLE9BWkQ7QUFhQXdGLHFCQUFlLENBQUMsSUFBRCxDQUFmO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTaVgsYUFBVCxDQUF3Qi9ULE1BQXhCLEVBQWdDMUksRUFBaEMsRUFBb0M7QUFDbEMsUUFBSTBJLE1BQUosRUFBWTtBQUNWO0FBQ0EsVUFBSTNELE1BQU0sR0FBR2hSLE1BQU0sQ0FBQ29DLE1BQVAsQ0FBYyxJQUFkLENBQWI7QUFDQSxVQUFJMkQsSUFBSSxHQUFHK0UsU0FBUyxHQUNoQkUsT0FBTyxDQUFDQyxPQUFSLENBQWdCMEosTUFBaEIsRUFBd0JnVSxNQUF4QixDQUErQixVQUFVdmxCLEdBQVYsRUFBZTtBQUM5QztBQUNBLGVBQU9wRCxNQUFNLENBQUMwUyx3QkFBUCxDQUFnQ2lDLE1BQWhDLEVBQXdDdlIsR0FBeEMsRUFBNkNvRixVQUFwRDtBQUNELE9BSEMsQ0FEZ0IsR0FLaEJ4SSxNQUFNLENBQUMrRixJQUFQLENBQVk0TyxNQUFaLENBTEo7O0FBT0EsV0FBSyxJQUFJcFMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3dELElBQUksQ0FBQ3ZELE1BQXpCLEVBQWlDRCxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDLFlBQUlhLEdBQUcsR0FBRzJDLElBQUksQ0FBQ3hELENBQUQsQ0FBZDtBQUNBLFlBQUlxbUIsVUFBVSxHQUFHalUsTUFBTSxDQUFDdlIsR0FBRCxDQUFOLENBQVlxUSxJQUE3QjtBQUNBLFlBQUlvVixNQUFNLEdBQUc1YyxFQUFiOztBQUNBLGVBQU80YyxNQUFQLEVBQWU7QUFDYixjQUFJQSxNQUFNLENBQUNMLFNBQVAsSUFBb0JybEIsTUFBTSxDQUFDMGxCLE1BQU0sQ0FBQ0wsU0FBUixFQUFtQkksVUFBbkIsQ0FBOUIsRUFBOEQ7QUFDNUQ1WCxrQkFBTSxDQUFDNU4sR0FBRCxDQUFOLEdBQWN5bEIsTUFBTSxDQUFDTCxTQUFQLENBQWlCSSxVQUFqQixDQUFkO0FBQ0E7QUFDRDs7QUFDREMsZ0JBQU0sR0FBR0EsTUFBTSxDQUFDNWIsT0FBaEI7QUFDRDs7QUFDRCxZQUFJLENBQUM0YixNQUFMLEVBQWE7QUFDWCxjQUFJLGFBQWFsVSxNQUFNLENBQUN2UixHQUFELENBQXZCLEVBQThCO0FBQzVCLGdCQUFJMGxCLGNBQWMsR0FBR25VLE1BQU0sQ0FBQ3ZSLEdBQUQsQ0FBTixDQUFZeVQsT0FBakM7QUFDQTdGLGtCQUFNLENBQUM1TixHQUFELENBQU4sR0FBYyxPQUFPMGxCLGNBQVAsS0FBMEIsVUFBMUIsR0FDVkEsY0FBYyxDQUFDOW5CLElBQWYsQ0FBb0JpTCxFQUFwQixDQURVLEdBRVY2YyxjQUZKO0FBR0QsV0FMRCxNQUtPO0FBQ0x0ZCxnQkFBSSxDQUFFLGlCQUFpQnBJLEdBQWpCLEdBQXVCLGNBQXpCLEVBQTBDNkksRUFBMUMsQ0FBSjtBQUNEO0FBQ0Y7QUFDRjs7QUFDRCxhQUFPK0UsTUFBUDtBQUNEO0FBQ0Y7QUFFRDs7QUFFQTs7Ozs7QUFHQSxXQUFTK1gsVUFBVCxDQUNFMW5CLEdBREYsRUFFRXdaLE1BRkYsRUFHRTtBQUNBLFFBQUk1VixHQUFKLEVBQVMxQyxDQUFULEVBQVlpQyxDQUFaLEVBQWV1QixJQUFmLEVBQXFCM0MsR0FBckI7O0FBQ0EsUUFBSThCLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY25GLEdBQWQsS0FBc0IsT0FBT0EsR0FBUCxLQUFlLFFBQXpDLEVBQW1EO0FBQ2pENEQsU0FBRyxHQUFHLElBQUlDLEtBQUosQ0FBVTdELEdBQUcsQ0FBQ21CLE1BQWQsQ0FBTjs7QUFDQSxXQUFLRCxDQUFDLEdBQUcsQ0FBSixFQUFPaUMsQ0FBQyxHQUFHbkQsR0FBRyxDQUFDbUIsTUFBcEIsRUFBNEJELENBQUMsR0FBR2lDLENBQWhDLEVBQW1DakMsQ0FBQyxFQUFwQyxFQUF3QztBQUN0QzBDLFdBQUcsQ0FBQzFDLENBQUQsQ0FBSCxHQUFTc1ksTUFBTSxDQUFDeFosR0FBRyxDQUFDa0IsQ0FBRCxDQUFKLEVBQVNBLENBQVQsQ0FBZjtBQUNEO0FBQ0YsS0FMRCxNQUtPLElBQUksT0FBT2xCLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQzRELFNBQUcsR0FBRyxJQUFJQyxLQUFKLENBQVU3RCxHQUFWLENBQU47O0FBQ0EsV0FBS2tCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR2xCLEdBQWhCLEVBQXFCa0IsQ0FBQyxFQUF0QixFQUEwQjtBQUN4QjBDLFdBQUcsQ0FBQzFDLENBQUQsQ0FBSCxHQUFTc1ksTUFBTSxDQUFDdFksQ0FBQyxHQUFHLENBQUwsRUFBUUEsQ0FBUixDQUFmO0FBQ0Q7QUFDRixLQUxNLE1BS0EsSUFBSTdCLFFBQVEsQ0FBQ1csR0FBRCxDQUFaLEVBQW1CO0FBQ3hCMEUsVUFBSSxHQUFHL0YsTUFBTSxDQUFDK0YsSUFBUCxDQUFZMUUsR0FBWixDQUFQO0FBQ0E0RCxTQUFHLEdBQUcsSUFBSUMsS0FBSixDQUFVYSxJQUFJLENBQUN2RCxNQUFmLENBQU47O0FBQ0EsV0FBS0QsQ0FBQyxHQUFHLENBQUosRUFBT2lDLENBQUMsR0FBR3VCLElBQUksQ0FBQ3ZELE1BQXJCLEVBQTZCRCxDQUFDLEdBQUdpQyxDQUFqQyxFQUFvQ2pDLENBQUMsRUFBckMsRUFBeUM7QUFDdkNhLFdBQUcsR0FBRzJDLElBQUksQ0FBQ3hELENBQUQsQ0FBVjtBQUNBMEMsV0FBRyxDQUFDMUMsQ0FBRCxDQUFILEdBQVNzWSxNQUFNLENBQUN4WixHQUFHLENBQUMrQixHQUFELENBQUosRUFBV0EsR0FBWCxFQUFnQmIsQ0FBaEIsQ0FBZjtBQUNEO0FBQ0Y7O0FBQ0QsUUFBSWxDLEtBQUssQ0FBQzRFLEdBQUQsQ0FBVCxFQUFnQjtBQUNiQSxTQUFELENBQU11WSxRQUFOLEdBQWlCLElBQWpCO0FBQ0Q7O0FBQ0QsV0FBT3ZZLEdBQVA7QUFDRDtBQUVEOztBQUVBOzs7OztBQUdBLFdBQVMrakIsVUFBVCxDQUNFcmMsSUFERixFQUVFc2MsUUFGRixFQUdFeFUsS0FIRixFQUlFeVUsVUFKRixFQUtFO0FBQ0EsUUFBSUMsWUFBWSxHQUFHLEtBQUtoRyxZQUFMLENBQWtCeFcsSUFBbEIsQ0FBbkI7QUFDQSxRQUFJeWMsS0FBSjs7QUFDQSxRQUFJRCxZQUFKLEVBQWtCO0FBQUU7QUFDbEIxVSxXQUFLLEdBQUdBLEtBQUssSUFBSSxFQUFqQjs7QUFDQSxVQUFJeVUsVUFBSixFQUFnQjtBQUNkLFlBQUksa0JBQWtCLFlBQWxCLElBQWtDLENBQUN4b0IsUUFBUSxDQUFDd29CLFVBQUQsQ0FBL0MsRUFBNkQ7QUFDM0QxZCxjQUFJLENBQ0YsZ0RBREUsRUFFRixJQUZFLENBQUo7QUFJRDs7QUFDRGlKLGFBQUssR0FBR3RQLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLEVBQUQsRUFBSytqQixVQUFMLENBQVAsRUFBeUJ6VSxLQUF6QixDQUFkO0FBQ0Q7O0FBQ0QyVSxXQUFLLEdBQUdELFlBQVksQ0FBQzFVLEtBQUQsQ0FBWixJQUF1QndVLFFBQS9CO0FBQ0QsS0FaRCxNQVlPO0FBQ0wsVUFBSUksU0FBUyxHQUFHLEtBQUs1RixNQUFMLENBQVk5VyxJQUFaLENBQWhCLENBREssQ0FFTDs7QUFDQSxVQUFJMGMsU0FBSixFQUFlO0FBQ2IsWUFBSSxrQkFBa0IsWUFBbEIsSUFBa0NBLFNBQVMsQ0FBQ0MsU0FBaEQsRUFBMkQ7QUFDekQ5ZCxjQUFJLENBQ0Ysa0NBQWtDbUIsSUFBbEMsR0FBeUMsbUNBQXpDLEdBQ0EseUNBRkUsRUFHRixJQUhFLENBQUo7QUFLRDs7QUFDRDBjLGlCQUFTLENBQUNDLFNBQVYsR0FBc0IsSUFBdEI7QUFDRDs7QUFDREYsV0FBSyxHQUFHQyxTQUFTLElBQUlKLFFBQXJCO0FBQ0Q7O0FBRUQsUUFBSW5iLE1BQU0sR0FBRzJHLEtBQUssSUFBSUEsS0FBSyxDQUFDMkwsSUFBNUI7O0FBQ0EsUUFBSXRTLE1BQUosRUFBWTtBQUNWLGFBQU8sS0FBS3liLGNBQUwsQ0FBb0IsVUFBcEIsRUFBZ0M7QUFBRW5KLFlBQUksRUFBRXRTO0FBQVIsT0FBaEMsRUFBa0RzYixLQUFsRCxDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBT0EsS0FBUDtBQUNEO0FBQ0Y7QUFFRDs7QUFFQTs7Ozs7QUFHQSxXQUFTSSxhQUFULENBQXdCaGMsRUFBeEIsRUFBNEI7QUFDMUIsV0FBT3FJLFlBQVksQ0FBQyxLQUFLcEosUUFBTixFQUFnQixTQUFoQixFQUEyQmUsRUFBM0IsRUFBK0IsSUFBL0IsQ0FBWixJQUFvRDdILFFBQTNEO0FBQ0Q7QUFFRDs7O0FBRUEsV0FBUzhqQixhQUFULENBQXdCQyxNQUF4QixFQUFnQ0MsTUFBaEMsRUFBd0M7QUFDdEMsUUFBSXprQixLQUFLLENBQUNzQixPQUFOLENBQWNrakIsTUFBZCxDQUFKLEVBQTJCO0FBQ3pCLGFBQU9BLE1BQU0sQ0FBQzFtQixPQUFQLENBQWUybUIsTUFBZixNQUEyQixDQUFDLENBQW5DO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBT0QsTUFBTSxLQUFLQyxNQUFsQjtBQUNEO0FBQ0Y7QUFFRDs7Ozs7OztBQUtBLFdBQVNDLGFBQVQsQ0FDRUMsWUFERixFQUVFem1CLEdBRkYsRUFHRTBtQixjQUhGLEVBSUVDLFlBSkYsRUFLRUMsY0FMRixFQU1FO0FBQ0EsUUFBSUMsYUFBYSxHQUFHN2lCLE1BQU0sQ0FBQ1MsUUFBUCxDQUFnQnpFLEdBQWhCLEtBQXdCMG1CLGNBQTVDOztBQUNBLFFBQUlFLGNBQWMsSUFBSUQsWUFBbEIsSUFBa0MsQ0FBQzNpQixNQUFNLENBQUNTLFFBQVAsQ0FBZ0J6RSxHQUFoQixDQUF2QyxFQUE2RDtBQUMzRCxhQUFPcW1CLGFBQWEsQ0FBQ08sY0FBRCxFQUFpQkQsWUFBakIsQ0FBcEI7QUFDRCxLQUZELE1BRU8sSUFBSUUsYUFBSixFQUFtQjtBQUN4QixhQUFPUixhQUFhLENBQUNRLGFBQUQsRUFBZ0JKLFlBQWhCLENBQXBCO0FBQ0QsS0FGTSxNQUVBLElBQUlFLFlBQUosRUFBa0I7QUFDdkIsYUFBTzVsQixTQUFTLENBQUM0bEIsWUFBRCxDQUFULEtBQTRCM21CLEdBQW5DO0FBQ0Q7QUFDRjtBQUVEOztBQUVBOzs7OztBQUdBLFdBQVM4bUIsZUFBVCxDQUNFemIsSUFERixFQUVFRCxHQUZGLEVBR0UvTixLQUhGLEVBSUUwcEIsTUFKRixFQUtFQyxNQUxGLEVBTUU7QUFDQSxRQUFJM3BCLEtBQUosRUFBVztBQUNULFVBQUksQ0FBQ0MsUUFBUSxDQUFDRCxLQUFELENBQWIsRUFBc0I7QUFDcEIsMEJBQWtCLFlBQWxCLElBQWtDK0ssSUFBSSxDQUNwQywwREFEb0MsRUFFcEMsSUFGb0MsQ0FBdEM7QUFJRCxPQUxELE1BS087QUFDTCxZQUFJdEcsS0FBSyxDQUFDc0IsT0FBTixDQUFjL0YsS0FBZCxDQUFKLEVBQTBCO0FBQ3hCQSxlQUFLLEdBQUc2RSxRQUFRLENBQUM3RSxLQUFELENBQWhCO0FBQ0Q7O0FBQ0QsWUFBSXNjLElBQUo7O0FBQ0EsWUFBSWdLLElBQUksR0FBRyxVQUFXM2pCLEdBQVgsRUFBaUI7QUFDMUIsY0FDRUEsR0FBRyxLQUFLLE9BQVIsSUFDQUEsR0FBRyxLQUFLLE9BRFIsSUFFQVQsbUJBQW1CLENBQUNTLEdBQUQsQ0FIckIsRUFJRTtBQUNBMlosZ0JBQUksR0FBR3RPLElBQVA7QUFDRCxXQU5ELE1BTU87QUFDTCxnQkFBSThGLElBQUksR0FBRzlGLElBQUksQ0FBQ2tPLEtBQUwsSUFBY2xPLElBQUksQ0FBQ2tPLEtBQUwsQ0FBV3BJLElBQXBDO0FBQ0F3SSxnQkFBSSxHQUFHb04sTUFBTSxJQUFJL2lCLE1BQU0sQ0FBQ2UsV0FBUCxDQUFtQnFHLEdBQW5CLEVBQXdCK0YsSUFBeEIsRUFBOEJuUixHQUE5QixDQUFWLEdBQ0hxTCxJQUFJLENBQUM0YixRQUFMLEtBQWtCNWIsSUFBSSxDQUFDNGIsUUFBTCxHQUFnQixFQUFsQyxDQURHLEdBRUg1YixJQUFJLENBQUNrTyxLQUFMLEtBQWVsTyxJQUFJLENBQUNrTyxLQUFMLEdBQWEsRUFBNUIsQ0FGSjtBQUdEOztBQUNELGNBQUksRUFBRXZaLEdBQUcsSUFBSTJaLElBQVQsQ0FBSixFQUFvQjtBQUNsQkEsZ0JBQUksQ0FBQzNaLEdBQUQsQ0FBSixHQUFZM0MsS0FBSyxDQUFDMkMsR0FBRCxDQUFqQjs7QUFFQSxnQkFBSWduQixNQUFKLEVBQVk7QUFDVixrQkFBSXJPLEVBQUUsR0FBR3ROLElBQUksQ0FBQ3NOLEVBQUwsS0FBWXROLElBQUksQ0FBQ3NOLEVBQUwsR0FBVSxFQUF0QixDQUFUOztBQUNBQSxnQkFBRSxDQUFFLFlBQVkzWSxHQUFkLENBQUYsR0FBd0IsVUFBVWtuQixNQUFWLEVBQWtCO0FBQ3hDN3BCLHFCQUFLLENBQUMyQyxHQUFELENBQUwsR0FBYWtuQixNQUFiO0FBQ0QsZUFGRDtBQUdEO0FBQ0Y7QUFDRixTQXZCRDs7QUF5QkEsYUFBSyxJQUFJbG5CLEdBQVQsSUFBZ0IzQyxLQUFoQixFQUF1QnNtQixJQUFJLENBQUUzakIsR0FBRixDQUFKO0FBQ3hCO0FBQ0Y7O0FBQ0QsV0FBT3FMLElBQVA7QUFDRDtBQUVEOztBQUVBOzs7OztBQUdBLFdBQVM4YixZQUFULENBQ0V4bkIsS0FERixFQUVFeW5CLE9BRkYsRUFHRTtBQUNBLFFBQUlubkIsTUFBTSxHQUFHLEtBQUtvbkIsWUFBTCxLQUFzQixLQUFLQSxZQUFMLEdBQW9CLEVBQTFDLENBQWI7QUFDQSxRQUFJdmQsSUFBSSxHQUFHN0osTUFBTSxDQUFDTixLQUFELENBQWpCLENBRkEsQ0FHQTtBQUNBOztBQUNBLFFBQUltSyxJQUFJLElBQUksQ0FBQ3NkLE9BQWIsRUFBc0I7QUFDcEIsYUFBT3RkLElBQVA7QUFDRCxLQVBELENBUUE7OztBQUNBQSxRQUFJLEdBQUc3SixNQUFNLENBQUNOLEtBQUQsQ0FBTixHQUFnQixLQUFLMEosUUFBTCxDQUFjaWUsZUFBZCxDQUE4QjNuQixLQUE5QixFQUFxQy9CLElBQXJDLENBQ3JCLEtBQUsrWixZQURnQixFQUVyQixJQUZxQixFQUdyQixJQUhxQixDQUdoQjtBQUhnQixLQUF2QjtBQUtBNFAsY0FBVSxDQUFDemQsSUFBRCxFQUFRLGVBQWVuSyxLQUF2QixFQUErQixLQUEvQixDQUFWO0FBQ0EsV0FBT21LLElBQVA7QUFDRDtBQUVEOzs7Ozs7QUFJQSxXQUFTMGQsUUFBVCxDQUNFMWQsSUFERixFQUVFbkssS0FGRixFQUdFSyxHQUhGLEVBSUU7QUFDQXVuQixjQUFVLENBQUN6ZCxJQUFELEVBQVEsYUFBYW5LLEtBQWIsSUFBc0JLLEdBQUcsR0FBSSxNQUFNQSxHQUFWLEdBQWlCLEVBQTFDLENBQVIsRUFBd0QsSUFBeEQsQ0FBVjtBQUNBLFdBQU84SixJQUFQO0FBQ0Q7O0FBRUQsV0FBU3lkLFVBQVQsQ0FDRXpkLElBREYsRUFFRTlKLEdBRkYsRUFHRXVNLE1BSEYsRUFJRTtBQUNBLFFBQUl6SyxLQUFLLENBQUNzQixPQUFOLENBQWMwRyxJQUFkLENBQUosRUFBeUI7QUFDdkIsV0FBSyxJQUFJM0ssQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJLLElBQUksQ0FBQzFLLE1BQXpCLEVBQWlDRCxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDLFlBQUkySyxJQUFJLENBQUMzSyxDQUFELENBQUosSUFBVyxPQUFPMkssSUFBSSxDQUFDM0ssQ0FBRCxDQUFYLEtBQW1CLFFBQWxDLEVBQTRDO0FBQzFDc29CLHdCQUFjLENBQUMzZCxJQUFJLENBQUMzSyxDQUFELENBQUwsRUFBV2EsR0FBRyxHQUFHLEdBQU4sR0FBWWIsQ0FBdkIsRUFBMkJvTixNQUEzQixDQUFkO0FBQ0Q7QUFDRjtBQUNGLEtBTkQsTUFNTztBQUNMa2Isb0JBQWMsQ0FBQzNkLElBQUQsRUFBTzlKLEdBQVAsRUFBWXVNLE1BQVosQ0FBZDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU2tiLGNBQVQsQ0FBeUIzYSxJQUF6QixFQUErQjlNLEdBQS9CLEVBQW9DdU0sTUFBcEMsRUFBNEM7QUFDMUNPLFFBQUksQ0FBQ1gsUUFBTCxHQUFnQixJQUFoQjtBQUNBVyxRQUFJLENBQUM5TSxHQUFMLEdBQVdBLEdBQVg7QUFDQThNLFFBQUksQ0FBQ1AsTUFBTCxHQUFjQSxNQUFkO0FBQ0Q7QUFFRDs7O0FBRUEsV0FBU21iLG1CQUFULENBQThCcmMsSUFBOUIsRUFBb0NoTyxLQUFwQyxFQUEyQztBQUN6QyxRQUFJQSxLQUFKLEVBQVc7QUFDVCxVQUFJLENBQUNTLGFBQWEsQ0FBQ1QsS0FBRCxDQUFsQixFQUEyQjtBQUN6QiwwQkFBa0IsWUFBbEIsSUFBa0MrSyxJQUFJLENBQ3BDLCtDQURvQyxFQUVwQyxJQUZvQyxDQUF0QztBQUlELE9BTEQsTUFLTztBQUNMLFlBQUl1USxFQUFFLEdBQUd0TixJQUFJLENBQUNzTixFQUFMLEdBQVV0TixJQUFJLENBQUNzTixFQUFMLEdBQVU1VyxNQUFNLENBQUMsRUFBRCxFQUFLc0osSUFBSSxDQUFDc04sRUFBVixDQUFoQixHQUFnQyxFQUFuRDs7QUFDQSxhQUFLLElBQUkzWSxHQUFULElBQWdCM0MsS0FBaEIsRUFBdUI7QUFDckIsY0FBSXNxQixRQUFRLEdBQUdoUCxFQUFFLENBQUMzWSxHQUFELENBQWpCO0FBQ0EsY0FBSTRuQixJQUFJLEdBQUd2cUIsS0FBSyxDQUFDMkMsR0FBRCxDQUFoQjtBQUNBMlksWUFBRSxDQUFDM1ksR0FBRCxDQUFGLEdBQVUybkIsUUFBUSxHQUFHLEdBQUc5a0IsTUFBSCxDQUFVOGtCLFFBQVYsRUFBb0JDLElBQXBCLENBQUgsR0FBK0JBLElBQWpEO0FBQ0Q7QUFDRjtBQUNGOztBQUNELFdBQU92YyxJQUFQO0FBQ0Q7QUFFRDs7O0FBRUEsV0FBU3djLG9CQUFULENBQStCbmQsTUFBL0IsRUFBdUM7QUFDckNBLFVBQU0sQ0FBQ29kLEVBQVAsR0FBWU4sUUFBWjtBQUNBOWMsVUFBTSxDQUFDcWQsRUFBUCxHQUFZcnBCLFFBQVo7QUFDQWdNLFVBQU0sQ0FBQ3NkLEVBQVAsR0FBWXRxQixRQUFaO0FBQ0FnTixVQUFNLENBQUN1ZCxFQUFQLEdBQVl0QyxVQUFaO0FBQ0FqYixVQUFNLENBQUN3ZCxFQUFQLEdBQVl0QyxVQUFaO0FBQ0FsYixVQUFNLENBQUN5ZCxFQUFQLEdBQVlubEIsVUFBWjtBQUNBMEgsVUFBTSxDQUFDMGQsRUFBUCxHQUFZMWtCLFlBQVo7QUFDQWdILFVBQU0sQ0FBQzJkLEVBQVAsR0FBWWxCLFlBQVo7QUFDQXpjLFVBQU0sQ0FBQzRkLEVBQVAsR0FBWWxDLGFBQVo7QUFDQTFiLFVBQU0sQ0FBQzZkLEVBQVAsR0FBWS9CLGFBQVo7QUFDQTliLFVBQU0sQ0FBQzhkLEVBQVAsR0FBWTFCLGVBQVo7QUFDQXBjLFVBQU0sQ0FBQytkLEVBQVAsR0FBWTFiLGVBQVo7QUFDQXJDLFVBQU0sQ0FBQ2dlLEVBQVAsR0FBWTdiLGdCQUFaO0FBQ0FuQyxVQUFNLENBQUNpZSxFQUFQLEdBQVl4TCxrQkFBWjtBQUNBelMsVUFBTSxDQUFDa2UsRUFBUCxHQUFZbEIsbUJBQVo7QUFDRDtBQUVEOzs7QUFFQSxXQUFTbUIsdUJBQVQsQ0FDRXhkLElBREYsRUFFRWdHLEtBRkYsRUFHRS9GLFFBSEYsRUFJRVcsTUFKRixFQUtFeEUsSUFMRixFQU1FO0FBQ0EsUUFBSXlCLE9BQU8sR0FBR3pCLElBQUksQ0FBQ3lCLE9BQW5CLENBREEsQ0FFQTtBQUNBOztBQUNBLFFBQUk0ZixTQUFKOztBQUNBLFFBQUkvb0IsTUFBTSxDQUFDa00sTUFBRCxFQUFTLE1BQVQsQ0FBVixFQUE0QjtBQUMxQjZjLGVBQVMsR0FBR2xzQixNQUFNLENBQUNvQyxNQUFQLENBQWNpTixNQUFkLENBQVosQ0FEMEIsQ0FFMUI7O0FBQ0E2YyxlQUFTLENBQUNDLFNBQVYsR0FBc0I5YyxNQUF0QjtBQUNELEtBSkQsTUFJTztBQUNMO0FBQ0E7QUFDQTtBQUNBNmMsZUFBUyxHQUFHN2MsTUFBWixDQUpLLENBS0w7O0FBQ0FBLFlBQU0sR0FBR0EsTUFBTSxDQUFDOGMsU0FBaEI7QUFDRDs7QUFDRCxRQUFJQyxVQUFVLEdBQUc5ckIsTUFBTSxDQUFDZ00sT0FBTyxDQUFDK2YsU0FBVCxDQUF2QjtBQUNBLFFBQUlDLGlCQUFpQixHQUFHLENBQUNGLFVBQXpCO0FBRUEsU0FBSzNkLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtnRyxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLL0YsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxTQUFLVyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLNlAsU0FBTCxHQUFpQnpRLElBQUksQ0FBQ3NOLEVBQUwsSUFBV2hjLFdBQTVCO0FBQ0EsU0FBS3dzQixVQUFMLEdBQWtCN0QsYUFBYSxDQUFDcGMsT0FBTyxDQUFDcUksTUFBVCxFQUFpQnRGLE1BQWpCLENBQS9COztBQUNBLFNBQUs4USxLQUFMLEdBQWEsWUFBWTtBQUFFLGFBQU9ELFlBQVksQ0FBQ3hSLFFBQUQsRUFBV1csTUFBWCxDQUFuQjtBQUF3QyxLQUFuRSxDQTFCQSxDQTRCQTs7O0FBQ0EsUUFBSStjLFVBQUosRUFBZ0I7QUFDZDtBQUNBLFdBQUszZixRQUFMLEdBQWdCSCxPQUFoQixDQUZjLENBR2Q7O0FBQ0EsV0FBS21YLE1BQUwsR0FBYyxLQUFLdEQsS0FBTCxFQUFkO0FBQ0EsV0FBS2dELFlBQUwsR0FBb0IxVSxJQUFJLENBQUN5VSxXQUFMLElBQW9CbmpCLFdBQXhDO0FBQ0Q7O0FBRUQsUUFBSXVNLE9BQU8sQ0FBQ2tnQixRQUFaLEVBQXNCO0FBQ3BCLFdBQUtDLEVBQUwsR0FBVSxVQUFVbG9CLENBQVYsRUFBYWtCLENBQWIsRUFBZ0IzQixDQUFoQixFQUFtQjRvQixDQUFuQixFQUFzQjtBQUM5QixZQUFJcmMsS0FBSyxHQUFHc2MsYUFBYSxDQUFDVCxTQUFELEVBQVkzbkIsQ0FBWixFQUFla0IsQ0FBZixFQUFrQjNCLENBQWxCLEVBQXFCNG9CLENBQXJCLEVBQXdCSixpQkFBeEIsQ0FBekI7O0FBQ0EsWUFBSWpjLEtBQUssSUFBSSxDQUFDbkwsS0FBSyxDQUFDc0IsT0FBTixDQUFjNkosS0FBZCxDQUFkLEVBQW9DO0FBQ2xDQSxlQUFLLENBQUNsQixTQUFOLEdBQWtCN0MsT0FBTyxDQUFDa2dCLFFBQTFCO0FBQ0FuYyxlQUFLLENBQUNwQixTQUFOLEdBQWtCSSxNQUFsQjtBQUNEOztBQUNELGVBQU9nQixLQUFQO0FBQ0QsT0FQRDtBQVFELEtBVEQsTUFTTztBQUNMLFdBQUtvYyxFQUFMLEdBQVUsVUFBVWxvQixDQUFWLEVBQWFrQixDQUFiLEVBQWdCM0IsQ0FBaEIsRUFBbUI0b0IsQ0FBbkIsRUFBc0I7QUFBRSxlQUFPQyxhQUFhLENBQUNULFNBQUQsRUFBWTNuQixDQUFaLEVBQWVrQixDQUFmLEVBQWtCM0IsQ0FBbEIsRUFBcUI0b0IsQ0FBckIsRUFBd0JKLGlCQUF4QixDQUFwQjtBQUFpRSxPQUFuRztBQUNEO0FBQ0Y7O0FBRURyQixzQkFBb0IsQ0FBQ2dCLHVCQUF1QixDQUFDcHJCLFNBQXpCLENBQXBCOztBQUVBLFdBQVMrckIseUJBQVQsQ0FDRS9oQixJQURGLEVBRUV5SSxTQUZGLEVBR0U3RSxJQUhGLEVBSUV5ZCxTQUpGLEVBS0V4ZCxRQUxGLEVBTUU7QUFDQSxRQUFJcEMsT0FBTyxHQUFHekIsSUFBSSxDQUFDeUIsT0FBbkI7QUFDQSxRQUFJbUksS0FBSyxHQUFHLEVBQVo7QUFDQSxRQUFJMEIsV0FBVyxHQUFHN0osT0FBTyxDQUFDbUksS0FBMUI7O0FBQ0EsUUFBSXBVLEtBQUssQ0FBQzhWLFdBQUQsQ0FBVCxFQUF3QjtBQUN0QixXQUFLLElBQUkvUyxHQUFULElBQWdCK1MsV0FBaEIsRUFBNkI7QUFDM0IxQixhQUFLLENBQUNyUixHQUFELENBQUwsR0FBYThTLFlBQVksQ0FBQzlTLEdBQUQsRUFBTStTLFdBQU4sRUFBbUI3QyxTQUFTLElBQUl2VCxXQUFoQyxDQUF6QjtBQUNEO0FBQ0YsS0FKRCxNQUlPO0FBQ0wsVUFBSU0sS0FBSyxDQUFDb08sSUFBSSxDQUFDa08sS0FBTixDQUFULEVBQXVCO0FBQUVrUSxrQkFBVSxDQUFDcFksS0FBRCxFQUFRaEcsSUFBSSxDQUFDa08sS0FBYixDQUFWO0FBQWdDOztBQUN6RCxVQUFJdGMsS0FBSyxDQUFDb08sSUFBSSxDQUFDZ0csS0FBTixDQUFULEVBQXVCO0FBQUVvWSxrQkFBVSxDQUFDcFksS0FBRCxFQUFRaEcsSUFBSSxDQUFDZ0csS0FBYixDQUFWO0FBQWdDO0FBQzFEOztBQUVELFFBQUlxWSxhQUFhLEdBQUcsSUFBSWIsdUJBQUosQ0FDbEJ4ZCxJQURrQixFQUVsQmdHLEtBRmtCLEVBR2xCL0YsUUFIa0IsRUFJbEJ3ZCxTQUprQixFQUtsQnJoQixJQUxrQixDQUFwQjtBQVFBLFFBQUl3RixLQUFLLEdBQUcvRCxPQUFPLENBQUN1TyxNQUFSLENBQWU3WixJQUFmLENBQW9CLElBQXBCLEVBQTBCOHJCLGFBQWEsQ0FBQ0wsRUFBeEMsRUFBNENLLGFBQTVDLENBQVo7O0FBRUEsUUFBSXpjLEtBQUssWUFBWTlCLEtBQXJCLEVBQTRCO0FBQzFCLGFBQU93ZSw0QkFBNEIsQ0FBQzFjLEtBQUQsRUFBUTVCLElBQVIsRUFBY3FlLGFBQWEsQ0FBQ3pkLE1BQTVCLEVBQW9DL0MsT0FBcEMsQ0FBbkM7QUFDRCxLQUZELE1BRU8sSUFBSXBILEtBQUssQ0FBQ3NCLE9BQU4sQ0FBYzZKLEtBQWQsQ0FBSixFQUEwQjtBQUMvQixVQUFJMmMsTUFBTSxHQUFHOVAsaUJBQWlCLENBQUM3TSxLQUFELENBQWpCLElBQTRCLEVBQXpDO0FBQ0EsVUFBSTlLLEdBQUcsR0FBRyxJQUFJTCxLQUFKLENBQVU4bkIsTUFBTSxDQUFDeHFCLE1BQWpCLENBQVY7O0FBQ0EsV0FBSyxJQUFJRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeXFCLE1BQU0sQ0FBQ3hxQixNQUEzQixFQUFtQ0QsQ0FBQyxFQUFwQyxFQUF3QztBQUN0Q2dELFdBQUcsQ0FBQ2hELENBQUQsQ0FBSCxHQUFTd3FCLDRCQUE0QixDQUFDQyxNQUFNLENBQUN6cUIsQ0FBRCxDQUFQLEVBQVlrTSxJQUFaLEVBQWtCcWUsYUFBYSxDQUFDemQsTUFBaEMsRUFBd0MvQyxPQUF4QyxDQUFyQztBQUNEOztBQUNELGFBQU8vRyxHQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTd25CLDRCQUFULENBQXVDMWMsS0FBdkMsRUFBOEM1QixJQUE5QyxFQUFvRHlkLFNBQXBELEVBQStENWYsT0FBL0QsRUFBd0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsUUFBSTJnQixLQUFLLEdBQUc3YyxVQUFVLENBQUNDLEtBQUQsQ0FBdEI7QUFDQTRjLFNBQUssQ0FBQ2hlLFNBQU4sR0FBa0JpZCxTQUFsQjtBQUNBZSxTQUFLLENBQUMvZCxTQUFOLEdBQWtCNUMsT0FBbEI7O0FBQ0EsUUFBSW1DLElBQUksQ0FBQzJSLElBQVQsRUFBZTtBQUNiLE9BQUM2TSxLQUFLLENBQUN4ZSxJQUFOLEtBQWV3ZSxLQUFLLENBQUN4ZSxJQUFOLEdBQWEsRUFBNUIsQ0FBRCxFQUFrQzJSLElBQWxDLEdBQXlDM1IsSUFBSSxDQUFDMlIsSUFBOUM7QUFDRDs7QUFDRCxXQUFPNk0sS0FBUDtBQUNEOztBQUVELFdBQVNKLFVBQVQsQ0FBcUJ6bkIsRUFBckIsRUFBeUJxTyxJQUF6QixFQUErQjtBQUM3QixTQUFLLElBQUlyUSxHQUFULElBQWdCcVEsSUFBaEIsRUFBc0I7QUFDcEJyTyxRQUFFLENBQUN6QixRQUFRLENBQUNQLEdBQUQsQ0FBVCxDQUFGLEdBQW9CcVEsSUFBSSxDQUFDclEsR0FBRCxDQUF4QjtBQUNEO0FBQ0Y7QUFFRDtBQUtBO0FBQ0E7QUFHQTs7QUFFQTtBQUVBO0FBRUE7O0FBRUE7O0FBRUE7QUFFQTs7O0FBQ0EsTUFBSThwQixtQkFBbUIsR0FBRztBQUN4QkMsUUFBSSxFQUFFLFNBQVNBLElBQVQsQ0FDSjljLEtBREksRUFFSmlSLFNBRkksRUFHSjhMLFNBSEksRUFJSkMsTUFKSSxFQUtKO0FBQ0EsVUFDRWhkLEtBQUssQ0FBQ2pCLGlCQUFOLElBQ0EsQ0FBQ2lCLEtBQUssQ0FBQ2pCLGlCQUFOLENBQXdCOFIsWUFEekIsSUFFQTdRLEtBQUssQ0FBQzVCLElBQU4sQ0FBVzZlLFNBSGIsRUFJRTtBQUNBO0FBQ0EsWUFBSUMsV0FBVyxHQUFHbGQsS0FBbEIsQ0FGQSxDQUV5Qjs7QUFDekI2YywyQkFBbUIsQ0FBQ00sUUFBcEIsQ0FBNkJELFdBQTdCLEVBQTBDQSxXQUExQztBQUNELE9BUkQsTUFRTztBQUNMLFlBQUl4ZCxLQUFLLEdBQUdNLEtBQUssQ0FBQ2pCLGlCQUFOLEdBQTBCcWUsK0JBQStCLENBQ25FcGQsS0FEbUUsRUFFbkVtUSxjQUZtRSxFQUduRTRNLFNBSG1FLEVBSW5FQyxNQUptRSxDQUFyRTtBQU1BdGQsYUFBSyxDQUFDMmQsTUFBTixDQUFhcE0sU0FBUyxHQUFHalIsS0FBSyxDQUFDekIsR0FBVCxHQUFleE8sU0FBckMsRUFBZ0RraEIsU0FBaEQ7QUFDRDtBQUNGLEtBeEJ1QjtBQTBCeEJrTSxZQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFtQkcsUUFBbkIsRUFBNkJ0ZCxLQUE3QixFQUFvQztBQUM1QyxVQUFJL0QsT0FBTyxHQUFHK0QsS0FBSyxDQUFDdkIsZ0JBQXBCO0FBQ0EsVUFBSWlCLEtBQUssR0FBR00sS0FBSyxDQUFDakIsaUJBQU4sR0FBMEJ1ZSxRQUFRLENBQUN2ZSxpQkFBL0M7QUFDQXlULDBCQUFvQixDQUNsQjlTLEtBRGtCLEVBRWxCekQsT0FBTyxDQUFDZ0gsU0FGVSxFQUVDO0FBQ25CaEgsYUFBTyxDQUFDNFMsU0FIVSxFQUdDO0FBQ25CN08sV0FKa0IsRUFJWDtBQUNQL0QsYUFBTyxDQUFDb0MsUUFMVSxDQUtEO0FBTEMsT0FBcEI7QUFPRCxLQXBDdUI7QUFzQ3hCa2YsVUFBTSxFQUFFLFNBQVNBLE1BQVQsQ0FBaUJ2ZCxLQUFqQixFQUF3QjtBQUM5QixVQUFJeEIsT0FBTyxHQUFHd0IsS0FBSyxDQUFDeEIsT0FBcEI7QUFDQSxVQUFJTyxpQkFBaUIsR0FBR2lCLEtBQUssQ0FBQ2pCLGlCQUE5Qjs7QUFDQSxVQUFJLENBQUNBLGlCQUFpQixDQUFDNlIsVUFBdkIsRUFBbUM7QUFDakM3Uix5QkFBaUIsQ0FBQzZSLFVBQWxCLEdBQStCLElBQS9CO0FBQ0FNLGdCQUFRLENBQUNuUyxpQkFBRCxFQUFvQixTQUFwQixDQUFSO0FBQ0Q7O0FBQ0QsVUFBSWlCLEtBQUssQ0FBQzVCLElBQU4sQ0FBVzZlLFNBQWYsRUFBMEI7QUFDeEIsWUFBSXplLE9BQU8sQ0FBQ29TLFVBQVosRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBZ0UsaUNBQXVCLENBQUM3VixpQkFBRCxDQUF2QjtBQUNELFNBUEQsTUFPTztBQUNMdVUsZ0NBQXNCLENBQUN2VSxpQkFBRCxFQUFvQjtBQUFLO0FBQXpCLFdBQXRCO0FBQ0Q7QUFDRjtBQUNGLEtBekR1QjtBQTJEeEJ5ZSxXQUFPLEVBQUUsU0FBU0EsT0FBVCxDQUFrQnhkLEtBQWxCLEVBQXlCO0FBQ2hDLFVBQUlqQixpQkFBaUIsR0FBR2lCLEtBQUssQ0FBQ2pCLGlCQUE5Qjs7QUFDQSxVQUFJLENBQUNBLGlCQUFpQixDQUFDOFIsWUFBdkIsRUFBcUM7QUFDbkMsWUFBSSxDQUFDN1EsS0FBSyxDQUFDNUIsSUFBTixDQUFXNmUsU0FBaEIsRUFBMkI7QUFDekJsZSwyQkFBaUIsQ0FBQzhTLFFBQWxCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wyQixrQ0FBd0IsQ0FBQ3pVLGlCQUFELEVBQW9CO0FBQUs7QUFBekIsV0FBeEI7QUFDRDtBQUNGO0FBQ0Y7QUFwRXVCLEdBQTFCO0FBdUVBLE1BQUkwZSxZQUFZLEdBQUc5dEIsTUFBTSxDQUFDK0YsSUFBUCxDQUFZbW5CLG1CQUFaLENBQW5COztBQUVBLFdBQVNhLGVBQVQsQ0FDRWxqQixJQURGLEVBRUU0RCxJQUZGLEVBR0VJLE9BSEYsRUFJRUgsUUFKRixFQUtFRixHQUxGLEVBTUU7QUFDQSxRQUFJdE8sT0FBTyxDQUFDMkssSUFBRCxDQUFYLEVBQW1CO0FBQ2pCO0FBQ0Q7O0FBRUQsUUFBSW1ULFFBQVEsR0FBR25QLE9BQU8sQ0FBQ3BDLFFBQVIsQ0FBaUJ1aEIsS0FBaEMsQ0FMQSxDQU9BOztBQUNBLFFBQUl0dEIsUUFBUSxDQUFDbUssSUFBRCxDQUFaLEVBQW9CO0FBQ2xCQSxVQUFJLEdBQUdtVCxRQUFRLENBQUM3WSxNQUFULENBQWdCMEYsSUFBaEIsQ0FBUDtBQUNELEtBVkQsQ0FZQTtBQUNBOzs7QUFDQSxRQUFJLE9BQU9BLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUI7QUFDRVcsWUFBSSxDQUFFLG1DQUFvQ2hLLE1BQU0sQ0FBQ3FKLElBQUQsQ0FBNUMsRUFBc0RnRSxPQUF0RCxDQUFKO0FBQ0Q7QUFDRDtBQUNELEtBbkJELENBcUJBOzs7QUFDQSxRQUFJRSxZQUFKOztBQUNBLFFBQUk3TyxPQUFPLENBQUMySyxJQUFJLENBQUMwQixHQUFOLENBQVgsRUFBdUI7QUFDckJ3QyxrQkFBWSxHQUFHbEUsSUFBZjtBQUNBQSxVQUFJLEdBQUdrVCxxQkFBcUIsQ0FBQ2hQLFlBQUQsRUFBZWlQLFFBQWYsRUFBeUJuUCxPQUF6QixDQUE1Qjs7QUFDQSxVQUFJaEUsSUFBSSxLQUFLekssU0FBYixFQUF3QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFPMGQsc0JBQXNCLENBQzNCL08sWUFEMkIsRUFFM0JOLElBRjJCLEVBRzNCSSxPQUgyQixFQUkzQkgsUUFKMkIsRUFLM0JGLEdBTDJCLENBQTdCO0FBT0Q7QUFDRjs7QUFFREMsUUFBSSxHQUFHQSxJQUFJLElBQUksRUFBZixDQXhDQSxDQTBDQTtBQUNBOztBQUNBd2YsNkJBQXlCLENBQUNwakIsSUFBRCxDQUF6QixDQTVDQSxDQThDQTs7QUFDQSxRQUFJeEssS0FBSyxDQUFDb08sSUFBSSxDQUFDeWYsS0FBTixDQUFULEVBQXVCO0FBQ3JCQyxvQkFBYyxDQUFDdGpCLElBQUksQ0FBQ3lCLE9BQU4sRUFBZW1DLElBQWYsQ0FBZDtBQUNELEtBakRELENBbURBOzs7QUFDQSxRQUFJNkUsU0FBUyxHQUFHb0oseUJBQXlCLENBQUNqTyxJQUFELEVBQU81RCxJQUFQLEVBQWEyRCxHQUFiLENBQXpDLENBcERBLENBc0RBOztBQUNBLFFBQUlsTyxNQUFNLENBQUN1SyxJQUFJLENBQUN5QixPQUFMLENBQWE4aEIsVUFBZCxDQUFWLEVBQXFDO0FBQ25DLGFBQU94Qix5QkFBeUIsQ0FBQy9oQixJQUFELEVBQU95SSxTQUFQLEVBQWtCN0UsSUFBbEIsRUFBd0JJLE9BQXhCLEVBQWlDSCxRQUFqQyxDQUFoQztBQUNELEtBekRELENBMkRBO0FBQ0E7OztBQUNBLFFBQUl3USxTQUFTLEdBQUd6USxJQUFJLENBQUNzTixFQUFyQixDQTdEQSxDQThEQTtBQUNBOztBQUNBdE4sUUFBSSxDQUFDc04sRUFBTCxHQUFVdE4sSUFBSSxDQUFDNGYsUUFBZjs7QUFFQSxRQUFJL3RCLE1BQU0sQ0FBQ3VLLElBQUksQ0FBQ3lCLE9BQUwsQ0FBYXFVLFFBQWQsQ0FBVixFQUFtQztBQUNqQztBQUNBO0FBRUE7QUFDQSxVQUFJUCxJQUFJLEdBQUczUixJQUFJLENBQUMyUixJQUFoQjtBQUNBM1IsVUFBSSxHQUFHLEVBQVA7O0FBQ0EsVUFBSTJSLElBQUosRUFBVTtBQUNSM1IsWUFBSSxDQUFDMlIsSUFBTCxHQUFZQSxJQUFaO0FBQ0Q7QUFDRixLQTVFRCxDQThFQTs7O0FBQ0FrTyx5QkFBcUIsQ0FBQzdmLElBQUQsQ0FBckIsQ0EvRUEsQ0FpRkE7O0FBQ0EsUUFBSTlCLElBQUksR0FBRzlCLElBQUksQ0FBQ3lCLE9BQUwsQ0FBYUssSUFBYixJQUFxQjZCLEdBQWhDO0FBQ0EsUUFBSTZCLEtBQUssR0FBRyxJQUFJOUIsS0FBSixDQUNULG1CQUFvQjFELElBQUksQ0FBQzBCLEdBQXpCLElBQWlDSSxJQUFJLEdBQUksTUFBTUEsSUFBVixHQUFrQixFQUF2RCxDQURTLEVBRVY4QixJQUZVLEVBRUpyTyxTQUZJLEVBRU9BLFNBRlAsRUFFa0JBLFNBRmxCLEVBRTZCeU8sT0FGN0IsRUFHVjtBQUFFaEUsVUFBSSxFQUFFQSxJQUFSO0FBQWN5SSxlQUFTLEVBQUVBLFNBQXpCO0FBQW9DNEwsZUFBUyxFQUFFQSxTQUEvQztBQUEwRDFRLFNBQUcsRUFBRUEsR0FBL0Q7QUFBb0VFLGNBQVEsRUFBRUE7QUFBOUUsS0FIVSxFQUlWSyxZQUpVLENBQVosQ0FuRkEsQ0EwRkE7QUFDQTtBQUNBOztBQUNBOztBQUNBLFdBQU9zQixLQUFQO0FBQ0Q7O0FBRUQsV0FBU29kLCtCQUFULENBQ0VwZCxLQURGLEVBQ1M7QUFDUGhCLFFBRkYsRUFFVTtBQUNSK2QsV0FIRixFQUlFQyxNQUpGLEVBS0U7QUFDQSxRQUFJL2dCLE9BQU8sR0FBRztBQUNaaWlCLGtCQUFZLEVBQUUsSUFERjtBQUVabGYsWUFBTSxFQUFFQSxNQUZJO0FBR1orVCxrQkFBWSxFQUFFL1MsS0FIRjtBQUlaeVIsZ0JBQVUsRUFBRXNMLFNBQVMsSUFBSSxJQUpiO0FBS1pyTCxhQUFPLEVBQUVzTCxNQUFNLElBQUk7QUFMUCxLQUFkLENBREEsQ0FRQTs7QUFDQSxRQUFJbUIsY0FBYyxHQUFHbmUsS0FBSyxDQUFDNUIsSUFBTixDQUFXK2YsY0FBaEM7O0FBQ0EsUUFBSW51QixLQUFLLENBQUNtdUIsY0FBRCxDQUFULEVBQTJCO0FBQ3pCbGlCLGFBQU8sQ0FBQ3VPLE1BQVIsR0FBaUIyVCxjQUFjLENBQUMzVCxNQUFoQztBQUNBdk8sYUFBTyxDQUFDb2UsZUFBUixHQUEwQjhELGNBQWMsQ0FBQzlELGVBQXpDO0FBQ0Q7O0FBQ0QsV0FBTyxJQUFJcmEsS0FBSyxDQUFDdkIsZ0JBQU4sQ0FBdUJqRSxJQUEzQixDQUFnQ3lCLE9BQWhDLENBQVA7QUFDRDs7QUFFRCxXQUFTZ2lCLHFCQUFULENBQWdDN2YsSUFBaEMsRUFBc0M7QUFDcEMsUUFBSXFKLEtBQUssR0FBR3JKLElBQUksQ0FBQzJGLElBQUwsS0FBYzNGLElBQUksQ0FBQzJGLElBQUwsR0FBWSxFQUExQixDQUFaOztBQUNBLFNBQUssSUFBSTdSLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1ckIsWUFBWSxDQUFDdHJCLE1BQWpDLEVBQXlDRCxDQUFDLEVBQTFDLEVBQThDO0FBQzVDLFVBQUlhLEdBQUcsR0FBRzBxQixZQUFZLENBQUN2ckIsQ0FBRCxDQUF0QjtBQUNBdVYsV0FBSyxDQUFDMVUsR0FBRCxDQUFMLEdBQWE4cEIsbUJBQW1CLENBQUM5cEIsR0FBRCxDQUFoQztBQUNEO0FBQ0YsR0Evc0lvQixDQWl0SXJCO0FBQ0E7OztBQUNBLFdBQVMrcUIsY0FBVCxDQUF5QjdoQixPQUF6QixFQUFrQ21DLElBQWxDLEVBQXdDO0FBQ3RDLFFBQUkySCxJQUFJLEdBQUk5SixPQUFPLENBQUM0aEIsS0FBUixJQUFpQjVoQixPQUFPLENBQUM0aEIsS0FBUixDQUFjOVgsSUFBaEMsSUFBeUMsT0FBcEQ7QUFDQSxRQUFJK0YsS0FBSyxHQUFJN1AsT0FBTyxDQUFDNGhCLEtBQVIsSUFBaUI1aEIsT0FBTyxDQUFDNGhCLEtBQVIsQ0FBYy9SLEtBQWhDLElBQTBDLE9BQXREO0FBQThELEtBQUMxTixJQUFJLENBQUNnRyxLQUFMLEtBQWVoRyxJQUFJLENBQUNnRyxLQUFMLEdBQWEsRUFBNUIsQ0FBRCxFQUFrQzJCLElBQWxDLElBQTBDM0gsSUFBSSxDQUFDeWYsS0FBTCxDQUFXenRCLEtBQXJEO0FBQzlELFFBQUlzYixFQUFFLEdBQUd0TixJQUFJLENBQUNzTixFQUFMLEtBQVl0TixJQUFJLENBQUNzTixFQUFMLEdBQVUsRUFBdEIsQ0FBVDs7QUFDQSxRQUFJMWIsS0FBSyxDQUFDMGIsRUFBRSxDQUFDSSxLQUFELENBQUgsQ0FBVCxFQUFzQjtBQUNwQkosUUFBRSxDQUFDSSxLQUFELENBQUYsR0FBWSxDQUFDMU4sSUFBSSxDQUFDeWYsS0FBTCxDQUFXTyxRQUFaLEVBQXNCeG9CLE1BQXRCLENBQTZCOFYsRUFBRSxDQUFDSSxLQUFELENBQS9CLENBQVo7QUFDRCxLQUZELE1BRU87QUFDTEosUUFBRSxDQUFDSSxLQUFELENBQUYsR0FBWTFOLElBQUksQ0FBQ3lmLEtBQUwsQ0FBV08sUUFBdkI7QUFDRDtBQUNGO0FBRUQ7OztBQUVBLE1BQUlDLGdCQUFnQixHQUFHLENBQXZCO0FBQ0EsTUFBSUMsZ0JBQWdCLEdBQUcsQ0FBdkIsQ0FqdUlxQixDQW11SXJCO0FBQ0E7O0FBQ0EsV0FBU2hDLGFBQVQsQ0FDRTlkLE9BREYsRUFFRUwsR0FGRixFQUdFQyxJQUhGLEVBSUVDLFFBSkYsRUFLRWtnQixpQkFMRixFQU1FQyxlQU5GLEVBT0U7QUFDQSxRQUFJM3BCLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY2lJLElBQWQsS0FBdUJqTyxXQUFXLENBQUNpTyxJQUFELENBQXRDLEVBQThDO0FBQzVDbWdCLHVCQUFpQixHQUFHbGdCLFFBQXBCO0FBQ0FBLGNBQVEsR0FBR0QsSUFBWDtBQUNBQSxVQUFJLEdBQUdyTyxTQUFQO0FBQ0Q7O0FBQ0QsUUFBSUUsTUFBTSxDQUFDdXVCLGVBQUQsQ0FBVixFQUE2QjtBQUMzQkQsdUJBQWlCLEdBQUdELGdCQUFwQjtBQUNEOztBQUNELFdBQU9HLGNBQWMsQ0FBQ2pnQixPQUFELEVBQVVMLEdBQVYsRUFBZUMsSUFBZixFQUFxQkMsUUFBckIsRUFBK0JrZ0IsaUJBQS9CLENBQXJCO0FBQ0Q7O0FBRUQsV0FBU0UsY0FBVCxDQUNFamdCLE9BREYsRUFFRUwsR0FGRixFQUdFQyxJQUhGLEVBSUVDLFFBSkYsRUFLRWtnQixpQkFMRixFQU1FO0FBQ0EsUUFBSXZ1QixLQUFLLENBQUNvTyxJQUFELENBQUwsSUFBZXBPLEtBQUssQ0FBRW9PLElBQUQsQ0FBT3lDLE1BQVIsQ0FBeEIsRUFBeUM7QUFDdkMsd0JBQWtCLFlBQWxCLElBQWtDMUYsSUFBSSxDQUNwQyxxREFBc0Q1SixJQUFJLENBQUNDLFNBQUwsQ0FBZTRNLElBQWYsQ0FBdEQsR0FBOEUsSUFBOUUsR0FDQSx3REFGb0MsRUFHcENJLE9BSG9DLENBQXRDO0FBS0EsYUFBT29CLGdCQUFnQixFQUF2QjtBQUNELEtBUkQsQ0FTQTs7O0FBQ0EsUUFBSTVQLEtBQUssQ0FBQ29PLElBQUQsQ0FBTCxJQUFlcE8sS0FBSyxDQUFDb08sSUFBSSxDQUFDc2dCLEVBQU4sQ0FBeEIsRUFBbUM7QUFDakN2Z0IsU0FBRyxHQUFHQyxJQUFJLENBQUNzZ0IsRUFBWDtBQUNEOztBQUNELFFBQUksQ0FBQ3ZnQixHQUFMLEVBQVU7QUFDUjtBQUNBLGFBQU95QixnQkFBZ0IsRUFBdkI7QUFDRCxLQWhCRCxDQWlCQTs7O0FBQ0EsUUFBSSxrQkFBa0IsWUFBbEIsSUFDRjVQLEtBQUssQ0FBQ29PLElBQUQsQ0FESCxJQUNhcE8sS0FBSyxDQUFDb08sSUFBSSxDQUFDckwsR0FBTixDQURsQixJQUNnQyxDQUFDNUMsV0FBVyxDQUFDaU8sSUFBSSxDQUFDckwsR0FBTixDQURoRCxFQUVFO0FBQ0E7QUFDRW9JLFlBQUksQ0FDRiw2Q0FDQSxrQ0FGRSxFQUdGcUQsT0FIRSxDQUFKO0FBS0Q7QUFDRixLQTVCRCxDQTZCQTs7O0FBQ0EsUUFBSTNKLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY2tJLFFBQWQsS0FDRixPQUFPQSxRQUFRLENBQUMsQ0FBRCxDQUFmLEtBQXVCLFVBRHpCLEVBRUU7QUFDQUQsVUFBSSxHQUFHQSxJQUFJLElBQUksRUFBZjtBQUNBQSxVQUFJLENBQUN5VSxXQUFMLEdBQW1CO0FBQUVyTSxlQUFPLEVBQUVuSSxRQUFRLENBQUMsQ0FBRDtBQUFuQixPQUFuQjtBQUNBQSxjQUFRLENBQUNsTSxNQUFULEdBQWtCLENBQWxCO0FBQ0Q7O0FBQ0QsUUFBSW9zQixpQkFBaUIsS0FBS0QsZ0JBQTFCLEVBQTRDO0FBQzFDamdCLGNBQVEsR0FBR3dPLGlCQUFpQixDQUFDeE8sUUFBRCxDQUE1QjtBQUNELEtBRkQsTUFFTyxJQUFJa2dCLGlCQUFpQixLQUFLRixnQkFBMUIsRUFBNEM7QUFDakRoZ0IsY0FBUSxHQUFHdU8sdUJBQXVCLENBQUN2TyxRQUFELENBQWxDO0FBQ0Q7O0FBQ0QsUUFBSTJCLEtBQUosRUFBV3JCLEVBQVg7O0FBQ0EsUUFBSSxPQUFPUixHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsVUFBSTNELElBQUo7QUFDQW1FLFFBQUUsR0FBSUgsT0FBTyxDQUFDb1QsTUFBUixJQUFrQnBULE9BQU8sQ0FBQ29ULE1BQVIsQ0FBZWpULEVBQWxDLElBQXlDNUgsTUFBTSxDQUFDYSxlQUFQLENBQXVCdUcsR0FBdkIsQ0FBOUM7O0FBQ0EsVUFBSXBILE1BQU0sQ0FBQ1UsYUFBUCxDQUFxQjBHLEdBQXJCLENBQUosRUFBK0I7QUFDN0I7QUFDQTZCLGFBQUssR0FBRyxJQUFJOUIsS0FBSixDQUNObkgsTUFBTSxDQUFDYyxvQkFBUCxDQUE0QnNHLEdBQTVCLENBRE0sRUFDNEJDLElBRDVCLEVBQ2tDQyxRQURsQyxFQUVOdE8sU0FGTSxFQUVLQSxTQUZMLEVBRWdCeU8sT0FGaEIsQ0FBUjtBQUlELE9BTkQsTUFNTyxJQUFJeE8sS0FBSyxDQUFDd0ssSUFBSSxHQUFHZ0wsWUFBWSxDQUFDaEgsT0FBTyxDQUFDcEMsUUFBVCxFQUFtQixZQUFuQixFQUFpQytCLEdBQWpDLENBQXBCLENBQVQsRUFBcUU7QUFDMUU7QUFDQTZCLGFBQUssR0FBRzBkLGVBQWUsQ0FBQ2xqQixJQUFELEVBQU80RCxJQUFQLEVBQWFJLE9BQWIsRUFBc0JILFFBQXRCLEVBQWdDRixHQUFoQyxDQUF2QjtBQUNELE9BSE0sTUFHQTtBQUNMO0FBQ0E7QUFDQTtBQUNBNkIsYUFBSyxHQUFHLElBQUk5QixLQUFKLENBQ05DLEdBRE0sRUFDREMsSUFEQyxFQUNLQyxRQURMLEVBRU50TyxTQUZNLEVBRUtBLFNBRkwsRUFFZ0J5TyxPQUZoQixDQUFSO0FBSUQ7QUFDRixLQXJCRCxNQXFCTztBQUNMO0FBQ0F3QixXQUFLLEdBQUcwZCxlQUFlLENBQUN2ZixHQUFELEVBQU1DLElBQU4sRUFBWUksT0FBWixFQUFxQkgsUUFBckIsQ0FBdkI7QUFDRDs7QUFDRCxRQUFJeEosS0FBSyxDQUFDc0IsT0FBTixDQUFjNkosS0FBZCxDQUFKLEVBQTBCO0FBQ3hCLGFBQU9BLEtBQVA7QUFDRCxLQUZELE1BRU8sSUFBSWhRLEtBQUssQ0FBQ2dRLEtBQUQsQ0FBVCxFQUFrQjtBQUN2QixVQUFJaFEsS0FBSyxDQUFDMk8sRUFBRCxDQUFULEVBQWU7QUFBRWdnQixlQUFPLENBQUMzZSxLQUFELEVBQVFyQixFQUFSLENBQVA7QUFBcUI7O0FBQ3RDLFVBQUkzTyxLQUFLLENBQUNvTyxJQUFELENBQVQsRUFBaUI7QUFBRXdnQiw0QkFBb0IsQ0FBQ3hnQixJQUFELENBQXBCO0FBQTZCOztBQUNoRCxhQUFPNEIsS0FBUDtBQUNELEtBSk0sTUFJQTtBQUNMLGFBQU9KLGdCQUFnQixFQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsV0FBUytlLE9BQVQsQ0FBa0IzZSxLQUFsQixFQUF5QnJCLEVBQXpCLEVBQTZCa2dCLEtBQTdCLEVBQW9DO0FBQ2xDN2UsU0FBSyxDQUFDckIsRUFBTixHQUFXQSxFQUFYOztBQUNBLFFBQUlxQixLQUFLLENBQUM3QixHQUFOLEtBQWMsZUFBbEIsRUFBbUM7QUFDakM7QUFDQVEsUUFBRSxHQUFHNU8sU0FBTDtBQUNBOHVCLFdBQUssR0FBRyxJQUFSO0FBQ0Q7O0FBQ0QsUUFBSTd1QixLQUFLLENBQUNnUSxLQUFLLENBQUMzQixRQUFQLENBQVQsRUFBMkI7QUFDekIsV0FBSyxJQUFJbk0sQ0FBQyxHQUFHLENBQVIsRUFBV2lDLENBQUMsR0FBRzZMLEtBQUssQ0FBQzNCLFFBQU4sQ0FBZWxNLE1BQW5DLEVBQTJDRCxDQUFDLEdBQUdpQyxDQUEvQyxFQUFrRGpDLENBQUMsRUFBbkQsRUFBdUQ7QUFDckQsWUFBSXdOLEtBQUssR0FBR00sS0FBSyxDQUFDM0IsUUFBTixDQUFlbk0sQ0FBZixDQUFaOztBQUNBLFlBQUlsQyxLQUFLLENBQUMwUCxLQUFLLENBQUN2QixHQUFQLENBQUwsS0FDRnRPLE9BQU8sQ0FBQzZQLEtBQUssQ0FBQ2YsRUFBUCxDQUFQLElBQXNCMU8sTUFBTSxDQUFDNHVCLEtBQUQsQ0FBTixJQUFpQm5mLEtBQUssQ0FBQ3ZCLEdBQU4sS0FBYyxLQURuRCxDQUFKLEVBQ2dFO0FBQzlEd2dCLGlCQUFPLENBQUNqZixLQUFELEVBQVFmLEVBQVIsRUFBWWtnQixLQUFaLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRixHQTcxSW9CLENBKzFJckI7QUFDQTtBQUNBOzs7QUFDQSxXQUFTRCxvQkFBVCxDQUErQnhnQixJQUEvQixFQUFxQztBQUNuQyxRQUFJL04sUUFBUSxDQUFDK04sSUFBSSxDQUFDMGdCLEtBQU4sQ0FBWixFQUEwQjtBQUN4QmxVLGNBQVEsQ0FBQ3hNLElBQUksQ0FBQzBnQixLQUFOLENBQVI7QUFDRDs7QUFDRCxRQUFJenVCLFFBQVEsQ0FBQytOLElBQUksQ0FBQzJnQixLQUFOLENBQVosRUFBMEI7QUFDeEJuVSxjQUFRLENBQUN4TSxJQUFJLENBQUMyZ0IsS0FBTixDQUFSO0FBQ0Q7QUFDRjtBQUVEOzs7QUFFQSxXQUFTQyxVQUFULENBQXFCcGpCLEVBQXJCLEVBQXlCO0FBQ3ZCQSxNQUFFLENBQUMwVixNQUFILEdBQVksSUFBWixDQUR1QixDQUNMOztBQUNsQjFWLE1BQUUsQ0FBQ3dlLFlBQUgsR0FBa0IsSUFBbEIsQ0FGdUIsQ0FFQzs7QUFDeEIsUUFBSW5lLE9BQU8sR0FBR0wsRUFBRSxDQUFDUSxRQUFqQjtBQUNBLFFBQUlxVyxXQUFXLEdBQUc3VyxFQUFFLENBQUNnVyxNQUFILEdBQVkzVixPQUFPLENBQUM4VyxZQUF0QyxDQUp1QixDQUk2Qjs7QUFDcEQsUUFBSTBKLGFBQWEsR0FBR2hLLFdBQVcsSUFBSUEsV0FBVyxDQUFDalUsT0FBL0M7QUFDQTVDLE1BQUUsQ0FBQ3dYLE1BQUgsR0FBWXZELFlBQVksQ0FBQzVULE9BQU8sQ0FBQzJXLGVBQVQsRUFBMEI2SixhQUExQixDQUF4QjtBQUNBN2dCLE1BQUUsQ0FBQ2tYLFlBQUgsR0FBa0JwakIsV0FBbEIsQ0FQdUIsQ0FRdkI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0FrTSxNQUFFLENBQUN3Z0IsRUFBSCxHQUFRLFVBQVVsb0IsQ0FBVixFQUFha0IsQ0FBYixFQUFnQjNCLENBQWhCLEVBQW1CNG9CLENBQW5CLEVBQXNCO0FBQUUsYUFBT0MsYUFBYSxDQUFDMWdCLEVBQUQsRUFBSzFILENBQUwsRUFBUWtCLENBQVIsRUFBVzNCLENBQVgsRUFBYzRvQixDQUFkLEVBQWlCLEtBQWpCLENBQXBCO0FBQThDLEtBQTlFLENBWnVCLENBYXZCO0FBQ0E7OztBQUNBemdCLE1BQUUsQ0FBQ3NkLGNBQUgsR0FBb0IsVUFBVWhsQixDQUFWLEVBQWFrQixDQUFiLEVBQWdCM0IsQ0FBaEIsRUFBbUI0b0IsQ0FBbkIsRUFBc0I7QUFBRSxhQUFPQyxhQUFhLENBQUMxZ0IsRUFBRCxFQUFLMUgsQ0FBTCxFQUFRa0IsQ0FBUixFQUFXM0IsQ0FBWCxFQUFjNG9CLENBQWQsRUFBaUIsSUFBakIsQ0FBcEI7QUFBNkMsS0FBekYsQ0FmdUIsQ0FpQnZCO0FBQ0E7OztBQUNBLFFBQUk0QyxVQUFVLEdBQUd4TSxXQUFXLElBQUlBLFdBQVcsQ0FBQ3JVLElBQTVDO0FBRUE7O0FBQ0E7QUFDRXVELG9CQUFjLENBQUMvRixFQUFELEVBQUssUUFBTCxFQUFlcWpCLFVBQVUsSUFBSUEsVUFBVSxDQUFDM1MsS0FBekIsSUFBa0M1YyxXQUFqRCxFQUE4RCxZQUFZO0FBQ3RGLFNBQUMwZ0Isd0JBQUQsSUFBNkJqVixJQUFJLENBQUMscUJBQUQsRUFBd0JTLEVBQXhCLENBQWpDO0FBQ0QsT0FGYSxFQUVYLElBRlcsQ0FBZDtBQUdBK0Ysb0JBQWMsQ0FBQy9GLEVBQUQsRUFBSyxZQUFMLEVBQW1CSyxPQUFPLENBQUM2UyxnQkFBUixJQUE0QnBmLFdBQS9DLEVBQTRELFlBQVk7QUFDcEYsU0FBQzBnQix3QkFBRCxJQUE2QmpWLElBQUksQ0FBQyx5QkFBRCxFQUE0QlMsRUFBNUIsQ0FBakM7QUFDRCxPQUZhLEVBRVgsSUFGVyxDQUFkO0FBR0Q7QUFDRjs7QUFFRCxXQUFTc2pCLFdBQVQsQ0FBc0I1UCxHQUF0QixFQUEyQjtBQUN6QjtBQUNBc0wsd0JBQW9CLENBQUN0TCxHQUFHLENBQUM5ZSxTQUFMLENBQXBCOztBQUVBOGUsT0FBRyxDQUFDOWUsU0FBSixDQUFjMnVCLFNBQWQsR0FBMEIsVUFBVWxzQixFQUFWLEVBQWM7QUFDdEMsYUFBT21XLFFBQVEsQ0FBQ25XLEVBQUQsRUFBSyxJQUFMLENBQWY7QUFDRCxLQUZEOztBQUlBcWMsT0FBRyxDQUFDOWUsU0FBSixDQUFjOGhCLE9BQWQsR0FBd0IsWUFBWTtBQUNsQyxVQUFJMVcsRUFBRSxHQUFHLElBQVQ7QUFDQSxVQUFJd2pCLEdBQUcsR0FBR3hqQixFQUFFLENBQUNRLFFBQWI7QUFDQSxVQUFJb08sTUFBTSxHQUFHNFUsR0FBRyxDQUFDNVUsTUFBakI7QUFDQSxVQUFJdUksWUFBWSxHQUFHcU0sR0FBRyxDQUFDck0sWUFBdkIsQ0FKa0MsQ0FNbEM7O0FBQ0E7QUFDRSxhQUFLLElBQUloZ0IsR0FBVCxJQUFnQjZJLEVBQUUsQ0FBQ3dYLE1BQW5CLEVBQTJCO0FBQ3pCO0FBQ0F4WCxZQUFFLENBQUN3WCxNQUFILENBQVVyZ0IsR0FBVixFQUFla21CLFNBQWYsR0FBMkIsS0FBM0I7QUFDRDtBQUNGOztBQUVELFVBQUlsRyxZQUFKLEVBQWtCO0FBQ2hCblgsVUFBRSxDQUFDa1gsWUFBSCxHQUFrQkMsWUFBWSxDQUFDM1UsSUFBYixDQUFrQnlVLFdBQWxCLElBQWlDbmpCLFdBQW5EO0FBQ0QsT0FoQmlDLENBa0JsQztBQUNBOzs7QUFDQWtNLFFBQUUsQ0FBQ2dXLE1BQUgsR0FBWW1CLFlBQVosQ0FwQmtDLENBcUJsQzs7QUFDQSxVQUFJL1MsS0FBSjs7QUFDQSxVQUFJO0FBQ0ZBLGFBQUssR0FBR3dLLE1BQU0sQ0FBQzdaLElBQVAsQ0FBWWlMLEVBQUUsQ0FBQzhPLFlBQWYsRUFBNkI5TyxFQUFFLENBQUNzZCxjQUFoQyxDQUFSO0FBQ0QsT0FGRCxDQUVFLE9BQU81aUIsQ0FBUCxFQUFVO0FBQ1YrUSxtQkFBVyxDQUFDL1EsQ0FBRCxFQUFJc0YsRUFBSixFQUFRLFFBQVIsQ0FBWCxDQURVLENBRVY7QUFDQTs7QUFDQTs7QUFDQTtBQUNFLGNBQUlBLEVBQUUsQ0FBQ1EsUUFBSCxDQUFZaWpCLFdBQWhCLEVBQTZCO0FBQzNCLGdCQUFJO0FBQ0ZyZixtQkFBSyxHQUFHcEUsRUFBRSxDQUFDUSxRQUFILENBQVlpakIsV0FBWixDQUF3QjF1QixJQUF4QixDQUE2QmlMLEVBQUUsQ0FBQzhPLFlBQWhDLEVBQThDOU8sRUFBRSxDQUFDc2QsY0FBakQsRUFBaUU1aUIsQ0FBakUsQ0FBUjtBQUNELGFBRkQsQ0FFRSxPQUFPQSxDQUFQLEVBQVU7QUFDVitRLHlCQUFXLENBQUMvUSxDQUFELEVBQUlzRixFQUFKLEVBQVEsYUFBUixDQUFYO0FBQ0FvRSxtQkFBSyxHQUFHcEUsRUFBRSxDQUFDMFYsTUFBWDtBQUNEO0FBQ0YsV0FQRCxNQU9PO0FBQ0x0UixpQkFBSyxHQUFHcEUsRUFBRSxDQUFDMFYsTUFBWDtBQUNEO0FBQ0Y7QUFDRixPQTFDaUMsQ0EyQ2xDOzs7QUFDQSxVQUFJLEVBQUV0UixLQUFLLFlBQVk5QixLQUFuQixDQUFKLEVBQStCO0FBQzdCLFlBQUksa0JBQWtCLFlBQWxCLElBQWtDckosS0FBSyxDQUFDc0IsT0FBTixDQUFjNkosS0FBZCxDQUF0QyxFQUE0RDtBQUMxRDdFLGNBQUksQ0FDRix3RUFDQSxtQ0FGRSxFQUdGUyxFQUhFLENBQUo7QUFLRDs7QUFDRG9FLGFBQUssR0FBR0osZ0JBQWdCLEVBQXhCO0FBQ0QsT0FyRGlDLENBc0RsQzs7O0FBQ0FJLFdBQUssQ0FBQ2hCLE1BQU4sR0FBZStULFlBQWY7QUFDQSxhQUFPL1MsS0FBUDtBQUNELEtBekREO0FBMEREO0FBRUQ7OztBQUVBLE1BQUlzZixLQUFLLEdBQUcsQ0FBWjs7QUFFQSxXQUFTQyxTQUFULENBQW9CalEsR0FBcEIsRUFBeUI7QUFDdkJBLE9BQUcsQ0FBQzllLFNBQUosQ0FBY2d2QixLQUFkLEdBQXNCLFVBQVV2akIsT0FBVixFQUFtQjtBQUN2QyxVQUFJTCxFQUFFLEdBQUcsSUFBVCxDQUR1QyxDQUV2Qzs7QUFDQUEsUUFBRSxDQUFDeVcsSUFBSCxHQUFVaU4sS0FBSyxFQUFmO0FBRUEsVUFBSTFWLFFBQUosRUFBY0MsTUFBZDtBQUNBOztBQUNBLFVBQUksa0JBQWtCLFlBQWxCLElBQWtDOVMsTUFBTSxDQUFDSyxXQUF6QyxJQUF3RG1TLElBQTVELEVBQWtFO0FBQ2hFSyxnQkFBUSxHQUFHLG9CQUFxQmhPLEVBQUUsQ0FBQ3lXLElBQW5DO0FBQ0F4SSxjQUFNLEdBQUcsa0JBQW1Cak8sRUFBRSxDQUFDeVcsSUFBL0I7QUFDQTlJLFlBQUksQ0FBQ0ssUUFBRCxDQUFKO0FBQ0QsT0FYc0MsQ0FhdkM7OztBQUNBaE8sUUFBRSxDQUFDTyxNQUFILEdBQVksSUFBWixDQWR1QyxDQWV2Qzs7QUFDQSxVQUFJRixPQUFPLElBQUlBLE9BQU8sQ0FBQ2lpQixZQUF2QixFQUFxQztBQUNuQztBQUNBO0FBQ0E7QUFDQXVCLDZCQUFxQixDQUFDN2pCLEVBQUQsRUFBS0ssT0FBTCxDQUFyQjtBQUNELE9BTEQsTUFLTztBQUNMTCxVQUFFLENBQUNRLFFBQUgsR0FBYzhJLFlBQVksQ0FDeEIwWSx5QkFBeUIsQ0FBQ2hpQixFQUFFLENBQUNTLFdBQUosQ0FERCxFQUV4QkosT0FBTyxJQUFJLEVBRmEsRUFHeEJMLEVBSHdCLENBQTFCO0FBS0Q7QUFDRDs7O0FBQ0E7QUFDRWtPLGlCQUFTLENBQUNsTyxFQUFELENBQVQ7QUFDRCxPQS9Cc0MsQ0FnQ3ZDOztBQUNBQSxRQUFFLENBQUM4akIsS0FBSCxHQUFXOWpCLEVBQVg7QUFDQXlVLG1CQUFhLENBQUN6VSxFQUFELENBQWI7QUFDQThTLGdCQUFVLENBQUM5UyxFQUFELENBQVY7QUFDQW9qQixnQkFBVSxDQUFDcGpCLEVBQUQsQ0FBVjtBQUNBc1YsY0FBUSxDQUFDdFYsRUFBRCxFQUFLLGNBQUwsQ0FBUjtBQUNBd2Msb0JBQWMsQ0FBQ3hjLEVBQUQsQ0FBZCxDQXRDdUMsQ0FzQ25COztBQUNwQnNhLGVBQVMsQ0FBQ3RhLEVBQUQsQ0FBVDtBQUNBc2MsaUJBQVcsQ0FBQ3RjLEVBQUQsQ0FBWCxDQXhDdUMsQ0F3Q3RCOztBQUNqQnNWLGNBQVEsQ0FBQ3RWLEVBQUQsRUFBSyxTQUFMLENBQVI7QUFFQTs7QUFDQSxVQUFJLGtCQUFrQixZQUFsQixJQUFrQzdFLE1BQU0sQ0FBQ0ssV0FBekMsSUFBd0RtUyxJQUE1RCxFQUFrRTtBQUNoRTNOLFVBQUUsQ0FBQ3dXLEtBQUgsR0FBVzlXLG1CQUFtQixDQUFDTSxFQUFELEVBQUssS0FBTCxDQUE5QjtBQUNBMk4sWUFBSSxDQUFDTSxNQUFELENBQUo7QUFDQUwsZUFBTyxDQUFFLFNBQVU1TixFQUFFLENBQUN3VyxLQUFiLEdBQXNCLE9BQXhCLEVBQWtDeEksUUFBbEMsRUFBNENDLE1BQTVDLENBQVA7QUFDRDs7QUFFRCxVQUFJak8sRUFBRSxDQUFDUSxRQUFILENBQVk0RyxFQUFoQixFQUFvQjtBQUNsQnBILFVBQUUsQ0FBQ3loQixNQUFILENBQVV6aEIsRUFBRSxDQUFDUSxRQUFILENBQVk0RyxFQUF0QjtBQUNEO0FBQ0YsS0FyREQ7QUFzREQ7O0FBRUQsV0FBU3ljLHFCQUFULENBQWdDN2pCLEVBQWhDLEVBQW9DSyxPQUFwQyxFQUE2QztBQUMzQyxRQUFJbEMsSUFBSSxHQUFHNkIsRUFBRSxDQUFDUSxRQUFILEdBQWN6TSxNQUFNLENBQUNvQyxNQUFQLENBQWM2SixFQUFFLENBQUNTLFdBQUgsQ0FBZUosT0FBN0IsQ0FBekIsQ0FEMkMsQ0FFM0M7O0FBQ0EsUUFBSXdXLFdBQVcsR0FBR3hXLE9BQU8sQ0FBQzhXLFlBQTFCO0FBQ0FoWixRQUFJLENBQUNpRixNQUFMLEdBQWMvQyxPQUFPLENBQUMrQyxNQUF0QjtBQUNBakYsUUFBSSxDQUFDZ1osWUFBTCxHQUFvQk4sV0FBcEI7QUFDQTFZLFFBQUksQ0FBQzBYLFVBQUwsR0FBa0J4VixPQUFPLENBQUN3VixVQUExQjtBQUNBMVgsUUFBSSxDQUFDMlgsT0FBTCxHQUFlelYsT0FBTyxDQUFDeVYsT0FBdkI7QUFFQSxRQUFJaU8scUJBQXFCLEdBQUdsTixXQUFXLENBQUNoVSxnQkFBeEM7QUFDQTFFLFFBQUksQ0FBQ2tKLFNBQUwsR0FBaUIwYyxxQkFBcUIsQ0FBQzFjLFNBQXZDO0FBQ0FsSixRQUFJLENBQUMrVSxnQkFBTCxHQUF3QjZRLHFCQUFxQixDQUFDOVEsU0FBOUM7QUFDQTlVLFFBQUksQ0FBQzZZLGVBQUwsR0FBdUIrTSxxQkFBcUIsQ0FBQ3RoQixRQUE3QztBQUNBdEUsUUFBSSxDQUFDd0MsYUFBTCxHQUFxQm9qQixxQkFBcUIsQ0FBQ3hoQixHQUEzQzs7QUFFQSxRQUFJbEMsT0FBTyxDQUFDdU8sTUFBWixFQUFvQjtBQUNsQnpRLFVBQUksQ0FBQ3lRLE1BQUwsR0FBY3ZPLE9BQU8sQ0FBQ3VPLE1BQXRCO0FBQ0F6USxVQUFJLENBQUNzZ0IsZUFBTCxHQUF1QnBlLE9BQU8sQ0FBQ29lLGVBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTdUQseUJBQVQsQ0FBb0NwakIsSUFBcEMsRUFBMEM7QUFDeEMsUUFBSXlCLE9BQU8sR0FBR3pCLElBQUksQ0FBQ3lCLE9BQW5COztBQUNBLFFBQUl6QixJQUFJLENBQUNvbEIsS0FBVCxFQUFnQjtBQUNkLFVBQUlDLFlBQVksR0FBR2pDLHlCQUF5QixDQUFDcGpCLElBQUksQ0FBQ29sQixLQUFOLENBQTVDO0FBQ0EsVUFBSUUsa0JBQWtCLEdBQUd0bEIsSUFBSSxDQUFDcWxCLFlBQTlCOztBQUNBLFVBQUlBLFlBQVksS0FBS0Msa0JBQXJCLEVBQXlDO0FBQ3ZDO0FBQ0E7QUFDQXRsQixZQUFJLENBQUNxbEIsWUFBTCxHQUFvQkEsWUFBcEIsQ0FIdUMsQ0FJdkM7O0FBQ0EsWUFBSUUsZUFBZSxHQUFHQyxzQkFBc0IsQ0FBQ3hsQixJQUFELENBQTVDLENBTHVDLENBTXZDOztBQUNBLFlBQUl1bEIsZUFBSixFQUFxQjtBQUNuQmpyQixnQkFBTSxDQUFDMEYsSUFBSSxDQUFDeWxCLGFBQU4sRUFBcUJGLGVBQXJCLENBQU47QUFDRDs7QUFDRDlqQixlQUFPLEdBQUd6QixJQUFJLENBQUN5QixPQUFMLEdBQWVpSixZQUFZLENBQUMyYSxZQUFELEVBQWVybEIsSUFBSSxDQUFDeWxCLGFBQXBCLENBQXJDOztBQUNBLFlBQUloa0IsT0FBTyxDQUFDSyxJQUFaLEVBQWtCO0FBQ2hCTCxpQkFBTyxDQUFDeUksVUFBUixDQUFtQnpJLE9BQU8sQ0FBQ0ssSUFBM0IsSUFBbUM5QixJQUFuQztBQUNEO0FBQ0Y7QUFDRjs7QUFDRCxXQUFPeUIsT0FBUDtBQUNEOztBQUVELFdBQVMrakIsc0JBQVQsQ0FBaUN4bEIsSUFBakMsRUFBdUM7QUFDckMsUUFBSTBsQixRQUFKO0FBQ0EsUUFBSUMsTUFBTSxHQUFHM2xCLElBQUksQ0FBQ3lCLE9BQWxCO0FBQ0EsUUFBSW1rQixRQUFRLEdBQUc1bEIsSUFBSSxDQUFDeWxCLGFBQXBCO0FBQ0EsUUFBSUksTUFBTSxHQUFHN2xCLElBQUksQ0FBQzhsQixhQUFsQjs7QUFDQSxTQUFLLElBQUl2dEIsR0FBVCxJQUFnQm90QixNQUFoQixFQUF3QjtBQUN0QixVQUFJQSxNQUFNLENBQUNwdEIsR0FBRCxDQUFOLEtBQWdCc3RCLE1BQU0sQ0FBQ3R0QixHQUFELENBQTFCLEVBQWlDO0FBQy9CLFlBQUksQ0FBQ210QixRQUFMLEVBQWU7QUFBRUEsa0JBQVEsR0FBRyxFQUFYO0FBQWdCOztBQUNqQ0EsZ0JBQVEsQ0FBQ250QixHQUFELENBQVIsR0FBZ0J3dEIsTUFBTSxDQUFDSixNQUFNLENBQUNwdEIsR0FBRCxDQUFQLEVBQWNxdEIsUUFBUSxDQUFDcnRCLEdBQUQsQ0FBdEIsRUFBNkJzdEIsTUFBTSxDQUFDdHRCLEdBQUQsQ0FBbkMsQ0FBdEI7QUFDRDtBQUNGOztBQUNELFdBQU9tdEIsUUFBUDtBQUNEOztBQUVELFdBQVNLLE1BQVQsQ0FBaUJKLE1BQWpCLEVBQXlCQyxRQUF6QixFQUFtQ0MsTUFBbkMsRUFBMkM7QUFDekM7QUFDQTtBQUNBLFFBQUl4ckIsS0FBSyxDQUFDc0IsT0FBTixDQUFjZ3FCLE1BQWQsQ0FBSixFQUEyQjtBQUN6QixVQUFJanJCLEdBQUcsR0FBRyxFQUFWO0FBQ0FtckIsWUFBTSxHQUFHeHJCLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY2txQixNQUFkLElBQXdCQSxNQUF4QixHQUFpQyxDQUFDQSxNQUFELENBQTFDO0FBQ0FELGNBQVEsR0FBR3ZyQixLQUFLLENBQUNzQixPQUFOLENBQWNpcUIsUUFBZCxJQUEwQkEsUUFBMUIsR0FBcUMsQ0FBQ0EsUUFBRCxDQUFoRDs7QUFDQSxXQUFLLElBQUlsdUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2l1QixNQUFNLENBQUNodUIsTUFBM0IsRUFBbUNELENBQUMsRUFBcEMsRUFBd0M7QUFDdEM7QUFDQSxZQUFJa3VCLFFBQVEsQ0FBQ3p0QixPQUFULENBQWlCd3RCLE1BQU0sQ0FBQ2p1QixDQUFELENBQXZCLEtBQStCLENBQS9CLElBQW9DbXVCLE1BQU0sQ0FBQzF0QixPQUFQLENBQWV3dEIsTUFBTSxDQUFDanVCLENBQUQsQ0FBckIsSUFBNEIsQ0FBcEUsRUFBdUU7QUFDckVnRCxhQUFHLENBQUM4SCxJQUFKLENBQVNtakIsTUFBTSxDQUFDanVCLENBQUQsQ0FBZjtBQUNEO0FBQ0Y7O0FBQ0QsYUFBT2dELEdBQVA7QUFDRCxLQVhELE1BV087QUFDTCxhQUFPaXJCLE1BQVA7QUFDRDtBQUNGOztBQUVELFdBQVM3USxHQUFULENBQWNyVCxPQUFkLEVBQXVCO0FBQ3JCLFFBQUksa0JBQWtCLFlBQWxCLElBQ0YsRUFBRSxnQkFBZ0JxVCxHQUFsQixDQURGLEVBRUU7QUFDQW5VLFVBQUksQ0FBQyxrRUFBRCxDQUFKO0FBQ0Q7O0FBQ0QsU0FBS3FrQixLQUFMLENBQVd2akIsT0FBWDtBQUNEOztBQUVEc2pCLFdBQVMsQ0FBQ2pRLEdBQUQsQ0FBVDtBQUNBb0ksWUFBVSxDQUFDcEksR0FBRCxDQUFWO0FBQ0FELGFBQVcsQ0FBQ0MsR0FBRCxDQUFYO0FBQ0F5QixnQkFBYyxDQUFDekIsR0FBRCxDQUFkO0FBQ0E0UCxhQUFXLENBQUM1UCxHQUFELENBQVg7QUFFQTs7QUFFQSxXQUFTa1IsT0FBVCxDQUFrQmxSLEdBQWxCLEVBQXVCO0FBQ3JCQSxPQUFHLENBQUNtUixHQUFKLEdBQVUsVUFBVUMsTUFBVixFQUFrQjtBQUMxQixVQUFJQyxnQkFBZ0IsR0FBSSxLQUFLQyxpQkFBTCxLQUEyQixLQUFLQSxpQkFBTCxHQUF5QixFQUFwRCxDQUF4Qjs7QUFDQSxVQUFJRCxnQkFBZ0IsQ0FBQ2h1QixPQUFqQixDQUF5Qit0QixNQUF6QixJQUFtQyxDQUFDLENBQXhDLEVBQTJDO0FBQ3pDLGVBQU8sSUFBUDtBQUNELE9BSnlCLENBTTFCOzs7QUFDQSxVQUFJamdCLElBQUksR0FBRy9MLE9BQU8sQ0FBQ04sU0FBRCxFQUFZLENBQVosQ0FBbEI7QUFDQXFNLFVBQUksQ0FBQ29nQixPQUFMLENBQWEsSUFBYjs7QUFDQSxVQUFJLE9BQU9ILE1BQU0sQ0FBQ0ksT0FBZCxLQUEwQixVQUE5QixFQUEwQztBQUN4Q0osY0FBTSxDQUFDSSxPQUFQLENBQWV6c0IsS0FBZixDQUFxQnFzQixNQUFyQixFQUE2QmpnQixJQUE3QjtBQUNELE9BRkQsTUFFTyxJQUFJLE9BQU9pZ0IsTUFBUCxLQUFrQixVQUF0QixFQUFrQztBQUN2Q0EsY0FBTSxDQUFDcnNCLEtBQVAsQ0FBYSxJQUFiLEVBQW1Cb00sSUFBbkI7QUFDRDs7QUFDRGtnQixzQkFBZ0IsQ0FBQzNqQixJQUFqQixDQUFzQjBqQixNQUF0QjtBQUNBLGFBQU8sSUFBUDtBQUNELEtBaEJEO0FBaUJEO0FBRUQ7OztBQUVBLFdBQVNLLFdBQVQsQ0FBc0J6UixHQUF0QixFQUEyQjtBQUN6QkEsT0FBRyxDQUFDMFIsS0FBSixHQUFZLFVBQVVBLEtBQVYsRUFBaUI7QUFDM0IsV0FBSy9rQixPQUFMLEdBQWVpSixZQUFZLENBQUMsS0FBS2pKLE9BQU4sRUFBZStrQixLQUFmLENBQTNCO0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0FIRDtBQUlEO0FBRUQ7OztBQUVBLFdBQVNDLFVBQVQsQ0FBcUIzUixHQUFyQixFQUEwQjtBQUN4Qjs7Ozs7QUFLQUEsT0FBRyxDQUFDcFQsR0FBSixHQUFVLENBQVY7QUFDQSxRQUFJQSxHQUFHLEdBQUcsQ0FBVjtBQUVBOzs7O0FBR0FvVCxPQUFHLENBQUN4YSxNQUFKLEdBQWEsVUFBVW1yQixhQUFWLEVBQXlCO0FBQ3BDQSxtQkFBYSxHQUFHQSxhQUFhLElBQUksRUFBakM7QUFDQSxVQUFJaUIsS0FBSyxHQUFHLElBQVo7QUFDQSxVQUFJQyxPQUFPLEdBQUdELEtBQUssQ0FBQ2hsQixHQUFwQjtBQUNBLFVBQUlrbEIsV0FBVyxHQUFHbkIsYUFBYSxDQUFDb0IsS0FBZCxLQUF3QnBCLGFBQWEsQ0FBQ29CLEtBQWQsR0FBc0IsRUFBOUMsQ0FBbEI7O0FBQ0EsVUFBSUQsV0FBVyxDQUFDRCxPQUFELENBQWYsRUFBMEI7QUFDeEIsZUFBT0MsV0FBVyxDQUFDRCxPQUFELENBQWxCO0FBQ0Q7O0FBRUQsVUFBSTdrQixJQUFJLEdBQUcyakIsYUFBYSxDQUFDM2pCLElBQWQsSUFBc0I0a0IsS0FBSyxDQUFDamxCLE9BQU4sQ0FBY0ssSUFBL0M7O0FBQ0EsVUFBSSxrQkFBa0IsWUFBbEIsSUFBa0NBLElBQXRDLEVBQTRDO0FBQzFDcUksNkJBQXFCLENBQUNySSxJQUFELENBQXJCO0FBQ0Q7O0FBRUQsVUFBSWdsQixHQUFHLEdBQUcsU0FBU0MsWUFBVCxDQUF1QnRsQixPQUF2QixFQUFnQztBQUN4QyxhQUFLdWpCLEtBQUwsQ0FBV3ZqQixPQUFYO0FBQ0QsT0FGRDs7QUFHQXFsQixTQUFHLENBQUM5d0IsU0FBSixHQUFnQmIsTUFBTSxDQUFDb0MsTUFBUCxDQUFjbXZCLEtBQUssQ0FBQzF3QixTQUFwQixDQUFoQjtBQUNBOHdCLFNBQUcsQ0FBQzl3QixTQUFKLENBQWM2TCxXQUFkLEdBQTRCaWxCLEdBQTVCO0FBQ0FBLFNBQUcsQ0FBQ3BsQixHQUFKLEdBQVVBLEdBQUcsRUFBYjtBQUNBb2xCLFNBQUcsQ0FBQ3JsQixPQUFKLEdBQWNpSixZQUFZLENBQ3hCZ2MsS0FBSyxDQUFDamxCLE9BRGtCLEVBRXhCZ2tCLGFBRndCLENBQTFCO0FBSUFxQixTQUFHLENBQUMsT0FBRCxDQUFILEdBQWVKLEtBQWYsQ0F4Qm9DLENBMEJwQztBQUNBO0FBQ0E7O0FBQ0EsVUFBSUksR0FBRyxDQUFDcmxCLE9BQUosQ0FBWW1JLEtBQWhCLEVBQXVCO0FBQ3JCb2QsbUJBQVcsQ0FBQ0YsR0FBRCxDQUFYO0FBQ0Q7O0FBQ0QsVUFBSUEsR0FBRyxDQUFDcmxCLE9BQUosQ0FBWXNJLFFBQWhCLEVBQTBCO0FBQ3hCa2Qsc0JBQWMsQ0FBQ0gsR0FBRCxDQUFkO0FBQ0QsT0FsQ21DLENBb0NwQzs7O0FBQ0FBLFNBQUcsQ0FBQ3hzQixNQUFKLEdBQWFvc0IsS0FBSyxDQUFDcHNCLE1BQW5CO0FBQ0F3c0IsU0FBRyxDQUFDTixLQUFKLEdBQVlFLEtBQUssQ0FBQ0YsS0FBbEI7QUFDQU0sU0FBRyxDQUFDYixHQUFKLEdBQVVTLEtBQUssQ0FBQ1QsR0FBaEIsQ0F2Q29DLENBeUNwQztBQUNBOztBQUNBNXBCLGlCQUFXLENBQUN3SixPQUFaLENBQW9CLFVBQVU2RCxJQUFWLEVBQWdCO0FBQ2xDb2QsV0FBRyxDQUFDcGQsSUFBRCxDQUFILEdBQVlnZCxLQUFLLENBQUNoZCxJQUFELENBQWpCO0FBQ0QsT0FGRCxFQTNDb0MsQ0E4Q3BDOztBQUNBLFVBQUk1SCxJQUFKLEVBQVU7QUFDUmdsQixXQUFHLENBQUNybEIsT0FBSixDQUFZeUksVUFBWixDQUF1QnBJLElBQXZCLElBQStCZ2xCLEdBQS9CO0FBQ0QsT0FqRG1DLENBbURwQztBQUNBO0FBQ0E7OztBQUNBQSxTQUFHLENBQUN6QixZQUFKLEdBQW1CcUIsS0FBSyxDQUFDamxCLE9BQXpCO0FBQ0FxbEIsU0FBRyxDQUFDckIsYUFBSixHQUFvQkEsYUFBcEI7QUFDQXFCLFNBQUcsQ0FBQ2hCLGFBQUosR0FBb0J4ckIsTUFBTSxDQUFDLEVBQUQsRUFBS3dzQixHQUFHLENBQUNybEIsT0FBVCxDQUExQixDQXhEb0MsQ0EwRHBDOztBQUNBbWxCLGlCQUFXLENBQUNELE9BQUQsQ0FBWCxHQUF1QkcsR0FBdkI7QUFDQSxhQUFPQSxHQUFQO0FBQ0QsS0E3REQ7QUE4REQ7O0FBRUQsV0FBU0UsV0FBVCxDQUFzQkUsSUFBdEIsRUFBNEI7QUFDMUIsUUFBSXRkLEtBQUssR0FBR3NkLElBQUksQ0FBQ3psQixPQUFMLENBQWFtSSxLQUF6Qjs7QUFDQSxTQUFLLElBQUlyUixHQUFULElBQWdCcVIsS0FBaEIsRUFBdUI7QUFDckIwUixXQUFLLENBQUM0TCxJQUFJLENBQUNseEIsU0FBTixFQUFpQixRQUFqQixFQUEyQnVDLEdBQTNCLENBQUw7QUFDRDtBQUNGOztBQUVELFdBQVMwdUIsY0FBVCxDQUF5QkMsSUFBekIsRUFBK0I7QUFDN0IsUUFBSW5kLFFBQVEsR0FBR21kLElBQUksQ0FBQ3psQixPQUFMLENBQWFzSSxRQUE1Qjs7QUFDQSxTQUFLLElBQUl4UixHQUFULElBQWdCd1IsUUFBaEIsRUFBMEI7QUFDeEIyUyxvQkFBYyxDQUFDd0ssSUFBSSxDQUFDbHhCLFNBQU4sRUFBaUJ1QyxHQUFqQixFQUFzQndSLFFBQVEsQ0FBQ3hSLEdBQUQsQ0FBOUIsQ0FBZDtBQUNEO0FBQ0Y7QUFFRDs7O0FBRUEsV0FBUzR1QixrQkFBVCxDQUE2QnJTLEdBQTdCLEVBQWtDO0FBQ2hDOzs7QUFHQXpZLGVBQVcsQ0FBQ3dKLE9BQVosQ0FBb0IsVUFBVTZELElBQVYsRUFBZ0I7QUFDbENvTCxTQUFHLENBQUNwTCxJQUFELENBQUgsR0FBWSxVQUNWL0csRUFEVSxFQUVWeWtCLFVBRlUsRUFHVjtBQUNBLFlBQUksQ0FBQ0EsVUFBTCxFQUFpQjtBQUNmLGlCQUFPLEtBQUszbEIsT0FBTCxDQUFhaUksSUFBSSxHQUFHLEdBQXBCLEVBQXlCL0csRUFBekIsQ0FBUDtBQUNELFNBRkQsTUFFTztBQUNMO0FBQ0EsY0FBSSxrQkFBa0IsWUFBbEIsSUFBa0MrRyxJQUFJLEtBQUssV0FBL0MsRUFBNEQ7QUFDMURTLGlDQUFxQixDQUFDeEgsRUFBRCxDQUFyQjtBQUNEOztBQUNELGNBQUkrRyxJQUFJLEtBQUssV0FBVCxJQUF3QnJULGFBQWEsQ0FBQyt3QixVQUFELENBQXpDLEVBQXVEO0FBQ3JEQSxzQkFBVSxDQUFDdGxCLElBQVgsR0FBa0JzbEIsVUFBVSxDQUFDdGxCLElBQVgsSUFBbUJhLEVBQXJDO0FBQ0F5a0Isc0JBQVUsR0FBRyxLQUFLM2xCLE9BQUwsQ0FBYTBoQixLQUFiLENBQW1CN29CLE1BQW5CLENBQTBCOHNCLFVBQTFCLENBQWI7QUFDRDs7QUFDRCxjQUFJMWQsSUFBSSxLQUFLLFdBQVQsSUFBd0IsT0FBTzBkLFVBQVAsS0FBc0IsVUFBbEQsRUFBOEQ7QUFDNURBLHNCQUFVLEdBQUc7QUFBRXB0QixrQkFBSSxFQUFFb3RCLFVBQVI7QUFBb0Joa0Isb0JBQU0sRUFBRWdrQjtBQUE1QixhQUFiO0FBQ0Q7O0FBQ0QsZUFBSzNsQixPQUFMLENBQWFpSSxJQUFJLEdBQUcsR0FBcEIsRUFBeUIvRyxFQUF6QixJQUErQnlrQixVQUEvQjtBQUNBLGlCQUFPQSxVQUFQO0FBQ0Q7QUFDRixPQXJCRDtBQXNCRCxLQXZCRDtBQXdCRDtBQUVEOzs7QUFFQSxXQUFTQyxnQkFBVCxDQUEyQjluQixJQUEzQixFQUFpQztBQUMvQixXQUFPQSxJQUFJLEtBQUtBLElBQUksQ0FBQ1MsSUFBTCxDQUFVeUIsT0FBVixDQUFrQkssSUFBbEIsSUFBMEJ2QyxJQUFJLENBQUNvRSxHQUFwQyxDQUFYO0FBQ0Q7O0FBRUQsV0FBUzJqQixPQUFULENBQWtCQyxPQUFsQixFQUEyQnpsQixJQUEzQixFQUFpQztBQUMvQixRQUFJekgsS0FBSyxDQUFDc0IsT0FBTixDQUFjNHJCLE9BQWQsQ0FBSixFQUE0QjtBQUMxQixhQUFPQSxPQUFPLENBQUNwdkIsT0FBUixDQUFnQjJKLElBQWhCLElBQXdCLENBQUMsQ0FBaEM7QUFDRCxLQUZELE1BRU8sSUFBSSxPQUFPeWxCLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDdEMsYUFBT0EsT0FBTyxDQUFDOXZCLEtBQVIsQ0FBYyxHQUFkLEVBQW1CVSxPQUFuQixDQUEyQjJKLElBQTNCLElBQW1DLENBQUMsQ0FBM0M7QUFDRCxLQUZNLE1BRUEsSUFBSXhMLFFBQVEsQ0FBQ2l4QixPQUFELENBQVosRUFBdUI7QUFDNUIsYUFBT0EsT0FBTyxDQUFDcnBCLElBQVIsQ0FBYTRELElBQWIsQ0FBUDtBQUNEO0FBQ0Q7OztBQUNBLFdBQU8sS0FBUDtBQUNEOztBQUVELFdBQVMwbEIsVUFBVCxDQUFxQkMsaUJBQXJCLEVBQXdDM0osTUFBeEMsRUFBZ0Q7QUFDOUMsUUFBSXBsQixLQUFLLEdBQUcrdUIsaUJBQWlCLENBQUMvdUIsS0FBOUI7QUFDQSxRQUFJd0MsSUFBSSxHQUFHdXNCLGlCQUFpQixDQUFDdnNCLElBQTdCO0FBQ0EsUUFBSTRiLE1BQU0sR0FBRzJRLGlCQUFpQixDQUFDM1EsTUFBL0I7O0FBQ0EsU0FBSyxJQUFJdmUsR0FBVCxJQUFnQkcsS0FBaEIsRUFBdUI7QUFDckIsVUFBSWd2QixVQUFVLEdBQUdodkIsS0FBSyxDQUFDSCxHQUFELENBQXRCOztBQUNBLFVBQUltdkIsVUFBSixFQUFnQjtBQUNkLFlBQUk1bEIsSUFBSSxHQUFHdWxCLGdCQUFnQixDQUFDSyxVQUFVLENBQUN6akIsZ0JBQVosQ0FBM0I7O0FBQ0EsWUFBSW5DLElBQUksSUFBSSxDQUFDZ2MsTUFBTSxDQUFDaGMsSUFBRCxDQUFuQixFQUEyQjtBQUN6QjZsQix5QkFBZSxDQUFDanZCLEtBQUQsRUFBUUgsR0FBUixFQUFhMkMsSUFBYixFQUFtQjRiLE1BQW5CLENBQWY7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTNlEsZUFBVCxDQUNFanZCLEtBREYsRUFFRUgsR0FGRixFQUdFMkMsSUFIRixFQUlFMHNCLE9BSkYsRUFLRTtBQUNBLFFBQUlDLFNBQVMsR0FBR252QixLQUFLLENBQUNILEdBQUQsQ0FBckI7O0FBQ0EsUUFBSXN2QixTQUFTLEtBQUssQ0FBQ0QsT0FBRCxJQUFZQyxTQUFTLENBQUNsa0IsR0FBVixLQUFrQmlrQixPQUFPLENBQUNqa0IsR0FBM0MsQ0FBYixFQUE4RDtBQUM1RGtrQixlQUFTLENBQUN0akIsaUJBQVYsQ0FBNEI4UyxRQUE1QjtBQUNEOztBQUNEM2UsU0FBSyxDQUFDSCxHQUFELENBQUwsR0FBYSxJQUFiO0FBQ0FSLFVBQU0sQ0FBQ21ELElBQUQsRUFBTzNDLEdBQVAsQ0FBTjtBQUNEOztBQUVELE1BQUl1dkIsWUFBWSxHQUFHLENBQUNueEIsTUFBRCxFQUFTb3hCLE1BQVQsRUFBaUIxdEIsS0FBakIsQ0FBbkI7QUFFQSxNQUFJMnRCLFNBQVMsR0FBRztBQUNkbG1CLFFBQUksRUFBRSxZQURRO0FBRWRnVSxZQUFRLEVBQUUsSUFGSTtBQUlkbE0sU0FBSyxFQUFFO0FBQ0xxZSxhQUFPLEVBQUVILFlBREo7QUFFTEksYUFBTyxFQUFFSixZQUZKO0FBR0x6ZixTQUFHLEVBQUUsQ0FBQzFSLE1BQUQsRUFBU3d4QixNQUFUO0FBSEEsS0FKTztBQVVkQyxXQUFPLEVBQUUsU0FBU0EsT0FBVCxHQUFvQjtBQUMzQixXQUFLMXZCLEtBQUwsR0FBYXZELE1BQU0sQ0FBQ29DLE1BQVAsQ0FBYyxJQUFkLENBQWI7QUFDQSxXQUFLMkQsSUFBTCxHQUFZLEVBQVo7QUFDRCxLQWJhO0FBZWRtdEIsYUFBUyxFQUFFLFNBQVNBLFNBQVQsR0FBc0I7QUFDL0IsVUFBSXJULE1BQU0sR0FBRyxJQUFiOztBQUVBLFdBQUssSUFBSXpjLEdBQVQsSUFBZ0J5YyxNQUFNLENBQUN0YyxLQUF2QixFQUE4QjtBQUM1Qml2Qix1QkFBZSxDQUFDM1MsTUFBTSxDQUFDdGMsS0FBUixFQUFlSCxHQUFmLEVBQW9CeWMsTUFBTSxDQUFDOVosSUFBM0IsQ0FBZjtBQUNEO0FBQ0YsS0FyQmE7QUF1QmRvdEIsV0FBTyxFQUFFLFNBQVNBLE9BQVQsR0FBb0I7QUFDM0IsVUFBSXRULE1BQU0sR0FBRyxJQUFiO0FBRUEsV0FBS2lJLE1BQUwsQ0FBWSxTQUFaLEVBQXVCLFVBQVV6bUIsR0FBVixFQUFlO0FBQ3BDZ3hCLGtCQUFVLENBQUN4UyxNQUFELEVBQVMsVUFBVWxULElBQVYsRUFBZ0I7QUFBRSxpQkFBT3dsQixPQUFPLENBQUM5d0IsR0FBRCxFQUFNc0wsSUFBTixDQUFkO0FBQTRCLFNBQXZELENBQVY7QUFDRCxPQUZEO0FBR0EsV0FBS21iLE1BQUwsQ0FBWSxTQUFaLEVBQXVCLFVBQVV6bUIsR0FBVixFQUFlO0FBQ3BDZ3hCLGtCQUFVLENBQUN4UyxNQUFELEVBQVMsVUFBVWxULElBQVYsRUFBZ0I7QUFBRSxpQkFBTyxDQUFDd2xCLE9BQU8sQ0FBQzl3QixHQUFELEVBQU1zTCxJQUFOLENBQWY7QUFBNkIsU0FBeEQsQ0FBVjtBQUNELE9BRkQ7QUFHRCxLQWhDYTtBQWtDZGtPLFVBQU0sRUFBRSxTQUFTQSxNQUFULEdBQW1CO0FBQ3pCLFVBQUl1RixJQUFJLEdBQUcsS0FBS3FELE1BQUwsQ0FBWTVNLE9BQXZCO0FBQ0EsVUFBSXhHLEtBQUssR0FBR3lPLHNCQUFzQixDQUFDc0IsSUFBRCxDQUFsQztBQUNBLFVBQUl0UixnQkFBZ0IsR0FBR3VCLEtBQUssSUFBSUEsS0FBSyxDQUFDdkIsZ0JBQXRDOztBQUNBLFVBQUlBLGdCQUFKLEVBQXNCO0FBQ3BCO0FBQ0EsWUFBSW5DLElBQUksR0FBR3VsQixnQkFBZ0IsQ0FBQ3BqQixnQkFBRCxDQUEzQjtBQUNBLFlBQUkyZ0IsR0FBRyxHQUFHLElBQVY7QUFDQSxZQUFJcUQsT0FBTyxHQUFHckQsR0FBRyxDQUFDcUQsT0FBbEI7QUFDQSxZQUFJQyxPQUFPLEdBQUd0RCxHQUFHLENBQUNzRCxPQUFsQjs7QUFDQSxhQUNFO0FBQ0NELGVBQU8sS0FBSyxDQUFDbm1CLElBQUQsSUFBUyxDQUFDd2xCLE9BQU8sQ0FBQ1csT0FBRCxFQUFVbm1CLElBQVYsQ0FBdEIsQ0FBUixJQUNBO0FBQ0NvbUIsZUFBTyxJQUFJcG1CLElBQVgsSUFBbUJ3bEIsT0FBTyxDQUFDWSxPQUFELEVBQVVwbUIsSUFBVixDQUo3QixFQUtFO0FBQ0EsaUJBQU8wRCxLQUFQO0FBQ0Q7O0FBRUQsWUFBSStpQixLQUFLLEdBQUcsSUFBWjtBQUNBLFlBQUk3dkIsS0FBSyxHQUFHNnZCLEtBQUssQ0FBQzd2QixLQUFsQjtBQUNBLFlBQUl3QyxJQUFJLEdBQUdxdEIsS0FBSyxDQUFDcnRCLElBQWpCO0FBQ0EsWUFBSTNDLEdBQUcsR0FBR2lOLEtBQUssQ0FBQ2pOLEdBQU4sSUFBYSxJQUFiLENBQ1I7QUFDQTtBQUZRLFVBR04wTCxnQkFBZ0IsQ0FBQ2pFLElBQWpCLENBQXNCMEIsR0FBdEIsSUFBNkJ1QyxnQkFBZ0IsQ0FBQ04sR0FBakIsR0FBd0IsT0FBUU0sZ0JBQWdCLENBQUNOLEdBQWpELEdBQXlELEVBQXRGLENBSE0sR0FJTjZCLEtBQUssQ0FBQ2pOLEdBSlY7O0FBS0EsWUFBSUcsS0FBSyxDQUFDSCxHQUFELENBQVQsRUFBZ0I7QUFDZGlOLGVBQUssQ0FBQ2pCLGlCQUFOLEdBQTBCN0wsS0FBSyxDQUFDSCxHQUFELENBQUwsQ0FBV2dNLGlCQUFyQyxDQURjLENBRWQ7O0FBQ0F4TSxnQkFBTSxDQUFDbUQsSUFBRCxFQUFPM0MsR0FBUCxDQUFOO0FBQ0EyQyxjQUFJLENBQUNzSCxJQUFMLENBQVVqSyxHQUFWO0FBQ0QsU0FMRCxNQUtPO0FBQ0xHLGVBQUssQ0FBQ0gsR0FBRCxDQUFMLEdBQWFpTixLQUFiO0FBQ0F0SyxjQUFJLENBQUNzSCxJQUFMLENBQVVqSyxHQUFWLEVBRkssQ0FHTDs7QUFDQSxjQUFJLEtBQUs4UCxHQUFMLElBQVluTixJQUFJLENBQUN2RCxNQUFMLEdBQWM2d0IsUUFBUSxDQUFDLEtBQUtuZ0IsR0FBTixDQUF0QyxFQUFrRDtBQUNoRHNmLDJCQUFlLENBQUNqdkIsS0FBRCxFQUFRd0MsSUFBSSxDQUFDLENBQUQsQ0FBWixFQUFpQkEsSUFBakIsRUFBdUIsS0FBSzRiLE1BQTVCLENBQWY7QUFDRDtBQUNGOztBQUVEdFIsYUFBSyxDQUFDNUIsSUFBTixDQUFXNmUsU0FBWCxHQUF1QixJQUF2QjtBQUNEOztBQUNELGFBQU9qZCxLQUFLLElBQUsrUCxJQUFJLElBQUlBLElBQUksQ0FBQyxDQUFELENBQTdCO0FBQ0Q7QUE5RWEsR0FBaEI7QUFpRkEsTUFBSWtULGlCQUFpQixHQUFHO0FBQ3RCVCxhQUFTLEVBQUVBO0FBR2I7O0FBSndCLEdBQXhCOztBQU1BLFdBQVNVLGFBQVQsQ0FBd0I1VCxHQUF4QixFQUE2QjtBQUMzQjtBQUNBLFFBQUk2VCxTQUFTLEdBQUcsRUFBaEI7O0FBQ0FBLGFBQVMsQ0FBQ25wQixHQUFWLEdBQWdCLFlBQVk7QUFBRSxhQUFPakQsTUFBUDtBQUFnQixLQUE5Qzs7QUFDQTtBQUNFb3NCLGVBQVMsQ0FBQ3BvQixHQUFWLEdBQWdCLFlBQVk7QUFDMUJJLFlBQUksQ0FDRixzRUFERSxDQUFKO0FBR0QsT0FKRDtBQUtEO0FBQ0R4TCxVQUFNLENBQUN5SSxjQUFQLENBQXNCa1gsR0FBdEIsRUFBMkIsUUFBM0IsRUFBcUM2VCxTQUFyQyxFQVgyQixDQWEzQjtBQUNBO0FBQ0E7O0FBQ0E3VCxPQUFHLENBQUM4VCxJQUFKLEdBQVc7QUFDVGpvQixVQUFJLEVBQUVBLElBREc7QUFFVHJHLFlBQU0sRUFBRUEsTUFGQztBQUdUb1Esa0JBQVksRUFBRUEsWUFITDtBQUlUdkQsb0JBQWMsRUFBRUE7QUFKUCxLQUFYO0FBT0EyTixPQUFHLENBQUN2VSxHQUFKLEdBQVVBLEdBQVY7QUFDQXVVLE9BQUcsQ0FBQytULE1BQUosR0FBYXZnQixHQUFiO0FBQ0F3TSxPQUFHLENBQUNsRyxRQUFKLEdBQWVBLFFBQWY7QUFFQWtHLE9BQUcsQ0FBQ3JULE9BQUosR0FBY3RNLE1BQU0sQ0FBQ29DLE1BQVAsQ0FBYyxJQUFkLENBQWQ7QUFDQThFLGVBQVcsQ0FBQ3dKLE9BQVosQ0FBb0IsVUFBVTZELElBQVYsRUFBZ0I7QUFDbENvTCxTQUFHLENBQUNyVCxPQUFKLENBQVlpSSxJQUFJLEdBQUcsR0FBbkIsSUFBMEJ2VSxNQUFNLENBQUNvQyxNQUFQLENBQWMsSUFBZCxDQUExQjtBQUNELEtBRkQsRUE1QjJCLENBZ0MzQjtBQUNBOztBQUNBdWQsT0FBRyxDQUFDclQsT0FBSixDQUFZMGhCLEtBQVosR0FBb0JyTyxHQUFwQjtBQUVBeGEsVUFBTSxDQUFDd2EsR0FBRyxDQUFDclQsT0FBSixDQUFZeUksVUFBYixFQUF5QnVlLGlCQUF6QixDQUFOO0FBRUF6QyxXQUFPLENBQUNsUixHQUFELENBQVA7QUFDQXlSLGVBQVcsQ0FBQ3pSLEdBQUQsQ0FBWDtBQUNBMlIsY0FBVSxDQUFDM1IsR0FBRCxDQUFWO0FBQ0FxUyxzQkFBa0IsQ0FBQ3JTLEdBQUQsQ0FBbEI7QUFDRDs7QUFFRDRULGVBQWEsQ0FBQzVULEdBQUQsQ0FBYjtBQUVBM2YsUUFBTSxDQUFDeUksY0FBUCxDQUFzQmtYLEdBQUcsQ0FBQzllLFNBQTFCLEVBQXFDLFdBQXJDLEVBQWtEO0FBQ2hEd0osT0FBRyxFQUFFRztBQUQyQyxHQUFsRDtBQUlBeEssUUFBTSxDQUFDeUksY0FBUCxDQUFzQmtYLEdBQUcsQ0FBQzllLFNBQTFCLEVBQXFDLGFBQXJDLEVBQW9EO0FBQ2xEd0osT0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZ0I7QUFDbkI7QUFDQSxhQUFPLEtBQUs0WCxNQUFMLElBQWUsS0FBS0EsTUFBTCxDQUFZMFIsVUFBbEM7QUFDRDtBQUppRCxHQUFwRCxFQWg4SnFCLENBdThKckI7O0FBQ0EzekIsUUFBTSxDQUFDeUksY0FBUCxDQUFzQmtYLEdBQXRCLEVBQTJCLHlCQUEzQixFQUFzRDtBQUNwRGxmLFNBQUssRUFBRXdyQjtBQUQ2QyxHQUF0RDtBQUlBdE0sS0FBRyxDQUFDaVUsT0FBSixHQUFjLFFBQWQ7QUFFQTtBQUVBO0FBQ0E7O0FBQ0EsTUFBSTdyQixjQUFjLEdBQUcvRixPQUFPLENBQUMsYUFBRCxDQUE1QixDQWw5SnFCLENBbzlKckI7O0FBQ0EsTUFBSTZ4QixXQUFXLEdBQUc3eEIsT0FBTyxDQUFDLHVDQUFELENBQXpCOztBQUNBLE1BQUltRyxXQUFXLEdBQUcsVUFBVXFHLEdBQVYsRUFBZStGLElBQWYsRUFBcUJ1ZixJQUFyQixFQUEyQjtBQUMzQyxXQUNHQSxJQUFJLEtBQUssT0FBVCxJQUFvQkQsV0FBVyxDQUFDcmxCLEdBQUQsQ0FBaEMsSUFBMEMrRixJQUFJLEtBQUssUUFBbkQsSUFDQ3VmLElBQUksS0FBSyxVQUFULElBQXVCdGxCLEdBQUcsS0FBSyxRQURoQyxJQUVDc2xCLElBQUksS0FBSyxTQUFULElBQXNCdGxCLEdBQUcsS0FBSyxPQUYvQixJQUdDc2xCLElBQUksS0FBSyxPQUFULElBQW9CdGxCLEdBQUcsS0FBSyxPQUovQjtBQU1ELEdBUEQ7O0FBU0EsTUFBSXVsQixnQkFBZ0IsR0FBRy94QixPQUFPLENBQUMsc0NBQUQsQ0FBOUI7QUFFQSxNQUFJZ3lCLGFBQWEsR0FBR2h5QixPQUFPLENBQ3pCLCtFQUNBLHFFQURBLEdBRUEsa0ZBRkEsR0FHQSw0RUFIQSxHQUlBLGdFQUpBLEdBS0EsaUNBTnlCLENBQTNCO0FBU0EsTUFBSWl5QixPQUFPLEdBQUcsOEJBQWQ7O0FBRUEsTUFBSUMsT0FBTyxHQUFHLFVBQVV2bkIsSUFBVixFQUFnQjtBQUM1QixXQUFPQSxJQUFJLENBQUMxSSxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFuQixJQUEwQjBJLElBQUksQ0FBQzFMLEtBQUwsQ0FBVyxDQUFYLEVBQWMsQ0FBZCxNQUFxQixPQUF0RDtBQUNELEdBRkQ7O0FBSUEsTUFBSWt6QixZQUFZLEdBQUcsVUFBVXhuQixJQUFWLEVBQWdCO0FBQ2pDLFdBQU91bkIsT0FBTyxDQUFDdm5CLElBQUQsQ0FBUCxHQUFnQkEsSUFBSSxDQUFDMUwsS0FBTCxDQUFXLENBQVgsRUFBYzBMLElBQUksQ0FBQ25LLE1BQW5CLENBQWhCLEdBQTZDLEVBQXBEO0FBQ0QsR0FGRDs7QUFJQSxNQUFJNHhCLGdCQUFnQixHQUFHLFVBQVUveUIsR0FBVixFQUFlO0FBQ3BDLFdBQU9BLEdBQUcsSUFBSSxJQUFQLElBQWVBLEdBQUcsS0FBSyxLQUE5QjtBQUNELEdBRkQ7QUFJQTs7O0FBRUEsV0FBU2d6QixnQkFBVCxDQUEyQmhrQixLQUEzQixFQUFrQztBQUNoQyxRQUFJNUIsSUFBSSxHQUFHNEIsS0FBSyxDQUFDNUIsSUFBakI7QUFDQSxRQUFJNmxCLFVBQVUsR0FBR2prQixLQUFqQjtBQUNBLFFBQUlra0IsU0FBUyxHQUFHbGtCLEtBQWhCOztBQUNBLFdBQU9oUSxLQUFLLENBQUNrMEIsU0FBUyxDQUFDbmxCLGlCQUFYLENBQVosRUFBMkM7QUFDekNtbEIsZUFBUyxHQUFHQSxTQUFTLENBQUNubEIsaUJBQVYsQ0FBNEJ1UyxNQUF4Qzs7QUFDQSxVQUFJNFMsU0FBUyxJQUFJQSxTQUFTLENBQUM5bEIsSUFBM0IsRUFBaUM7QUFDL0JBLFlBQUksR0FBRytsQixjQUFjLENBQUNELFNBQVMsQ0FBQzlsQixJQUFYLEVBQWlCQSxJQUFqQixDQUFyQjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT3BPLEtBQUssQ0FBQ2kwQixVQUFVLEdBQUdBLFVBQVUsQ0FBQ2psQixNQUF6QixDQUFaLEVBQThDO0FBQzVDLFVBQUlpbEIsVUFBVSxJQUFJQSxVQUFVLENBQUM3bEIsSUFBN0IsRUFBbUM7QUFDakNBLFlBQUksR0FBRytsQixjQUFjLENBQUMvbEIsSUFBRCxFQUFPNmxCLFVBQVUsQ0FBQzdsQixJQUFsQixDQUFyQjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT2dtQixXQUFXLENBQUNobUIsSUFBSSxDQUFDaW1CLFdBQU4sRUFBbUJqbUIsSUFBSSxDQUFDMmdCLEtBQXhCLENBQWxCO0FBQ0Q7O0FBRUQsV0FBU29GLGNBQVQsQ0FBeUJ6a0IsS0FBekIsRUFBZ0NWLE1BQWhDLEVBQXdDO0FBQ3RDLFdBQU87QUFDTHFsQixpQkFBVyxFQUFFenVCLE1BQU0sQ0FBQzhKLEtBQUssQ0FBQzJrQixXQUFQLEVBQW9CcmxCLE1BQU0sQ0FBQ3FsQixXQUEzQixDQURkO0FBRUx0RixXQUFLLEVBQUUvdUIsS0FBSyxDQUFDMFAsS0FBSyxDQUFDcWYsS0FBUCxDQUFMLEdBQ0gsQ0FBQ3JmLEtBQUssQ0FBQ3FmLEtBQVAsRUFBYy9mLE1BQU0sQ0FBQytmLEtBQXJCLENBREcsR0FFSC9mLE1BQU0sQ0FBQytmO0FBSk4sS0FBUDtBQU1EOztBQUVELFdBQVNxRixXQUFULENBQ0VDLFdBREYsRUFFRUMsWUFGRixFQUdFO0FBQ0EsUUFBSXQwQixLQUFLLENBQUNxMEIsV0FBRCxDQUFMLElBQXNCcjBCLEtBQUssQ0FBQ3MwQixZQUFELENBQS9CLEVBQStDO0FBQzdDLGFBQU8xdUIsTUFBTSxDQUFDeXVCLFdBQUQsRUFBY0UsY0FBYyxDQUFDRCxZQUFELENBQTVCLENBQWI7QUFDRDtBQUNEOzs7QUFDQSxXQUFPLEVBQVA7QUFDRDs7QUFFRCxXQUFTMXVCLE1BQVQsQ0FBaUIxQixDQUFqQixFQUFvQmtCLENBQXBCLEVBQXVCO0FBQ3JCLFdBQU9sQixDQUFDLEdBQUdrQixDQUFDLEdBQUlsQixDQUFDLEdBQUcsR0FBSixHQUFVa0IsQ0FBZCxHQUFtQmxCLENBQXZCLEdBQTRCa0IsQ0FBQyxJQUFJLEVBQXpDO0FBQ0Q7O0FBRUQsV0FBU212QixjQUFULENBQXlCbjBCLEtBQXpCLEVBQWdDO0FBQzlCLFFBQUl5RSxLQUFLLENBQUNzQixPQUFOLENBQWMvRixLQUFkLENBQUosRUFBMEI7QUFDeEIsYUFBT28wQixjQUFjLENBQUNwMEIsS0FBRCxDQUFyQjtBQUNEOztBQUNELFFBQUlDLFFBQVEsQ0FBQ0QsS0FBRCxDQUFaLEVBQXFCO0FBQ25CLGFBQU9xMEIsZUFBZSxDQUFDcjBCLEtBQUQsQ0FBdEI7QUFDRDs7QUFDRCxRQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsYUFBT0EsS0FBUDtBQUNEO0FBQ0Q7OztBQUNBLFdBQU8sRUFBUDtBQUNEOztBQUVELFdBQVNvMEIsY0FBVCxDQUF5QnAwQixLQUF6QixFQUFnQztBQUM5QixRQUFJOEUsR0FBRyxHQUFHLEVBQVY7QUFDQSxRQUFJd3ZCLFdBQUo7O0FBQ0EsU0FBSyxJQUFJeHlCLENBQUMsR0FBRyxDQUFSLEVBQVdpQyxDQUFDLEdBQUcvRCxLQUFLLENBQUMrQixNQUExQixFQUFrQ0QsQ0FBQyxHQUFHaUMsQ0FBdEMsRUFBeUNqQyxDQUFDLEVBQTFDLEVBQThDO0FBQzVDLFVBQUlsQyxLQUFLLENBQUMwMEIsV0FBVyxHQUFHSCxjQUFjLENBQUNuMEIsS0FBSyxDQUFDOEIsQ0FBRCxDQUFOLENBQTdCLENBQUwsSUFBaUR3eUIsV0FBVyxLQUFLLEVBQXJFLEVBQXlFO0FBQ3ZFLFlBQUl4dkIsR0FBSixFQUFTO0FBQUVBLGFBQUcsSUFBSSxHQUFQO0FBQWE7O0FBQ3hCQSxXQUFHLElBQUl3dkIsV0FBUDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT3h2QixHQUFQO0FBQ0Q7O0FBRUQsV0FBU3V2QixlQUFULENBQTBCcjBCLEtBQTFCLEVBQWlDO0FBQy9CLFFBQUk4RSxHQUFHLEdBQUcsRUFBVjs7QUFDQSxTQUFLLElBQUluQyxHQUFULElBQWdCM0MsS0FBaEIsRUFBdUI7QUFDckIsVUFBSUEsS0FBSyxDQUFDMkMsR0FBRCxDQUFULEVBQWdCO0FBQ2QsWUFBSW1DLEdBQUosRUFBUztBQUFFQSxhQUFHLElBQUksR0FBUDtBQUFhOztBQUN4QkEsV0FBRyxJQUFJbkMsR0FBUDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT21DLEdBQVA7QUFDRDtBQUVEOzs7QUFFQSxNQUFJeXZCLFlBQVksR0FBRztBQUNqQkMsT0FBRyxFQUFFLDRCQURZO0FBRWpCQyxRQUFJLEVBQUU7QUFGVyxHQUFuQjtBQUtBLE1BQUlDLFNBQVMsR0FBR256QixPQUFPLENBQ3JCLCtDQUNBLDJFQURBLEdBRUEsb0VBRkEsR0FHQSx3RUFIQSxHQUlBLDZFQUpBLEdBS0EsMkRBTEEsR0FNQSxrREFOQSxHQU9BLHlFQVBBLEdBUUEsa0NBUkEsR0FTQSx1Q0FUQSxHQVVBLHlEQVhxQixDQUF2QixDQWhsS3FCLENBOGxLckI7QUFDQTs7QUFDQSxNQUFJb3pCLEtBQUssR0FBR3B6QixPQUFPLENBQ2pCLDJFQUNBLDBFQURBLEdBRUEsa0VBSGlCLEVBSWpCLElBSmlCLENBQW5COztBQU9BLE1BQUlxekIsUUFBUSxHQUFHLFVBQVU3bUIsR0FBVixFQUFlO0FBQUUsV0FBT0EsR0FBRyxLQUFLLEtBQWY7QUFBdUIsR0FBdkQ7O0FBRUEsTUFBSTFHLGFBQWEsR0FBRyxVQUFVMEcsR0FBVixFQUFlO0FBQ2pDLFdBQU8ybUIsU0FBUyxDQUFDM21CLEdBQUQsQ0FBVCxJQUFrQjRtQixLQUFLLENBQUM1bUIsR0FBRCxDQUE5QjtBQUNELEdBRkQ7O0FBSUEsV0FBU3ZHLGVBQVQsQ0FBMEJ1RyxHQUExQixFQUErQjtBQUM3QixRQUFJNG1CLEtBQUssQ0FBQzVtQixHQUFELENBQVQsRUFBZ0I7QUFDZCxhQUFPLEtBQVA7QUFDRCxLQUg0QixDQUk3QjtBQUNBOzs7QUFDQSxRQUFJQSxHQUFHLEtBQUssTUFBWixFQUFvQjtBQUNsQixhQUFPLE1BQVA7QUFDRDtBQUNGOztBQUVELE1BQUk4bUIsbUJBQW1CLEdBQUd0MUIsTUFBTSxDQUFDb0MsTUFBUCxDQUFjLElBQWQsQ0FBMUI7O0FBQ0EsV0FBUzRGLGdCQUFULENBQTJCd0csR0FBM0IsRUFBZ0M7QUFDOUI7QUFDQSxRQUFJLENBQUN0RixTQUFMLEVBQWdCO0FBQ2QsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsUUFBSXBCLGFBQWEsQ0FBQzBHLEdBQUQsQ0FBakIsRUFBd0I7QUFDdEIsYUFBTyxLQUFQO0FBQ0Q7O0FBQ0RBLE9BQUcsR0FBR0EsR0FBRyxDQUFDL0wsV0FBSixFQUFOO0FBQ0E7O0FBQ0EsUUFBSTZ5QixtQkFBbUIsQ0FBQzltQixHQUFELENBQW5CLElBQTRCLElBQWhDLEVBQXNDO0FBQ3BDLGFBQU84bUIsbUJBQW1CLENBQUM5bUIsR0FBRCxDQUExQjtBQUNEOztBQUNELFFBQUk2RSxFQUFFLEdBQUdraUIsUUFBUSxDQUFDNUksYUFBVCxDQUF1Qm5lLEdBQXZCLENBQVQ7O0FBQ0EsUUFBSUEsR0FBRyxDQUFDeEwsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBQyxDQUF4QixFQUEyQjtBQUN6QjtBQUNBLGFBQVFzeUIsbUJBQW1CLENBQUM5bUIsR0FBRCxDQUFuQixHQUNONkUsRUFBRSxDQUFDM0csV0FBSCxLQUFtQnZELE1BQU0sQ0FBQ3FzQixrQkFBMUIsSUFDQW5pQixFQUFFLENBQUMzRyxXQUFILEtBQW1CdkQsTUFBTSxDQUFDc3NCLFdBRjVCO0FBSUQsS0FORCxNQU1PO0FBQ0wsYUFBUUgsbUJBQW1CLENBQUM5bUIsR0FBRCxDQUFuQixHQUEyQixxQkFBcUJ6RixJQUFyQixDQUEwQnNLLEVBQUUsQ0FBQ3ZTLFFBQUgsRUFBMUIsQ0FBbkM7QUFDRDtBQUNGOztBQUVELE1BQUk0MEIsZUFBZSxHQUFHMXpCLE9BQU8sQ0FBQywyQ0FBRCxDQUE3QjtBQUVBOztBQUVBOzs7O0FBR0EsV0FBUzJ6QixLQUFULENBQWdCdGlCLEVBQWhCLEVBQW9CO0FBQ2xCLFFBQUksT0FBT0EsRUFBUCxLQUFjLFFBQWxCLEVBQTRCO0FBQzFCLFVBQUl1aUIsUUFBUSxHQUFHTCxRQUFRLENBQUNNLGFBQVQsQ0FBdUJ4aUIsRUFBdkIsQ0FBZjs7QUFDQSxVQUFJLENBQUN1aUIsUUFBTCxFQUFlO0FBQ2IsMEJBQWtCLFlBQWxCLElBQWtDcHFCLElBQUksQ0FDcEMsMEJBQTBCNkgsRUFEVSxDQUF0QztBQUdBLGVBQU9raUIsUUFBUSxDQUFDNUksYUFBVCxDQUF1QixLQUF2QixDQUFQO0FBQ0Q7O0FBQ0QsYUFBT2lKLFFBQVA7QUFDRCxLQVRELE1BU087QUFDTCxhQUFPdmlCLEVBQVA7QUFDRDtBQUNGO0FBRUQ7OztBQUVBLFdBQVN5aUIsZUFBVCxDQUEwQkMsT0FBMUIsRUFBbUMxbEIsS0FBbkMsRUFBMEM7QUFDeEMsUUFBSXpCLEdBQUcsR0FBRzJtQixRQUFRLENBQUM1SSxhQUFULENBQXVCb0osT0FBdkIsQ0FBVjs7QUFDQSxRQUFJQSxPQUFPLEtBQUssUUFBaEIsRUFBMEI7QUFDeEIsYUFBT25uQixHQUFQO0FBQ0QsS0FKdUMsQ0FLeEM7OztBQUNBLFFBQUl5QixLQUFLLENBQUM1QixJQUFOLElBQWM0QixLQUFLLENBQUM1QixJQUFOLENBQVdrTyxLQUF6QixJQUFrQ3RNLEtBQUssQ0FBQzVCLElBQU4sQ0FBV2tPLEtBQVgsQ0FBaUJxWixRQUFqQixLQUE4QjUxQixTQUFwRSxFQUErRTtBQUM3RXdPLFNBQUcsQ0FBQ3FuQixZQUFKLENBQWlCLFVBQWpCLEVBQTZCLFVBQTdCO0FBQ0Q7O0FBQ0QsV0FBT3JuQixHQUFQO0FBQ0Q7O0FBRUQsV0FBU3NuQixlQUFULENBQTBCQyxTQUExQixFQUFxQ0osT0FBckMsRUFBOEM7QUFDNUMsV0FBT1IsUUFBUSxDQUFDVyxlQUFULENBQXlCbEIsWUFBWSxDQUFDbUIsU0FBRCxDQUFyQyxFQUFrREosT0FBbEQsQ0FBUDtBQUNEOztBQUVELFdBQVNLLGNBQVQsQ0FBeUJ6bkIsSUFBekIsRUFBK0I7QUFDN0IsV0FBTzRtQixRQUFRLENBQUNhLGNBQVQsQ0FBd0J6bkIsSUFBeEIsQ0FBUDtBQUNEOztBQUVELFdBQVMwbkIsYUFBVCxDQUF3QjFuQixJQUF4QixFQUE4QjtBQUM1QixXQUFPNG1CLFFBQVEsQ0FBQ2MsYUFBVCxDQUF1QjFuQixJQUF2QixDQUFQO0FBQ0Q7O0FBRUQsV0FBUzJuQixZQUFULENBQXVCaEMsVUFBdkIsRUFBbUNpQyxPQUFuQyxFQUE0Q0MsYUFBNUMsRUFBMkQ7QUFDekRsQyxjQUFVLENBQUNnQyxZQUFYLENBQXdCQyxPQUF4QixFQUFpQ0MsYUFBakM7QUFDRDs7QUFFRCxXQUFTQyxXQUFULENBQXNCdm1CLElBQXRCLEVBQTRCSCxLQUE1QixFQUFtQztBQUNqQ0csUUFBSSxDQUFDdW1CLFdBQUwsQ0FBaUIxbUIsS0FBakI7QUFDRDs7QUFFRCxXQUFTMm1CLFdBQVQsQ0FBc0J4bUIsSUFBdEIsRUFBNEJILEtBQTVCLEVBQW1DO0FBQ2pDRyxRQUFJLENBQUN3bUIsV0FBTCxDQUFpQjNtQixLQUFqQjtBQUNEOztBQUVELFdBQVN1a0IsVUFBVCxDQUFxQnBrQixJQUFyQixFQUEyQjtBQUN6QixXQUFPQSxJQUFJLENBQUNva0IsVUFBWjtBQUNEOztBQUVELFdBQVNxQyxXQUFULENBQXNCem1CLElBQXRCLEVBQTRCO0FBQzFCLFdBQU9BLElBQUksQ0FBQ3ltQixXQUFaO0FBQ0Q7O0FBRUQsV0FBU1osT0FBVCxDQUFrQjdsQixJQUFsQixFQUF3QjtBQUN0QixXQUFPQSxJQUFJLENBQUM2bEIsT0FBWjtBQUNEOztBQUVELFdBQVNhLGNBQVQsQ0FBeUIxbUIsSUFBekIsRUFBK0J2QixJQUEvQixFQUFxQztBQUNuQ3VCLFFBQUksQ0FBQzJtQixXQUFMLEdBQW1CbG9CLElBQW5CO0FBQ0Q7O0FBRUQsV0FBU21vQixhQUFULENBQXdCNW1CLElBQXhCLEVBQThCNm1CLE9BQTlCLEVBQXVDO0FBQ3JDN21CLFFBQUksQ0FBQytsQixZQUFMLENBQWtCYyxPQUFsQixFQUEyQixFQUEzQjtBQUNEOztBQUdELE1BQUlDLE9BQU8sR0FBR2gzQixNQUFNLENBQUNDLE1BQVAsQ0FBYztBQUMzQjBzQixpQkFBYSxFQUFFbUosZUFEWTtBQUUzQkksbUJBQWUsRUFBRUEsZUFGVTtBQUczQkUsa0JBQWMsRUFBRUEsY0FIVztBQUkzQkMsaUJBQWEsRUFBRUEsYUFKWTtBQUszQkMsZ0JBQVksRUFBRUEsWUFMYTtBQU0zQkcsZUFBVyxFQUFFQSxXQU5jO0FBTzNCQyxlQUFXLEVBQUVBLFdBUGM7QUFRM0JwQyxjQUFVLEVBQUVBLFVBUmU7QUFTM0JxQyxlQUFXLEVBQUVBLFdBVGM7QUFVM0JaLFdBQU8sRUFBRUEsT0FWa0I7QUFXM0JhLGtCQUFjLEVBQUVBLGNBWFc7QUFZM0JFLGlCQUFhLEVBQUVBO0FBWlksR0FBZCxDQUFkO0FBZUE7O0FBRUEsTUFBSXJILEdBQUcsR0FBRztBQUNScnRCLFVBQU0sRUFBRSxTQUFTQSxNQUFULENBQWlCeUIsQ0FBakIsRUFBb0J3TSxLQUFwQixFQUEyQjtBQUNqQzRtQixpQkFBVyxDQUFDNW1CLEtBQUQsQ0FBWDtBQUNELEtBSE87QUFJUnBDLFVBQU0sRUFBRSxTQUFTQSxNQUFULENBQWlCMGYsUUFBakIsRUFBMkJ0ZCxLQUEzQixFQUFrQztBQUN4QyxVQUFJc2QsUUFBUSxDQUFDbGYsSUFBVCxDQUFjZ2hCLEdBQWQsS0FBc0JwZixLQUFLLENBQUM1QixJQUFOLENBQVdnaEIsR0FBckMsRUFBMEM7QUFDeEN3SCxtQkFBVyxDQUFDdEosUUFBRCxFQUFXLElBQVgsQ0FBWDtBQUNBc0osbUJBQVcsQ0FBQzVtQixLQUFELENBQVg7QUFDRDtBQUNGLEtBVE87QUFVUndkLFdBQU8sRUFBRSxTQUFTQSxPQUFULENBQWtCeGQsS0FBbEIsRUFBeUI7QUFDaEM0bUIsaUJBQVcsQ0FBQzVtQixLQUFELEVBQVEsSUFBUixDQUFYO0FBQ0Q7QUFaTyxHQUFWOztBQWVBLFdBQVM0bUIsV0FBVCxDQUFzQjVtQixLQUF0QixFQUE2QjZtQixTQUE3QixFQUF3QztBQUN0QyxRQUFJOXpCLEdBQUcsR0FBR2lOLEtBQUssQ0FBQzVCLElBQU4sQ0FBV2doQixHQUFyQjs7QUFDQSxRQUFJLENBQUNwdkIsS0FBSyxDQUFDK0MsR0FBRCxDQUFWLEVBQWlCO0FBQUU7QUFBUTs7QUFFM0IsUUFBSTZJLEVBQUUsR0FBR29FLEtBQUssQ0FBQ3hCLE9BQWY7QUFDQSxRQUFJNGdCLEdBQUcsR0FBR3BmLEtBQUssQ0FBQ2pCLGlCQUFOLElBQTJCaUIsS0FBSyxDQUFDekIsR0FBM0M7QUFDQSxRQUFJdW9CLElBQUksR0FBR2xyQixFQUFFLENBQUM0VSxLQUFkOztBQUNBLFFBQUlxVyxTQUFKLEVBQWU7QUFDYixVQUFJaHlCLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBYzJ3QixJQUFJLENBQUMvekIsR0FBRCxDQUFsQixDQUFKLEVBQThCO0FBQzVCUixjQUFNLENBQUN1MEIsSUFBSSxDQUFDL3pCLEdBQUQsQ0FBTCxFQUFZcXNCLEdBQVosQ0FBTjtBQUNELE9BRkQsTUFFTyxJQUFJMEgsSUFBSSxDQUFDL3pCLEdBQUQsQ0FBSixLQUFjcXNCLEdBQWxCLEVBQXVCO0FBQzVCMEgsWUFBSSxDQUFDL3pCLEdBQUQsQ0FBSixHQUFZaEQsU0FBWjtBQUNEO0FBQ0YsS0FORCxNQU1PO0FBQ0wsVUFBSWlRLEtBQUssQ0FBQzVCLElBQU4sQ0FBVzJvQixRQUFmLEVBQXlCO0FBQ3ZCLFlBQUksQ0FBQ2x5QixLQUFLLENBQUNzQixPQUFOLENBQWMyd0IsSUFBSSxDQUFDL3pCLEdBQUQsQ0FBbEIsQ0FBTCxFQUErQjtBQUM3Qit6QixjQUFJLENBQUMvekIsR0FBRCxDQUFKLEdBQVksQ0FBQ3FzQixHQUFELENBQVo7QUFDRCxTQUZELE1BRU8sSUFBSTBILElBQUksQ0FBQy96QixHQUFELENBQUosQ0FBVUosT0FBVixDQUFrQnlzQixHQUFsQixJQUF5QixDQUE3QixFQUFnQztBQUNyQztBQUNBMEgsY0FBSSxDQUFDL3pCLEdBQUQsQ0FBSixDQUFVaUssSUFBVixDQUFlb2lCLEdBQWY7QUFDRDtBQUNGLE9BUEQsTUFPTztBQUNMMEgsWUFBSSxDQUFDL3pCLEdBQUQsQ0FBSixHQUFZcXNCLEdBQVo7QUFDRDtBQUNGO0FBQ0Y7QUFFRDs7Ozs7Ozs7Ozs7OztBQVlBLE1BQUk0SCxTQUFTLEdBQUcsSUFBSTlvQixLQUFKLENBQVUsRUFBVixFQUFjLEVBQWQsRUFBa0IsRUFBbEIsQ0FBaEI7QUFFQSxNQUFJdUosS0FBSyxHQUFHLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsUUFBdkIsRUFBaUMsUUFBakMsRUFBMkMsU0FBM0MsQ0FBWjs7QUFFQSxXQUFTd2YsU0FBVCxDQUFvQi95QixDQUFwQixFQUF1QmtCLENBQXZCLEVBQTBCO0FBQ3hCLFdBQ0VsQixDQUFDLENBQUNuQixHQUFGLEtBQVVxQyxDQUFDLENBQUNyQyxHQUFaLEtBRUltQixDQUFDLENBQUNpSyxHQUFGLEtBQVUvSSxDQUFDLENBQUMrSSxHQUFaLElBQ0FqSyxDQUFDLENBQUNrTCxTQUFGLEtBQWdCaEssQ0FBQyxDQUFDZ0ssU0FEbEIsSUFFQXBQLEtBQUssQ0FBQ2tFLENBQUMsQ0FBQ2tLLElBQUgsQ0FBTCxLQUFrQnBPLEtBQUssQ0FBQ29GLENBQUMsQ0FBQ2dKLElBQUgsQ0FGdkIsSUFHQThvQixhQUFhLENBQUNoekIsQ0FBRCxFQUFJa0IsQ0FBSixDQUpmLElBTUVuRixNQUFNLENBQUNpRSxDQUFDLENBQUNzTCxrQkFBSCxDQUFOLElBQ0F0TCxDQUFDLENBQUN3SyxZQUFGLEtBQW1CdEosQ0FBQyxDQUFDc0osWUFEckIsSUFFQTdPLE9BQU8sQ0FBQ3VGLENBQUMsQ0FBQ3NKLFlBQUYsQ0FBZTVDLEtBQWhCLENBVFgsQ0FERjtBQWNEOztBQUVELFdBQVNvckIsYUFBVCxDQUF3Qmh6QixDQUF4QixFQUEyQmtCLENBQTNCLEVBQThCO0FBQzVCLFFBQUlsQixDQUFDLENBQUNpSyxHQUFGLEtBQVUsT0FBZCxFQUF1QjtBQUFFLGFBQU8sSUFBUDtBQUFhOztBQUN0QyxRQUFJak0sQ0FBSjtBQUNBLFFBQUlpMUIsS0FBSyxHQUFHbjNCLEtBQUssQ0FBQ2tDLENBQUMsR0FBR2dDLENBQUMsQ0FBQ2tLLElBQVAsQ0FBTCxJQUFxQnBPLEtBQUssQ0FBQ2tDLENBQUMsR0FBR0EsQ0FBQyxDQUFDb2EsS0FBUCxDQUExQixJQUEyQ3BhLENBQUMsQ0FBQ2dTLElBQXpEO0FBQ0EsUUFBSWtqQixLQUFLLEdBQUdwM0IsS0FBSyxDQUFDa0MsQ0FBQyxHQUFHa0QsQ0FBQyxDQUFDZ0osSUFBUCxDQUFMLElBQXFCcE8sS0FBSyxDQUFDa0MsQ0FBQyxHQUFHQSxDQUFDLENBQUNvYSxLQUFQLENBQTFCLElBQTJDcGEsQ0FBQyxDQUFDZ1MsSUFBekQ7QUFDQSxXQUFPaWpCLEtBQUssS0FBS0MsS0FBVixJQUFtQi9CLGVBQWUsQ0FBQzhCLEtBQUQsQ0FBZixJQUEwQjlCLGVBQWUsQ0FBQytCLEtBQUQsQ0FBbkU7QUFDRDs7QUFFRCxXQUFTQyxpQkFBVCxDQUE0QmhwQixRQUE1QixFQUFzQ2lwQixRQUF0QyxFQUFnREMsTUFBaEQsRUFBd0Q7QUFDdEQsUUFBSXIxQixDQUFKLEVBQU9hLEdBQVA7QUFDQSxRQUFJakIsR0FBRyxHQUFHLEVBQVY7O0FBQ0EsU0FBS0ksQ0FBQyxHQUFHbzFCLFFBQVQsRUFBbUJwMUIsQ0FBQyxJQUFJcTFCLE1BQXhCLEVBQWdDLEVBQUVyMUIsQ0FBbEMsRUFBcUM7QUFDbkNhLFNBQUcsR0FBR3NMLFFBQVEsQ0FBQ25NLENBQUQsQ0FBUixDQUFZYSxHQUFsQjs7QUFDQSxVQUFJL0MsS0FBSyxDQUFDK0MsR0FBRCxDQUFULEVBQWdCO0FBQUVqQixXQUFHLENBQUNpQixHQUFELENBQUgsR0FBV2IsQ0FBWDtBQUFlO0FBQ2xDOztBQUNELFdBQU9KLEdBQVA7QUFDRDs7QUFFRCxXQUFTMDFCLG1CQUFULENBQThCQyxPQUE5QixFQUF1QztBQUNyQyxRQUFJdjFCLENBQUosRUFBT3VoQixDQUFQO0FBQ0EsUUFBSWhFLEdBQUcsR0FBRyxFQUFWO0FBRUEsUUFBSWphLE9BQU8sR0FBR2l5QixPQUFPLENBQUNqeUIsT0FBdEI7QUFDQSxRQUFJbXhCLE9BQU8sR0FBR2MsT0FBTyxDQUFDZCxPQUF0Qjs7QUFFQSxTQUFLejBCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3VWLEtBQUssQ0FBQ3RWLE1BQXRCLEVBQThCLEVBQUVELENBQWhDLEVBQW1DO0FBQ2pDdWQsU0FBRyxDQUFDaEksS0FBSyxDQUFDdlYsQ0FBRCxDQUFOLENBQUgsR0FBZ0IsRUFBaEI7O0FBQ0EsV0FBS3VoQixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdqZSxPQUFPLENBQUNyRCxNQUF4QixFQUFnQyxFQUFFc2hCLENBQWxDLEVBQXFDO0FBQ25DLFlBQUl6akIsS0FBSyxDQUFDd0YsT0FBTyxDQUFDaWUsQ0FBRCxDQUFQLENBQVdoTSxLQUFLLENBQUN2VixDQUFELENBQWhCLENBQUQsQ0FBVCxFQUFpQztBQUMvQnVkLGFBQUcsQ0FBQ2hJLEtBQUssQ0FBQ3ZWLENBQUQsQ0FBTixDQUFILENBQWM4SyxJQUFkLENBQW1CeEgsT0FBTyxDQUFDaWUsQ0FBRCxDQUFQLENBQVdoTSxLQUFLLENBQUN2VixDQUFELENBQWhCLENBQW5CO0FBQ0Q7QUFDRjtBQUNGOztBQUVELGFBQVN3MUIsV0FBVCxDQUFzQm5wQixHQUF0QixFQUEyQjtBQUN6QixhQUFPLElBQUlMLEtBQUosQ0FBVXlvQixPQUFPLENBQUNqQixPQUFSLENBQWdCbm5CLEdBQWhCLEVBQXFCbk0sV0FBckIsRUFBVixFQUE4QyxFQUE5QyxFQUFrRCxFQUFsRCxFQUFzRHJDLFNBQXRELEVBQWlFd08sR0FBakUsQ0FBUDtBQUNEOztBQUVELGFBQVNvcEIsVUFBVCxDQUFxQkMsUUFBckIsRUFBK0IvWSxTQUEvQixFQUEwQztBQUN4QyxlQUFTdGMsTUFBVCxHQUFtQjtBQUNqQixZQUFJLEVBQUVBLE1BQU0sQ0FBQ3NjLFNBQVQsS0FBdUIsQ0FBM0IsRUFBOEI7QUFDNUJnWixvQkFBVSxDQUFDRCxRQUFELENBQVY7QUFDRDtBQUNGOztBQUNEcjFCLFlBQU0sQ0FBQ3NjLFNBQVAsR0FBbUJBLFNBQW5CO0FBQ0EsYUFBT3RjLE1BQVA7QUFDRDs7QUFFRCxhQUFTczFCLFVBQVQsQ0FBcUI3a0IsRUFBckIsRUFBeUI7QUFDdkIsVUFBSWhFLE1BQU0sR0FBRzJuQixPQUFPLENBQUMxQyxVQUFSLENBQW1CamhCLEVBQW5CLENBQWIsQ0FEdUIsQ0FFdkI7O0FBQ0EsVUFBSWhULEtBQUssQ0FBQ2dQLE1BQUQsQ0FBVCxFQUFtQjtBQUNqQjJuQixlQUFPLENBQUNQLFdBQVIsQ0FBb0JwbkIsTUFBcEIsRUFBNEJnRSxFQUE1QjtBQUNEO0FBQ0Y7O0FBRUQsYUFBUzhrQixtQkFBVCxDQUE4QjluQixLQUE5QixFQUFxQytuQixNQUFyQyxFQUE2QztBQUMzQyxhQUNFLENBQUNBLE1BQUQsSUFDQSxDQUFDL25CLEtBQUssQ0FBQ3JCLEVBRFAsSUFFQSxFQUNFNUgsTUFBTSxDQUFDUSxlQUFQLENBQXVCcEYsTUFBdkIsSUFDQTRFLE1BQU0sQ0FBQ1EsZUFBUCxDQUF1Qnl3QixJQUF2QixDQUE0QixVQUFVQyxNQUFWLEVBQWtCO0FBQzVDLGVBQU9uM0IsUUFBUSxDQUFDbTNCLE1BQUQsQ0FBUixHQUNIQSxNQUFNLENBQUN2dkIsSUFBUCxDQUFZc0gsS0FBSyxDQUFDN0IsR0FBbEIsQ0FERyxHQUVIOHBCLE1BQU0sS0FBS2pvQixLQUFLLENBQUM3QixHQUZyQjtBQUdELE9BSkQsQ0FGRixDQUZBLElBVUFwSCxNQUFNLENBQUNZLGdCQUFQLENBQXdCcUksS0FBSyxDQUFDN0IsR0FBOUIsQ0FYRjtBQWFEOztBQUVELFFBQUkrcEIsaUJBQWlCLEdBQUcsQ0FBeEI7O0FBRUEsYUFBU0MsU0FBVCxDQUNFbm9CLEtBREYsRUFFRW9vQixrQkFGRixFQUdFckwsU0FIRixFQUlFQyxNQUpGLEVBS0VxTCxNQUxGLEVBTUVDLFVBTkYsRUFPRTUxQixLQVBGLEVBUUU7QUFDQSxVQUFJMUMsS0FBSyxDQUFDZ1EsS0FBSyxDQUFDekIsR0FBUCxDQUFMLElBQW9Cdk8sS0FBSyxDQUFDczRCLFVBQUQsQ0FBN0IsRUFBMkM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBdG9CLGFBQUssR0FBR3NvQixVQUFVLENBQUM1MUIsS0FBRCxDQUFWLEdBQW9CcU4sVUFBVSxDQUFDQyxLQUFELENBQXRDO0FBQ0Q7O0FBRURBLFdBQUssQ0FBQ2IsWUFBTixHQUFxQixDQUFDa3BCLE1BQXRCLENBVkEsQ0FVOEI7O0FBQzlCLFVBQUkzSyxlQUFlLENBQUMxZCxLQUFELEVBQVFvb0Isa0JBQVIsRUFBNEJyTCxTQUE1QixFQUF1Q0MsTUFBdkMsQ0FBbkIsRUFBbUU7QUFDakU7QUFDRDs7QUFFRCxVQUFJNWUsSUFBSSxHQUFHNEIsS0FBSyxDQUFDNUIsSUFBakI7QUFDQSxVQUFJQyxRQUFRLEdBQUcyQixLQUFLLENBQUMzQixRQUFyQjtBQUNBLFVBQUlGLEdBQUcsR0FBRzZCLEtBQUssQ0FBQzdCLEdBQWhCOztBQUNBLFVBQUluTyxLQUFLLENBQUNtTyxHQUFELENBQVQsRUFBZ0I7QUFDZDtBQUNFLGNBQUlDLElBQUksSUFBSUEsSUFBSSxDQUFDbXFCLEdBQWpCLEVBQXNCO0FBQ3BCTCw2QkFBaUI7QUFDbEI7O0FBQ0QsY0FBSUosbUJBQW1CLENBQUM5bkIsS0FBRCxFQUFRa29CLGlCQUFSLENBQXZCLEVBQW1EO0FBQ2pEL3NCLGdCQUFJLENBQ0YsOEJBQThCZ0QsR0FBOUIsR0FBb0MsY0FBcEMsR0FDQSw4REFEQSxHQUVBLHlDQUhFLEVBSUY2QixLQUFLLENBQUN4QixPQUpKLENBQUo7QUFNRDtBQUNGO0FBRUR3QixhQUFLLENBQUN6QixHQUFOLEdBQVl5QixLQUFLLENBQUNyQixFQUFOLEdBQ1Jnb0IsT0FBTyxDQUFDZCxlQUFSLENBQXdCN2xCLEtBQUssQ0FBQ3JCLEVBQTlCLEVBQWtDUixHQUFsQyxDQURRLEdBRVJ3b0IsT0FBTyxDQUFDckssYUFBUixDQUFzQm5lLEdBQXRCLEVBQTJCNkIsS0FBM0IsQ0FGSjtBQUdBd29CLGdCQUFRLENBQUN4b0IsS0FBRCxDQUFSO0FBRUE7O0FBQ0E7QUFDRXlvQix3QkFBYyxDQUFDem9CLEtBQUQsRUFBUTNCLFFBQVIsRUFBa0IrcEIsa0JBQWxCLENBQWQ7O0FBQ0EsY0FBSXA0QixLQUFLLENBQUNvTyxJQUFELENBQVQsRUFBaUI7QUFDZnNxQiw2QkFBaUIsQ0FBQzFvQixLQUFELEVBQVFvb0Isa0JBQVIsQ0FBakI7QUFDRDs7QUFDRDdLLGdCQUFNLENBQUNSLFNBQUQsRUFBWS9jLEtBQUssQ0FBQ3pCLEdBQWxCLEVBQXVCeWUsTUFBdkIsQ0FBTjtBQUNEOztBQUVELFlBQUksa0JBQWtCLFlBQWxCLElBQWtDNWUsSUFBbEMsSUFBMENBLElBQUksQ0FBQ21xQixHQUFuRCxFQUF3RDtBQUN0REwsMkJBQWlCO0FBQ2xCO0FBQ0YsT0FoQ0QsTUFnQ08sSUFBSWo0QixNQUFNLENBQUMrUCxLQUFLLENBQUNaLFNBQVAsQ0FBVixFQUE2QjtBQUNsQ1ksYUFBSyxDQUFDekIsR0FBTixHQUFZb29CLE9BQU8sQ0FBQ1gsYUFBUixDQUFzQmhtQixLQUFLLENBQUMxQixJQUE1QixDQUFaO0FBQ0FpZixjQUFNLENBQUNSLFNBQUQsRUFBWS9jLEtBQUssQ0FBQ3pCLEdBQWxCLEVBQXVCeWUsTUFBdkIsQ0FBTjtBQUNELE9BSE0sTUFHQTtBQUNMaGQsYUFBSyxDQUFDekIsR0FBTixHQUFZb29CLE9BQU8sQ0FBQ1osY0FBUixDQUF1Qi9sQixLQUFLLENBQUMxQixJQUE3QixDQUFaO0FBQ0FpZixjQUFNLENBQUNSLFNBQUQsRUFBWS9jLEtBQUssQ0FBQ3pCLEdBQWxCLEVBQXVCeWUsTUFBdkIsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsYUFBU1UsZUFBVCxDQUEwQjFkLEtBQTFCLEVBQWlDb29CLGtCQUFqQyxFQUFxRHJMLFNBQXJELEVBQWdFQyxNQUFoRSxFQUF3RTtBQUN0RSxVQUFJOXFCLENBQUMsR0FBRzhOLEtBQUssQ0FBQzVCLElBQWQ7O0FBQ0EsVUFBSXBPLEtBQUssQ0FBQ2tDLENBQUQsQ0FBVCxFQUFjO0FBQ1osWUFBSXkyQixhQUFhLEdBQUczNEIsS0FBSyxDQUFDZ1EsS0FBSyxDQUFDakIsaUJBQVAsQ0FBTCxJQUFrQzdNLENBQUMsQ0FBQytxQixTQUF4RDs7QUFDQSxZQUFJanRCLEtBQUssQ0FBQ2tDLENBQUMsR0FBR0EsQ0FBQyxDQUFDNlIsSUFBUCxDQUFMLElBQXFCL1QsS0FBSyxDQUFDa0MsQ0FBQyxHQUFHQSxDQUFDLENBQUM0cUIsSUFBUCxDQUE5QixFQUE0QztBQUMxQzVxQixXQUFDLENBQUM4TixLQUFELEVBQVE7QUFBTTtBQUFkLFlBQStCK2MsU0FBL0IsRUFBMENDLE1BQTFDLENBQUQ7QUFDRCxTQUpXLENBS1o7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFlBQUlodEIsS0FBSyxDQUFDZ1EsS0FBSyxDQUFDakIsaUJBQVAsQ0FBVCxFQUFvQztBQUNsQzZwQix1QkFBYSxDQUFDNW9CLEtBQUQsRUFBUW9vQixrQkFBUixDQUFiOztBQUNBLGNBQUluNEIsTUFBTSxDQUFDMDRCLGFBQUQsQ0FBVixFQUEyQjtBQUN6QkUsK0JBQW1CLENBQUM3b0IsS0FBRCxFQUFRb29CLGtCQUFSLEVBQTRCckwsU0FBNUIsRUFBdUNDLE1BQXZDLENBQW5CO0FBQ0Q7O0FBQ0QsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxhQUFTNEwsYUFBVCxDQUF3QjVvQixLQUF4QixFQUErQm9vQixrQkFBL0IsRUFBbUQ7QUFDakQsVUFBSXA0QixLQUFLLENBQUNnUSxLQUFLLENBQUM1QixJQUFOLENBQVcwcUIsYUFBWixDQUFULEVBQXFDO0FBQ25DViwwQkFBa0IsQ0FBQ3ByQixJQUFuQixDQUF3QjNJLEtBQXhCLENBQThCK3pCLGtCQUE5QixFQUFrRHBvQixLQUFLLENBQUM1QixJQUFOLENBQVcwcUIsYUFBN0Q7QUFDQTlvQixhQUFLLENBQUM1QixJQUFOLENBQVcwcUIsYUFBWCxHQUEyQixJQUEzQjtBQUNEOztBQUNEOW9CLFdBQUssQ0FBQ3pCLEdBQU4sR0FBWXlCLEtBQUssQ0FBQ2pCLGlCQUFOLENBQXdCcVMsR0FBcEM7O0FBQ0EsVUFBSTJYLFdBQVcsQ0FBQy9vQixLQUFELENBQWYsRUFBd0I7QUFDdEIwb0IseUJBQWlCLENBQUMxb0IsS0FBRCxFQUFRb29CLGtCQUFSLENBQWpCO0FBQ0FJLGdCQUFRLENBQUN4b0IsS0FBRCxDQUFSO0FBQ0QsT0FIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBNG1CLG1CQUFXLENBQUM1bUIsS0FBRCxDQUFYLENBSEssQ0FJTDs7QUFDQW9vQiwwQkFBa0IsQ0FBQ3ByQixJQUFuQixDQUF3QmdELEtBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxhQUFTNm9CLG1CQUFULENBQThCN29CLEtBQTlCLEVBQXFDb29CLGtCQUFyQyxFQUF5RHJMLFNBQXpELEVBQW9FQyxNQUFwRSxFQUE0RTtBQUMxRSxVQUFJOXFCLENBQUosQ0FEMEUsQ0FFMUU7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBSTgyQixTQUFTLEdBQUdocEIsS0FBaEI7O0FBQ0EsYUFBT2dwQixTQUFTLENBQUNqcUIsaUJBQWpCLEVBQW9DO0FBQ2xDaXFCLGlCQUFTLEdBQUdBLFNBQVMsQ0FBQ2pxQixpQkFBVixDQUE0QnVTLE1BQXhDOztBQUNBLFlBQUl0aEIsS0FBSyxDQUFDa0MsQ0FBQyxHQUFHODJCLFNBQVMsQ0FBQzVxQixJQUFmLENBQUwsSUFBNkJwTyxLQUFLLENBQUNrQyxDQUFDLEdBQUdBLENBQUMsQ0FBQysyQixVQUFQLENBQXRDLEVBQTBEO0FBQ3hELGVBQUsvMkIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdWQsR0FBRyxDQUFDeVosUUFBSixDQUFhLzJCLE1BQTdCLEVBQXFDLEVBQUVELENBQXZDLEVBQTBDO0FBQ3hDdWQsZUFBRyxDQUFDeVosUUFBSixDQUFhaDNCLENBQWIsRUFBZ0I4MEIsU0FBaEIsRUFBMkJnQyxTQUEzQjtBQUNEOztBQUNEWiw0QkFBa0IsQ0FBQ3ByQixJQUFuQixDQUF3QmdzQixTQUF4QjtBQUNBO0FBQ0Q7QUFDRixPQWhCeUUsQ0FpQjFFO0FBQ0E7OztBQUNBekwsWUFBTSxDQUFDUixTQUFELEVBQVkvYyxLQUFLLENBQUN6QixHQUFsQixFQUF1QnllLE1BQXZCLENBQU47QUFDRDs7QUFFRCxhQUFTTyxNQUFULENBQWlCdmUsTUFBakIsRUFBeUJULEdBQXpCLEVBQThCNHFCLE1BQTlCLEVBQXNDO0FBQ3BDLFVBQUluNUIsS0FBSyxDQUFDZ1AsTUFBRCxDQUFULEVBQW1CO0FBQ2pCLFlBQUloUCxLQUFLLENBQUNtNUIsTUFBRCxDQUFULEVBQW1CO0FBQ2pCLGNBQUlBLE1BQU0sQ0FBQ2xGLFVBQVAsS0FBc0JqbEIsTUFBMUIsRUFBa0M7QUFDaEMybkIsbUJBQU8sQ0FBQ1YsWUFBUixDQUFxQmpuQixNQUFyQixFQUE2QlQsR0FBN0IsRUFBa0M0cUIsTUFBbEM7QUFDRDtBQUNGLFNBSkQsTUFJTztBQUNMeEMsaUJBQU8sQ0FBQ04sV0FBUixDQUFvQnJuQixNQUFwQixFQUE0QlQsR0FBNUI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsYUFBU2txQixjQUFULENBQXlCem9CLEtBQXpCLEVBQWdDM0IsUUFBaEMsRUFBMEMrcEIsa0JBQTFDLEVBQThEO0FBQzVELFVBQUl2ekIsS0FBSyxDQUFDc0IsT0FBTixDQUFja0ksUUFBZCxDQUFKLEVBQTZCO0FBQzNCO0FBQ0UrcUIsNEJBQWtCLENBQUMvcUIsUUFBRCxDQUFsQjtBQUNEOztBQUNELGFBQUssSUFBSW5NLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdtTSxRQUFRLENBQUNsTSxNQUE3QixFQUFxQyxFQUFFRCxDQUF2QyxFQUEwQztBQUN4Q2kyQixtQkFBUyxDQUFDOXBCLFFBQVEsQ0FBQ25NLENBQUQsQ0FBVCxFQUFjazJCLGtCQUFkLEVBQWtDcG9CLEtBQUssQ0FBQ3pCLEdBQXhDLEVBQTZDLElBQTdDLEVBQW1ELElBQW5ELEVBQXlERixRQUF6RCxFQUFtRW5NLENBQW5FLENBQVQ7QUFDRDtBQUNGLE9BUEQsTUFPTyxJQUFJL0IsV0FBVyxDQUFDNlAsS0FBSyxDQUFDMUIsSUFBUCxDQUFmLEVBQTZCO0FBQ2xDcW9CLGVBQU8sQ0FBQ04sV0FBUixDQUFvQnJtQixLQUFLLENBQUN6QixHQUExQixFQUErQm9vQixPQUFPLENBQUNaLGNBQVIsQ0FBdUI1MEIsTUFBTSxDQUFDNk8sS0FBSyxDQUFDMUIsSUFBUCxDQUE3QixDQUEvQjtBQUNEO0FBQ0Y7O0FBRUQsYUFBU3lxQixXQUFULENBQXNCL29CLEtBQXRCLEVBQTZCO0FBQzNCLGFBQU9BLEtBQUssQ0FBQ2pCLGlCQUFiLEVBQWdDO0FBQzlCaUIsYUFBSyxHQUFHQSxLQUFLLENBQUNqQixpQkFBTixDQUF3QnVTLE1BQWhDO0FBQ0Q7O0FBQ0QsYUFBT3RoQixLQUFLLENBQUNnUSxLQUFLLENBQUM3QixHQUFQLENBQVo7QUFDRDs7QUFFRCxhQUFTdXFCLGlCQUFULENBQTRCMW9CLEtBQTVCLEVBQW1Db29CLGtCQUFuQyxFQUF1RDtBQUNyRCxXQUFLLElBQUkxWSxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHRCxHQUFHLENBQUMxZCxNQUFKLENBQVdJLE1BQW5DLEVBQTJDLEVBQUV1ZCxHQUE3QyxFQUFrRDtBQUNoREQsV0FBRyxDQUFDMWQsTUFBSixDQUFXMmQsR0FBWCxFQUFnQnNYLFNBQWhCLEVBQTJCaG5CLEtBQTNCO0FBQ0Q7O0FBQ0Q5TixPQUFDLEdBQUc4TixLQUFLLENBQUM1QixJQUFOLENBQVcyRixJQUFmLENBSnFELENBSWhDOztBQUNyQixVQUFJL1QsS0FBSyxDQUFDa0MsQ0FBRCxDQUFULEVBQWM7QUFDWixZQUFJbEMsS0FBSyxDQUFDa0MsQ0FBQyxDQUFDSCxNQUFILENBQVQsRUFBcUI7QUFBRUcsV0FBQyxDQUFDSCxNQUFGLENBQVNpMUIsU0FBVCxFQUFvQmhuQixLQUFwQjtBQUE2Qjs7QUFDcEQsWUFBSWhRLEtBQUssQ0FBQ2tDLENBQUMsQ0FBQ3FyQixNQUFILENBQVQsRUFBcUI7QUFBRTZLLDRCQUFrQixDQUFDcHJCLElBQW5CLENBQXdCZ0QsS0FBeEI7QUFBaUM7QUFDekQ7QUFDRixLQWpPb0MsQ0FtT3JDO0FBQ0E7QUFDQTs7O0FBQ0EsYUFBU3dvQixRQUFULENBQW1CeG9CLEtBQW5CLEVBQTBCO0FBQ3hCLFVBQUk5TixDQUFKOztBQUNBLFVBQUlsQyxLQUFLLENBQUNrQyxDQUFDLEdBQUc4TixLQUFLLENBQUNsQixTQUFYLENBQVQsRUFBZ0M7QUFDOUI2bkIsZUFBTyxDQUFDRixhQUFSLENBQXNCem1CLEtBQUssQ0FBQ3pCLEdBQTVCLEVBQWlDck0sQ0FBakM7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJbTNCLFFBQVEsR0FBR3JwQixLQUFmOztBQUNBLGVBQU9xcEIsUUFBUCxFQUFpQjtBQUNmLGNBQUlyNUIsS0FBSyxDQUFDa0MsQ0FBQyxHQUFHbTNCLFFBQVEsQ0FBQzdxQixPQUFkLENBQUwsSUFBK0J4TyxLQUFLLENBQUNrQyxDQUFDLEdBQUdBLENBQUMsQ0FBQ2tLLFFBQUYsQ0FBVytmLFFBQWhCLENBQXhDLEVBQW1FO0FBQ2pFd0ssbUJBQU8sQ0FBQ0YsYUFBUixDQUFzQnptQixLQUFLLENBQUN6QixHQUE1QixFQUFpQ3JNLENBQWpDO0FBQ0Q7O0FBQ0RtM0Isa0JBQVEsR0FBR0EsUUFBUSxDQUFDcnFCLE1BQXBCO0FBQ0Q7QUFDRixPQVp1QixDQWF4Qjs7O0FBQ0EsVUFBSWhQLEtBQUssQ0FBQ2tDLENBQUMsR0FBR2llLGNBQUwsQ0FBTCxJQUNGamUsQ0FBQyxLQUFLOE4sS0FBSyxDQUFDeEIsT0FEVixJQUVGdE0sQ0FBQyxLQUFLOE4sS0FBSyxDQUFDcEIsU0FGVixJQUdGNU8sS0FBSyxDQUFDa0MsQ0FBQyxHQUFHQSxDQUFDLENBQUNrSyxRQUFGLENBQVcrZixRQUFoQixDQUhQLEVBSUU7QUFDQXdLLGVBQU8sQ0FBQ0YsYUFBUixDQUFzQnptQixLQUFLLENBQUN6QixHQUE1QixFQUFpQ3JNLENBQWpDO0FBQ0Q7QUFDRjs7QUFFRCxhQUFTbzNCLFNBQVQsQ0FBb0J2TSxTQUFwQixFQUErQkMsTUFBL0IsRUFBdUNMLE1BQXZDLEVBQStDNE0sUUFBL0MsRUFBeURoQyxNQUF6RCxFQUFpRWEsa0JBQWpFLEVBQXFGO0FBQ25GLGFBQU9tQixRQUFRLElBQUloQyxNQUFuQixFQUEyQixFQUFFZ0MsUUFBN0IsRUFBdUM7QUFDckNwQixpQkFBUyxDQUFDeEwsTUFBTSxDQUFDNE0sUUFBRCxDQUFQLEVBQW1CbkIsa0JBQW5CLEVBQXVDckwsU0FBdkMsRUFBa0RDLE1BQWxELEVBQTBELEtBQTFELEVBQWlFTCxNQUFqRSxFQUF5RTRNLFFBQXpFLENBQVQ7QUFDRDtBQUNGOztBQUVELGFBQVNDLGlCQUFULENBQTRCeHBCLEtBQTVCLEVBQW1DO0FBQ2pDLFVBQUk5TixDQUFKLEVBQU91aEIsQ0FBUDtBQUNBLFVBQUlyVixJQUFJLEdBQUc0QixLQUFLLENBQUM1QixJQUFqQjs7QUFDQSxVQUFJcE8sS0FBSyxDQUFDb08sSUFBRCxDQUFULEVBQWlCO0FBQ2YsWUFBSXBPLEtBQUssQ0FBQ2tDLENBQUMsR0FBR2tNLElBQUksQ0FBQzJGLElBQVYsQ0FBTCxJQUF3Qi9ULEtBQUssQ0FBQ2tDLENBQUMsR0FBR0EsQ0FBQyxDQUFDc3JCLE9BQVAsQ0FBakMsRUFBa0Q7QUFBRXRyQixXQUFDLENBQUM4TixLQUFELENBQUQ7QUFBVzs7QUFDL0QsYUFBSzlOLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3VkLEdBQUcsQ0FBQytOLE9BQUosQ0FBWXJyQixNQUE1QixFQUFvQyxFQUFFRCxDQUF0QyxFQUF5QztBQUFFdWQsYUFBRyxDQUFDK04sT0FBSixDQUFZdHJCLENBQVosRUFBZThOLEtBQWY7QUFBd0I7QUFDcEU7O0FBQ0QsVUFBSWhRLEtBQUssQ0FBQ2tDLENBQUMsR0FBRzhOLEtBQUssQ0FBQzNCLFFBQVgsQ0FBVCxFQUErQjtBQUM3QixhQUFLb1YsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHelQsS0FBSyxDQUFDM0IsUUFBTixDQUFlbE0sTUFBL0IsRUFBdUMsRUFBRXNoQixDQUF6QyxFQUE0QztBQUMxQytWLDJCQUFpQixDQUFDeHBCLEtBQUssQ0FBQzNCLFFBQU4sQ0FBZW9WLENBQWYsQ0FBRCxDQUFqQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxhQUFTZ1csWUFBVCxDQUF1QjFNLFNBQXZCLEVBQWtDSixNQUFsQyxFQUEwQzRNLFFBQTFDLEVBQW9EaEMsTUFBcEQsRUFBNEQ7QUFDMUQsYUFBT2dDLFFBQVEsSUFBSWhDLE1BQW5CLEVBQTJCLEVBQUVnQyxRQUE3QixFQUF1QztBQUNyQyxZQUFJRyxFQUFFLEdBQUcvTSxNQUFNLENBQUM0TSxRQUFELENBQWY7O0FBQ0EsWUFBSXY1QixLQUFLLENBQUMwNUIsRUFBRCxDQUFULEVBQWU7QUFDYixjQUFJMTVCLEtBQUssQ0FBQzA1QixFQUFFLENBQUN2ckIsR0FBSixDQUFULEVBQW1CO0FBQ2pCd3JCLHFDQUF5QixDQUFDRCxFQUFELENBQXpCO0FBQ0FGLDZCQUFpQixDQUFDRSxFQUFELENBQWpCO0FBQ0QsV0FIRCxNQUdPO0FBQUU7QUFDUDdCLHNCQUFVLENBQUM2QixFQUFFLENBQUNuckIsR0FBSixDQUFWO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsYUFBU29yQix5QkFBVCxDQUFvQzNwQixLQUFwQyxFQUEyQzRwQixFQUEzQyxFQUErQztBQUM3QyxVQUFJNTVCLEtBQUssQ0FBQzQ1QixFQUFELENBQUwsSUFBYTU1QixLQUFLLENBQUNnUSxLQUFLLENBQUM1QixJQUFQLENBQXRCLEVBQW9DO0FBQ2xDLFlBQUlsTSxDQUFKO0FBQ0EsWUFBSTJjLFNBQVMsR0FBR1ksR0FBRyxDQUFDbGQsTUFBSixDQUFXSixNQUFYLEdBQW9CLENBQXBDOztBQUNBLFlBQUluQyxLQUFLLENBQUM0NUIsRUFBRCxDQUFULEVBQWU7QUFDYjtBQUNBO0FBQ0FBLFlBQUUsQ0FBQy9hLFNBQUgsSUFBZ0JBLFNBQWhCO0FBQ0QsU0FKRCxNQUlPO0FBQ0w7QUFDQSthLFlBQUUsR0FBR2pDLFVBQVUsQ0FBQzNuQixLQUFLLENBQUN6QixHQUFQLEVBQVlzUSxTQUFaLENBQWY7QUFDRCxTQVZpQyxDQVdsQzs7O0FBQ0EsWUFBSTdlLEtBQUssQ0FBQ2tDLENBQUMsR0FBRzhOLEtBQUssQ0FBQ2pCLGlCQUFYLENBQUwsSUFBc0MvTyxLQUFLLENBQUNrQyxDQUFDLEdBQUdBLENBQUMsQ0FBQ29mLE1BQVAsQ0FBM0MsSUFBNkR0aEIsS0FBSyxDQUFDa0MsQ0FBQyxDQUFDa00sSUFBSCxDQUF0RSxFQUFnRjtBQUM5RXVyQixtQ0FBeUIsQ0FBQ3ozQixDQUFELEVBQUkwM0IsRUFBSixDQUF6QjtBQUNEOztBQUNELGFBQUsxM0IsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdWQsR0FBRyxDQUFDbGQsTUFBSixDQUFXSixNQUEzQixFQUFtQyxFQUFFRCxDQUFyQyxFQUF3QztBQUN0Q3VkLGFBQUcsQ0FBQ2xkLE1BQUosQ0FBV0wsQ0FBWCxFQUFjOE4sS0FBZCxFQUFxQjRwQixFQUFyQjtBQUNEOztBQUNELFlBQUk1NUIsS0FBSyxDQUFDa0MsQ0FBQyxHQUFHOE4sS0FBSyxDQUFDNUIsSUFBTixDQUFXMkYsSUFBaEIsQ0FBTCxJQUE4Qi9ULEtBQUssQ0FBQ2tDLENBQUMsR0FBR0EsQ0FBQyxDQUFDSyxNQUFQLENBQXZDLEVBQXVEO0FBQ3JETCxXQUFDLENBQUM4TixLQUFELEVBQVE0cEIsRUFBUixDQUFEO0FBQ0QsU0FGRCxNQUVPO0FBQ0xBLFlBQUU7QUFDSDtBQUNGLE9BdkJELE1BdUJPO0FBQ0wvQixrQkFBVSxDQUFDN25CLEtBQUssQ0FBQ3pCLEdBQVAsQ0FBVjtBQUNEO0FBQ0Y7O0FBRUQsYUFBU3NyQixjQUFULENBQXlCOU0sU0FBekIsRUFBb0MrTSxLQUFwQyxFQUEyQ0MsS0FBM0MsRUFBa0QzQixrQkFBbEQsRUFBc0U0QixVQUF0RSxFQUFrRjtBQUNoRixVQUFJQyxXQUFXLEdBQUcsQ0FBbEI7QUFDQSxVQUFJQyxXQUFXLEdBQUcsQ0FBbEI7QUFDQSxVQUFJQyxTQUFTLEdBQUdMLEtBQUssQ0FBQzMzQixNQUFOLEdBQWUsQ0FBL0I7QUFDQSxVQUFJaTRCLGFBQWEsR0FBR04sS0FBSyxDQUFDLENBQUQsQ0FBekI7QUFDQSxVQUFJTyxXQUFXLEdBQUdQLEtBQUssQ0FBQ0ssU0FBRCxDQUF2QjtBQUNBLFVBQUlHLFNBQVMsR0FBR1AsS0FBSyxDQUFDNTNCLE1BQU4sR0FBZSxDQUEvQjtBQUNBLFVBQUlvNEIsYUFBYSxHQUFHUixLQUFLLENBQUMsQ0FBRCxDQUF6QjtBQUNBLFVBQUlTLFdBQVcsR0FBR1QsS0FBSyxDQUFDTyxTQUFELENBQXZCO0FBQ0EsVUFBSUcsV0FBSixFQUFpQkMsUUFBakIsRUFBMkJDLFdBQTNCLEVBQXdDM04sTUFBeEMsQ0FUZ0YsQ0FXaEY7QUFDQTtBQUNBOztBQUNBLFVBQUk0TixPQUFPLEdBQUcsQ0FBQ1osVUFBZjtBQUVBO0FBQ0VaLDBCQUFrQixDQUFDVyxLQUFELENBQWxCO0FBQ0Q7O0FBRUQsYUFBT0UsV0FBVyxJQUFJRSxTQUFmLElBQTRCRCxXQUFXLElBQUlJLFNBQWxELEVBQTZEO0FBQzNELFlBQUl6NkIsT0FBTyxDQUFDdTZCLGFBQUQsQ0FBWCxFQUE0QjtBQUMxQkEsdUJBQWEsR0FBR04sS0FBSyxDQUFDLEVBQUVHLFdBQUgsQ0FBckIsQ0FEMEIsQ0FDWTtBQUN2QyxTQUZELE1BRU8sSUFBSXA2QixPQUFPLENBQUN3NkIsV0FBRCxDQUFYLEVBQTBCO0FBQy9CQSxxQkFBVyxHQUFHUCxLQUFLLENBQUMsRUFBRUssU0FBSCxDQUFuQjtBQUNELFNBRk0sTUFFQSxJQUFJbEQsU0FBUyxDQUFDbUQsYUFBRCxFQUFnQkcsYUFBaEIsQ0FBYixFQUE2QztBQUNsRE0sb0JBQVUsQ0FBQ1QsYUFBRCxFQUFnQkcsYUFBaEIsRUFBK0JuQyxrQkFBL0IsQ0FBVjtBQUNBZ0MsdUJBQWEsR0FBR04sS0FBSyxDQUFDLEVBQUVHLFdBQUgsQ0FBckI7QUFDQU0sdUJBQWEsR0FBR1IsS0FBSyxDQUFDLEVBQUVHLFdBQUgsQ0FBckI7QUFDRCxTQUpNLE1BSUEsSUFBSWpELFNBQVMsQ0FBQ29ELFdBQUQsRUFBY0csV0FBZCxDQUFiLEVBQXlDO0FBQzlDSyxvQkFBVSxDQUFDUixXQUFELEVBQWNHLFdBQWQsRUFBMkJwQyxrQkFBM0IsQ0FBVjtBQUNBaUMscUJBQVcsR0FBR1AsS0FBSyxDQUFDLEVBQUVLLFNBQUgsQ0FBbkI7QUFDQUsscUJBQVcsR0FBR1QsS0FBSyxDQUFDLEVBQUVPLFNBQUgsQ0FBbkI7QUFDRCxTQUpNLE1BSUEsSUFBSXJELFNBQVMsQ0FBQ21ELGFBQUQsRUFBZ0JJLFdBQWhCLENBQWIsRUFBMkM7QUFBRTtBQUNsREssb0JBQVUsQ0FBQ1QsYUFBRCxFQUFnQkksV0FBaEIsRUFBNkJwQyxrQkFBN0IsQ0FBVjtBQUNBd0MsaUJBQU8sSUFBSWpFLE9BQU8sQ0FBQ1YsWUFBUixDQUFxQmxKLFNBQXJCLEVBQWdDcU4sYUFBYSxDQUFDN3JCLEdBQTlDLEVBQW1Eb29CLE9BQU8sQ0FBQ0wsV0FBUixDQUFvQitELFdBQVcsQ0FBQzlyQixHQUFoQyxDQUFuRCxDQUFYO0FBQ0E2ckIsdUJBQWEsR0FBR04sS0FBSyxDQUFDLEVBQUVHLFdBQUgsQ0FBckI7QUFDQU8scUJBQVcsR0FBR1QsS0FBSyxDQUFDLEVBQUVPLFNBQUgsQ0FBbkI7QUFDRCxTQUxNLE1BS0EsSUFBSXJELFNBQVMsQ0FBQ29ELFdBQUQsRUFBY0UsYUFBZCxDQUFiLEVBQTJDO0FBQUU7QUFDbERNLG9CQUFVLENBQUNSLFdBQUQsRUFBY0UsYUFBZCxFQUE2Qm5DLGtCQUE3QixDQUFWO0FBQ0F3QyxpQkFBTyxJQUFJakUsT0FBTyxDQUFDVixZQUFSLENBQXFCbEosU0FBckIsRUFBZ0NzTixXQUFXLENBQUM5ckIsR0FBNUMsRUFBaUQ2ckIsYUFBYSxDQUFDN3JCLEdBQS9ELENBQVg7QUFDQThyQixxQkFBVyxHQUFHUCxLQUFLLENBQUMsRUFBRUssU0FBSCxDQUFuQjtBQUNBSSx1QkFBYSxHQUFHUixLQUFLLENBQUMsRUFBRUcsV0FBSCxDQUFyQjtBQUNELFNBTE0sTUFLQTtBQUNMLGNBQUlyNkIsT0FBTyxDQUFDNDZCLFdBQUQsQ0FBWCxFQUEwQjtBQUFFQSx1QkFBVyxHQUFHcEQsaUJBQWlCLENBQUN5QyxLQUFELEVBQVFHLFdBQVIsRUFBcUJFLFNBQXJCLENBQS9CO0FBQWlFOztBQUM3Rk8sa0JBQVEsR0FBRzE2QixLQUFLLENBQUN1NkIsYUFBYSxDQUFDeDNCLEdBQWYsQ0FBTCxHQUNQMDNCLFdBQVcsQ0FBQ0YsYUFBYSxDQUFDeDNCLEdBQWYsQ0FESixHQUVQKzNCLFlBQVksQ0FBQ1AsYUFBRCxFQUFnQlQsS0FBaEIsRUFBdUJHLFdBQXZCLEVBQW9DRSxTQUFwQyxDQUZoQjs7QUFHQSxjQUFJdDZCLE9BQU8sQ0FBQzY2QixRQUFELENBQVgsRUFBdUI7QUFBRTtBQUN2QnZDLHFCQUFTLENBQUNvQyxhQUFELEVBQWdCbkMsa0JBQWhCLEVBQW9DckwsU0FBcEMsRUFBK0NxTixhQUFhLENBQUM3ckIsR0FBN0QsRUFBa0UsS0FBbEUsRUFBeUV3ckIsS0FBekUsRUFBZ0ZHLFdBQWhGLENBQVQ7QUFDRCxXQUZELE1BRU87QUFDTFMsdUJBQVcsR0FBR2IsS0FBSyxDQUFDWSxRQUFELENBQW5COztBQUNBLGdCQUFJekQsU0FBUyxDQUFDMEQsV0FBRCxFQUFjSixhQUFkLENBQWIsRUFBMkM7QUFDekNNLHdCQUFVLENBQUNGLFdBQUQsRUFBY0osYUFBZCxFQUE2Qm5DLGtCQUE3QixDQUFWO0FBQ0EwQixtQkFBSyxDQUFDWSxRQUFELENBQUwsR0FBa0IzNkIsU0FBbEI7QUFDQTY2QixxQkFBTyxJQUFJakUsT0FBTyxDQUFDVixZQUFSLENBQXFCbEosU0FBckIsRUFBZ0M0TixXQUFXLENBQUNwc0IsR0FBNUMsRUFBaUQ2ckIsYUFBYSxDQUFDN3JCLEdBQS9ELENBQVg7QUFDRCxhQUpELE1BSU87QUFDTDtBQUNBNHBCLHVCQUFTLENBQUNvQyxhQUFELEVBQWdCbkMsa0JBQWhCLEVBQW9DckwsU0FBcEMsRUFBK0NxTixhQUFhLENBQUM3ckIsR0FBN0QsRUFBa0UsS0FBbEUsRUFBeUV3ckIsS0FBekUsRUFBZ0ZHLFdBQWhGLENBQVQ7QUFDRDtBQUNGOztBQUNESyx1QkFBYSxHQUFHUixLQUFLLENBQUMsRUFBRUcsV0FBSCxDQUFyQjtBQUNEO0FBQ0Y7O0FBQ0QsVUFBSUQsV0FBVyxHQUFHRSxTQUFsQixFQUE2QjtBQUMzQm5OLGNBQU0sR0FBR250QixPQUFPLENBQUNrNkIsS0FBSyxDQUFDTyxTQUFTLEdBQUcsQ0FBYixDQUFOLENBQVAsR0FBZ0MsSUFBaEMsR0FBdUNQLEtBQUssQ0FBQ08sU0FBUyxHQUFHLENBQWIsQ0FBTCxDQUFxQi9yQixHQUFyRTtBQUNBK3FCLGlCQUFTLENBQUN2TSxTQUFELEVBQVlDLE1BQVosRUFBb0IrTSxLQUFwQixFQUEyQkcsV0FBM0IsRUFBd0NJLFNBQXhDLEVBQW1EbEMsa0JBQW5ELENBQVQ7QUFDRCxPQUhELE1BR08sSUFBSThCLFdBQVcsR0FBR0ksU0FBbEIsRUFBNkI7QUFDbENiLG9CQUFZLENBQUMxTSxTQUFELEVBQVkrTSxLQUFaLEVBQW1CRyxXQUFuQixFQUFnQ0UsU0FBaEMsQ0FBWjtBQUNEO0FBQ0Y7O0FBRUQsYUFBU2Ysa0JBQVQsQ0FBNkIvcUIsUUFBN0IsRUFBdUM7QUFDckMsVUFBSTBzQixRQUFRLEdBQUcsRUFBZjs7QUFDQSxXQUFLLElBQUk3NEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21NLFFBQVEsQ0FBQ2xNLE1BQTdCLEVBQXFDRCxDQUFDLEVBQXRDLEVBQTBDO0FBQ3hDLFlBQUk4TixLQUFLLEdBQUczQixRQUFRLENBQUNuTSxDQUFELENBQXBCO0FBQ0EsWUFBSWEsR0FBRyxHQUFHaU4sS0FBSyxDQUFDak4sR0FBaEI7O0FBQ0EsWUFBSS9DLEtBQUssQ0FBQytDLEdBQUQsQ0FBVCxFQUFnQjtBQUNkLGNBQUlnNEIsUUFBUSxDQUFDaDRCLEdBQUQsQ0FBWixFQUFtQjtBQUNqQm9JLGdCQUFJLENBQ0QsK0JBQStCcEksR0FBL0IsR0FBcUMsb0NBRHBDLEVBRUZpTixLQUFLLENBQUN4QixPQUZKLENBQUo7QUFJRCxXQUxELE1BS087QUFDTHVzQixvQkFBUSxDQUFDaDRCLEdBQUQsQ0FBUixHQUFnQixJQUFoQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELGFBQVMrM0IsWUFBVCxDQUF1QmpyQixJQUF2QixFQUE2QmlxQixLQUE3QixFQUFvQ24xQixLQUFwQyxFQUEyQ3EyQixHQUEzQyxFQUFnRDtBQUM5QyxXQUFLLElBQUk5NEIsQ0FBQyxHQUFHeUMsS0FBYixFQUFvQnpDLENBQUMsR0FBRzg0QixHQUF4QixFQUE2Qjk0QixDQUFDLEVBQTlCLEVBQWtDO0FBQ2hDLFlBQUl1QixDQUFDLEdBQUdxMkIsS0FBSyxDQUFDNTNCLENBQUQsQ0FBYjs7QUFDQSxZQUFJbEMsS0FBSyxDQUFDeUQsQ0FBRCxDQUFMLElBQVl3ekIsU0FBUyxDQUFDcG5CLElBQUQsRUFBT3BNLENBQVAsQ0FBekIsRUFBb0M7QUFBRSxpQkFBT3ZCLENBQVA7QUFBVTtBQUNqRDtBQUNGOztBQUVELGFBQVMyNEIsVUFBVCxDQUFxQnZOLFFBQXJCLEVBQStCdGQsS0FBL0IsRUFBc0Nvb0Isa0JBQXRDLEVBQTBENEIsVUFBMUQsRUFBc0U7QUFDcEUsVUFBSTFNLFFBQVEsS0FBS3RkLEtBQWpCLEVBQXdCO0FBQ3RCO0FBQ0Q7O0FBRUQsVUFBSXpCLEdBQUcsR0FBR3lCLEtBQUssQ0FBQ3pCLEdBQU4sR0FBWStlLFFBQVEsQ0FBQy9lLEdBQS9COztBQUVBLFVBQUl0TyxNQUFNLENBQUNxdEIsUUFBUSxDQUFDOWQsa0JBQVYsQ0FBVixFQUF5QztBQUN2QyxZQUFJeFAsS0FBSyxDQUFDZ1EsS0FBSyxDQUFDdEIsWUFBTixDQUFtQm1QLFFBQXBCLENBQVQsRUFBd0M7QUFDdENvZCxpQkFBTyxDQUFDM04sUUFBUSxDQUFDL2UsR0FBVixFQUFleUIsS0FBZixFQUFzQm9vQixrQkFBdEIsQ0FBUDtBQUNELFNBRkQsTUFFTztBQUNMcG9CLGVBQUssQ0FBQ1Isa0JBQU4sR0FBMkIsSUFBM0I7QUFDRDs7QUFDRDtBQUNELE9BZG1FLENBZ0JwRTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsVUFBSXZQLE1BQU0sQ0FBQytQLEtBQUssQ0FBQ2QsUUFBUCxDQUFOLElBQ0ZqUCxNQUFNLENBQUNxdEIsUUFBUSxDQUFDcGUsUUFBVixDQURKLElBRUZjLEtBQUssQ0FBQ2pOLEdBQU4sS0FBY3VxQixRQUFRLENBQUN2cUIsR0FGckIsS0FHRDlDLE1BQU0sQ0FBQytQLEtBQUssQ0FBQ1gsUUFBUCxDQUFOLElBQTBCcFAsTUFBTSxDQUFDK1AsS0FBSyxDQUFDVixNQUFQLENBSC9CLENBQUosRUFJRTtBQUNBVSxhQUFLLENBQUNqQixpQkFBTixHQUEwQnVlLFFBQVEsQ0FBQ3ZlLGlCQUFuQztBQUNBO0FBQ0Q7O0FBRUQsVUFBSTdNLENBQUo7QUFDQSxVQUFJa00sSUFBSSxHQUFHNEIsS0FBSyxDQUFDNUIsSUFBakI7O0FBQ0EsVUFBSXBPLEtBQUssQ0FBQ29PLElBQUQsQ0FBTCxJQUFlcE8sS0FBSyxDQUFDa0MsQ0FBQyxHQUFHa00sSUFBSSxDQUFDMkYsSUFBVixDQUFwQixJQUF1Qy9ULEtBQUssQ0FBQ2tDLENBQUMsR0FBR0EsQ0FBQyxDQUFDaXJCLFFBQVAsQ0FBaEQsRUFBa0U7QUFDaEVqckIsU0FBQyxDQUFDb3JCLFFBQUQsRUFBV3RkLEtBQVgsQ0FBRDtBQUNEOztBQUVELFVBQUk4cEIsS0FBSyxHQUFHeE0sUUFBUSxDQUFDamYsUUFBckI7QUFDQSxVQUFJcXJCLEVBQUUsR0FBRzFwQixLQUFLLENBQUMzQixRQUFmOztBQUNBLFVBQUlyTyxLQUFLLENBQUNvTyxJQUFELENBQUwsSUFBZTJxQixXQUFXLENBQUMvb0IsS0FBRCxDQUE5QixFQUF1QztBQUNyQyxhQUFLOU4sQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdWQsR0FBRyxDQUFDN1IsTUFBSixDQUFXekwsTUFBM0IsRUFBbUMsRUFBRUQsQ0FBckMsRUFBd0M7QUFBRXVkLGFBQUcsQ0FBQzdSLE1BQUosQ0FBVzFMLENBQVgsRUFBY29yQixRQUFkLEVBQXdCdGQsS0FBeEI7QUFBaUM7O0FBQzNFLFlBQUloUSxLQUFLLENBQUNrQyxDQUFDLEdBQUdrTSxJQUFJLENBQUMyRixJQUFWLENBQUwsSUFBd0IvVCxLQUFLLENBQUNrQyxDQUFDLEdBQUdBLENBQUMsQ0FBQzBMLE1BQVAsQ0FBakMsRUFBaUQ7QUFBRTFMLFdBQUMsQ0FBQ29yQixRQUFELEVBQVd0ZCxLQUFYLENBQUQ7QUFBcUI7QUFDekU7O0FBQ0QsVUFBSW5RLE9BQU8sQ0FBQ21RLEtBQUssQ0FBQzFCLElBQVAsQ0FBWCxFQUF5QjtBQUN2QixZQUFJdE8sS0FBSyxDQUFDODVCLEtBQUQsQ0FBTCxJQUFnQjk1QixLQUFLLENBQUMwNUIsRUFBRCxDQUF6QixFQUErQjtBQUM3QixjQUFJSSxLQUFLLEtBQUtKLEVBQWQsRUFBa0I7QUFBRUcsMEJBQWMsQ0FBQ3RyQixHQUFELEVBQU11ckIsS0FBTixFQUFhSixFQUFiLEVBQWlCdEIsa0JBQWpCLEVBQXFDNEIsVUFBckMsQ0FBZDtBQUFpRTtBQUN0RixTQUZELE1BRU8sSUFBSWg2QixLQUFLLENBQUMwNUIsRUFBRCxDQUFULEVBQWU7QUFDcEIsY0FBSTE1QixLQUFLLENBQUNzdEIsUUFBUSxDQUFDaGYsSUFBVixDQUFULEVBQTBCO0FBQUVxb0IsbUJBQU8sQ0FBQ0osY0FBUixDQUF1QmhvQixHQUF2QixFQUE0QixFQUE1QjtBQUFrQzs7QUFDOUQrcUIsbUJBQVMsQ0FBQy9xQixHQUFELEVBQU0sSUFBTixFQUFZbXJCLEVBQVosRUFBZ0IsQ0FBaEIsRUFBbUJBLEVBQUUsQ0FBQ3YzQixNQUFILEdBQVksQ0FBL0IsRUFBa0NpMkIsa0JBQWxDLENBQVQ7QUFDRCxTQUhNLE1BR0EsSUFBSXA0QixLQUFLLENBQUM4NUIsS0FBRCxDQUFULEVBQWtCO0FBQ3ZCTCxzQkFBWSxDQUFDbHJCLEdBQUQsRUFBTXVyQixLQUFOLEVBQWEsQ0FBYixFQUFnQkEsS0FBSyxDQUFDMzNCLE1BQU4sR0FBZSxDQUEvQixDQUFaO0FBQ0QsU0FGTSxNQUVBLElBQUluQyxLQUFLLENBQUNzdEIsUUFBUSxDQUFDaGYsSUFBVixDQUFULEVBQTBCO0FBQy9CcW9CLGlCQUFPLENBQUNKLGNBQVIsQ0FBdUJob0IsR0FBdkIsRUFBNEIsRUFBNUI7QUFDRDtBQUNGLE9BWEQsTUFXTyxJQUFJK2UsUUFBUSxDQUFDaGYsSUFBVCxLQUFrQjBCLEtBQUssQ0FBQzFCLElBQTVCLEVBQWtDO0FBQ3ZDcW9CLGVBQU8sQ0FBQ0osY0FBUixDQUF1QmhvQixHQUF2QixFQUE0QnlCLEtBQUssQ0FBQzFCLElBQWxDO0FBQ0Q7O0FBQ0QsVUFBSXRPLEtBQUssQ0FBQ29PLElBQUQsQ0FBVCxFQUFpQjtBQUNmLFlBQUlwTyxLQUFLLENBQUNrQyxDQUFDLEdBQUdrTSxJQUFJLENBQUMyRixJQUFWLENBQUwsSUFBd0IvVCxLQUFLLENBQUNrQyxDQUFDLEdBQUdBLENBQUMsQ0FBQ2c1QixTQUFQLENBQWpDLEVBQW9EO0FBQUVoNUIsV0FBQyxDQUFDb3JCLFFBQUQsRUFBV3RkLEtBQVgsQ0FBRDtBQUFxQjtBQUM1RTtBQUNGOztBQUVELGFBQVNtckIsZ0JBQVQsQ0FBMkJuckIsS0FBM0IsRUFBa0MyVCxLQUFsQyxFQUF5Q3lYLE9BQXpDLEVBQWtEO0FBQ2hEO0FBQ0E7QUFDQSxVQUFJbjdCLE1BQU0sQ0FBQ203QixPQUFELENBQU4sSUFBbUJwN0IsS0FBSyxDQUFDZ1EsS0FBSyxDQUFDaEIsTUFBUCxDQUE1QixFQUE0QztBQUMxQ2dCLGFBQUssQ0FBQ2hCLE1BQU4sQ0FBYVosSUFBYixDQUFrQjBxQixhQUFsQixHQUFrQ25WLEtBQWxDO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBSyxJQUFJemhCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5aEIsS0FBSyxDQUFDeGhCLE1BQTFCLEVBQWtDLEVBQUVELENBQXBDLEVBQXVDO0FBQ3JDeWhCLGVBQUssQ0FBQ3poQixDQUFELENBQUwsQ0FBU2tNLElBQVQsQ0FBYzJGLElBQWQsQ0FBbUJ3WixNQUFuQixDQUEwQjVKLEtBQUssQ0FBQ3poQixDQUFELENBQS9CO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFFBQUltNUIsZUFBZSxHQUFHLEtBQXRCLENBcmVxQyxDQXNlckM7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsUUFBSUMsZ0JBQWdCLEdBQUczNUIsT0FBTyxDQUFDLHlDQUFELENBQTlCLENBMWVxQyxDQTRlckM7O0FBQ0EsYUFBU3M1QixPQUFULENBQWtCMXNCLEdBQWxCLEVBQXVCeUIsS0FBdkIsRUFBOEJvb0Isa0JBQTlCLEVBQWtETCxNQUFsRCxFQUEwRDtBQUN4RCxVQUFJNzFCLENBQUo7QUFDQSxVQUFJaU0sR0FBRyxHQUFHNkIsS0FBSyxDQUFDN0IsR0FBaEI7QUFDQSxVQUFJQyxJQUFJLEdBQUc0QixLQUFLLENBQUM1QixJQUFqQjtBQUNBLFVBQUlDLFFBQVEsR0FBRzJCLEtBQUssQ0FBQzNCLFFBQXJCO0FBQ0EwcEIsWUFBTSxHQUFHQSxNQUFNLElBQUszcEIsSUFBSSxJQUFJQSxJQUFJLENBQUNtcUIsR0FBakM7QUFDQXZvQixXQUFLLENBQUN6QixHQUFOLEdBQVlBLEdBQVo7O0FBRUEsVUFBSXRPLE1BQU0sQ0FBQytQLEtBQUssQ0FBQ1osU0FBUCxDQUFOLElBQTJCcFAsS0FBSyxDQUFDZ1EsS0FBSyxDQUFDdEIsWUFBUCxDQUFwQyxFQUEwRDtBQUN4RHNCLGFBQUssQ0FBQ1Isa0JBQU4sR0FBMkIsSUFBM0I7QUFDQSxlQUFPLElBQVA7QUFDRCxPQVh1RCxDQVl4RDs7O0FBQ0E7QUFDRSxZQUFJLENBQUMrckIsZUFBZSxDQUFDaHRCLEdBQUQsRUFBTXlCLEtBQU4sRUFBYStuQixNQUFiLENBQXBCLEVBQTBDO0FBQ3hDLGlCQUFPLEtBQVA7QUFDRDtBQUNGOztBQUNELFVBQUkvM0IsS0FBSyxDQUFDb08sSUFBRCxDQUFULEVBQWlCO0FBQ2YsWUFBSXBPLEtBQUssQ0FBQ2tDLENBQUMsR0FBR2tNLElBQUksQ0FBQzJGLElBQVYsQ0FBTCxJQUF3Qi9ULEtBQUssQ0FBQ2tDLENBQUMsR0FBR0EsQ0FBQyxDQUFDNHFCLElBQVAsQ0FBakMsRUFBK0M7QUFBRTVxQixXQUFDLENBQUM4TixLQUFELEVBQVE7QUFBSztBQUFiLFdBQUQ7QUFBaUM7O0FBQ2xGLFlBQUloUSxLQUFLLENBQUNrQyxDQUFDLEdBQUc4TixLQUFLLENBQUNqQixpQkFBWCxDQUFULEVBQXdDO0FBQ3RDO0FBQ0E2cEIsdUJBQWEsQ0FBQzVvQixLQUFELEVBQVFvb0Isa0JBQVIsQ0FBYjtBQUNBLGlCQUFPLElBQVA7QUFDRDtBQUNGOztBQUNELFVBQUlwNEIsS0FBSyxDQUFDbU8sR0FBRCxDQUFULEVBQWdCO0FBQ2QsWUFBSW5PLEtBQUssQ0FBQ3FPLFFBQUQsQ0FBVCxFQUFxQjtBQUNuQjtBQUNBLGNBQUksQ0FBQ0UsR0FBRyxDQUFDaXRCLGFBQUosRUFBTCxFQUEwQjtBQUN4Qi9DLDBCQUFjLENBQUN6b0IsS0FBRCxFQUFRM0IsUUFBUixFQUFrQitwQixrQkFBbEIsQ0FBZDtBQUNELFdBRkQsTUFFTztBQUNMO0FBQ0EsZ0JBQUlwNEIsS0FBSyxDQUFDa0MsQ0FBQyxHQUFHa00sSUFBTCxDQUFMLElBQW1CcE8sS0FBSyxDQUFDa0MsQ0FBQyxHQUFHQSxDQUFDLENBQUM4bkIsUUFBUCxDQUF4QixJQUE0Q2hxQixLQUFLLENBQUNrQyxDQUFDLEdBQUdBLENBQUMsQ0FBQ3U1QixTQUFQLENBQXJELEVBQXdFO0FBQ3RFLGtCQUFJdjVCLENBQUMsS0FBS3FNLEdBQUcsQ0FBQ2t0QixTQUFkLEVBQXlCO0FBQ3ZCO0FBQ0Esb0JBQUksa0JBQWtCLFlBQWxCLElBQ0YsT0FBT2p3QixPQUFQLEtBQW1CLFdBRGpCLElBRUYsQ0FBQzZ2QixlQUZILEVBR0U7QUFDQUEsaUNBQWUsR0FBRyxJQUFsQjtBQUNBN3ZCLHlCQUFPLENBQUNMLElBQVIsQ0FBYSxVQUFiLEVBQXlCb0QsR0FBekI7QUFDQS9DLHlCQUFPLENBQUNMLElBQVIsQ0FBYSxvQkFBYixFQUFtQ2pKLENBQW5DO0FBQ0FzSix5QkFBTyxDQUFDTCxJQUFSLENBQWEsb0JBQWIsRUFBbUNvRCxHQUFHLENBQUNrdEIsU0FBdkM7QUFDRDs7QUFDRCx1QkFBTyxLQUFQO0FBQ0Q7QUFDRixhQWRELE1BY087QUFDTDtBQUNBLGtCQUFJQyxhQUFhLEdBQUcsSUFBcEI7QUFDQSxrQkFBSXhILFNBQVMsR0FBRzNsQixHQUFHLENBQUNvdEIsVUFBcEI7O0FBQ0EsbUJBQUssSUFBSWpjLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdyUixRQUFRLENBQUNsTSxNQUFqQyxFQUF5Q3VkLEdBQUcsRUFBNUMsRUFBZ0Q7QUFDOUMsb0JBQUksQ0FBQ3dVLFNBQUQsSUFBYyxDQUFDK0csT0FBTyxDQUFDL0csU0FBRCxFQUFZN2xCLFFBQVEsQ0FBQ3FSLEdBQUQsQ0FBcEIsRUFBMkIwWSxrQkFBM0IsRUFBK0NMLE1BQS9DLENBQTFCLEVBQWtGO0FBQ2hGMkQsK0JBQWEsR0FBRyxLQUFoQjtBQUNBO0FBQ0Q7O0FBQ0R4SCx5QkFBUyxHQUFHQSxTQUFTLENBQUNvQyxXQUF0QjtBQUNELGVBVkksQ0FXTDtBQUNBOzs7QUFDQSxrQkFBSSxDQUFDb0YsYUFBRCxJQUFrQnhILFNBQXRCLEVBQWlDO0FBQy9CO0FBQ0Esb0JBQUksa0JBQWtCLFlBQWxCLElBQ0YsT0FBTzFvQixPQUFQLEtBQW1CLFdBRGpCLElBRUYsQ0FBQzZ2QixlQUZILEVBR0U7QUFDQUEsaUNBQWUsR0FBRyxJQUFsQjtBQUNBN3ZCLHlCQUFPLENBQUNMLElBQVIsQ0FBYSxVQUFiLEVBQXlCb0QsR0FBekI7QUFDQS9DLHlCQUFPLENBQUNMLElBQVIsQ0FBYSxxQ0FBYixFQUFvRG9ELEdBQUcsQ0FBQ3F0QixVQUF4RCxFQUFvRXZ0QixRQUFwRTtBQUNEOztBQUNELHVCQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFDRCxZQUFJck8sS0FBSyxDQUFDb08sSUFBRCxDQUFULEVBQWlCO0FBQ2YsY0FBSXl0QixVQUFVLEdBQUcsS0FBakI7O0FBQ0EsZUFBSyxJQUFJOTRCLEdBQVQsSUFBZ0JxTCxJQUFoQixFQUFzQjtBQUNwQixnQkFBSSxDQUFDa3RCLGdCQUFnQixDQUFDdjRCLEdBQUQsQ0FBckIsRUFBNEI7QUFDMUI4NEIsd0JBQVUsR0FBRyxJQUFiO0FBQ0FuRCwrQkFBaUIsQ0FBQzFvQixLQUFELEVBQVFvb0Isa0JBQVIsQ0FBakI7QUFDQTtBQUNEO0FBQ0Y7O0FBQ0QsY0FBSSxDQUFDeUQsVUFBRCxJQUFlenRCLElBQUksQ0FBQyxPQUFELENBQXZCLEVBQWtDO0FBQ2hDO0FBQ0F3TSxvQkFBUSxDQUFDeE0sSUFBSSxDQUFDLE9BQUQsQ0FBTCxDQUFSO0FBQ0Q7QUFDRjtBQUNGLE9BL0RELE1BK0RPLElBQUlHLEdBQUcsQ0FBQ0gsSUFBSixLQUFhNEIsS0FBSyxDQUFDMUIsSUFBdkIsRUFBNkI7QUFDbENDLFdBQUcsQ0FBQ0gsSUFBSixHQUFXNEIsS0FBSyxDQUFDMUIsSUFBakI7QUFDRDs7QUFDRCxhQUFPLElBQVA7QUFDRDs7QUFFRCxhQUFTaXRCLGVBQVQsQ0FBMEIxckIsSUFBMUIsRUFBZ0NHLEtBQWhDLEVBQXVDK25CLE1BQXZDLEVBQStDO0FBQzdDLFVBQUkvM0IsS0FBSyxDQUFDZ1EsS0FBSyxDQUFDN0IsR0FBUCxDQUFULEVBQXNCO0FBQ3BCLGVBQU82QixLQUFLLENBQUM3QixHQUFOLENBQVV4TCxPQUFWLENBQWtCLGVBQWxCLE1BQXVDLENBQXZDLElBQ0wsQ0FBQ20xQixtQkFBbUIsQ0FBQzluQixLQUFELEVBQVErbkIsTUFBUixDQUFwQixJQUNBL25CLEtBQUssQ0FBQzdCLEdBQU4sQ0FBVS9MLFdBQVYsUUFBNkJ5TixJQUFJLENBQUM2bEIsT0FBTCxJQUFnQjdsQixJQUFJLENBQUM2bEIsT0FBTCxDQUFhdHpCLFdBQWIsRUFBN0MsQ0FGRjtBQUlELE9BTEQsTUFLTztBQUNMLGVBQU95TixJQUFJLENBQUNpc0IsUUFBTCxNQUFtQjlyQixLQUFLLENBQUNaLFNBQU4sR0FBa0IsQ0FBbEIsR0FBc0IsQ0FBekMsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxTQUFTMnNCLEtBQVQsQ0FBZ0J6TyxRQUFoQixFQUEwQnRkLEtBQTFCLEVBQWlDaVIsU0FBakMsRUFBNEMrWSxVQUE1QyxFQUF3RGpOLFNBQXhELEVBQW1FQyxNQUFuRSxFQUEyRTtBQUNoRixVQUFJbnRCLE9BQU8sQ0FBQ21RLEtBQUQsQ0FBWCxFQUFvQjtBQUNsQixZQUFJaFEsS0FBSyxDQUFDc3RCLFFBQUQsQ0FBVCxFQUFxQjtBQUFFa00sMkJBQWlCLENBQUNsTSxRQUFELENBQWpCO0FBQThCOztBQUNyRDtBQUNEOztBQUVELFVBQUkwTyxjQUFjLEdBQUcsS0FBckI7QUFDQSxVQUFJNUQsa0JBQWtCLEdBQUcsRUFBekI7O0FBRUEsVUFBSXY0QixPQUFPLENBQUN5dEIsUUFBRCxDQUFYLEVBQXVCO0FBQ3JCO0FBQ0EwTyxzQkFBYyxHQUFHLElBQWpCO0FBQ0E3RCxpQkFBUyxDQUFDbm9CLEtBQUQsRUFBUW9vQixrQkFBUixFQUE0QnJMLFNBQTVCLEVBQXVDQyxNQUF2QyxDQUFUO0FBQ0QsT0FKRCxNQUlPO0FBQ0wsWUFBSWlQLGFBQWEsR0FBR2o4QixLQUFLLENBQUNzdEIsUUFBUSxDQUFDd08sUUFBVixDQUF6Qjs7QUFDQSxZQUFJLENBQUNHLGFBQUQsSUFBa0JoRixTQUFTLENBQUMzSixRQUFELEVBQVd0ZCxLQUFYLENBQS9CLEVBQWtEO0FBQ2hEO0FBQ0E2cUIsb0JBQVUsQ0FBQ3ZOLFFBQUQsRUFBV3RkLEtBQVgsRUFBa0Jvb0Isa0JBQWxCLEVBQXNDNEIsVUFBdEMsQ0FBVjtBQUNELFNBSEQsTUFHTztBQUNMLGNBQUlpQyxhQUFKLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFJM08sUUFBUSxDQUFDd08sUUFBVCxLQUFzQixDQUF0QixJQUEyQnhPLFFBQVEsQ0FBQzRPLFlBQVQsQ0FBc0J0MUIsUUFBdEIsQ0FBL0IsRUFBZ0U7QUFDOUQwbUIsc0JBQVEsQ0FBQzZPLGVBQVQsQ0FBeUJ2MUIsUUFBekI7QUFDQXFhLHVCQUFTLEdBQUcsSUFBWjtBQUNEOztBQUNELGdCQUFJaGhCLE1BQU0sQ0FBQ2doQixTQUFELENBQVYsRUFBdUI7QUFDckIsa0JBQUlnYSxPQUFPLENBQUMzTixRQUFELEVBQVd0ZCxLQUFYLEVBQWtCb29CLGtCQUFsQixDQUFYLEVBQWtEO0FBQ2hEK0MsZ0NBQWdCLENBQUNuckIsS0FBRCxFQUFRb29CLGtCQUFSLEVBQTRCLElBQTVCLENBQWhCO0FBQ0EsdUJBQU85SyxRQUFQO0FBQ0QsZUFIRCxNQUdPO0FBQ0xuaUIsb0JBQUksQ0FDRiwrREFDQSw4REFEQSxHQUVBLCtEQUZBLEdBR0EsNERBSEEsR0FJQSwwQkFMRSxDQUFKO0FBT0Q7QUFDRixhQXJCZ0IsQ0FzQmpCO0FBQ0E7OztBQUNBbWlCLG9CQUFRLEdBQUdvSyxXQUFXLENBQUNwSyxRQUFELENBQXRCO0FBQ0QsV0ExQkksQ0E0Qkw7OztBQUNBLGNBQUk4TyxNQUFNLEdBQUc5TyxRQUFRLENBQUMvZSxHQUF0QjtBQUNBLGNBQUk4dEIsV0FBVyxHQUFHMUYsT0FBTyxDQUFDMUMsVUFBUixDQUFtQm1JLE1BQW5CLENBQWxCLENBOUJLLENBZ0NMOztBQUNBakUsbUJBQVMsQ0FDUG5vQixLQURPLEVBRVBvb0Isa0JBRk8sRUFHUDtBQUNBO0FBQ0E7QUFDQWdFLGdCQUFNLENBQUNFLFFBQVAsR0FBa0IsSUFBbEIsR0FBeUJELFdBTmxCLEVBT1AxRixPQUFPLENBQUNMLFdBQVIsQ0FBb0I4RixNQUFwQixDQVBPLENBQVQsQ0FqQ0ssQ0EyQ0w7O0FBQ0EsY0FBSXA4QixLQUFLLENBQUNnUSxLQUFLLENBQUNoQixNQUFQLENBQVQsRUFBeUI7QUFDdkIsZ0JBQUlxcUIsUUFBUSxHQUFHcnBCLEtBQUssQ0FBQ2hCLE1BQXJCO0FBQ0EsZ0JBQUl1dEIsU0FBUyxHQUFHeEQsV0FBVyxDQUFDL29CLEtBQUQsQ0FBM0I7O0FBQ0EsbUJBQU9xcEIsUUFBUCxFQUFpQjtBQUNmLG1CQUFLLElBQUluM0IsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VkLEdBQUcsQ0FBQytOLE9BQUosQ0FBWXJyQixNQUFoQyxFQUF3QyxFQUFFRCxDQUExQyxFQUE2QztBQUMzQ3VkLG1CQUFHLENBQUMrTixPQUFKLENBQVl0ckIsQ0FBWixFQUFlbTNCLFFBQWY7QUFDRDs7QUFDREEsc0JBQVEsQ0FBQzlxQixHQUFULEdBQWV5QixLQUFLLENBQUN6QixHQUFyQjs7QUFDQSxrQkFBSWd1QixTQUFKLEVBQWU7QUFDYixxQkFBSyxJQUFJN2MsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR0QsR0FBRyxDQUFDMWQsTUFBSixDQUFXSSxNQUFuQyxFQUEyQyxFQUFFdWQsR0FBN0MsRUFBa0Q7QUFDaERELHFCQUFHLENBQUMxZCxNQUFKLENBQVcyZCxHQUFYLEVBQWdCc1gsU0FBaEIsRUFBMkJxQyxRQUEzQjtBQUNELGlCQUhZLENBSWI7QUFDQTtBQUNBOzs7QUFDQSxvQkFBSTlMLE1BQU0sR0FBRzhMLFFBQVEsQ0FBQ2pyQixJQUFULENBQWMyRixJQUFkLENBQW1Cd1osTUFBaEM7O0FBQ0Esb0JBQUlBLE1BQU0sQ0FBQ25SLE1BQVgsRUFBbUI7QUFDakI7QUFDQSx1QkFBSyxJQUFJb2dCLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdqUCxNQUFNLENBQUNqUyxHQUFQLENBQVduWixNQUFuQyxFQUEyQ3E2QixHQUFHLEVBQTlDLEVBQWtEO0FBQ2hEalAsMEJBQU0sQ0FBQ2pTLEdBQVAsQ0FBV2toQixHQUFYO0FBQ0Q7QUFDRjtBQUNGLGVBZEQsTUFjTztBQUNMNUYsMkJBQVcsQ0FBQ3lDLFFBQUQsQ0FBWDtBQUNEOztBQUNEQSxzQkFBUSxHQUFHQSxRQUFRLENBQUNycUIsTUFBcEI7QUFDRDtBQUNGLFdBdkVJLENBeUVMOzs7QUFDQSxjQUFJaFAsS0FBSyxDQUFDcThCLFdBQUQsQ0FBVCxFQUF3QjtBQUN0QjVDLHdCQUFZLENBQUM0QyxXQUFELEVBQWMsQ0FBQy9PLFFBQUQsQ0FBZCxFQUEwQixDQUExQixFQUE2QixDQUE3QixDQUFaO0FBQ0QsV0FGRCxNQUVPLElBQUl0dEIsS0FBSyxDQUFDc3RCLFFBQVEsQ0FBQ25mLEdBQVYsQ0FBVCxFQUF5QjtBQUM5QnFyQiw2QkFBaUIsQ0FBQ2xNLFFBQUQsQ0FBakI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ2TixzQkFBZ0IsQ0FBQ25yQixLQUFELEVBQVFvb0Isa0JBQVIsRUFBNEI0RCxjQUE1QixDQUFoQjtBQUNBLGFBQU9oc0IsS0FBSyxDQUFDekIsR0FBYjtBQUNELEtBdEdEO0FBdUdEO0FBRUQ7OztBQUVBLE1BQUkwRyxVQUFVLEdBQUc7QUFDZmxULFVBQU0sRUFBRTA2QixnQkFETztBQUVmN3VCLFVBQU0sRUFBRTZ1QixnQkFGTztBQUdmalAsV0FBTyxFQUFFLFNBQVNrUCxnQkFBVCxDQUEyQjFzQixLQUEzQixFQUFrQztBQUN6Q3lzQixzQkFBZ0IsQ0FBQ3pzQixLQUFELEVBQVFnbkIsU0FBUixDQUFoQjtBQUNEO0FBTGMsR0FBakI7O0FBUUEsV0FBU3lGLGdCQUFULENBQTJCblAsUUFBM0IsRUFBcUN0ZCxLQUFyQyxFQUE0QztBQUMxQyxRQUFJc2QsUUFBUSxDQUFDbGYsSUFBVCxDQUFjNkcsVUFBZCxJQUE0QmpGLEtBQUssQ0FBQzVCLElBQU4sQ0FBVzZHLFVBQTNDLEVBQXVEO0FBQ3JEK0wsYUFBTyxDQUFDc00sUUFBRCxFQUFXdGQsS0FBWCxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTZ1IsT0FBVCxDQUFrQnNNLFFBQWxCLEVBQTRCdGQsS0FBNUIsRUFBbUM7QUFDakMsUUFBSTJzQixRQUFRLEdBQUdyUCxRQUFRLEtBQUswSixTQUE1QjtBQUNBLFFBQUk0RixTQUFTLEdBQUc1c0IsS0FBSyxLQUFLZ25CLFNBQTFCO0FBQ0EsUUFBSTZGLE9BQU8sR0FBR0MscUJBQXFCLENBQUN4UCxRQUFRLENBQUNsZixJQUFULENBQWM2RyxVQUFmLEVBQTJCcVksUUFBUSxDQUFDOWUsT0FBcEMsQ0FBbkM7QUFDQSxRQUFJdXVCLE9BQU8sR0FBR0QscUJBQXFCLENBQUM5c0IsS0FBSyxDQUFDNUIsSUFBTixDQUFXNkcsVUFBWixFQUF3QmpGLEtBQUssQ0FBQ3hCLE9BQTlCLENBQW5DO0FBRUEsUUFBSXd1QixjQUFjLEdBQUcsRUFBckI7QUFDQSxRQUFJQyxpQkFBaUIsR0FBRyxFQUF4QjtBQUVBLFFBQUlsNkIsR0FBSixFQUFTbTZCLE1BQVQsRUFBaUJDLEdBQWpCOztBQUNBLFNBQUtwNkIsR0FBTCxJQUFZZzZCLE9BQVosRUFBcUI7QUFDbkJHLFlBQU0sR0FBR0wsT0FBTyxDQUFDOTVCLEdBQUQsQ0FBaEI7QUFDQW82QixTQUFHLEdBQUdKLE9BQU8sQ0FBQ2g2QixHQUFELENBQWI7O0FBQ0EsVUFBSSxDQUFDbTZCLE1BQUwsRUFBYTtBQUNYO0FBQ0FFLGtCQUFVLENBQUNELEdBQUQsRUFBTSxNQUFOLEVBQWNudEIsS0FBZCxFQUFxQnNkLFFBQXJCLENBQVY7O0FBQ0EsWUFBSTZQLEdBQUcsQ0FBQ2oxQixHQUFKLElBQVdpMUIsR0FBRyxDQUFDajFCLEdBQUosQ0FBUTRJLFFBQXZCLEVBQWlDO0FBQy9Ca3NCLHdCQUFjLENBQUNod0IsSUFBZixDQUFvQm13QixHQUFwQjtBQUNEO0FBQ0YsT0FORCxNQU1PO0FBQ0w7QUFDQUEsV0FBRyxDQUFDeFgsUUFBSixHQUFldVgsTUFBTSxDQUFDOThCLEtBQXRCO0FBQ0FnOUIsa0JBQVUsQ0FBQ0QsR0FBRCxFQUFNLFFBQU4sRUFBZ0JudEIsS0FBaEIsRUFBdUJzZCxRQUF2QixDQUFWOztBQUNBLFlBQUk2UCxHQUFHLENBQUNqMUIsR0FBSixJQUFXaTFCLEdBQUcsQ0FBQ2oxQixHQUFKLENBQVFtMUIsZ0JBQXZCLEVBQXlDO0FBQ3ZDSiwyQkFBaUIsQ0FBQ2p3QixJQUFsQixDQUF1Qm13QixHQUF2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFJSCxjQUFjLENBQUM3NkIsTUFBbkIsRUFBMkI7QUFDekIsVUFBSW03QixVQUFVLEdBQUcsWUFBWTtBQUMzQixhQUFLLElBQUlwN0IsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzg2QixjQUFjLENBQUM3NkIsTUFBbkMsRUFBMkNELENBQUMsRUFBNUMsRUFBZ0Q7QUFDOUNrN0Isb0JBQVUsQ0FBQ0osY0FBYyxDQUFDOTZCLENBQUQsQ0FBZixFQUFvQixVQUFwQixFQUFnQzhOLEtBQWhDLEVBQXVDc2QsUUFBdkMsQ0FBVjtBQUNEO0FBQ0YsT0FKRDs7QUFLQSxVQUFJcVAsUUFBSixFQUFjO0FBQ1ozZ0Isc0JBQWMsQ0FBQ2hNLEtBQUQsRUFBUSxRQUFSLEVBQWtCc3RCLFVBQWxCLENBQWQ7QUFDRCxPQUZELE1BRU87QUFDTEEsa0JBQVU7QUFDWDtBQUNGOztBQUVELFFBQUlMLGlCQUFpQixDQUFDOTZCLE1BQXRCLEVBQThCO0FBQzVCNlosb0JBQWMsQ0FBQ2hNLEtBQUQsRUFBUSxXQUFSLEVBQXFCLFlBQVk7QUFDN0MsYUFBSyxJQUFJOU4sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRys2QixpQkFBaUIsQ0FBQzk2QixNQUF0QyxFQUE4Q0QsQ0FBQyxFQUEvQyxFQUFtRDtBQUNqRGs3QixvQkFBVSxDQUFDSCxpQkFBaUIsQ0FBQy82QixDQUFELENBQWxCLEVBQXVCLGtCQUF2QixFQUEyQzhOLEtBQTNDLEVBQWtEc2QsUUFBbEQsQ0FBVjtBQUNEO0FBQ0YsT0FKYSxDQUFkO0FBS0Q7O0FBRUQsUUFBSSxDQUFDcVAsUUFBTCxFQUFlO0FBQ2IsV0FBSzU1QixHQUFMLElBQVk4NUIsT0FBWixFQUFxQjtBQUNuQixZQUFJLENBQUNFLE9BQU8sQ0FBQ2g2QixHQUFELENBQVosRUFBbUI7QUFDakI7QUFDQXE2QixvQkFBVSxDQUFDUCxPQUFPLENBQUM5NUIsR0FBRCxDQUFSLEVBQWUsUUFBZixFQUF5QnVxQixRQUF6QixFQUFtQ0EsUUFBbkMsRUFBNkNzUCxTQUE3QyxDQUFWO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsTUFBSVcsY0FBYyxHQUFHNTlCLE1BQU0sQ0FBQ29DLE1BQVAsQ0FBYyxJQUFkLENBQXJCOztBQUVBLFdBQVMrNkIscUJBQVQsQ0FDRTluQixJQURGLEVBRUVwSixFQUZGLEVBR0U7QUFDQSxRQUFJMUcsR0FBRyxHQUFHdkYsTUFBTSxDQUFDb0MsTUFBUCxDQUFjLElBQWQsQ0FBVjs7QUFDQSxRQUFJLENBQUNpVCxJQUFMLEVBQVc7QUFDVDtBQUNBLGFBQU85UCxHQUFQO0FBQ0Q7O0FBQ0QsUUFBSWhELENBQUosRUFBT2k3QixHQUFQOztBQUNBLFNBQUtqN0IsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHOFMsSUFBSSxDQUFDN1MsTUFBckIsRUFBNkJELENBQUMsRUFBOUIsRUFBa0M7QUFDaENpN0IsU0FBRyxHQUFHbm9CLElBQUksQ0FBQzlTLENBQUQsQ0FBVjs7QUFDQSxVQUFJLENBQUNpN0IsR0FBRyxDQUFDSyxTQUFULEVBQW9CO0FBQ2xCO0FBQ0FMLFdBQUcsQ0FBQ0ssU0FBSixHQUFnQkQsY0FBaEI7QUFDRDs7QUFDRHI0QixTQUFHLENBQUN1NEIsYUFBYSxDQUFDTixHQUFELENBQWQsQ0FBSCxHQUEwQkEsR0FBMUI7QUFDQUEsU0FBRyxDQUFDajFCLEdBQUosR0FBVXNOLFlBQVksQ0FBQzVKLEVBQUUsQ0FBQ1EsUUFBSixFQUFjLFlBQWQsRUFBNEIrd0IsR0FBRyxDQUFDN3dCLElBQWhDLEVBQXNDLElBQXRDLENBQXRCO0FBQ0QsS0FmRCxDQWdCQTs7O0FBQ0EsV0FBT3BILEdBQVA7QUFDRDs7QUFFRCxXQUFTdTRCLGFBQVQsQ0FBd0JOLEdBQXhCLEVBQTZCO0FBQzNCLFdBQU9BLEdBQUcsQ0FBQ08sT0FBSixJQUFpQlAsR0FBRyxDQUFDN3dCLElBQUwsR0FBYSxHQUFiLEdBQW9CM00sTUFBTSxDQUFDK0YsSUFBUCxDQUFZeTNCLEdBQUcsQ0FBQ0ssU0FBSixJQUFpQixFQUE3QixFQUFpQzEzQixJQUFqQyxDQUFzQyxHQUF0QyxDQUEzQztBQUNEOztBQUVELFdBQVNzM0IsVUFBVCxDQUFxQkQsR0FBckIsRUFBMEJwcEIsSUFBMUIsRUFBZ0MvRCxLQUFoQyxFQUF1Q3NkLFFBQXZDLEVBQWlEc1AsU0FBakQsRUFBNEQ7QUFDMUQsUUFBSTM1QixFQUFFLEdBQUdrNkIsR0FBRyxDQUFDajFCLEdBQUosSUFBV2kxQixHQUFHLENBQUNqMUIsR0FBSixDQUFRNkwsSUFBUixDQUFwQjs7QUFDQSxRQUFJOVEsRUFBSixFQUFRO0FBQ04sVUFBSTtBQUNGQSxVQUFFLENBQUMrTSxLQUFLLENBQUN6QixHQUFQLEVBQVk0dUIsR0FBWixFQUFpQm50QixLQUFqQixFQUF3QnNkLFFBQXhCLEVBQWtDc1AsU0FBbEMsQ0FBRjtBQUNELE9BRkQsQ0FFRSxPQUFPdDJCLENBQVAsRUFBVTtBQUNWK1EsbUJBQVcsQ0FBQy9RLENBQUQsRUFBSTBKLEtBQUssQ0FBQ3hCLE9BQVYsRUFBb0IsZUFBZ0IydUIsR0FBRyxDQUFDN3dCLElBQXBCLEdBQTRCLEdBQTVCLEdBQWtDeUgsSUFBbEMsR0FBeUMsT0FBN0QsQ0FBWDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJNHBCLFdBQVcsR0FBRyxDQUNoQnZPLEdBRGdCLEVBRWhCbmEsVUFGZ0IsQ0FBbEI7QUFLQTs7QUFFQSxXQUFTMm9CLFdBQVQsQ0FBc0J0USxRQUF0QixFQUFnQ3RkLEtBQWhDLEVBQXVDO0FBQ3JDLFFBQUlqRyxJQUFJLEdBQUdpRyxLQUFLLENBQUN2QixnQkFBakI7O0FBQ0EsUUFBSXpPLEtBQUssQ0FBQytKLElBQUQsQ0FBTCxJQUFlQSxJQUFJLENBQUNTLElBQUwsQ0FBVXlCLE9BQVYsQ0FBa0I0eEIsWUFBbEIsS0FBbUMsS0FBdEQsRUFBNkQ7QUFDM0Q7QUFDRDs7QUFDRCxRQUFJaCtCLE9BQU8sQ0FBQ3l0QixRQUFRLENBQUNsZixJQUFULENBQWNrTyxLQUFmLENBQVAsSUFBZ0N6YyxPQUFPLENBQUNtUSxLQUFLLENBQUM1QixJQUFOLENBQVdrTyxLQUFaLENBQTNDLEVBQStEO0FBQzdEO0FBQ0Q7O0FBQ0QsUUFBSXZaLEdBQUosRUFBU3lVLEdBQVQsRUFBY3FFLEdBQWQ7QUFDQSxRQUFJdE4sR0FBRyxHQUFHeUIsS0FBSyxDQUFDekIsR0FBaEI7QUFDQSxRQUFJdXZCLFFBQVEsR0FBR3hRLFFBQVEsQ0FBQ2xmLElBQVQsQ0FBY2tPLEtBQWQsSUFBdUIsRUFBdEM7QUFDQSxRQUFJQSxLQUFLLEdBQUd0TSxLQUFLLENBQUM1QixJQUFOLENBQVdrTyxLQUFYLElBQW9CLEVBQWhDLENBWHFDLENBWXJDOztBQUNBLFFBQUl0YyxLQUFLLENBQUNzYyxLQUFLLENBQUN6TCxNQUFQLENBQVQsRUFBeUI7QUFDdkJ5TCxXQUFLLEdBQUd0TSxLQUFLLENBQUM1QixJQUFOLENBQVdrTyxLQUFYLEdBQW1CeFgsTUFBTSxDQUFDLEVBQUQsRUFBS3dYLEtBQUwsQ0FBakM7QUFDRDs7QUFFRCxTQUFLdlosR0FBTCxJQUFZdVosS0FBWixFQUFtQjtBQUNqQjlFLFNBQUcsR0FBRzhFLEtBQUssQ0FBQ3ZaLEdBQUQsQ0FBWDtBQUNBOFksU0FBRyxHQUFHaWlCLFFBQVEsQ0FBQy82QixHQUFELENBQWQ7O0FBQ0EsVUFBSThZLEdBQUcsS0FBS3JFLEdBQVosRUFBaUI7QUFDZnVtQixlQUFPLENBQUN4dkIsR0FBRCxFQUFNeEwsR0FBTixFQUFXeVUsR0FBWCxDQUFQO0FBQ0Q7QUFDRixLQXZCb0MsQ0F3QnJDO0FBQ0E7O0FBQ0E7OztBQUNBLFFBQUksQ0FBQ2xPLElBQUksSUFBSUUsTUFBVCxLQUFvQjhTLEtBQUssQ0FBQ2xjLEtBQU4sS0FBZ0IwOUIsUUFBUSxDQUFDMTlCLEtBQWpELEVBQXdEO0FBQ3REMjlCLGFBQU8sQ0FBQ3h2QixHQUFELEVBQU0sT0FBTixFQUFlK04sS0FBSyxDQUFDbGMsS0FBckIsQ0FBUDtBQUNEOztBQUNELFNBQUsyQyxHQUFMLElBQVkrNkIsUUFBWixFQUFzQjtBQUNwQixVQUFJaitCLE9BQU8sQ0FBQ3ljLEtBQUssQ0FBQ3ZaLEdBQUQsQ0FBTixDQUFYLEVBQXlCO0FBQ3ZCLFlBQUk4d0IsT0FBTyxDQUFDOXdCLEdBQUQsQ0FBWCxFQUFrQjtBQUNoQndMLGFBQUcsQ0FBQ3l2QixpQkFBSixDQUFzQnBLLE9BQXRCLEVBQStCRSxZQUFZLENBQUMvd0IsR0FBRCxDQUEzQztBQUNELFNBRkQsTUFFTyxJQUFJLENBQUMyd0IsZ0JBQWdCLENBQUMzd0IsR0FBRCxDQUFyQixFQUE0QjtBQUNqQ3dMLGFBQUcsQ0FBQzR0QixlQUFKLENBQW9CcDVCLEdBQXBCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBU2c3QixPQUFULENBQWtCL3FCLEVBQWxCLEVBQXNCalEsR0FBdEIsRUFBMkIzQyxLQUEzQixFQUFrQztBQUNoQyxRQUFJNFMsRUFBRSxDQUFDMGlCLE9BQUgsQ0FBVy95QixPQUFYLENBQW1CLEdBQW5CLElBQTBCLENBQUMsQ0FBL0IsRUFBa0M7QUFDaENzN0IsaUJBQVcsQ0FBQ2pyQixFQUFELEVBQUtqUSxHQUFMLEVBQVUzQyxLQUFWLENBQVg7QUFDRCxLQUZELE1BRU8sSUFBSXV6QixhQUFhLENBQUM1d0IsR0FBRCxDQUFqQixFQUF3QjtBQUM3QjtBQUNBO0FBQ0EsVUFBSWd4QixnQkFBZ0IsQ0FBQzN6QixLQUFELENBQXBCLEVBQTZCO0FBQzNCNFMsVUFBRSxDQUFDbXBCLGVBQUgsQ0FBbUJwNUIsR0FBbkI7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBO0FBQ0EzQyxhQUFLLEdBQUcyQyxHQUFHLEtBQUssaUJBQVIsSUFBNkJpUSxFQUFFLENBQUMwaUIsT0FBSCxLQUFlLE9BQTVDLEdBQ0osTUFESSxHQUVKM3lCLEdBRko7QUFHQWlRLFVBQUUsQ0FBQzRpQixZQUFILENBQWdCN3lCLEdBQWhCLEVBQXFCM0MsS0FBckI7QUFDRDtBQUNGLEtBYk0sTUFhQSxJQUFJc3pCLGdCQUFnQixDQUFDM3dCLEdBQUQsQ0FBcEIsRUFBMkI7QUFDaENpUSxRQUFFLENBQUM0aUIsWUFBSCxDQUFnQjd5QixHQUFoQixFQUFxQmd4QixnQkFBZ0IsQ0FBQzN6QixLQUFELENBQWhCLElBQTJCQSxLQUFLLEtBQUssT0FBckMsR0FBK0MsT0FBL0MsR0FBeUQsTUFBOUU7QUFDRCxLQUZNLE1BRUEsSUFBSXl6QixPQUFPLENBQUM5d0IsR0FBRCxDQUFYLEVBQWtCO0FBQ3ZCLFVBQUlneEIsZ0JBQWdCLENBQUMzekIsS0FBRCxDQUFwQixFQUE2QjtBQUMzQjRTLFVBQUUsQ0FBQ2dyQixpQkFBSCxDQUFxQnBLLE9BQXJCLEVBQThCRSxZQUFZLENBQUMvd0IsR0FBRCxDQUExQztBQUNELE9BRkQsTUFFTztBQUNMaVEsVUFBRSxDQUFDa3JCLGNBQUgsQ0FBa0J0SyxPQUFsQixFQUEyQjd3QixHQUEzQixFQUFnQzNDLEtBQWhDO0FBQ0Q7QUFDRixLQU5NLE1BTUE7QUFDTDY5QixpQkFBVyxDQUFDanJCLEVBQUQsRUFBS2pRLEdBQUwsRUFBVTNDLEtBQVYsQ0FBWDtBQUNEO0FBQ0Y7O0FBRUQsV0FBUzY5QixXQUFULENBQXNCanJCLEVBQXRCLEVBQTBCalEsR0FBMUIsRUFBK0IzQyxLQUEvQixFQUFzQztBQUNwQyxRQUFJMnpCLGdCQUFnQixDQUFDM3pCLEtBQUQsQ0FBcEIsRUFBNkI7QUFDM0I0UyxRQUFFLENBQUNtcEIsZUFBSCxDQUFtQnA1QixHQUFuQjtBQUNELEtBRkQsTUFFTztBQUNMO0FBQ0E7QUFDQTs7QUFDQTtBQUNBLFVBQ0V1RyxJQUFJLElBQUksQ0FBQ0MsS0FBVCxJQUNBeUosRUFBRSxDQUFDMGlCLE9BQUgsS0FBZSxVQURmLElBRUEzeUIsR0FBRyxLQUFLLGFBRlIsSUFFeUIsQ0FBQ2lRLEVBQUUsQ0FBQ21yQixNQUgvQixFQUlFO0FBQ0EsWUFBSUMsT0FBTyxHQUFHLFVBQVU5M0IsQ0FBVixFQUFhO0FBQ3pCQSxXQUFDLENBQUMrM0Isd0JBQUY7QUFDQXJyQixZQUFFLENBQUNzckIsbUJBQUgsQ0FBdUIsT0FBdkIsRUFBZ0NGLE9BQWhDO0FBQ0QsU0FIRDs7QUFJQXByQixVQUFFLENBQUMvSSxnQkFBSCxDQUFvQixPQUFwQixFQUE2Qm0wQixPQUE3QixFQUxBLENBTUE7O0FBQ0FwckIsVUFBRSxDQUFDbXJCLE1BQUgsR0FBWSxJQUFaO0FBQWtCO0FBQ25COztBQUNEbnJCLFFBQUUsQ0FBQzRpQixZQUFILENBQWdCN3lCLEdBQWhCLEVBQXFCM0MsS0FBckI7QUFDRDtBQUNGOztBQUVELE1BQUlrYyxLQUFLLEdBQUc7QUFDVnZhLFVBQU0sRUFBRTY3QixXQURFO0FBRVZod0IsVUFBTSxFQUFFZ3dCO0FBR1Y7O0FBTFksR0FBWjs7QUFPQSxXQUFTVyxXQUFULENBQXNCalIsUUFBdEIsRUFBZ0N0ZCxLQUFoQyxFQUF1QztBQUNyQyxRQUFJZ0QsRUFBRSxHQUFHaEQsS0FBSyxDQUFDekIsR0FBZjtBQUNBLFFBQUlILElBQUksR0FBRzRCLEtBQUssQ0FBQzVCLElBQWpCO0FBQ0EsUUFBSW93QixPQUFPLEdBQUdsUixRQUFRLENBQUNsZixJQUF2Qjs7QUFDQSxRQUNFdk8sT0FBTyxDQUFDdU8sSUFBSSxDQUFDaW1CLFdBQU4sQ0FBUCxJQUNBeDBCLE9BQU8sQ0FBQ3VPLElBQUksQ0FBQzJnQixLQUFOLENBRFAsS0FFRWx2QixPQUFPLENBQUMyK0IsT0FBRCxDQUFQLElBQ0UzK0IsT0FBTyxDQUFDMitCLE9BQU8sQ0FBQ25LLFdBQVQsQ0FBUCxJQUNBeDBCLE9BQU8sQ0FBQzIrQixPQUFPLENBQUN6UCxLQUFULENBSlgsQ0FERixFQVFFO0FBQ0E7QUFDRDs7QUFFRCxRQUFJMFAsR0FBRyxHQUFHekssZ0JBQWdCLENBQUNoa0IsS0FBRCxDQUExQixDQWhCcUMsQ0FrQnJDOztBQUNBLFFBQUkwdUIsZUFBZSxHQUFHMXJCLEVBQUUsQ0FBQzJyQixrQkFBekI7O0FBQ0EsUUFBSTMrQixLQUFLLENBQUMwK0IsZUFBRCxDQUFULEVBQTRCO0FBQzFCRCxTQUFHLEdBQUc3NEIsTUFBTSxDQUFDNjRCLEdBQUQsRUFBTWxLLGNBQWMsQ0FBQ21LLGVBQUQsQ0FBcEIsQ0FBWjtBQUNELEtBdEJvQyxDQXdCckM7OztBQUNBLFFBQUlELEdBQUcsS0FBS3pyQixFQUFFLENBQUM0ckIsVUFBZixFQUEyQjtBQUN6QjVyQixRQUFFLENBQUM0aUIsWUFBSCxDQUFnQixPQUFoQixFQUF5QjZJLEdBQXpCO0FBQ0F6ckIsUUFBRSxDQUFDNHJCLFVBQUgsR0FBZ0JILEdBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJSSxLQUFLLEdBQUc7QUFDVjk4QixVQUFNLEVBQUV3OEIsV0FERTtBQUVWM3dCLFVBQU0sRUFBRTJ3QjtBQUdWOztBQUxZLEdBQVo7QUFPQSxNQUFJTyxtQkFBbUIsR0FBRyxlQUExQjs7QUFFQSxXQUFTQyxZQUFULENBQXVCQyxHQUF2QixFQUE0QjtBQUMxQixRQUFJQyxRQUFRLEdBQUcsS0FBZjtBQUNBLFFBQUlDLFFBQVEsR0FBRyxLQUFmO0FBQ0EsUUFBSUMsZ0JBQWdCLEdBQUcsS0FBdkI7QUFDQSxRQUFJQyxPQUFPLEdBQUcsS0FBZDtBQUNBLFFBQUlDLEtBQUssR0FBRyxDQUFaO0FBQ0EsUUFBSUMsTUFBTSxHQUFHLENBQWI7QUFDQSxRQUFJQyxLQUFLLEdBQUcsQ0FBWjtBQUNBLFFBQUlDLGVBQWUsR0FBRyxDQUF0QjtBQUNBLFFBQUkvN0IsQ0FBSixFQUFPZzhCLElBQVAsRUFBYXY5QixDQUFiLEVBQWdCb2lCLFVBQWhCLEVBQTRCb2IsT0FBNUI7O0FBRUEsU0FBS3g5QixDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUc4OEIsR0FBRyxDQUFDNzhCLE1BQXBCLEVBQTRCRCxDQUFDLEVBQTdCLEVBQWlDO0FBQy9CdTlCLFVBQUksR0FBR2g4QixDQUFQO0FBQ0FBLE9BQUMsR0FBR3U3QixHQUFHLENBQUMvMkIsVUFBSixDQUFlL0YsQ0FBZixDQUFKOztBQUNBLFVBQUkrOEIsUUFBSixFQUFjO0FBQ1osWUFBSXg3QixDQUFDLEtBQUssSUFBTixJQUFjZzhCLElBQUksS0FBSyxJQUEzQixFQUFpQztBQUFFUixrQkFBUSxHQUFHLEtBQVg7QUFBbUI7QUFDdkQsT0FGRCxNQUVPLElBQUlDLFFBQUosRUFBYztBQUNuQixZQUFJejdCLENBQUMsS0FBSyxJQUFOLElBQWNnOEIsSUFBSSxLQUFLLElBQTNCLEVBQWlDO0FBQUVQLGtCQUFRLEdBQUcsS0FBWDtBQUFtQjtBQUN2RCxPQUZNLE1BRUEsSUFBSUMsZ0JBQUosRUFBc0I7QUFDM0IsWUFBSTE3QixDQUFDLEtBQUssSUFBTixJQUFjZzhCLElBQUksS0FBSyxJQUEzQixFQUFpQztBQUFFTiwwQkFBZ0IsR0FBRyxLQUFuQjtBQUEyQjtBQUMvRCxPQUZNLE1BRUEsSUFBSUMsT0FBSixFQUFhO0FBQ2xCLFlBQUkzN0IsQ0FBQyxLQUFLLElBQU4sSUFBY2c4QixJQUFJLEtBQUssSUFBM0IsRUFBaUM7QUFBRUwsaUJBQU8sR0FBRyxLQUFWO0FBQWtCO0FBQ3RELE9BRk0sTUFFQSxJQUNMMzdCLENBQUMsS0FBSyxJQUFOLElBQWM7QUFDZHU3QixTQUFHLENBQUMvMkIsVUFBSixDQUFlL0YsQ0FBQyxHQUFHLENBQW5CLE1BQTBCLElBRDFCLElBRUE4OEIsR0FBRyxDQUFDLzJCLFVBQUosQ0FBZS9GLENBQUMsR0FBRyxDQUFuQixNQUEwQixJQUYxQixJQUdBLENBQUNtOUIsS0FIRCxJQUdVLENBQUNDLE1BSFgsSUFHcUIsQ0FBQ0MsS0FKakIsRUFLTDtBQUNBLFlBQUlqYixVQUFVLEtBQUt2a0IsU0FBbkIsRUFBOEI7QUFDNUI7QUFDQXkvQix5QkFBZSxHQUFHdDlCLENBQUMsR0FBRyxDQUF0QjtBQUNBb2lCLG9CQUFVLEdBQUcwYSxHQUFHLENBQUNwK0IsS0FBSixDQUFVLENBQVYsRUFBYXNCLENBQWIsRUFBZ0J5OUIsSUFBaEIsRUFBYjtBQUNELFNBSkQsTUFJTztBQUNMQyxvQkFBVTtBQUNYO0FBQ0YsT0FiTSxNQWFBO0FBQ0wsZ0JBQVFuOEIsQ0FBUjtBQUNFLGVBQUssSUFBTDtBQUFXeTdCLG9CQUFRLEdBQUcsSUFBWDtBQUFpQjtBQUFjOztBQUMxQyxlQUFLLElBQUw7QUFBV0Qsb0JBQVEsR0FBRyxJQUFYO0FBQWlCO0FBQWM7O0FBQzFDLGVBQUssSUFBTDtBQUFXRSw0QkFBZ0IsR0FBRyxJQUFuQjtBQUF5QjtBQUFNOztBQUMxQyxlQUFLLElBQUw7QUFBV0ksaUJBQUs7QUFBSTtBQUFzQjs7QUFDMUMsZUFBSyxJQUFMO0FBQVdBLGlCQUFLO0FBQUk7QUFBc0I7O0FBQzFDLGVBQUssSUFBTDtBQUFXRCxrQkFBTTtBQUFJO0FBQXFCOztBQUMxQyxlQUFLLElBQUw7QUFBV0Esa0JBQU07QUFBSTtBQUFxQjs7QUFDMUMsZUFBSyxJQUFMO0FBQVdELGlCQUFLO0FBQUk7QUFBc0I7O0FBQzFDLGVBQUssSUFBTDtBQUFXQSxpQkFBSztBQUFJO0FBQXNCO0FBVDVDOztBQVdBLFlBQUk1N0IsQ0FBQyxLQUFLLElBQVYsRUFBZ0I7QUFBRTtBQUNoQixjQUFJZ2dCLENBQUMsR0FBR3ZoQixDQUFDLEdBQUcsQ0FBWjtBQUNBLGNBQUk2VyxDQUFDLEdBQUksS0FBSyxDQUFkLENBRmMsQ0FHZDs7QUFDQSxpQkFBTzBLLENBQUMsSUFBSSxDQUFaLEVBQWVBLENBQUMsRUFBaEIsRUFBb0I7QUFDbEIxSyxhQUFDLEdBQUdpbUIsR0FBRyxDQUFDcDdCLE1BQUosQ0FBVzZmLENBQVgsQ0FBSjs7QUFDQSxnQkFBSTFLLENBQUMsS0FBSyxHQUFWLEVBQWU7QUFBRTtBQUFPO0FBQ3pCOztBQUNELGNBQUksQ0FBQ0EsQ0FBRCxJQUFNLENBQUMrbEIsbUJBQW1CLENBQUNwMkIsSUFBcEIsQ0FBeUJxUSxDQUF6QixDQUFYLEVBQXdDO0FBQ3RDcW1CLG1CQUFPLEdBQUcsSUFBVjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFFBQUk5YSxVQUFVLEtBQUt2a0IsU0FBbkIsRUFBOEI7QUFDNUJ1a0IsZ0JBQVUsR0FBRzBhLEdBQUcsQ0FBQ3ArQixLQUFKLENBQVUsQ0FBVixFQUFhc0IsQ0FBYixFQUFnQnk5QixJQUFoQixFQUFiO0FBQ0QsS0FGRCxNQUVPLElBQUlILGVBQWUsS0FBSyxDQUF4QixFQUEyQjtBQUNoQ0ksZ0JBQVU7QUFDWDs7QUFFRCxhQUFTQSxVQUFULEdBQXVCO0FBQ3JCLE9BQUNGLE9BQU8sS0FBS0EsT0FBTyxHQUFHLEVBQWYsQ0FBUixFQUE0QjF5QixJQUE1QixDQUFpQ2d5QixHQUFHLENBQUNwK0IsS0FBSixDQUFVNCtCLGVBQVYsRUFBMkJ0OUIsQ0FBM0IsRUFBOEJ5OUIsSUFBOUIsRUFBakM7QUFDQUgscUJBQWUsR0FBR3Q5QixDQUFDLEdBQUcsQ0FBdEI7QUFDRDs7QUFFRCxRQUFJdzlCLE9BQUosRUFBYTtBQUNYLFdBQUt4OUIsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdzlCLE9BQU8sQ0FBQ3Y5QixNQUF4QixFQUFnQ0QsQ0FBQyxFQUFqQyxFQUFxQztBQUNuQ29pQixrQkFBVSxHQUFHdWIsVUFBVSxDQUFDdmIsVUFBRCxFQUFhb2IsT0FBTyxDQUFDeDlCLENBQUQsQ0FBcEIsQ0FBdkI7QUFDRDtBQUNGOztBQUVELFdBQU9vaUIsVUFBUDtBQUNEOztBQUVELFdBQVN1YixVQUFULENBQXFCYixHQUFyQixFQUEwQjFXLE1BQTFCLEVBQWtDO0FBQ2hDLFFBQUlwbUIsQ0FBQyxHQUFHb21CLE1BQU0sQ0FBQzNsQixPQUFQLENBQWUsR0FBZixDQUFSOztBQUNBLFFBQUlULENBQUMsR0FBRyxDQUFSLEVBQVc7QUFDVDtBQUNBLGFBQVEsVUFBVW9tQixNQUFWLEdBQW1CLE1BQW5CLEdBQTRCMFcsR0FBNUIsR0FBa0MsR0FBMUM7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJMXlCLElBQUksR0FBR2djLE1BQU0sQ0FBQzFuQixLQUFQLENBQWEsQ0FBYixFQUFnQnNCLENBQWhCLENBQVg7QUFDQSxVQUFJdU8sSUFBSSxHQUFHNlgsTUFBTSxDQUFDMW5CLEtBQVAsQ0FBYXNCLENBQUMsR0FBRyxDQUFqQixDQUFYO0FBQ0EsYUFBUSxVQUFVb0ssSUFBVixHQUFpQixNQUFqQixHQUEwQjB5QixHQUExQixJQUFpQ3Z1QixJQUFJLEtBQUssR0FBVCxHQUFlLE1BQU1BLElBQXJCLEdBQTRCQSxJQUE3RCxDQUFSO0FBQ0Q7QUFDRjtBQUVEOzs7QUFFQSxXQUFTcXZCLFFBQVQsQ0FBbUJuMEIsR0FBbkIsRUFBd0I7QUFDdEJILFdBQU8sQ0FBQ00sS0FBUixDQUFlLHFCQUFxQkgsR0FBcEM7QUFDRDs7QUFFRCxXQUFTbzBCLG1CQUFULENBQ0V2NkIsT0FERixFQUVFekMsR0FGRixFQUdFO0FBQ0EsV0FBT3lDLE9BQU8sR0FDVkEsT0FBTyxDQUFDMUQsR0FBUixDQUFZLFVBQVU2RCxDQUFWLEVBQWE7QUFBRSxhQUFPQSxDQUFDLENBQUM1QyxHQUFELENBQVI7QUFBZ0IsS0FBM0MsRUFBNkN1bEIsTUFBN0MsQ0FBb0QsVUFBVTlrQixDQUFWLEVBQWE7QUFBRSxhQUFPQSxDQUFQO0FBQVcsS0FBOUUsQ0FEVSxHQUVWLEVBRko7QUFHRDs7QUFFRCxXQUFTdzhCLE9BQVQsQ0FBa0JodEIsRUFBbEIsRUFBc0IxRyxJQUF0QixFQUE0QmxNLEtBQTVCLEVBQW1DO0FBQ2pDLEtBQUM0UyxFQUFFLENBQUNvQixLQUFILEtBQWFwQixFQUFFLENBQUNvQixLQUFILEdBQVcsRUFBeEIsQ0FBRCxFQUE4QnBILElBQTlCLENBQW1DO0FBQUVWLFVBQUksRUFBRUEsSUFBUjtBQUFjbE0sV0FBSyxFQUFFQTtBQUFyQixLQUFuQztBQUNBNFMsTUFBRSxDQUFDaXRCLEtBQUgsR0FBVyxLQUFYO0FBQ0Q7O0FBRUQsV0FBU0MsT0FBVCxDQUFrQmx0QixFQUFsQixFQUFzQjFHLElBQXRCLEVBQTRCbE0sS0FBNUIsRUFBbUM7QUFDakMsS0FBQzRTLEVBQUUsQ0FBQ3NKLEtBQUgsS0FBYXRKLEVBQUUsQ0FBQ3NKLEtBQUgsR0FBVyxFQUF4QixDQUFELEVBQThCdFAsSUFBOUIsQ0FBbUM7QUFBRVYsVUFBSSxFQUFFQSxJQUFSO0FBQWNsTSxXQUFLLEVBQUVBO0FBQXJCLEtBQW5DO0FBQ0E0UyxNQUFFLENBQUNpdEIsS0FBSCxHQUFXLEtBQVg7QUFDRCxHQS80TW9CLENBaTVNckI7OztBQUNBLFdBQVNFLFVBQVQsQ0FBcUJudEIsRUFBckIsRUFBeUIxRyxJQUF6QixFQUErQmxNLEtBQS9CLEVBQXNDO0FBQ3BDNFMsTUFBRSxDQUFDb3RCLFFBQUgsQ0FBWTl6QixJQUFaLElBQW9CbE0sS0FBcEI7QUFDQTRTLE1BQUUsQ0FBQ3F0QixTQUFILENBQWFyekIsSUFBYixDQUFrQjtBQUFFVixVQUFJLEVBQUVBLElBQVI7QUFBY2xNLFdBQUssRUFBRUE7QUFBckIsS0FBbEI7QUFDRDs7QUFFRCxXQUFTa2dDLFlBQVQsQ0FDRXR0QixFQURGLEVBRUUxRyxJQUZGLEVBR0VveEIsT0FIRixFQUlFdDlCLEtBSkYsRUFLRW1nQyxHQUxGLEVBTUUvQyxTQU5GLEVBT0U7QUFDQSxLQUFDeHFCLEVBQUUsQ0FBQ2lDLFVBQUgsS0FBa0JqQyxFQUFFLENBQUNpQyxVQUFILEdBQWdCLEVBQWxDLENBQUQsRUFBd0NqSSxJQUF4QyxDQUE2QztBQUFFVixVQUFJLEVBQUVBLElBQVI7QUFBY294QixhQUFPLEVBQUVBLE9BQXZCO0FBQWdDdDlCLFdBQUssRUFBRUEsS0FBdkM7QUFBOENtZ0MsU0FBRyxFQUFFQSxHQUFuRDtBQUF3RC9DLGVBQVMsRUFBRUE7QUFBbkUsS0FBN0M7QUFDQXhxQixNQUFFLENBQUNpdEIsS0FBSCxHQUFXLEtBQVg7QUFDRDs7QUFFRCxXQUFTTyxVQUFULENBQ0V4dEIsRUFERixFQUVFMUcsSUFGRixFQUdFbE0sS0FIRixFQUlFbzlCLFNBSkYsRUFLRWlELFNBTEYsRUFNRXQxQixJQU5GLEVBT0U7QUFDQXF5QixhQUFTLEdBQUdBLFNBQVMsSUFBSTk5QixXQUF6QixDQURBLENBRUE7O0FBQ0E7O0FBQ0EsUUFDRSxrQkFBa0IsWUFBbEIsSUFBa0N5TCxJQUFsQyxJQUNBcXlCLFNBQVMsQ0FBQ2tELE9BRFYsSUFDcUJsRCxTQUFTLENBQUNyaUIsT0FGakMsRUFHRTtBQUNBaFEsVUFBSSxDQUNGLGtEQUNBLCtDQUZFLENBQUo7QUFJRCxLQVpELENBY0E7OztBQUNBLFFBQUlxeUIsU0FBUyxDQUFDN2xCLE9BQWQsRUFBdUI7QUFDckIsYUFBTzZsQixTQUFTLENBQUM3bEIsT0FBakI7QUFDQXJMLFVBQUksR0FBRyxNQUFNQSxJQUFiLENBRnFCLENBRUY7QUFDcEI7O0FBQ0QsUUFBSWt4QixTQUFTLENBQUM5MkIsSUFBZCxFQUFvQjtBQUNsQixhQUFPODJCLFNBQVMsQ0FBQzkyQixJQUFqQjtBQUNBNEYsVUFBSSxHQUFHLE1BQU1BLElBQWIsQ0FGa0IsQ0FFQztBQUNwQjtBQUNEOzs7QUFDQSxRQUFJa3hCLFNBQVMsQ0FBQ3JpQixPQUFkLEVBQXVCO0FBQ3JCLGFBQU9xaUIsU0FBUyxDQUFDcmlCLE9BQWpCO0FBQ0E3TyxVQUFJLEdBQUcsTUFBTUEsSUFBYixDQUZxQixDQUVGO0FBQ3BCLEtBM0JELENBNkJBO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBSUEsSUFBSSxLQUFLLE9BQWIsRUFBc0I7QUFDcEIsVUFBSWt4QixTQUFTLENBQUNtRCxLQUFkLEVBQXFCO0FBQ25CcjBCLFlBQUksR0FBRyxhQUFQO0FBQ0EsZUFBT2t4QixTQUFTLENBQUNtRCxLQUFqQjtBQUNELE9BSEQsTUFHTyxJQUFJbkQsU0FBUyxDQUFDb0QsTUFBZCxFQUFzQjtBQUMzQnQwQixZQUFJLEdBQUcsU0FBUDtBQUNEO0FBQ0Y7O0FBRUQsUUFBSXUwQixNQUFKOztBQUNBLFFBQUlyRCxTQUFTLENBQUNzRCxNQUFkLEVBQXNCO0FBQ3BCLGFBQU90RCxTQUFTLENBQUNzRCxNQUFqQjtBQUNBRCxZQUFNLEdBQUc3dEIsRUFBRSxDQUFDK3RCLFlBQUgsS0FBb0IvdEIsRUFBRSxDQUFDK3RCLFlBQUgsR0FBa0IsRUFBdEMsQ0FBVDtBQUNELEtBSEQsTUFHTztBQUNMRixZQUFNLEdBQUc3dEIsRUFBRSxDQUFDNnRCLE1BQUgsS0FBYzd0QixFQUFFLENBQUM2dEIsTUFBSCxHQUFZLEVBQTFCLENBQVQ7QUFDRDs7QUFFRCxRQUFJRyxVQUFVLEdBQUc7QUFDZjVnQyxXQUFLLEVBQUVBLEtBQUssQ0FBQ3UvQixJQUFOO0FBRFEsS0FBakI7O0FBR0EsUUFBSW5DLFNBQVMsS0FBSzk5QixXQUFsQixFQUErQjtBQUM3QnNoQyxnQkFBVSxDQUFDeEQsU0FBWCxHQUF1QkEsU0FBdkI7QUFDRDs7QUFFRCxRQUFJampCLFFBQVEsR0FBR3NtQixNQUFNLENBQUN2MEIsSUFBRCxDQUFyQjtBQUNBOztBQUNBLFFBQUl6SCxLQUFLLENBQUNzQixPQUFOLENBQWNvVSxRQUFkLENBQUosRUFBNkI7QUFDM0JrbUIsZUFBUyxHQUFHbG1CLFFBQVEsQ0FBQ3NXLE9BQVQsQ0FBaUJtUSxVQUFqQixDQUFILEdBQWtDem1CLFFBQVEsQ0FBQ3ZOLElBQVQsQ0FBY2cwQixVQUFkLENBQTNDO0FBQ0QsS0FGRCxNQUVPLElBQUl6bUIsUUFBSixFQUFjO0FBQ25Cc21CLFlBQU0sQ0FBQ3YwQixJQUFELENBQU4sR0FBZW0wQixTQUFTLEdBQUcsQ0FBQ08sVUFBRCxFQUFhem1CLFFBQWIsQ0FBSCxHQUE0QixDQUFDQSxRQUFELEVBQVd5bUIsVUFBWCxDQUFwRDtBQUNELEtBRk0sTUFFQTtBQUNMSCxZQUFNLENBQUN2MEIsSUFBRCxDQUFOLEdBQWUwMEIsVUFBZjtBQUNEOztBQUVEaHVCLE1BQUUsQ0FBQ2l0QixLQUFILEdBQVcsS0FBWDtBQUNEOztBQUVELFdBQVNnQixjQUFULENBQ0VqdUIsRUFERixFQUVFMUcsSUFGRixFQUdFNDBCLFNBSEYsRUFJRTtBQUNBLFFBQUlDLFlBQVksR0FDZEMsZ0JBQWdCLENBQUNwdUIsRUFBRCxFQUFLLE1BQU0xRyxJQUFYLENBQWhCLElBQ0E4MEIsZ0JBQWdCLENBQUNwdUIsRUFBRCxFQUFLLFlBQVkxRyxJQUFqQixDQUZsQjs7QUFHQSxRQUFJNjBCLFlBQVksSUFBSSxJQUFwQixFQUEwQjtBQUN4QixhQUFPcEMsWUFBWSxDQUFDb0MsWUFBRCxDQUFuQjtBQUNELEtBRkQsTUFFTyxJQUFJRCxTQUFTLEtBQUssS0FBbEIsRUFBeUI7QUFDOUIsVUFBSUcsV0FBVyxHQUFHRCxnQkFBZ0IsQ0FBQ3B1QixFQUFELEVBQUsxRyxJQUFMLENBQWxDOztBQUNBLFVBQUkrMEIsV0FBVyxJQUFJLElBQW5CLEVBQXlCO0FBQ3ZCLGVBQU85L0IsSUFBSSxDQUFDQyxTQUFMLENBQWU2L0IsV0FBZixDQUFQO0FBQ0Q7QUFDRjtBQUNGLEdBLy9Nb0IsQ0FpZ05yQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU0QsZ0JBQVQsQ0FDRXB1QixFQURGLEVBRUUxRyxJQUZGLEVBR0VnMUIsYUFIRixFQUlFO0FBQ0EsUUFBSXRnQyxHQUFKOztBQUNBLFFBQUksQ0FBQ0EsR0FBRyxHQUFHZ1MsRUFBRSxDQUFDb3RCLFFBQUgsQ0FBWTl6QixJQUFaLENBQVAsS0FBNkIsSUFBakMsRUFBdUM7QUFDckMsVUFBSXRLLElBQUksR0FBR2dSLEVBQUUsQ0FBQ3F0QixTQUFkOztBQUNBLFdBQUssSUFBSW4rQixDQUFDLEdBQUcsQ0FBUixFQUFXaUMsQ0FBQyxHQUFHbkMsSUFBSSxDQUFDRyxNQUF6QixFQUFpQ0QsQ0FBQyxHQUFHaUMsQ0FBckMsRUFBd0NqQyxDQUFDLEVBQXpDLEVBQTZDO0FBQzNDLFlBQUlGLElBQUksQ0FBQ0UsQ0FBRCxDQUFKLENBQVFvSyxJQUFSLEtBQWlCQSxJQUFyQixFQUEyQjtBQUN6QnRLLGNBQUksQ0FBQ1ksTUFBTCxDQUFZVixDQUFaLEVBQWUsQ0FBZjtBQUNBO0FBQ0Q7QUFDRjtBQUNGOztBQUNELFFBQUlvL0IsYUFBSixFQUFtQjtBQUNqQixhQUFPdHVCLEVBQUUsQ0FBQ290QixRQUFILENBQVk5ekIsSUFBWixDQUFQO0FBQ0Q7O0FBQ0QsV0FBT3RMLEdBQVA7QUFDRDtBQUVEOztBQUVBOzs7OztBQUdBLFdBQVN1Z0MsaUJBQVQsQ0FDRXZ1QixFQURGLEVBRUU1UyxLQUZGLEVBR0VvOUIsU0FIRixFQUlFO0FBQ0EsUUFBSXBPLEdBQUcsR0FBR29PLFNBQVMsSUFBSSxFQUF2QjtBQUNBLFFBQUlnRSxNQUFNLEdBQUdwUyxHQUFHLENBQUNvUyxNQUFqQjtBQUNBLFFBQUk3QixJQUFJLEdBQUd2USxHQUFHLENBQUN1USxJQUFmO0FBRUEsUUFBSThCLG1CQUFtQixHQUFHLEtBQTFCO0FBQ0EsUUFBSUMsZUFBZSxHQUFHRCxtQkFBdEI7O0FBQ0EsUUFBSTlCLElBQUosRUFBVTtBQUNSK0IscUJBQWUsR0FDYixhQUFhRCxtQkFBYixHQUFtQyxlQUFuQyxHQUNBLElBREEsR0FDT0EsbUJBRFAsR0FDNkIsU0FEN0IsR0FFQSxJQUZBLEdBRU9BLG1CQUZQLEdBRTZCLEdBSC9CO0FBSUQ7O0FBQ0QsUUFBSUQsTUFBSixFQUFZO0FBQ1ZFLHFCQUFlLEdBQUcsUUFBUUEsZUFBUixHQUEwQixHQUE1QztBQUNEOztBQUNELFFBQUlDLFVBQVUsR0FBR0MsaUJBQWlCLENBQUN4aEMsS0FBRCxFQUFRc2hDLGVBQVIsQ0FBbEM7QUFFQTF1QixNQUFFLENBQUM2YSxLQUFILEdBQVc7QUFDVHp0QixXQUFLLEVBQUcsTUFBTUEsS0FBTixHQUFjLEdBRGI7QUFFVGtrQixnQkFBVSxFQUFHLE9BQU9sa0IsS0FBUCxHQUFlLElBRm5CO0FBR1RndUIsY0FBUSxFQUFHLGVBQWVxVCxtQkFBZixHQUFxQyxLQUFyQyxHQUE2Q0UsVUFBN0MsR0FBMEQ7QUFINUQsS0FBWDtBQUtEO0FBRUQ7Ozs7O0FBR0EsV0FBU0MsaUJBQVQsQ0FDRXhoQyxLQURGLEVBRUV1aEMsVUFGRixFQUdFO0FBQ0EsUUFBSXo4QixHQUFHLEdBQUcyOEIsVUFBVSxDQUFDemhDLEtBQUQsQ0FBcEI7O0FBQ0EsUUFBSThFLEdBQUcsQ0FBQ25DLEdBQUosS0FBWSxJQUFoQixFQUFzQjtBQUNwQixhQUFRM0MsS0FBSyxHQUFHLEdBQVIsR0FBY3VoQyxVQUF0QjtBQUNELEtBRkQsTUFFTztBQUNMLGFBQVEsVUFBV3o4QixHQUFHLENBQUM4NUIsR0FBZixHQUFzQixJQUF0QixHQUE4Qjk1QixHQUFHLENBQUNuQyxHQUFsQyxHQUF5QyxJQUF6QyxHQUFnRDQrQixVQUFoRCxHQUE2RCxHQUFyRTtBQUNEO0FBQ0Y7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztBQWVBLE1BQUlqeEIsR0FBSjtBQUNBLE1BQUk5TyxHQUFKO0FBQ0EsTUFBSWtnQyxHQUFKO0FBQ0EsTUFBSUMsT0FBSjtBQUNBLE1BQUlDLGFBQUo7QUFDQSxNQUFJQyxnQkFBSjs7QUFJQSxXQUFTSixVQUFULENBQXFCN2dDLEdBQXJCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQUEsT0FBRyxHQUFHQSxHQUFHLENBQUMyK0IsSUFBSixFQUFOO0FBQ0FqdkIsT0FBRyxHQUFHMVAsR0FBRyxDQUFDbUIsTUFBVjs7QUFFQSxRQUFJbkIsR0FBRyxDQUFDMkIsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBbkIsSUFBd0IzQixHQUFHLENBQUNraEMsV0FBSixDQUFnQixHQUFoQixJQUF1Qnh4QixHQUFHLEdBQUcsQ0FBekQsRUFBNEQ7QUFDMURxeEIsYUFBTyxHQUFHL2dDLEdBQUcsQ0FBQ2toQyxXQUFKLENBQWdCLEdBQWhCLENBQVY7O0FBQ0EsVUFBSUgsT0FBTyxHQUFHLENBQUMsQ0FBZixFQUFrQjtBQUNoQixlQUFPO0FBQ0wvQyxhQUFHLEVBQUVoK0IsR0FBRyxDQUFDSixLQUFKLENBQVUsQ0FBVixFQUFhbWhDLE9BQWIsQ0FEQTtBQUVMaC9CLGFBQUcsRUFBRSxNQUFNL0IsR0FBRyxDQUFDSixLQUFKLENBQVVtaEMsT0FBTyxHQUFHLENBQXBCLENBQU4sR0FBK0I7QUFGL0IsU0FBUDtBQUlELE9BTEQsTUFLTztBQUNMLGVBQU87QUFDTC9DLGFBQUcsRUFBRWgrQixHQURBO0FBRUwrQixhQUFHLEVBQUU7QUFGQSxTQUFQO0FBSUQ7QUFDRjs7QUFFRG5CLE9BQUcsR0FBR1osR0FBTjtBQUNBK2dDLFdBQU8sR0FBR0MsYUFBYSxHQUFHQyxnQkFBZ0IsR0FBRyxDQUE3Qzs7QUFFQSxXQUFPLENBQUNFLEdBQUcsRUFBWCxFQUFlO0FBQ2JMLFNBQUcsR0FBR00sSUFBSSxFQUFWO0FBQ0E7O0FBQ0EsVUFBSUMsYUFBYSxDQUFDUCxHQUFELENBQWpCLEVBQXdCO0FBQ3RCUSxtQkFBVyxDQUFDUixHQUFELENBQVg7QUFDRCxPQUZELE1BRU8sSUFBSUEsR0FBRyxLQUFLLElBQVosRUFBa0I7QUFDdkJTLG9CQUFZLENBQUNULEdBQUQsQ0FBWjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTztBQUNMOUMsU0FBRyxFQUFFaCtCLEdBQUcsQ0FBQ0osS0FBSixDQUFVLENBQVYsRUFBYW9oQyxhQUFiLENBREE7QUFFTGovQixTQUFHLEVBQUUvQixHQUFHLENBQUNKLEtBQUosQ0FBVW9oQyxhQUFhLEdBQUcsQ0FBMUIsRUFBNkJDLGdCQUE3QjtBQUZBLEtBQVA7QUFJRDs7QUFFRCxXQUFTRyxJQUFULEdBQWlCO0FBQ2YsV0FBT3hnQyxHQUFHLENBQUNxRyxVQUFKLENBQWUsRUFBRTg1QixPQUFqQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU0ksR0FBVCxHQUFnQjtBQUNkLFdBQU9KLE9BQU8sSUFBSXJ4QixHQUFsQjtBQUNEOztBQUVELFdBQVMyeEIsYUFBVCxDQUF3QlAsR0FBeEIsRUFBNkI7QUFDM0IsV0FBT0EsR0FBRyxLQUFLLElBQVIsSUFBZ0JBLEdBQUcsS0FBSyxJQUEvQjtBQUNEOztBQUVELFdBQVNTLFlBQVQsQ0FBdUJULEdBQXZCLEVBQTRCO0FBQzFCLFFBQUlVLFNBQVMsR0FBRyxDQUFoQjtBQUNBUixpQkFBYSxHQUFHRCxPQUFoQjs7QUFDQSxXQUFPLENBQUNJLEdBQUcsRUFBWCxFQUFlO0FBQ2JMLFNBQUcsR0FBR00sSUFBSSxFQUFWOztBQUNBLFVBQUlDLGFBQWEsQ0FBQ1AsR0FBRCxDQUFqQixFQUF3QjtBQUN0QlEsbUJBQVcsQ0FBQ1IsR0FBRCxDQUFYO0FBQ0E7QUFDRDs7QUFDRCxVQUFJQSxHQUFHLEtBQUssSUFBWixFQUFrQjtBQUFFVSxpQkFBUztBQUFLOztBQUNsQyxVQUFJVixHQUFHLEtBQUssSUFBWixFQUFrQjtBQUFFVSxpQkFBUztBQUFLOztBQUNsQyxVQUFJQSxTQUFTLEtBQUssQ0FBbEIsRUFBcUI7QUFDbkJQLHdCQUFnQixHQUFHRixPQUFuQjtBQUNBO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVNPLFdBQVQsQ0FBc0JSLEdBQXRCLEVBQTJCO0FBQ3pCLFFBQUlXLFdBQVcsR0FBR1gsR0FBbEI7O0FBQ0EsV0FBTyxDQUFDSyxHQUFHLEVBQVgsRUFBZTtBQUNiTCxTQUFHLEdBQUdNLElBQUksRUFBVjs7QUFDQSxVQUFJTixHQUFHLEtBQUtXLFdBQVosRUFBeUI7QUFDdkI7QUFDRDtBQUNGO0FBQ0Y7QUFFRDs7O0FBRUEsTUFBSUMsTUFBSixDQXJyTnFCLENBdXJOckI7QUFDQTs7QUFDQSxNQUFJQyxXQUFXLEdBQUcsS0FBbEI7QUFDQSxNQUFJQyxvQkFBb0IsR0FBRyxLQUEzQjs7QUFFQSxXQUFTL1UsS0FBVCxDQUNFN2EsRUFERixFQUVFbXFCLEdBRkYsRUFHRTBGLEtBSEYsRUFJRTtBQUNBSCxVQUFNLEdBQUdHLEtBQVQ7QUFDQSxRQUFJemlDLEtBQUssR0FBRys4QixHQUFHLENBQUMvOEIsS0FBaEI7QUFDQSxRQUFJbzlCLFNBQVMsR0FBR0wsR0FBRyxDQUFDSyxTQUFwQjtBQUNBLFFBQUlydkIsR0FBRyxHQUFHNkUsRUFBRSxDQUFDN0UsR0FBYjtBQUNBLFFBQUkrRixJQUFJLEdBQUdsQixFQUFFLENBQUNvdEIsUUFBSCxDQUFZbHNCLElBQXZCO0FBRUE7QUFDRTtBQUNBO0FBQ0EsVUFBSS9GLEdBQUcsS0FBSyxPQUFSLElBQW1CK0YsSUFBSSxLQUFLLE1BQWhDLEVBQXdDO0FBQ3RDd3VCLGNBQU0sQ0FDSixNQUFPMXZCLEVBQUUsQ0FBQzdFLEdBQVYsR0FBaUIsYUFBakIsR0FBaUMvTixLQUFqQyxHQUF5QyxzQkFBekMsR0FDQSxnRUFGSSxDQUFOO0FBSUQ7QUFDRjs7QUFFRCxRQUFJNFMsRUFBRSxDQUFDc0wsU0FBUCxFQUFrQjtBQUNoQmlqQix1QkFBaUIsQ0FBQ3Z1QixFQUFELEVBQUs1UyxLQUFMLEVBQVlvOUIsU0FBWixDQUFqQixDQURnQixDQUVoQjs7QUFDQSxhQUFPLEtBQVA7QUFDRCxLQUpELE1BSU8sSUFBSXJ2QixHQUFHLEtBQUssUUFBWixFQUFzQjtBQUMzQjIwQixlQUFTLENBQUM5dkIsRUFBRCxFQUFLNVMsS0FBTCxFQUFZbzlCLFNBQVosQ0FBVDtBQUNELEtBRk0sTUFFQSxJQUFJcnZCLEdBQUcsS0FBSyxPQUFSLElBQW1CK0YsSUFBSSxLQUFLLFVBQWhDLEVBQTRDO0FBQ2pENnVCLHNCQUFnQixDQUFDL3ZCLEVBQUQsRUFBSzVTLEtBQUwsRUFBWW85QixTQUFaLENBQWhCO0FBQ0QsS0FGTSxNQUVBLElBQUlydkIsR0FBRyxLQUFLLE9BQVIsSUFBbUIrRixJQUFJLEtBQUssT0FBaEMsRUFBeUM7QUFDOUM4dUIsbUJBQWEsQ0FBQ2h3QixFQUFELEVBQUs1UyxLQUFMLEVBQVlvOUIsU0FBWixDQUFiO0FBQ0QsS0FGTSxNQUVBLElBQUlydkIsR0FBRyxLQUFLLE9BQVIsSUFBbUJBLEdBQUcsS0FBSyxVQUEvQixFQUEyQztBQUNoRDgwQixxQkFBZSxDQUFDandCLEVBQUQsRUFBSzVTLEtBQUwsRUFBWW85QixTQUFaLENBQWY7QUFDRCxLQUZNLE1BRUEsSUFBSSxDQUFDejJCLE1BQU0sQ0FBQ1UsYUFBUCxDQUFxQjBHLEdBQXJCLENBQUwsRUFBZ0M7QUFDckNvekIsdUJBQWlCLENBQUN2dUIsRUFBRCxFQUFLNVMsS0FBTCxFQUFZbzlCLFNBQVosQ0FBakIsQ0FEcUMsQ0FFckM7O0FBQ0EsYUFBTyxLQUFQO0FBQ0QsS0FKTSxNQUlBO0FBQ0xrRixZQUFNLENBQ0osTUFBTzF2QixFQUFFLENBQUM3RSxHQUFWLEdBQWlCLGFBQWpCLEdBQWlDL04sS0FBakMsR0FBeUMsT0FBekMsR0FDQSxpREFEQSxHQUVBLGdFQUZBLEdBR0Esc0VBSkksQ0FBTjtBQU1ELEtBekNELENBMkNBOzs7QUFDQSxXQUFPLElBQVA7QUFDRDs7QUFFRCxXQUFTMmlDLGdCQUFULENBQ0UvdkIsRUFERixFQUVFNVMsS0FGRixFQUdFbzlCLFNBSEYsRUFJRTtBQUNBLFFBQUlnRSxNQUFNLEdBQUdoRSxTQUFTLElBQUlBLFNBQVMsQ0FBQ2dFLE1BQXBDO0FBQ0EsUUFBSTBCLFlBQVksR0FBR2pDLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssT0FBTCxDQUFkLElBQStCLE1BQWxEO0FBQ0EsUUFBSW13QixnQkFBZ0IsR0FBR2xDLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssWUFBTCxDQUFkLElBQW9DLE1BQTNEO0FBQ0EsUUFBSW93QixpQkFBaUIsR0FBR25DLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssYUFBTCxDQUFkLElBQXFDLE9BQTdEO0FBQ0FndEIsV0FBTyxDQUFDaHRCLEVBQUQsRUFBSyxTQUFMLEVBQ0wsbUJBQW1CNVMsS0FBbkIsR0FBMkIsR0FBM0IsR0FDQSxNQURBLEdBQ1NBLEtBRFQsR0FDaUIsR0FEakIsR0FDdUI4aUMsWUFEdkIsR0FDc0MsTUFEdEMsSUFFRUMsZ0JBQWdCLEtBQUssTUFBckIsR0FDSyxPQUFPL2lDLEtBQVAsR0FBZSxHQURwQixHQUVLLFNBQVNBLEtBQVQsR0FBaUIsR0FBakIsR0FBdUIraUMsZ0JBQXZCLEdBQTBDLEdBSmpELENBREssQ0FBUDtBQVFBM0MsY0FBVSxDQUFDeHRCLEVBQUQsRUFBSyxRQUFMLEVBQ1IsYUFBYTVTLEtBQWIsR0FBcUIsR0FBckIsR0FDSSxxQkFESixHQUVJLG9CQUZKLEdBRTJCK2lDLGdCQUYzQixHQUU4QyxLQUY5QyxHQUVzREMsaUJBRnRELEdBRTBFLElBRjFFLEdBR0EseUJBSEEsR0FJRSxVQUpGLElBSWdCNUIsTUFBTSxHQUFHLFFBQVEwQixZQUFSLEdBQXVCLEdBQTFCLEdBQWdDQSxZQUp0RCxJQUlzRSxHQUp0RSxHQUtNLGtCQUxOLEdBTUUsMkJBTkYsR0FNaUN0QixpQkFBaUIsQ0FBQ3hoQyxLQUFELEVBQVEsbUJBQVIsQ0FObEQsR0FNa0YsSUFObEYsR0FPRSxnQkFQRixHQU9zQndoQyxpQkFBaUIsQ0FBQ3hoQyxLQUFELEVBQVEsMkNBQVIsQ0FQdkMsR0FPK0YsSUFQL0YsR0FRQSxRQVJBLEdBUVl3aEMsaUJBQWlCLENBQUN4aEMsS0FBRCxFQUFRLEtBQVIsQ0FSN0IsR0FRK0MsR0FUdkMsRUFVUixJQVZRLEVBVUYsSUFWRSxDQUFWO0FBWUQ7O0FBRUQsV0FBUzRpQyxhQUFULENBQ0Vod0IsRUFERixFQUVFNVMsS0FGRixFQUdFbzlCLFNBSEYsRUFJRTtBQUNBLFFBQUlnRSxNQUFNLEdBQUdoRSxTQUFTLElBQUlBLFNBQVMsQ0FBQ2dFLE1BQXBDO0FBQ0EsUUFBSTBCLFlBQVksR0FBR2pDLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssT0FBTCxDQUFkLElBQStCLE1BQWxEO0FBQ0Frd0IsZ0JBQVksR0FBRzFCLE1BQU0sR0FBSSxRQUFRMEIsWUFBUixHQUF1QixHQUEzQixHQUFrQ0EsWUFBdkQ7QUFDQWxELFdBQU8sQ0FBQ2h0QixFQUFELEVBQUssU0FBTCxFQUFpQixRQUFRNVMsS0FBUixHQUFnQixHQUFoQixHQUFzQjhpQyxZQUF0QixHQUFxQyxHQUF0RCxDQUFQO0FBQ0ExQyxjQUFVLENBQUN4dEIsRUFBRCxFQUFLLFFBQUwsRUFBZTR1QixpQkFBaUIsQ0FBQ3hoQyxLQUFELEVBQVE4aUMsWUFBUixDQUFoQyxFQUF1RCxJQUF2RCxFQUE2RCxJQUE3RCxDQUFWO0FBQ0Q7O0FBRUQsV0FBU0osU0FBVCxDQUNFOXZCLEVBREYsRUFFRTVTLEtBRkYsRUFHRW85QixTQUhGLEVBSUU7QUFDQSxRQUFJZ0UsTUFBTSxHQUFHaEUsU0FBUyxJQUFJQSxTQUFTLENBQUNnRSxNQUFwQztBQUNBLFFBQUk2QixXQUFXLEdBQUcsMkJBQ2hCLDZEQURnQixHQUVoQixrRUFGZ0IsR0FHaEIsU0FIZ0IsSUFHSDdCLE1BQU0sR0FBRyxTQUFILEdBQWUsS0FIbEIsSUFHMkIsSUFIN0M7QUFLQSxRQUFJRyxVQUFVLEdBQUcsMkRBQWpCO0FBQ0EsUUFBSTJCLElBQUksR0FBRyx5QkFBeUJELFdBQXpCLEdBQXVDLEdBQWxEO0FBQ0FDLFFBQUksR0FBR0EsSUFBSSxHQUFHLEdBQVAsR0FBYzFCLGlCQUFpQixDQUFDeGhDLEtBQUQsRUFBUXVoQyxVQUFSLENBQXRDO0FBQ0FuQixjQUFVLENBQUN4dEIsRUFBRCxFQUFLLFFBQUwsRUFBZXN3QixJQUFmLEVBQXFCLElBQXJCLEVBQTJCLElBQTNCLENBQVY7QUFDRDs7QUFFRCxXQUFTTCxlQUFULENBQ0Vqd0IsRUFERixFQUVFNVMsS0FGRixFQUdFbzlCLFNBSEYsRUFJRTtBQUNBLFFBQUl0cEIsSUFBSSxHQUFHbEIsRUFBRSxDQUFDb3RCLFFBQUgsQ0FBWWxzQixJQUF2QixDQURBLENBR0E7QUFDQTs7QUFDQTtBQUNFLFVBQUlxdkIsT0FBTyxHQUFHdndCLEVBQUUsQ0FBQ290QixRQUFILENBQVksY0FBWixLQUErQnB0QixFQUFFLENBQUNvdEIsUUFBSCxDQUFZLFFBQVosQ0FBN0M7QUFDQSxVQUFJb0QsV0FBVyxHQUFHeHdCLEVBQUUsQ0FBQ290QixRQUFILENBQVksYUFBWixLQUE4QnB0QixFQUFFLENBQUNvdEIsUUFBSCxDQUFZLE9BQVosQ0FBaEQ7O0FBQ0EsVUFBSW1ELE9BQU8sSUFBSSxDQUFDQyxXQUFoQixFQUE2QjtBQUMzQixZQUFJQyxPQUFPLEdBQUd6d0IsRUFBRSxDQUFDb3RCLFFBQUgsQ0FBWSxjQUFaLElBQThCLGNBQTlCLEdBQStDLFFBQTdEO0FBQ0FzQyxjQUFNLENBQ0plLE9BQU8sR0FBRyxLQUFWLEdBQWtCRixPQUFsQixHQUE0QixnREFBNUIsR0FDQSxrRUFGSSxDQUFOO0FBSUQ7QUFDRjtBQUVELFFBQUluVSxHQUFHLEdBQUdvTyxTQUFTLElBQUksRUFBdkI7QUFDQSxRQUFJdFksSUFBSSxHQUFHa0ssR0FBRyxDQUFDbEssSUFBZjtBQUNBLFFBQUlzYyxNQUFNLEdBQUdwUyxHQUFHLENBQUNvUyxNQUFqQjtBQUNBLFFBQUk3QixJQUFJLEdBQUd2USxHQUFHLENBQUN1USxJQUFmO0FBQ0EsUUFBSStELG9CQUFvQixHQUFHLENBQUN4ZSxJQUFELElBQVNoUixJQUFJLEtBQUssT0FBN0M7QUFDQSxRQUFJNEgsS0FBSyxHQUFHb0osSUFBSSxHQUNaLFFBRFksR0FFWmhSLElBQUksS0FBSyxPQUFULEdBQ0V5dUIsV0FERixHQUVFLE9BSk47QUFNQSxRQUFJakIsZUFBZSxHQUFHLHFCQUF0Qjs7QUFDQSxRQUFJL0IsSUFBSixFQUFVO0FBQ1IrQixxQkFBZSxHQUFHLDRCQUFsQjtBQUNEOztBQUNELFFBQUlGLE1BQUosRUFBWTtBQUNWRSxxQkFBZSxHQUFHLFFBQVFBLGVBQVIsR0FBMEIsR0FBNUM7QUFDRDs7QUFFRCxRQUFJNEIsSUFBSSxHQUFHMUIsaUJBQWlCLENBQUN4aEMsS0FBRCxFQUFRc2hDLGVBQVIsQ0FBNUI7O0FBQ0EsUUFBSWdDLG9CQUFKLEVBQTBCO0FBQ3hCSixVQUFJLEdBQUcsdUNBQXVDQSxJQUE5QztBQUNEOztBQUVEdEQsV0FBTyxDQUFDaHRCLEVBQUQsRUFBSyxPQUFMLEVBQWUsTUFBTTVTLEtBQU4sR0FBYyxHQUE3QixDQUFQO0FBQ0FvZ0MsY0FBVSxDQUFDeHRCLEVBQUQsRUFBSzhJLEtBQUwsRUFBWXduQixJQUFaLEVBQWtCLElBQWxCLEVBQXdCLElBQXhCLENBQVY7O0FBQ0EsUUFBSTNELElBQUksSUFBSTZCLE1BQVosRUFBb0I7QUFDbEJoQixnQkFBVSxDQUFDeHRCLEVBQUQsRUFBSyxNQUFMLEVBQWEsZ0JBQWIsQ0FBVjtBQUNEO0FBQ0Y7QUFFRDtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTMndCLGVBQVQsQ0FBMEJqb0IsRUFBMUIsRUFBOEI7QUFDNUI7QUFDQSxRQUFJMWIsS0FBSyxDQUFDMGIsRUFBRSxDQUFDaW5CLFdBQUQsQ0FBSCxDQUFULEVBQTRCO0FBQzFCO0FBQ0EsVUFBSTdtQixLQUFLLEdBQUd4UyxJQUFJLEdBQUcsUUFBSCxHQUFjLE9BQTlCO0FBQ0FvUyxRQUFFLENBQUNJLEtBQUQsQ0FBRixHQUFZLEdBQUdsVyxNQUFILENBQVU4VixFQUFFLENBQUNpbkIsV0FBRCxDQUFaLEVBQTJCam5CLEVBQUUsQ0FBQ0ksS0FBRCxDQUFGLElBQWEsRUFBeEMsQ0FBWjtBQUNBLGFBQU9KLEVBQUUsQ0FBQ2luQixXQUFELENBQVQ7QUFDRCxLQVAyQixDQVE1QjtBQUNBOztBQUNBOzs7QUFDQSxRQUFJM2lDLEtBQUssQ0FBQzBiLEVBQUUsQ0FBQ2tuQixvQkFBRCxDQUFILENBQVQsRUFBcUM7QUFDbkNsbkIsUUFBRSxDQUFDa29CLE1BQUgsR0FBWSxHQUFHaCtCLE1BQUgsQ0FBVThWLEVBQUUsQ0FBQ2tuQixvQkFBRCxDQUFaLEVBQW9DbG5CLEVBQUUsQ0FBQ2tvQixNQUFILElBQWEsRUFBakQsQ0FBWjtBQUNBLGFBQU9sb0IsRUFBRSxDQUFDa25CLG9CQUFELENBQVQ7QUFDRDtBQUNGOztBQUVELE1BQUlpQixRQUFKOztBQUVBLFdBQVNDLGlCQUFULENBQTRCdmMsT0FBNUIsRUFBcUN6TCxLQUFyQyxFQUE0Q25FLE9BQTVDLEVBQXFEO0FBQ25ELFFBQUk1SixPQUFPLEdBQUc4MUIsUUFBZCxDQURtRCxDQUMzQjs7QUFDeEIsV0FBTyxTQUFTRSxXQUFULEdBQXdCO0FBQzdCLFVBQUk3K0IsR0FBRyxHQUFHcWlCLE9BQU8sQ0FBQ2xqQixLQUFSLENBQWMsSUFBZCxFQUFvQkQsU0FBcEIsQ0FBVjs7QUFDQSxVQUFJYyxHQUFHLEtBQUssSUFBWixFQUFrQjtBQUNoQjgrQixnQkFBUSxDQUFDbG9CLEtBQUQsRUFBUWlvQixXQUFSLEVBQXFCcHNCLE9BQXJCLEVBQThCNUosT0FBOUIsQ0FBUjtBQUNEO0FBQ0YsS0FMRDtBQU1EOztBQUVELFdBQVNrMkIsS0FBVCxDQUNFbm9CLEtBREYsRUFFRXlMLE9BRkYsRUFHRW5NLE9BSEYsRUFJRXpELE9BSkYsRUFLRXdELE9BTEYsRUFNRTtBQUNBb00sV0FBTyxHQUFHck8sYUFBYSxDQUFDcU8sT0FBRCxDQUF2Qjs7QUFDQSxRQUFJbk0sT0FBSixFQUFhO0FBQUVtTSxhQUFPLEdBQUd1YyxpQkFBaUIsQ0FBQ3ZjLE9BQUQsRUFBVXpMLEtBQVYsRUFBaUJuRSxPQUFqQixDQUEzQjtBQUF1RDs7QUFDdEVrc0IsWUFBUSxDQUFDNTVCLGdCQUFULENBQ0U2UixLQURGLEVBRUV5TCxPQUZGLEVBR0V6ZCxlQUFlLEdBQ1g7QUFBRTZOLGFBQU8sRUFBRUEsT0FBWDtBQUFvQndELGFBQU8sRUFBRUE7QUFBN0IsS0FEVyxHQUVYeEQsT0FMTjtBQU9EOztBQUVELFdBQVNxc0IsUUFBVCxDQUNFbG9CLEtBREYsRUFFRXlMLE9BRkYsRUFHRTVQLE9BSEYsRUFJRTVKLE9BSkYsRUFLRTtBQUNBLEtBQUNBLE9BQU8sSUFBSTgxQixRQUFaLEVBQXNCdkYsbUJBQXRCLENBQ0V4aUIsS0FERixFQUVFeUwsT0FBTyxDQUFDcE8sU0FBUixJQUFxQm9PLE9BRnZCLEVBR0U1UCxPQUhGO0FBS0Q7O0FBRUQsV0FBU3VzQixrQkFBVCxDQUE2QjVXLFFBQTdCLEVBQXVDdGQsS0FBdkMsRUFBOEM7QUFDNUMsUUFBSW5RLE9BQU8sQ0FBQ3l0QixRQUFRLENBQUNsZixJQUFULENBQWNzTixFQUFmLENBQVAsSUFBNkI3YixPQUFPLENBQUNtUSxLQUFLLENBQUM1QixJQUFOLENBQVdzTixFQUFaLENBQXhDLEVBQXlEO0FBQ3ZEO0FBQ0Q7O0FBQ0QsUUFBSUEsRUFBRSxHQUFHMUwsS0FBSyxDQUFDNUIsSUFBTixDQUFXc04sRUFBWCxJQUFpQixFQUExQjtBQUNBLFFBQUlDLEtBQUssR0FBRzJSLFFBQVEsQ0FBQ2xmLElBQVQsQ0FBY3NOLEVBQWQsSUFBb0IsRUFBaEM7QUFDQW1vQixZQUFRLEdBQUc3ekIsS0FBSyxDQUFDekIsR0FBakI7QUFDQW8xQixtQkFBZSxDQUFDam9CLEVBQUQsQ0FBZjtBQUNBRCxtQkFBZSxDQUFDQyxFQUFELEVBQUtDLEtBQUwsRUFBWXNvQixLQUFaLEVBQW1CRCxRQUFuQixFQUE2QmgwQixLQUFLLENBQUN4QixPQUFuQyxDQUFmO0FBQ0FxMUIsWUFBUSxHQUFHOWpDLFNBQVg7QUFDRDs7QUFFRCxNQUFJOGdDLE1BQU0sR0FBRztBQUNYOStCLFVBQU0sRUFBRW1pQyxrQkFERztBQUVYdDJCLFVBQU0sRUFBRXMyQjtBQUdWOztBQUxhLEdBQWI7O0FBT0EsV0FBU0MsY0FBVCxDQUF5QjdXLFFBQXpCLEVBQW1DdGQsS0FBbkMsRUFBMEM7QUFDeEMsUUFBSW5RLE9BQU8sQ0FBQ3l0QixRQUFRLENBQUNsZixJQUFULENBQWM0YixRQUFmLENBQVAsSUFBbUNucUIsT0FBTyxDQUFDbVEsS0FBSyxDQUFDNUIsSUFBTixDQUFXNGIsUUFBWixDQUE5QyxFQUFxRTtBQUNuRTtBQUNEOztBQUNELFFBQUlqbkIsR0FBSixFQUFTeVUsR0FBVDtBQUNBLFFBQUlqSixHQUFHLEdBQUd5QixLQUFLLENBQUN6QixHQUFoQjtBQUNBLFFBQUk2MUIsUUFBUSxHQUFHOVcsUUFBUSxDQUFDbGYsSUFBVCxDQUFjNGIsUUFBZCxJQUEwQixFQUF6QztBQUNBLFFBQUk1VixLQUFLLEdBQUdwRSxLQUFLLENBQUM1QixJQUFOLENBQVc0YixRQUFYLElBQXVCLEVBQW5DLENBUHdDLENBUXhDOztBQUNBLFFBQUlocUIsS0FBSyxDQUFDb1UsS0FBSyxDQUFDdkQsTUFBUCxDQUFULEVBQXlCO0FBQ3ZCdUQsV0FBSyxHQUFHcEUsS0FBSyxDQUFDNUIsSUFBTixDQUFXNGIsUUFBWCxHQUFzQmxsQixNQUFNLENBQUMsRUFBRCxFQUFLc1AsS0FBTCxDQUFwQztBQUNEOztBQUVELFNBQUtyUixHQUFMLElBQVlxaEMsUUFBWixFQUFzQjtBQUNwQixVQUFJdmtDLE9BQU8sQ0FBQ3VVLEtBQUssQ0FBQ3JSLEdBQUQsQ0FBTixDQUFYLEVBQXlCO0FBQ3ZCd0wsV0FBRyxDQUFDeEwsR0FBRCxDQUFILEdBQVcsRUFBWDtBQUNEO0FBQ0Y7O0FBQ0QsU0FBS0EsR0FBTCxJQUFZcVIsS0FBWixFQUFtQjtBQUNqQm9ELFNBQUcsR0FBR3BELEtBQUssQ0FBQ3JSLEdBQUQsQ0FBWCxDQURpQixDQUVqQjtBQUNBO0FBQ0E7O0FBQ0EsVUFBSUEsR0FBRyxLQUFLLGFBQVIsSUFBeUJBLEdBQUcsS0FBSyxXQUFyQyxFQUFrRDtBQUNoRCxZQUFJaU4sS0FBSyxDQUFDM0IsUUFBVixFQUFvQjtBQUFFMkIsZUFBSyxDQUFDM0IsUUFBTixDQUFlbE0sTUFBZixHQUF3QixDQUF4QjtBQUE0Qjs7QUFDbEQsWUFBSXFWLEdBQUcsS0FBSzRzQixRQUFRLENBQUNyaEMsR0FBRCxDQUFwQixFQUEyQjtBQUFFO0FBQVUsU0FGUyxDQUdoRDtBQUNBOzs7QUFDQSxZQUFJd0wsR0FBRyxDQUFDcXRCLFVBQUosQ0FBZXo1QixNQUFmLEtBQTBCLENBQTlCLEVBQWlDO0FBQy9Cb00sYUFBRyxDQUFDNm5CLFdBQUosQ0FBZ0I3bkIsR0FBRyxDQUFDcXRCLFVBQUosQ0FBZSxDQUFmLENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJNzRCLEdBQUcsS0FBSyxPQUFaLEVBQXFCO0FBQ25CO0FBQ0E7QUFDQXdMLFdBQUcsQ0FBQzgxQixNQUFKLEdBQWE3c0IsR0FBYixDQUhtQixDQUluQjs7QUFDQSxZQUFJOHNCLE1BQU0sR0FBR3prQyxPQUFPLENBQUMyWCxHQUFELENBQVAsR0FBZSxFQUFmLEdBQW9CclcsTUFBTSxDQUFDcVcsR0FBRCxDQUF2Qzs7QUFDQSxZQUFJK3NCLGlCQUFpQixDQUFDaDJCLEdBQUQsRUFBTSsxQixNQUFOLENBQXJCLEVBQW9DO0FBQ2xDLzFCLGFBQUcsQ0FBQ25PLEtBQUosR0FBWWtrQyxNQUFaO0FBQ0Q7QUFDRixPQVRELE1BU087QUFDTC8xQixXQUFHLENBQUN4TCxHQUFELENBQUgsR0FBV3lVLEdBQVg7QUFDRDtBQUNGO0FBQ0YsR0FsK05vQixDQW8rTnJCOzs7QUFHQSxXQUFTK3NCLGlCQUFULENBQTRCaDJCLEdBQTVCLEVBQWlDaTJCLFFBQWpDLEVBQTJDO0FBQ3pDLFdBQVEsQ0FBQ2oyQixHQUFHLENBQUNrMkIsU0FBTCxLQUNObDJCLEdBQUcsQ0FBQ21uQixPQUFKLEtBQWdCLFFBQWhCLElBQ0FnUCxvQkFBb0IsQ0FBQ24yQixHQUFELEVBQU1pMkIsUUFBTixDQURwQixJQUVBRyxvQkFBb0IsQ0FBQ3AyQixHQUFELEVBQU1pMkIsUUFBTixDQUhkLENBQVI7QUFLRDs7QUFFRCxXQUFTRSxvQkFBVCxDQUErQm4yQixHQUEvQixFQUFvQ2kyQixRQUFwQyxFQUE4QztBQUM1QztBQUNBO0FBQ0EsUUFBSUksVUFBVSxHQUFHLElBQWpCLENBSDRDLENBSTVDO0FBQ0E7O0FBQ0EsUUFBSTtBQUFFQSxnQkFBVSxHQUFHMVAsUUFBUSxDQUFDMlAsYUFBVCxLQUEyQnQyQixHQUF4QztBQUE4QyxLQUFwRCxDQUFxRCxPQUFPakksQ0FBUCxFQUFVLENBQUU7O0FBQ2pFLFdBQU9zK0IsVUFBVSxJQUFJcjJCLEdBQUcsQ0FBQ25PLEtBQUosS0FBY29rQyxRQUFuQztBQUNEOztBQUVELFdBQVNHLG9CQUFULENBQStCcDJCLEdBQS9CLEVBQW9DcUUsTUFBcEMsRUFBNEM7QUFDMUMsUUFBSXhTLEtBQUssR0FBR21PLEdBQUcsQ0FBQ25PLEtBQWhCO0FBQ0EsUUFBSW85QixTQUFTLEdBQUdqdkIsR0FBRyxDQUFDdTJCLFdBQXBCLENBRjBDLENBRVQ7O0FBQ2pDLFFBQUk5a0MsS0FBSyxDQUFDdzlCLFNBQUQsQ0FBVCxFQUFzQjtBQUNwQixVQUFJQSxTQUFTLENBQUN0WSxJQUFkLEVBQW9CO0FBQ2xCO0FBQ0EsZUFBTyxLQUFQO0FBQ0Q7O0FBQ0QsVUFBSXNZLFNBQVMsQ0FBQ2dFLE1BQWQsRUFBc0I7QUFDcEIsZUFBTy8vQixRQUFRLENBQUNyQixLQUFELENBQVIsS0FBb0JxQixRQUFRLENBQUNtUixNQUFELENBQW5DO0FBQ0Q7O0FBQ0QsVUFBSTRxQixTQUFTLENBQUNtQyxJQUFkLEVBQW9CO0FBQ2xCLGVBQU92L0IsS0FBSyxDQUFDdS9CLElBQU4sT0FBaUIvc0IsTUFBTSxDQUFDK3NCLElBQVAsRUFBeEI7QUFDRDtBQUNGOztBQUNELFdBQU92L0IsS0FBSyxLQUFLd1MsTUFBakI7QUFDRDs7QUFFRCxNQUFJb1gsUUFBUSxHQUFHO0FBQ2Jqb0IsVUFBTSxFQUFFb2lDLGNBREs7QUFFYnYyQixVQUFNLEVBQUV1MkI7QUFHVjs7QUFMZSxHQUFmO0FBT0EsTUFBSVksY0FBYyxHQUFHL2hDLE1BQU0sQ0FBQyxVQUFVZ2lDLE9BQVYsRUFBbUI7QUFDN0MsUUFBSTkvQixHQUFHLEdBQUcsRUFBVjtBQUNBLFFBQUkrL0IsYUFBYSxHQUFHLGVBQXBCO0FBQ0EsUUFBSUMsaUJBQWlCLEdBQUcsT0FBeEI7QUFDQUYsV0FBTyxDQUFDL2lDLEtBQVIsQ0FBY2dqQyxhQUFkLEVBQTZCNTBCLE9BQTdCLENBQXFDLFVBQVU1TixJQUFWLEVBQWdCO0FBQ25ELFVBQUlBLElBQUosRUFBVTtBQUNSLFlBQUlpakIsR0FBRyxHQUFHampCLElBQUksQ0FBQ1IsS0FBTCxDQUFXaWpDLGlCQUFYLENBQVY7QUFDQXhmLFdBQUcsQ0FBQ3ZqQixNQUFKLEdBQWEsQ0FBYixLQUFtQitDLEdBQUcsQ0FBQ3dnQixHQUFHLENBQUMsQ0FBRCxDQUFILENBQU9pYSxJQUFQLEVBQUQsQ0FBSCxHQUFxQmphLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBT2lhLElBQVAsRUFBeEM7QUFDRDtBQUNGLEtBTEQ7QUFNQSxXQUFPejZCLEdBQVA7QUFDRCxHQVgwQixDQUEzQixDQWxoT3FCLENBK2hPckI7O0FBQ0EsV0FBU2lnQyxrQkFBVCxDQUE2Qi8yQixJQUE3QixFQUFtQztBQUNqQyxRQUFJMGdCLEtBQUssR0FBR3NXLHFCQUFxQixDQUFDaDNCLElBQUksQ0FBQzBnQixLQUFOLENBQWpDLENBRGlDLENBRWpDO0FBQ0E7O0FBQ0EsV0FBTzFnQixJQUFJLENBQUNpM0IsV0FBTCxHQUNIdmdDLE1BQU0sQ0FBQ3NKLElBQUksQ0FBQ2kzQixXQUFOLEVBQW1CdlcsS0FBbkIsQ0FESCxHQUVIQSxLQUZKO0FBR0QsR0F2aU9vQixDQXlpT3JCOzs7QUFDQSxXQUFTc1cscUJBQVQsQ0FBZ0NFLFlBQWhDLEVBQThDO0FBQzVDLFFBQUl6Z0MsS0FBSyxDQUFDc0IsT0FBTixDQUFjbS9CLFlBQWQsQ0FBSixFQUFpQztBQUMvQixhQUFPcmdDLFFBQVEsQ0FBQ3FnQyxZQUFELENBQWY7QUFDRDs7QUFDRCxRQUFJLE9BQU9BLFlBQVAsS0FBd0IsUUFBNUIsRUFBc0M7QUFDcEMsYUFBT1AsY0FBYyxDQUFDTyxZQUFELENBQXJCO0FBQ0Q7O0FBQ0QsV0FBT0EsWUFBUDtBQUNEO0FBRUQ7Ozs7OztBQUlBLFdBQVNDLFFBQVQsQ0FBbUJ2MUIsS0FBbkIsRUFBMEJ3MUIsVUFBMUIsRUFBc0M7QUFDcEMsUUFBSXRnQyxHQUFHLEdBQUcsRUFBVjtBQUNBLFFBQUl1Z0MsU0FBSjs7QUFFQSxRQUFJRCxVQUFKLEVBQWdCO0FBQ2QsVUFBSXRSLFNBQVMsR0FBR2xrQixLQUFoQjs7QUFDQSxhQUFPa2tCLFNBQVMsQ0FBQ25sQixpQkFBakIsRUFBb0M7QUFDbENtbEIsaUJBQVMsR0FBR0EsU0FBUyxDQUFDbmxCLGlCQUFWLENBQTRCdVMsTUFBeEM7O0FBQ0EsWUFDRTRTLFNBQVMsSUFBSUEsU0FBUyxDQUFDOWxCLElBQXZCLEtBQ0NxM0IsU0FBUyxHQUFHTixrQkFBa0IsQ0FBQ2pSLFNBQVMsQ0FBQzlsQixJQUFYLENBRC9CLENBREYsRUFHRTtBQUNBdEosZ0JBQU0sQ0FBQ0ksR0FBRCxFQUFNdWdDLFNBQU4sQ0FBTjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxRQUFLQSxTQUFTLEdBQUdOLGtCQUFrQixDQUFDbjFCLEtBQUssQ0FBQzVCLElBQVAsQ0FBbkMsRUFBa0Q7QUFDaER0SixZQUFNLENBQUNJLEdBQUQsRUFBTXVnQyxTQUFOLENBQU47QUFDRDs7QUFFRCxRQUFJeFIsVUFBVSxHQUFHamtCLEtBQWpCOztBQUNBLFdBQVFpa0IsVUFBVSxHQUFHQSxVQUFVLENBQUNqbEIsTUFBaEMsRUFBeUM7QUFDdkMsVUFBSWlsQixVQUFVLENBQUM3bEIsSUFBWCxLQUFvQnEzQixTQUFTLEdBQUdOLGtCQUFrQixDQUFDbFIsVUFBVSxDQUFDN2xCLElBQVosQ0FBbEQsQ0FBSixFQUEwRTtBQUN4RXRKLGNBQU0sQ0FBQ0ksR0FBRCxFQUFNdWdDLFNBQU4sQ0FBTjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT3ZnQyxHQUFQO0FBQ0Q7QUFFRDs7O0FBRUEsTUFBSXdnQyxRQUFRLEdBQUcsS0FBZjtBQUNBLE1BQUlDLFdBQVcsR0FBRyxnQkFBbEI7O0FBQ0EsTUFBSUMsT0FBTyxHQUFHLFVBQVU1eUIsRUFBVixFQUFjMUcsSUFBZCxFQUFvQnRMLEdBQXBCLEVBQXlCO0FBQ3JDO0FBQ0EsUUFBSTBrQyxRQUFRLENBQUNoOUIsSUFBVCxDQUFjNEQsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCMEcsUUFBRSxDQUFDOGIsS0FBSCxDQUFTK1csV0FBVCxDQUFxQnY1QixJQUFyQixFQUEyQnRMLEdBQTNCO0FBQ0QsS0FGRCxNQUVPLElBQUkya0MsV0FBVyxDQUFDajlCLElBQVosQ0FBaUIxSCxHQUFqQixDQUFKLEVBQTJCO0FBQ2hDZ1MsUUFBRSxDQUFDOGIsS0FBSCxDQUFTK1csV0FBVCxDQUFxQnY1QixJQUFyQixFQUEyQnRMLEdBQUcsQ0FBQ3VDLE9BQUosQ0FBWW9pQyxXQUFaLEVBQXlCLEVBQXpCLENBQTNCLEVBQXlELFdBQXpEO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsVUFBSUcsY0FBYyxHQUFHQyxTQUFTLENBQUN6NUIsSUFBRCxDQUE5Qjs7QUFDQSxVQUFJekgsS0FBSyxDQUFDc0IsT0FBTixDQUFjbkYsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGFBQUssSUFBSWtCLENBQUMsR0FBRyxDQUFSLEVBQVd3TyxHQUFHLEdBQUcxUCxHQUFHLENBQUNtQixNQUExQixFQUFrQ0QsQ0FBQyxHQUFHd08sR0FBdEMsRUFBMkN4TyxDQUFDLEVBQTVDLEVBQWdEO0FBQzlDOFEsWUFBRSxDQUFDOGIsS0FBSCxDQUFTZ1gsY0FBVCxJQUEyQjlrQyxHQUFHLENBQUNrQixDQUFELENBQTlCO0FBQ0Q7QUFDRixPQVBELE1BT087QUFDTDhRLFVBQUUsQ0FBQzhiLEtBQUgsQ0FBU2dYLGNBQVQsSUFBMkI5a0MsR0FBM0I7QUFDRDtBQUNGO0FBQ0YsR0FuQkQ7O0FBcUJBLE1BQUlnbEMsV0FBVyxHQUFHLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsSUFBbEIsQ0FBbEI7QUFFQSxNQUFJQyxVQUFKO0FBQ0EsTUFBSUYsU0FBUyxHQUFHL2lDLE1BQU0sQ0FBQyxVQUFVK1MsSUFBVixFQUFnQjtBQUNyQ2t3QixjQUFVLEdBQUdBLFVBQVUsSUFBSS9RLFFBQVEsQ0FBQzVJLGFBQVQsQ0FBdUIsS0FBdkIsRUFBOEJ3QyxLQUF6RDtBQUNBL1ksUUFBSSxHQUFHelMsUUFBUSxDQUFDeVMsSUFBRCxDQUFmOztBQUNBLFFBQUlBLElBQUksS0FBSyxRQUFULElBQXNCQSxJQUFJLElBQUlrd0IsVUFBbEMsRUFBK0M7QUFDN0MsYUFBT2x3QixJQUFQO0FBQ0Q7O0FBQ0QsUUFBSW13QixPQUFPLEdBQUdud0IsSUFBSSxDQUFDblMsTUFBTCxDQUFZLENBQVosRUFBZUYsV0FBZixLQUErQnFTLElBQUksQ0FBQ25WLEtBQUwsQ0FBVyxDQUFYLENBQTdDOztBQUNBLFNBQUssSUFBSXNCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc4akMsV0FBVyxDQUFDN2pDLE1BQWhDLEVBQXdDRCxDQUFDLEVBQXpDLEVBQTZDO0FBQzNDLFVBQUlvSyxJQUFJLEdBQUcwNUIsV0FBVyxDQUFDOWpDLENBQUQsQ0FBWCxHQUFpQmdrQyxPQUE1Qjs7QUFDQSxVQUFJNTVCLElBQUksSUFBSTI1QixVQUFaLEVBQXdCO0FBQ3RCLGVBQU8zNUIsSUFBUDtBQUNEO0FBQ0Y7QUFDRixHQWJxQixDQUF0Qjs7QUFlQSxXQUFTNjVCLFdBQVQsQ0FBc0I3WSxRQUF0QixFQUFnQ3RkLEtBQWhDLEVBQXVDO0FBQ3JDLFFBQUk1QixJQUFJLEdBQUc0QixLQUFLLENBQUM1QixJQUFqQjtBQUNBLFFBQUlvd0IsT0FBTyxHQUFHbFIsUUFBUSxDQUFDbGYsSUFBdkI7O0FBRUEsUUFBSXZPLE9BQU8sQ0FBQ3VPLElBQUksQ0FBQ2kzQixXQUFOLENBQVAsSUFBNkJ4bEMsT0FBTyxDQUFDdU8sSUFBSSxDQUFDMGdCLEtBQU4sQ0FBcEMsSUFDRmp2QixPQUFPLENBQUMyK0IsT0FBTyxDQUFDNkcsV0FBVCxDQURMLElBQzhCeGxDLE9BQU8sQ0FBQzIrQixPQUFPLENBQUMxUCxLQUFULENBRHpDLEVBRUU7QUFDQTtBQUNEOztBQUVELFFBQUl0WCxHQUFKLEVBQVNsTCxJQUFUO0FBQ0EsUUFBSTBHLEVBQUUsR0FBR2hELEtBQUssQ0FBQ3pCLEdBQWY7QUFDQSxRQUFJNjNCLGNBQWMsR0FBRzVILE9BQU8sQ0FBQzZHLFdBQTdCO0FBQ0EsUUFBSWdCLGVBQWUsR0FBRzdILE9BQU8sQ0FBQzhILGVBQVIsSUFBMkI5SCxPQUFPLENBQUMxUCxLQUFuQyxJQUE0QyxFQUFsRSxDQWJxQyxDQWVyQzs7QUFDQSxRQUFJeVgsUUFBUSxHQUFHSCxjQUFjLElBQUlDLGVBQWpDO0FBRUEsUUFBSXZYLEtBQUssR0FBR3NXLHFCQUFxQixDQUFDcDFCLEtBQUssQ0FBQzVCLElBQU4sQ0FBVzBnQixLQUFaLENBQXJCLElBQTJDLEVBQXZELENBbEJxQyxDQW9CckM7QUFDQTtBQUNBOztBQUNBOWUsU0FBSyxDQUFDNUIsSUFBTixDQUFXazRCLGVBQVgsR0FBNkJ0bUMsS0FBSyxDQUFDOHVCLEtBQUssQ0FBQ2plLE1BQVAsQ0FBTCxHQUN6Qi9MLE1BQU0sQ0FBQyxFQUFELEVBQUtncUIsS0FBTCxDQURtQixHQUV6QkEsS0FGSjtBQUlBLFFBQUkwWCxRQUFRLEdBQUdqQixRQUFRLENBQUN2MUIsS0FBRCxFQUFRLElBQVIsQ0FBdkI7O0FBRUEsU0FBSzFELElBQUwsSUFBYWk2QixRQUFiLEVBQXVCO0FBQ3JCLFVBQUkxbUMsT0FBTyxDQUFDMm1DLFFBQVEsQ0FBQ2w2QixJQUFELENBQVQsQ0FBWCxFQUE2QjtBQUMzQnM1QixlQUFPLENBQUM1eUIsRUFBRCxFQUFLMUcsSUFBTCxFQUFXLEVBQVgsQ0FBUDtBQUNEO0FBQ0Y7O0FBQ0QsU0FBS0EsSUFBTCxJQUFhazZCLFFBQWIsRUFBdUI7QUFDckJodkIsU0FBRyxHQUFHZ3ZCLFFBQVEsQ0FBQ2w2QixJQUFELENBQWQ7O0FBQ0EsVUFBSWtMLEdBQUcsS0FBSyt1QixRQUFRLENBQUNqNkIsSUFBRCxDQUFwQixFQUE0QjtBQUMxQjtBQUNBczVCLGVBQU8sQ0FBQzV5QixFQUFELEVBQUsxRyxJQUFMLEVBQVdrTCxHQUFHLElBQUksSUFBUCxHQUFjLEVBQWQsR0FBbUJBLEdBQTlCLENBQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsTUFBSXNYLEtBQUssR0FBRztBQUNWL3NCLFVBQU0sRUFBRW9rQyxXQURFO0FBRVZ2NEIsVUFBTSxFQUFFdTRCO0FBR1Y7O0FBRUE7Ozs7O0FBUFksR0FBWjs7QUFXQSxXQUFTTSxRQUFULENBQW1CenpCLEVBQW5CLEVBQXVCeXJCLEdBQXZCLEVBQTRCO0FBQzFCO0FBQ0EsUUFBSSxDQUFDQSxHQUFELElBQVEsRUFBRUEsR0FBRyxHQUFHQSxHQUFHLENBQUNrQixJQUFKLEVBQVIsQ0FBWixFQUFpQztBQUMvQjtBQUNEO0FBRUQ7OztBQUNBLFFBQUkzc0IsRUFBRSxDQUFDMHpCLFNBQVAsRUFBa0I7QUFDaEIsVUFBSWpJLEdBQUcsQ0FBQzk3QixPQUFKLENBQVksR0FBWixJQUFtQixDQUFDLENBQXhCLEVBQTJCO0FBQ3pCODdCLFdBQUcsQ0FBQ3g4QixLQUFKLENBQVUsS0FBVixFQUFpQm9PLE9BQWpCLENBQXlCLFVBQVU1TSxDQUFWLEVBQWE7QUFBRSxpQkFBT3VQLEVBQUUsQ0FBQzB6QixTQUFILENBQWF6N0IsR0FBYixDQUFpQnhILENBQWpCLENBQVA7QUFBNkIsU0FBckU7QUFDRCxPQUZELE1BRU87QUFDTHVQLFVBQUUsQ0FBQzB6QixTQUFILENBQWF6N0IsR0FBYixDQUFpQnd6QixHQUFqQjtBQUNEO0FBQ0YsS0FORCxNQU1PO0FBQ0wsVUFBSWpuQixHQUFHLEdBQUcsT0FBT3hFLEVBQUUsQ0FBQzJ6QixZQUFILENBQWdCLE9BQWhCLEtBQTRCLEVBQW5DLElBQXlDLEdBQW5EOztBQUNBLFVBQUludkIsR0FBRyxDQUFDN1UsT0FBSixDQUFZLE1BQU04N0IsR0FBTixHQUFZLEdBQXhCLElBQStCLENBQW5DLEVBQXNDO0FBQ3BDenJCLFVBQUUsQ0FBQzRpQixZQUFILENBQWdCLE9BQWhCLEVBQXlCLENBQUNwZSxHQUFHLEdBQUdpbkIsR0FBUCxFQUFZa0IsSUFBWixFQUF6QjtBQUNEO0FBQ0Y7QUFDRjtBQUVEOzs7Ozs7QUFJQSxXQUFTaUgsV0FBVCxDQUFzQjV6QixFQUF0QixFQUEwQnlyQixHQUExQixFQUErQjtBQUM3QjtBQUNBLFFBQUksQ0FBQ0EsR0FBRCxJQUFRLEVBQUVBLEdBQUcsR0FBR0EsR0FBRyxDQUFDa0IsSUFBSixFQUFSLENBQVosRUFBaUM7QUFDL0I7QUFDRDtBQUVEOzs7QUFDQSxRQUFJM3NCLEVBQUUsQ0FBQzB6QixTQUFQLEVBQWtCO0FBQ2hCLFVBQUlqSSxHQUFHLENBQUM5N0IsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBQyxDQUF4QixFQUEyQjtBQUN6Qjg3QixXQUFHLENBQUN4OEIsS0FBSixDQUFVLEtBQVYsRUFBaUJvTyxPQUFqQixDQUF5QixVQUFVNU0sQ0FBVixFQUFhO0FBQUUsaUJBQU91UCxFQUFFLENBQUMwekIsU0FBSCxDQUFhbmtDLE1BQWIsQ0FBb0JrQixDQUFwQixDQUFQO0FBQWdDLFNBQXhFO0FBQ0QsT0FGRCxNQUVPO0FBQ0x1UCxVQUFFLENBQUMwekIsU0FBSCxDQUFhbmtDLE1BQWIsQ0FBb0JrOEIsR0FBcEI7QUFDRDs7QUFDRCxVQUFJLENBQUN6ckIsRUFBRSxDQUFDMHpCLFNBQUgsQ0FBYXZrQyxNQUFsQixFQUEwQjtBQUN4QjZRLFVBQUUsQ0FBQ21wQixlQUFILENBQW1CLE9BQW5CO0FBQ0Q7QUFDRixLQVRELE1BU087QUFDTCxVQUFJM2tCLEdBQUcsR0FBRyxPQUFPeEUsRUFBRSxDQUFDMnpCLFlBQUgsQ0FBZ0IsT0FBaEIsS0FBNEIsRUFBbkMsSUFBeUMsR0FBbkQ7QUFDQSxVQUFJRSxHQUFHLEdBQUcsTUFBTXBJLEdBQU4sR0FBWSxHQUF0Qjs7QUFDQSxhQUFPam5CLEdBQUcsQ0FBQzdVLE9BQUosQ0FBWWtrQyxHQUFaLEtBQW9CLENBQTNCLEVBQThCO0FBQzVCcnZCLFdBQUcsR0FBR0EsR0FBRyxDQUFDalUsT0FBSixDQUFZc2pDLEdBQVosRUFBaUIsR0FBakIsQ0FBTjtBQUNEOztBQUNEcnZCLFNBQUcsR0FBR0EsR0FBRyxDQUFDbW9CLElBQUosRUFBTjs7QUFDQSxVQUFJbm9CLEdBQUosRUFBUztBQUNQeEUsVUFBRSxDQUFDNGlCLFlBQUgsQ0FBZ0IsT0FBaEIsRUFBeUJwZSxHQUF6QjtBQUNELE9BRkQsTUFFTztBQUNMeEUsVUFBRSxDQUFDbXBCLGVBQUgsQ0FBbUIsT0FBbkI7QUFDRDtBQUNGO0FBQ0Y7QUFFRDs7O0FBRUEsV0FBUzJLLGlCQUFULENBQTRCNStCLEdBQTVCLEVBQWlDO0FBQy9CLFFBQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ1I7QUFDRDtBQUNEOzs7QUFDQSxRQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixVQUFJaEQsR0FBRyxHQUFHLEVBQVY7O0FBQ0EsVUFBSWdELEdBQUcsQ0FBQzYrQixHQUFKLEtBQVksS0FBaEIsRUFBdUI7QUFDckJqaUMsY0FBTSxDQUFDSSxHQUFELEVBQU04aEMsaUJBQWlCLENBQUM5K0IsR0FBRyxDQUFDb0UsSUFBSixJQUFZLEdBQWIsQ0FBdkIsQ0FBTjtBQUNEOztBQUNEeEgsWUFBTSxDQUFDSSxHQUFELEVBQU1nRCxHQUFOLENBQU47QUFDQSxhQUFPaEQsR0FBUDtBQUNELEtBUEQsTUFPTyxJQUFJLE9BQU9nRCxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbEMsYUFBTzgrQixpQkFBaUIsQ0FBQzkrQixHQUFELENBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJOCtCLGlCQUFpQixHQUFHaGtDLE1BQU0sQ0FBQyxVQUFVc0osSUFBVixFQUFnQjtBQUM3QyxXQUFPO0FBQ0wyNkIsZ0JBQVUsRUFBRzM2QixJQUFJLEdBQUcsUUFEZjtBQUVMNDZCLGtCQUFZLEVBQUc1NkIsSUFBSSxHQUFHLFdBRmpCO0FBR0w2NkIsc0JBQWdCLEVBQUc3NkIsSUFBSSxHQUFHLGVBSHJCO0FBSUw4NkIsZ0JBQVUsRUFBRzk2QixJQUFJLEdBQUcsUUFKZjtBQUtMKzZCLGtCQUFZLEVBQUcvNkIsSUFBSSxHQUFHLFdBTGpCO0FBTUxnN0Isc0JBQWdCLEVBQUdoN0IsSUFBSSxHQUFHO0FBTnJCLEtBQVA7QUFRRCxHQVQ2QixDQUE5QjtBQVdBLE1BQUlpN0IsYUFBYSxHQUFHMStCLFNBQVMsSUFBSSxDQUFDVSxLQUFsQztBQUNBLE1BQUlpK0IsVUFBVSxHQUFHLFlBQWpCO0FBQ0EsTUFBSUMsU0FBUyxHQUFHLFdBQWhCLENBL3dPcUIsQ0FpeE9yQjs7QUFDQSxNQUFJQyxjQUFjLEdBQUcsWUFBckI7QUFDQSxNQUFJQyxrQkFBa0IsR0FBRyxlQUF6QjtBQUNBLE1BQUlDLGFBQWEsR0FBRyxXQUFwQjtBQUNBLE1BQUlDLGlCQUFpQixHQUFHLGNBQXhCOztBQUNBLE1BQUlOLGFBQUosRUFBbUI7QUFDakI7QUFDQSxRQUFJeitCLE1BQU0sQ0FBQ2cvQixlQUFQLEtBQTJCL25DLFNBQTNCLElBQ0YrSSxNQUFNLENBQUNpL0IscUJBQVAsS0FBaUNob0MsU0FEbkMsRUFFRTtBQUNBMm5DLG9CQUFjLEdBQUcsa0JBQWpCO0FBQ0FDLHdCQUFrQixHQUFHLHFCQUFyQjtBQUNEOztBQUNELFFBQUk3K0IsTUFBTSxDQUFDay9CLGNBQVAsS0FBMEJqb0MsU0FBMUIsSUFDRitJLE1BQU0sQ0FBQ20vQixvQkFBUCxLQUFnQ2xvQyxTQURsQyxFQUVFO0FBQ0E2bkMsbUJBQWEsR0FBRyxpQkFBaEI7QUFDQUMsdUJBQWlCLEdBQUcsb0JBQXBCO0FBQ0Q7QUFDRixHQXB5T29CLENBc3lPckI7OztBQUNBLE1BQUlLLEdBQUcsR0FBR3IvQixTQUFTLEdBQ2ZDLE1BQU0sQ0FBQ3EvQixxQkFBUCxHQUNFci9CLE1BQU0sQ0FBQ3EvQixxQkFBUCxDQUE2QjNqQyxJQUE3QixDQUFrQ3NFLE1BQWxDLENBREYsR0FFRStQLFVBSGE7QUFJZjtBQUEyQixZQUFVNVYsRUFBVixFQUFjO0FBQUUsV0FBT0EsRUFBRSxFQUFUO0FBQWMsR0FKN0Q7O0FBTUEsV0FBU21sQyxTQUFULENBQW9CbmxDLEVBQXBCLEVBQXdCO0FBQ3RCaWxDLE9BQUcsQ0FBQyxZQUFZO0FBQ2RBLFNBQUcsQ0FBQ2psQyxFQUFELENBQUg7QUFDRCxLQUZFLENBQUg7QUFHRDs7QUFFRCxXQUFTb2xDLGtCQUFULENBQTZCcjFCLEVBQTdCLEVBQWlDeXJCLEdBQWpDLEVBQXNDO0FBQ3BDLFFBQUk2SixpQkFBaUIsR0FBR3QxQixFQUFFLENBQUMyckIsa0JBQUgsS0FBMEIzckIsRUFBRSxDQUFDMnJCLGtCQUFILEdBQXdCLEVBQWxELENBQXhCOztBQUNBLFFBQUkySixpQkFBaUIsQ0FBQzNsQyxPQUFsQixDQUEwQjg3QixHQUExQixJQUFpQyxDQUFyQyxFQUF3QztBQUN0QzZKLHVCQUFpQixDQUFDdDdCLElBQWxCLENBQXVCeXhCLEdBQXZCO0FBQ0FnSSxjQUFRLENBQUN6ekIsRUFBRCxFQUFLeXJCLEdBQUwsQ0FBUjtBQUNEO0FBQ0Y7O0FBRUQsV0FBUzhKLHFCQUFULENBQWdDdjFCLEVBQWhDLEVBQW9DeXJCLEdBQXBDLEVBQXlDO0FBQ3ZDLFFBQUl6ckIsRUFBRSxDQUFDMnJCLGtCQUFQLEVBQTJCO0FBQ3pCcDhCLFlBQU0sQ0FBQ3lRLEVBQUUsQ0FBQzJyQixrQkFBSixFQUF3QkYsR0FBeEIsQ0FBTjtBQUNEOztBQUNEbUksZUFBVyxDQUFDNXpCLEVBQUQsRUFBS3lyQixHQUFMLENBQVg7QUFDRDs7QUFFRCxXQUFTK0osa0JBQVQsQ0FDRXgxQixFQURGLEVBRUVnRSxZQUZGLEVBR0VxQyxFQUhGLEVBSUU7QUFDQSxRQUFJK1YsR0FBRyxHQUFHcVosaUJBQWlCLENBQUN6MUIsRUFBRCxFQUFLZ0UsWUFBTCxDQUEzQjtBQUNBLFFBQUk5QyxJQUFJLEdBQUdrYixHQUFHLENBQUNsYixJQUFmO0FBQ0EsUUFBSXNLLE9BQU8sR0FBRzRRLEdBQUcsQ0FBQzVRLE9BQWxCO0FBQ0EsUUFBSWtxQixTQUFTLEdBQUd0WixHQUFHLENBQUNzWixTQUFwQjs7QUFDQSxRQUFJLENBQUN4MEIsSUFBTCxFQUFXO0FBQUUsYUFBT21GLEVBQUUsRUFBVDtBQUFhOztBQUMxQixRQUFJeUMsS0FBSyxHQUFHNUgsSUFBSSxLQUFLc3pCLFVBQVQsR0FBc0JHLGtCQUF0QixHQUEyQ0UsaUJBQXZEO0FBQ0EsUUFBSWMsS0FBSyxHQUFHLENBQVo7O0FBQ0EsUUFBSTNOLEdBQUcsR0FBRyxZQUFZO0FBQ3BCaG9CLFFBQUUsQ0FBQ3NyQixtQkFBSCxDQUF1QnhpQixLQUF2QixFQUE4QjhzQixLQUE5QjtBQUNBdnZCLFFBQUU7QUFDSCxLQUhEOztBQUlBLFFBQUl1dkIsS0FBSyxHQUFHLFVBQVV0aUMsQ0FBVixFQUFhO0FBQ3ZCLFVBQUlBLENBQUMsQ0FBQ21ILE1BQUYsS0FBYXVGLEVBQWpCLEVBQXFCO0FBQ25CLFlBQUksRUFBRTIxQixLQUFGLElBQVdELFNBQWYsRUFBMEI7QUFDeEIxTixhQUFHO0FBQ0o7QUFDRjtBQUNGLEtBTkQ7O0FBT0FuaUIsY0FBVSxDQUFDLFlBQVk7QUFDckIsVUFBSTh2QixLQUFLLEdBQUdELFNBQVosRUFBdUI7QUFDckIxTixXQUFHO0FBQ0o7QUFDRixLQUpTLEVBSVB4YyxPQUFPLEdBQUcsQ0FKSCxDQUFWO0FBS0F4TCxNQUFFLENBQUMvSSxnQkFBSCxDQUFvQjZSLEtBQXBCLEVBQTJCOHNCLEtBQTNCO0FBQ0Q7O0FBRUQsTUFBSUMsV0FBVyxHQUFHLHdCQUFsQjs7QUFFQSxXQUFTSixpQkFBVCxDQUE0QnoxQixFQUE1QixFQUFnQ2dFLFlBQWhDLEVBQThDO0FBQzVDLFFBQUk4eEIsTUFBTSxHQUFHaGdDLE1BQU0sQ0FBQ2lnQyxnQkFBUCxDQUF3Qi8xQixFQUF4QixDQUFiO0FBQ0EsUUFBSWcyQixnQkFBZ0IsR0FBR0YsTUFBTSxDQUFDcEIsY0FBYyxHQUFHLE9BQWxCLENBQU4sQ0FBaUN6bEMsS0FBakMsQ0FBdUMsSUFBdkMsQ0FBdkI7QUFDQSxRQUFJZ25DLG1CQUFtQixHQUFHSCxNQUFNLENBQUNwQixjQUFjLEdBQUcsVUFBbEIsQ0FBTixDQUFvQ3psQyxLQUFwQyxDQUEwQyxJQUExQyxDQUExQjtBQUNBLFFBQUlpbkMsaUJBQWlCLEdBQUdDLFVBQVUsQ0FBQ0gsZ0JBQUQsRUFBbUJDLG1CQUFuQixDQUFsQztBQUNBLFFBQUlHLGVBQWUsR0FBR04sTUFBTSxDQUFDbEIsYUFBYSxHQUFHLE9BQWpCLENBQU4sQ0FBZ0MzbEMsS0FBaEMsQ0FBc0MsSUFBdEMsQ0FBdEI7QUFDQSxRQUFJb25DLGtCQUFrQixHQUFHUCxNQUFNLENBQUNsQixhQUFhLEdBQUcsVUFBakIsQ0FBTixDQUFtQzNsQyxLQUFuQyxDQUF5QyxJQUF6QyxDQUF6QjtBQUNBLFFBQUlxbkMsZ0JBQWdCLEdBQUdILFVBQVUsQ0FBQ0MsZUFBRCxFQUFrQkMsa0JBQWxCLENBQWpDO0FBRUEsUUFBSW4xQixJQUFKO0FBQ0EsUUFBSXNLLE9BQU8sR0FBRyxDQUFkO0FBQ0EsUUFBSWtxQixTQUFTLEdBQUcsQ0FBaEI7QUFDQTs7QUFDQSxRQUFJMXhCLFlBQVksS0FBS3d3QixVQUFyQixFQUFpQztBQUMvQixVQUFJMEIsaUJBQWlCLEdBQUcsQ0FBeEIsRUFBMkI7QUFDekJoMUIsWUFBSSxHQUFHc3pCLFVBQVA7QUFDQWhwQixlQUFPLEdBQUcwcUIsaUJBQVY7QUFDQVIsaUJBQVMsR0FBR08sbUJBQW1CLENBQUM5bUMsTUFBaEM7QUFDRDtBQUNGLEtBTkQsTUFNTyxJQUFJNlUsWUFBWSxLQUFLeXdCLFNBQXJCLEVBQWdDO0FBQ3JDLFVBQUk2QixnQkFBZ0IsR0FBRyxDQUF2QixFQUEwQjtBQUN4QnAxQixZQUFJLEdBQUd1ekIsU0FBUDtBQUNBanBCLGVBQU8sR0FBRzhxQixnQkFBVjtBQUNBWixpQkFBUyxHQUFHVyxrQkFBa0IsQ0FBQ2xuQyxNQUEvQjtBQUNEO0FBQ0YsS0FOTSxNQU1BO0FBQ0xxYyxhQUFPLEdBQUdwZCxJQUFJLENBQUN5UixHQUFMLENBQVNxMkIsaUJBQVQsRUFBNEJJLGdCQUE1QixDQUFWO0FBQ0FwMUIsVUFBSSxHQUFHc0ssT0FBTyxHQUFHLENBQVYsR0FDSDBxQixpQkFBaUIsR0FBR0ksZ0JBQXBCLEdBQ0U5QixVQURGLEdBRUVDLFNBSEMsR0FJSCxJQUpKO0FBS0FpQixlQUFTLEdBQUd4MEIsSUFBSSxHQUNaQSxJQUFJLEtBQUtzekIsVUFBVCxHQUNFeUIsbUJBQW1CLENBQUM5bUMsTUFEdEIsR0FFRWtuQyxrQkFBa0IsQ0FBQ2xuQyxNQUhULEdBSVosQ0FKSjtBQUtEOztBQUNELFFBQUlvbkMsWUFBWSxHQUNkcjFCLElBQUksS0FBS3N6QixVQUFULElBQ0FxQixXQUFXLENBQUNuZ0MsSUFBWixDQUFpQm9nQyxNQUFNLENBQUNwQixjQUFjLEdBQUcsVUFBbEIsQ0FBdkIsQ0FGRjtBQUdBLFdBQU87QUFDTHh6QixVQUFJLEVBQUVBLElBREQ7QUFFTHNLLGFBQU8sRUFBRUEsT0FGSjtBQUdMa3FCLGVBQVMsRUFBRUEsU0FITjtBQUlMYSxrQkFBWSxFQUFFQTtBQUpULEtBQVA7QUFNRDs7QUFFRCxXQUFTSixVQUFULENBQXFCSyxNQUFyQixFQUE2QkMsU0FBN0IsRUFBd0M7QUFDdEM7QUFDQSxXQUFPRCxNQUFNLENBQUNybkMsTUFBUCxHQUFnQnNuQyxTQUFTLENBQUN0bkMsTUFBakMsRUFBeUM7QUFDdkNxbkMsWUFBTSxHQUFHQSxNQUFNLENBQUM1akMsTUFBUCxDQUFjNGpDLE1BQWQsQ0FBVDtBQUNEOztBQUVELFdBQU9wb0MsSUFBSSxDQUFDeVIsR0FBTCxDQUFTeE8sS0FBVCxDQUFlLElBQWYsRUFBcUJvbEMsU0FBUyxDQUFDM25DLEdBQVYsQ0FBYyxVQUFVdXFCLENBQVYsRUFBYW5xQixDQUFiLEVBQWdCO0FBQ3hELGFBQU93bkMsSUFBSSxDQUFDcmQsQ0FBRCxDQUFKLEdBQVVxZCxJQUFJLENBQUNGLE1BQU0sQ0FBQ3RuQyxDQUFELENBQVAsQ0FBckI7QUFDRCxLQUYyQixDQUFyQixDQUFQO0FBR0Q7O0FBRUQsV0FBU3duQyxJQUFULENBQWVDLENBQWYsRUFBa0I7QUFDaEIsV0FBT2hYLE1BQU0sQ0FBQ2dYLENBQUMsQ0FBQy9vQyxLQUFGLENBQVEsQ0FBUixFQUFXLENBQUMsQ0FBWixDQUFELENBQU4sR0FBeUIsSUFBaEM7QUFDRDtBQUVEOzs7QUFFQSxXQUFTZ3BDLEtBQVQsQ0FBZ0I1NUIsS0FBaEIsRUFBdUI2NUIsYUFBdkIsRUFBc0M7QUFDcEMsUUFBSTcyQixFQUFFLEdBQUdoRCxLQUFLLENBQUN6QixHQUFmLENBRG9DLENBR3BDOztBQUNBLFFBQUl2TyxLQUFLLENBQUNnVCxFQUFFLENBQUNzcEIsUUFBSixDQUFULEVBQXdCO0FBQ3RCdHBCLFFBQUUsQ0FBQ3NwQixRQUFILENBQVl3TixTQUFaLEdBQXdCLElBQXhCOztBQUNBOTJCLFFBQUUsQ0FBQ3NwQixRQUFIO0FBQ0Q7O0FBRUQsUUFBSWx1QixJQUFJLEdBQUcwNEIsaUJBQWlCLENBQUM5MkIsS0FBSyxDQUFDNUIsSUFBTixDQUFXNnFCLFVBQVosQ0FBNUI7O0FBQ0EsUUFBSXA1QixPQUFPLENBQUN1TyxJQUFELENBQVgsRUFBbUI7QUFDakI7QUFDRDtBQUVEOzs7QUFDQSxRQUFJcE8sS0FBSyxDQUFDZ1QsRUFBRSxDQUFDKzJCLFFBQUosQ0FBTCxJQUFzQi8yQixFQUFFLENBQUM4b0IsUUFBSCxLQUFnQixDQUExQyxFQUE2QztBQUMzQztBQUNEOztBQUVELFFBQUlpTCxHQUFHLEdBQUczNEIsSUFBSSxDQUFDMjRCLEdBQWY7QUFDQSxRQUFJN3lCLElBQUksR0FBRzlGLElBQUksQ0FBQzhGLElBQWhCO0FBQ0EsUUFBSSt5QixVQUFVLEdBQUc3NEIsSUFBSSxDQUFDNjRCLFVBQXRCO0FBQ0EsUUFBSUMsWUFBWSxHQUFHOTRCLElBQUksQ0FBQzg0QixZQUF4QjtBQUNBLFFBQUlDLGdCQUFnQixHQUFHLzRCLElBQUksQ0FBQys0QixnQkFBNUI7QUFDQSxRQUFJNkMsV0FBVyxHQUFHNTdCLElBQUksQ0FBQzQ3QixXQUF2QjtBQUNBLFFBQUlDLGFBQWEsR0FBRzc3QixJQUFJLENBQUM2N0IsYUFBekI7QUFDQSxRQUFJQyxpQkFBaUIsR0FBRzk3QixJQUFJLENBQUM4N0IsaUJBQTdCO0FBQ0EsUUFBSUMsV0FBVyxHQUFHLzdCLElBQUksQ0FBQys3QixXQUF2QjtBQUNBLFFBQUlQLEtBQUssR0FBR3g3QixJQUFJLENBQUN3N0IsS0FBakI7QUFDQSxRQUFJUSxVQUFVLEdBQUdoOEIsSUFBSSxDQUFDZzhCLFVBQXRCO0FBQ0EsUUFBSUMsY0FBYyxHQUFHajhCLElBQUksQ0FBQ2k4QixjQUExQjtBQUNBLFFBQUlDLFlBQVksR0FBR2w4QixJQUFJLENBQUNrOEIsWUFBeEI7QUFDQSxRQUFJQyxNQUFNLEdBQUduOEIsSUFBSSxDQUFDbThCLE1BQWxCO0FBQ0EsUUFBSUMsV0FBVyxHQUFHcDhCLElBQUksQ0FBQ284QixXQUF2QjtBQUNBLFFBQUlDLGVBQWUsR0FBR3I4QixJQUFJLENBQUNxOEIsZUFBM0I7QUFDQSxRQUFJQyxRQUFRLEdBQUd0OEIsSUFBSSxDQUFDczhCLFFBQXBCLENBbkNvQyxDQXFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsUUFBSWw4QixPQUFPLEdBQUcyUixjQUFkO0FBQ0EsUUFBSXdxQixjQUFjLEdBQUd4cUIsY0FBYyxDQUFDeUIsTUFBcEM7O0FBQ0EsV0FBTytvQixjQUFjLElBQUlBLGNBQWMsQ0FBQzM3QixNQUF4QyxFQUFnRDtBQUM5QzI3QixvQkFBYyxHQUFHQSxjQUFjLENBQUMzN0IsTUFBaEM7QUFDQVIsYUFBTyxHQUFHbThCLGNBQWMsQ0FBQ244QixPQUF6QjtBQUNEOztBQUVELFFBQUlvOEIsUUFBUSxHQUFHLENBQUNwOEIsT0FBTyxDQUFDb1MsVUFBVCxJQUF1QixDQUFDNVEsS0FBSyxDQUFDYixZQUE3Qzs7QUFFQSxRQUFJeTdCLFFBQVEsSUFBSSxDQUFDTCxNQUFiLElBQXVCQSxNQUFNLEtBQUssRUFBdEMsRUFBMEM7QUFDeEM7QUFDRDs7QUFFRCxRQUFJTSxVQUFVLEdBQUdELFFBQVEsSUFBSVosV0FBWixHQUNiQSxXQURhLEdBRWIvQyxVQUZKO0FBR0EsUUFBSTZELFdBQVcsR0FBR0YsUUFBUSxJQUFJVixpQkFBWixHQUNkQSxpQkFEYyxHQUVkL0MsZ0JBRko7QUFHQSxRQUFJNEQsT0FBTyxHQUFHSCxRQUFRLElBQUlYLGFBQVosR0FDVkEsYUFEVSxHQUVWL0MsWUFGSjtBQUlBLFFBQUk4RCxlQUFlLEdBQUdKLFFBQVEsR0FDekJOLFlBQVksSUFBSUgsV0FEUyxHQUUxQkEsV0FGSjtBQUdBLFFBQUljLFNBQVMsR0FBR0wsUUFBUSxHQUNuQixPQUFPTCxNQUFQLEtBQWtCLFVBQWxCLEdBQStCQSxNQUEvQixHQUF3Q1gsS0FEckIsR0FFcEJBLEtBRko7QUFHQSxRQUFJc0IsY0FBYyxHQUFHTixRQUFRLEdBQ3hCSixXQUFXLElBQUlKLFVBRFMsR0FFekJBLFVBRko7QUFHQSxRQUFJZSxrQkFBa0IsR0FBR1AsUUFBUSxHQUM1QkgsZUFBZSxJQUFJSixjQURTLEdBRTdCQSxjQUZKO0FBSUEsUUFBSWUscUJBQXFCLEdBQUczcEMsUUFBUSxDQUNsQ3BCLFFBQVEsQ0FBQ3FxQyxRQUFELENBQVIsR0FDSUEsUUFBUSxDQUFDZCxLQURiLEdBRUljLFFBSDhCLENBQXBDOztBQU1BLFFBQUksa0JBQWtCLFlBQWxCLElBQWtDVSxxQkFBcUIsSUFBSSxJQUEvRCxFQUFxRTtBQUNuRUMsbUJBQWEsQ0FBQ0QscUJBQUQsRUFBd0IsT0FBeEIsRUFBaUNwN0IsS0FBakMsQ0FBYjtBQUNEOztBQUVELFFBQUlzN0IsVUFBVSxHQUFHdkUsR0FBRyxLQUFLLEtBQVIsSUFBaUIsQ0FBQ3g5QixLQUFuQztBQUNBLFFBQUlnaUMsZ0JBQWdCLEdBQUdDLHNCQUFzQixDQUFDUCxTQUFELENBQTdDO0FBRUEsUUFBSTV4QixFQUFFLEdBQUdyRyxFQUFFLENBQUMrMkIsUUFBSCxHQUFjcmpDLElBQUksQ0FBQyxZQUFZO0FBQ3RDLFVBQUk0a0MsVUFBSixFQUFnQjtBQUNkL0MsNkJBQXFCLENBQUN2MUIsRUFBRCxFQUFLKzNCLE9BQUwsQ0FBckI7QUFDQXhDLDZCQUFxQixDQUFDdjFCLEVBQUQsRUFBSzgzQixXQUFMLENBQXJCO0FBQ0Q7O0FBQ0QsVUFBSXp4QixFQUFFLENBQUN5d0IsU0FBUCxFQUFrQjtBQUNoQixZQUFJd0IsVUFBSixFQUFnQjtBQUNkL0MsK0JBQXFCLENBQUN2MUIsRUFBRCxFQUFLNjNCLFVBQUwsQ0FBckI7QUFDRDs7QUFDRE0sMEJBQWtCLElBQUlBLGtCQUFrQixDQUFDbjRCLEVBQUQsQ0FBeEM7QUFDRCxPQUxELE1BS087QUFDTGs0QixzQkFBYyxJQUFJQSxjQUFjLENBQUNsNEIsRUFBRCxDQUFoQztBQUNEOztBQUNEQSxRQUFFLENBQUMrMkIsUUFBSCxHQUFjLElBQWQ7QUFDRCxLQWQwQixDQUEzQjs7QUFnQkEsUUFBSSxDQUFDLzVCLEtBQUssQ0FBQzVCLElBQU4sQ0FBV3E5QixJQUFoQixFQUFzQjtBQUNwQjtBQUNBenZCLG9CQUFjLENBQUNoTSxLQUFELEVBQVEsUUFBUixFQUFrQixZQUFZO0FBQzFDLFlBQUloQixNQUFNLEdBQUdnRSxFQUFFLENBQUNpaEIsVUFBaEI7QUFDQSxZQUFJeVgsV0FBVyxHQUFHMThCLE1BQU0sSUFBSUEsTUFBTSxDQUFDMjhCLFFBQWpCLElBQTZCMzhCLE1BQU0sQ0FBQzI4QixRQUFQLENBQWdCMzdCLEtBQUssQ0FBQ2pOLEdBQXRCLENBQS9DOztBQUNBLFlBQUkyb0MsV0FBVyxJQUNiQSxXQUFXLENBQUN2OUIsR0FBWixLQUFvQjZCLEtBQUssQ0FBQzdCLEdBRHhCLElBRUZ1OUIsV0FBVyxDQUFDbjlCLEdBQVosQ0FBZ0IrdEIsUUFGbEIsRUFHRTtBQUNBb1AscUJBQVcsQ0FBQ245QixHQUFaLENBQWdCK3RCLFFBQWhCO0FBQ0Q7O0FBQ0QyTyxpQkFBUyxJQUFJQSxTQUFTLENBQUNqNEIsRUFBRCxFQUFLcUcsRUFBTCxDQUF0QjtBQUNELE9BVmEsQ0FBZDtBQVdELEtBdkhtQyxDQXlIcEM7OztBQUNBMnhCLG1CQUFlLElBQUlBLGVBQWUsQ0FBQ2g0QixFQUFELENBQWxDOztBQUNBLFFBQUlzNEIsVUFBSixFQUFnQjtBQUNkakQsd0JBQWtCLENBQUNyMUIsRUFBRCxFQUFLNjNCLFVBQUwsQ0FBbEI7QUFDQXhDLHdCQUFrQixDQUFDcjFCLEVBQUQsRUFBSzgzQixXQUFMLENBQWxCO0FBQ0ExQyxlQUFTLENBQUMsWUFBWTtBQUNwQkcsNkJBQXFCLENBQUN2MUIsRUFBRCxFQUFLNjNCLFVBQUwsQ0FBckI7O0FBQ0EsWUFBSSxDQUFDeHhCLEVBQUUsQ0FBQ3l3QixTQUFSLEVBQW1CO0FBQ2pCekIsNEJBQWtCLENBQUNyMUIsRUFBRCxFQUFLKzNCLE9BQUwsQ0FBbEI7O0FBQ0EsY0FBSSxDQUFDUSxnQkFBTCxFQUF1QjtBQUNyQixnQkFBSUssZUFBZSxDQUFDUixxQkFBRCxDQUFuQixFQUE0QztBQUMxQ3Z5Qix3QkFBVSxDQUFDUSxFQUFELEVBQUsreEIscUJBQUwsQ0FBVjtBQUNELGFBRkQsTUFFTztBQUNMNUMsZ0NBQWtCLENBQUN4MUIsRUFBRCxFQUFLa0IsSUFBTCxFQUFXbUYsRUFBWCxDQUFsQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLE9BWlEsQ0FBVDtBQWFEOztBQUVELFFBQUlySixLQUFLLENBQUM1QixJQUFOLENBQVdxOUIsSUFBZixFQUFxQjtBQUNuQjVCLG1CQUFhLElBQUlBLGFBQWEsRUFBOUI7QUFDQW9CLGVBQVMsSUFBSUEsU0FBUyxDQUFDajRCLEVBQUQsRUFBS3FHLEVBQUwsQ0FBdEI7QUFDRDs7QUFFRCxRQUFJLENBQUNpeUIsVUFBRCxJQUFlLENBQUNDLGdCQUFwQixFQUFzQztBQUNwQ2x5QixRQUFFO0FBQ0g7QUFDRjs7QUFFRCxXQUFTd3lCLEtBQVQsQ0FBZ0I3N0IsS0FBaEIsRUFBdUI0cEIsRUFBdkIsRUFBMkI7QUFDekIsUUFBSTVtQixFQUFFLEdBQUdoRCxLQUFLLENBQUN6QixHQUFmLENBRHlCLENBR3pCOztBQUNBLFFBQUl2TyxLQUFLLENBQUNnVCxFQUFFLENBQUMrMkIsUUFBSixDQUFULEVBQXdCO0FBQ3RCLzJCLFFBQUUsQ0FBQysyQixRQUFILENBQVlELFNBQVosR0FBd0IsSUFBeEI7O0FBQ0E5MkIsUUFBRSxDQUFDKzJCLFFBQUg7QUFDRDs7QUFFRCxRQUFJMzdCLElBQUksR0FBRzA0QixpQkFBaUIsQ0FBQzkyQixLQUFLLENBQUM1QixJQUFOLENBQVc2cUIsVUFBWixDQUE1Qjs7QUFDQSxRQUFJcDVCLE9BQU8sQ0FBQ3VPLElBQUQsQ0FBUCxJQUFpQjRFLEVBQUUsQ0FBQzhvQixRQUFILEtBQWdCLENBQXJDLEVBQXdDO0FBQ3RDLGFBQU9sQyxFQUFFLEVBQVQ7QUFDRDtBQUVEOzs7QUFDQSxRQUFJNTVCLEtBQUssQ0FBQ2dULEVBQUUsQ0FBQ3NwQixRQUFKLENBQVQsRUFBd0I7QUFDdEI7QUFDRDs7QUFFRCxRQUFJeUssR0FBRyxHQUFHMzRCLElBQUksQ0FBQzI0QixHQUFmO0FBQ0EsUUFBSTd5QixJQUFJLEdBQUc5RixJQUFJLENBQUM4RixJQUFoQjtBQUNBLFFBQUlrekIsVUFBVSxHQUFHaDVCLElBQUksQ0FBQ2c1QixVQUF0QjtBQUNBLFFBQUlDLFlBQVksR0FBR2o1QixJQUFJLENBQUNpNUIsWUFBeEI7QUFDQSxRQUFJQyxnQkFBZ0IsR0FBR2w1QixJQUFJLENBQUNrNUIsZ0JBQTVCO0FBQ0EsUUFBSXdFLFdBQVcsR0FBRzE5QixJQUFJLENBQUMwOUIsV0FBdkI7QUFDQSxRQUFJRCxLQUFLLEdBQUd6OUIsSUFBSSxDQUFDeTlCLEtBQWpCO0FBQ0EsUUFBSUUsVUFBVSxHQUFHMzlCLElBQUksQ0FBQzI5QixVQUF0QjtBQUNBLFFBQUlDLGNBQWMsR0FBRzU5QixJQUFJLENBQUM0OUIsY0FBMUI7QUFDQSxRQUFJQyxVQUFVLEdBQUc3OUIsSUFBSSxDQUFDNjlCLFVBQXRCO0FBQ0EsUUFBSXZCLFFBQVEsR0FBR3Q4QixJQUFJLENBQUNzOEIsUUFBcEI7QUFFQSxRQUFJWSxVQUFVLEdBQUd2RSxHQUFHLEtBQUssS0FBUixJQUFpQixDQUFDeDlCLEtBQW5DO0FBQ0EsUUFBSWdpQyxnQkFBZ0IsR0FBR0Msc0JBQXNCLENBQUNLLEtBQUQsQ0FBN0M7QUFFQSxRQUFJSyxxQkFBcUIsR0FBR3pxQyxRQUFRLENBQ2xDcEIsUUFBUSxDQUFDcXFDLFFBQUQsQ0FBUixHQUNJQSxRQUFRLENBQUNtQixLQURiLEdBRUluQixRQUg4QixDQUFwQzs7QUFNQSxRQUFJLGtCQUFrQixZQUFsQixJQUFrQzFxQyxLQUFLLENBQUNrc0MscUJBQUQsQ0FBM0MsRUFBb0U7QUFDbEViLG1CQUFhLENBQUNhLHFCQUFELEVBQXdCLE9BQXhCLEVBQWlDbDhCLEtBQWpDLENBQWI7QUFDRDs7QUFFRCxRQUFJcUosRUFBRSxHQUFHckcsRUFBRSxDQUFDc3BCLFFBQUgsR0FBYzUxQixJQUFJLENBQUMsWUFBWTtBQUN0QyxVQUFJc00sRUFBRSxDQUFDaWhCLFVBQUgsSUFBaUJqaEIsRUFBRSxDQUFDaWhCLFVBQUgsQ0FBYzBYLFFBQW5DLEVBQTZDO0FBQzNDMzRCLFVBQUUsQ0FBQ2loQixVQUFILENBQWMwWCxRQUFkLENBQXVCMzdCLEtBQUssQ0FBQ2pOLEdBQTdCLElBQW9DLElBQXBDO0FBQ0Q7O0FBQ0QsVUFBSXVvQyxVQUFKLEVBQWdCO0FBQ2QvQyw2QkFBcUIsQ0FBQ3YxQixFQUFELEVBQUtxMEIsWUFBTCxDQUFyQjtBQUNBa0IsNkJBQXFCLENBQUN2MUIsRUFBRCxFQUFLczBCLGdCQUFMLENBQXJCO0FBQ0Q7O0FBQ0QsVUFBSWp1QixFQUFFLENBQUN5d0IsU0FBUCxFQUFrQjtBQUNoQixZQUFJd0IsVUFBSixFQUFnQjtBQUNkL0MsK0JBQXFCLENBQUN2MUIsRUFBRCxFQUFLbzBCLFVBQUwsQ0FBckI7QUFDRDs7QUFDRDRFLHNCQUFjLElBQUlBLGNBQWMsQ0FBQ2g1QixFQUFELENBQWhDO0FBQ0QsT0FMRCxNQUtPO0FBQ0w0bUIsVUFBRTtBQUNGbVMsa0JBQVUsSUFBSUEsVUFBVSxDQUFDLzRCLEVBQUQsQ0FBeEI7QUFDRDs7QUFDREEsUUFBRSxDQUFDc3BCLFFBQUgsR0FBYyxJQUFkO0FBQ0QsS0FsQjBCLENBQTNCOztBQW9CQSxRQUFJMlAsVUFBSixFQUFnQjtBQUNkQSxnQkFBVSxDQUFDRSxZQUFELENBQVY7QUFDRCxLQUZELE1BRU87QUFDTEEsa0JBQVk7QUFDYjs7QUFFRCxhQUFTQSxZQUFULEdBQXlCO0FBQ3ZCO0FBQ0EsVUFBSTl5QixFQUFFLENBQUN5d0IsU0FBUCxFQUFrQjtBQUNoQjtBQUNELE9BSnNCLENBS3ZCOzs7QUFDQSxVQUFJLENBQUM5NUIsS0FBSyxDQUFDNUIsSUFBTixDQUFXcTlCLElBQWhCLEVBQXNCO0FBQ3BCLFNBQUN6NEIsRUFBRSxDQUFDaWhCLFVBQUgsQ0FBYzBYLFFBQWQsS0FBMkIzNEIsRUFBRSxDQUFDaWhCLFVBQUgsQ0FBYzBYLFFBQWQsR0FBeUIsRUFBcEQsQ0FBRCxFQUEyRDM3QixLQUFLLENBQUNqTixHQUFqRSxJQUF5RWlOLEtBQXpFO0FBQ0Q7O0FBQ0Q4N0IsaUJBQVcsSUFBSUEsV0FBVyxDQUFDOTRCLEVBQUQsQ0FBMUI7O0FBQ0EsVUFBSXM0QixVQUFKLEVBQWdCO0FBQ2RqRCwwQkFBa0IsQ0FBQ3IxQixFQUFELEVBQUtvMEIsVUFBTCxDQUFsQjtBQUNBaUIsMEJBQWtCLENBQUNyMUIsRUFBRCxFQUFLczBCLGdCQUFMLENBQWxCO0FBQ0FjLGlCQUFTLENBQUMsWUFBWTtBQUNwQkcsK0JBQXFCLENBQUN2MUIsRUFBRCxFQUFLbzBCLFVBQUwsQ0FBckI7O0FBQ0EsY0FBSSxDQUFDL3RCLEVBQUUsQ0FBQ3l3QixTQUFSLEVBQW1CO0FBQ2pCekIsOEJBQWtCLENBQUNyMUIsRUFBRCxFQUFLcTBCLFlBQUwsQ0FBbEI7O0FBQ0EsZ0JBQUksQ0FBQ2tFLGdCQUFMLEVBQXVCO0FBQ3JCLGtCQUFJSyxlQUFlLENBQUNNLHFCQUFELENBQW5CLEVBQTRDO0FBQzFDcnpCLDBCQUFVLENBQUNRLEVBQUQsRUFBSzZ5QixxQkFBTCxDQUFWO0FBQ0QsZUFGRCxNQUVPO0FBQ0wxRCxrQ0FBa0IsQ0FBQ3gxQixFQUFELEVBQUtrQixJQUFMLEVBQVdtRixFQUFYLENBQWxCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsU0FaUSxDQUFUO0FBYUQ7O0FBQ0R3eUIsV0FBSyxJQUFJQSxLQUFLLENBQUM3NEIsRUFBRCxFQUFLcUcsRUFBTCxDQUFkOztBQUNBLFVBQUksQ0FBQ2l5QixVQUFELElBQWUsQ0FBQ0MsZ0JBQXBCLEVBQXNDO0FBQ3BDbHlCLFVBQUU7QUFDSDtBQUNGO0FBQ0YsR0FscVBvQixDQW9xUHJCOzs7QUFDQSxXQUFTZ3lCLGFBQVQsQ0FBd0JycUMsR0FBeEIsRUFBNkJzTCxJQUE3QixFQUFtQzBELEtBQW5DLEVBQTBDO0FBQ3hDLFFBQUksT0FBT2hQLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQm1LLFVBQUksQ0FDRiwyQkFBMkJtQixJQUEzQixHQUFrQyxvQ0FBbEMsR0FDQSxNQURBLEdBQ1UvSyxJQUFJLENBQUNDLFNBQUwsQ0FBZVIsR0FBZixDQURWLEdBQ2lDLEdBRi9CLEVBR0ZnUCxLQUFLLENBQUN4QixPQUhKLENBQUo7QUFLRCxLQU5ELE1BTU8sSUFBSTlNLEtBQUssQ0FBQ1YsR0FBRCxDQUFULEVBQWdCO0FBQ3JCbUssVUFBSSxDQUNGLDJCQUEyQm1CLElBQTNCLEdBQWtDLHFCQUFsQyxHQUNBLDZDQUZFLEVBR0YwRCxLQUFLLENBQUN4QixPQUhKLENBQUo7QUFLRDtBQUNGOztBQUVELFdBQVNvOUIsZUFBVCxDQUEwQjVxQyxHQUExQixFQUErQjtBQUM3QixXQUFPLE9BQU9BLEdBQVAsS0FBZSxRQUFmLElBQTJCLENBQUNVLEtBQUssQ0FBQ1YsR0FBRCxDQUF4QztBQUNEO0FBRUQ7Ozs7Ozs7O0FBTUEsV0FBU3dxQyxzQkFBVCxDQUFpQ3ZvQyxFQUFqQyxFQUFxQztBQUNuQyxRQUFJcEQsT0FBTyxDQUFDb0QsRUFBRCxDQUFYLEVBQWlCO0FBQ2YsYUFBTyxLQUFQO0FBQ0Q7O0FBQ0QsUUFBSW1wQyxVQUFVLEdBQUducEMsRUFBRSxDQUFDcVksR0FBcEI7O0FBQ0EsUUFBSXRiLEtBQUssQ0FBQ29zQyxVQUFELENBQVQsRUFBdUI7QUFDckI7QUFDQSxhQUFPWixzQkFBc0IsQ0FDM0IzbUMsS0FBSyxDQUFDc0IsT0FBTixDQUFjaW1DLFVBQWQsSUFDSUEsVUFBVSxDQUFDLENBQUQsQ0FEZCxHQUVJQSxVQUh1QixDQUE3QjtBQUtELEtBUEQsTUFPTztBQUNMLGFBQU8sQ0FBQ25wQyxFQUFFLENBQUNxQixPQUFILElBQWNyQixFQUFFLENBQUNkLE1BQWxCLElBQTRCLENBQW5DO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTa3FDLE1BQVQsQ0FBaUI3b0MsQ0FBakIsRUFBb0J3TSxLQUFwQixFQUEyQjtBQUN6QixRQUFJQSxLQUFLLENBQUM1QixJQUFOLENBQVdxOUIsSUFBWCxLQUFvQixJQUF4QixFQUE4QjtBQUM1QjdCLFdBQUssQ0FBQzU1QixLQUFELENBQUw7QUFDRDtBQUNGOztBQUVELE1BQUlpcEIsVUFBVSxHQUFHcHdCLFNBQVMsR0FBRztBQUMzQjlHLFVBQU0sRUFBRXNxQyxNQURtQjtBQUUzQm5ULFlBQVEsRUFBRW1ULE1BRmlCO0FBRzNCOXBDLFVBQU0sRUFBRSxTQUFTcVosU0FBVCxDQUFvQjVMLEtBQXBCLEVBQTJCNHBCLEVBQTNCLEVBQStCO0FBQ3JDO0FBQ0EsVUFBSTVwQixLQUFLLENBQUM1QixJQUFOLENBQVdxOUIsSUFBWCxLQUFvQixJQUF4QixFQUE4QjtBQUM1QkksYUFBSyxDQUFDNzdCLEtBQUQsRUFBUTRwQixFQUFSLENBQUw7QUFDRCxPQUZELE1BRU87QUFDTEEsVUFBRTtBQUNIO0FBQ0Y7QUFWMEIsR0FBSCxHQVd0QixFQVhKO0FBYUEsTUFBSTBTLGVBQWUsR0FBRyxDQUNwQmh3QixLQURvQixFQUVwQnVpQixLQUZvQixFQUdwQmdDLE1BSG9CLEVBSXBCN1csUUFKb0IsRUFLcEI4RSxLQUxvQixFQU1wQm1LLFVBTm9CLENBQXRCO0FBU0E7QUFFQTtBQUNBOztBQUNBLE1BQUl6ekIsT0FBTyxHQUFHOG1DLGVBQWUsQ0FBQzFtQyxNQUFoQixDQUF1QiszQixXQUF2QixDQUFkO0FBRUEsTUFBSTVCLEtBQUssR0FBR3ZFLG1CQUFtQixDQUFDO0FBQUViLFdBQU8sRUFBRUEsT0FBWDtBQUFvQm54QixXQUFPLEVBQUVBO0FBQTdCLEdBQUQsQ0FBL0I7QUFFQTs7Ozs7QUFLQTs7QUFDQSxNQUFJK0QsS0FBSixFQUFXO0FBQ1Q7QUFDQTJyQixZQUFRLENBQUNqckIsZ0JBQVQsQ0FBMEIsaUJBQTFCLEVBQTZDLFlBQVk7QUFDdkQsVUFBSStJLEVBQUUsR0FBR2tpQixRQUFRLENBQUMyUCxhQUFsQjs7QUFDQSxVQUFJN3hCLEVBQUUsSUFBSUEsRUFBRSxDQUFDdTVCLE1BQWIsRUFBcUI7QUFDbkJDLGVBQU8sQ0FBQ3g1QixFQUFELEVBQUssT0FBTCxDQUFQO0FBQ0Q7QUFDRixLQUxEO0FBTUQ7O0FBRUQsTUFBSXk1QixTQUFTLEdBQUc7QUFDZDM3QixZQUFRLEVBQUUsU0FBU0EsUUFBVCxDQUFtQmtDLEVBQW5CLEVBQXVCeXdCLE9BQXZCLEVBQWdDenpCLEtBQWhDLEVBQXVDc2QsUUFBdkMsRUFBaUQ7QUFDekQsVUFBSXRkLEtBQUssQ0FBQzdCLEdBQU4sS0FBYyxRQUFsQixFQUE0QjtBQUMxQjtBQUNBLFlBQUltZixRQUFRLENBQUMvZSxHQUFULElBQWdCLENBQUMrZSxRQUFRLENBQUMvZSxHQUFULENBQWFtK0IsU0FBbEMsRUFBNkM7QUFDM0Mxd0Isd0JBQWMsQ0FBQ2hNLEtBQUQsRUFBUSxXQUFSLEVBQXFCLFlBQVk7QUFDN0N5OEIscUJBQVMsQ0FBQ3BQLGdCQUFWLENBQTJCcnFCLEVBQTNCLEVBQStCeXdCLE9BQS9CLEVBQXdDenpCLEtBQXhDO0FBQ0QsV0FGYSxDQUFkO0FBR0QsU0FKRCxNQUlPO0FBQ0wyOEIscUJBQVcsQ0FBQzM1QixFQUFELEVBQUt5d0IsT0FBTCxFQUFjenpCLEtBQUssQ0FBQ3hCLE9BQXBCLENBQVg7QUFDRDs7QUFDRHdFLFVBQUUsQ0FBQzA1QixTQUFILEdBQWUsR0FBRzVxQyxHQUFILENBQU9uQixJQUFQLENBQVlxUyxFQUFFLENBQUMvRyxPQUFmLEVBQXdCMmdDLFFBQXhCLENBQWY7QUFDRCxPQVZELE1BVU8sSUFBSTU4QixLQUFLLENBQUM3QixHQUFOLEtBQWMsVUFBZCxJQUE0QmtuQixlQUFlLENBQUNyaUIsRUFBRSxDQUFDa0IsSUFBSixDQUEvQyxFQUEwRDtBQUMvRGxCLFVBQUUsQ0FBQzh4QixXQUFILEdBQWlCckIsT0FBTyxDQUFDakcsU0FBekI7O0FBQ0EsWUFBSSxDQUFDaUcsT0FBTyxDQUFDakcsU0FBUixDQUFrQnRZLElBQXZCLEVBQTZCO0FBQzNCbFMsWUFBRSxDQUFDL0ksZ0JBQUgsQ0FBb0Isa0JBQXBCLEVBQXdDNGlDLGtCQUF4QztBQUNBNzVCLFlBQUUsQ0FBQy9JLGdCQUFILENBQW9CLGdCQUFwQixFQUFzQzZpQyxnQkFBdEMsRUFGMkIsQ0FHM0I7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E5NUIsWUFBRSxDQUFDL0ksZ0JBQUgsQ0FBb0IsUUFBcEIsRUFBOEI2aUMsZ0JBQTlCO0FBQ0E7O0FBQ0EsY0FBSXZqQyxLQUFKLEVBQVc7QUFDVHlKLGNBQUUsQ0FBQ3U1QixNQUFILEdBQVksSUFBWjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEtBNUJhO0FBOEJkbFAsb0JBQWdCLEVBQUUsU0FBU0EsZ0JBQVQsQ0FBMkJycUIsRUFBM0IsRUFBK0J5d0IsT0FBL0IsRUFBd0N6ekIsS0FBeEMsRUFBK0M7QUFDL0QsVUFBSUEsS0FBSyxDQUFDN0IsR0FBTixLQUFjLFFBQWxCLEVBQTRCO0FBQzFCdytCLG1CQUFXLENBQUMzNUIsRUFBRCxFQUFLeXdCLE9BQUwsRUFBY3p6QixLQUFLLENBQUN4QixPQUFwQixDQUFYLENBRDBCLENBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFlBQUl1K0IsV0FBVyxHQUFHLzVCLEVBQUUsQ0FBQzA1QixTQUFyQjtBQUNBLFlBQUlNLFVBQVUsR0FBR2g2QixFQUFFLENBQUMwNUIsU0FBSCxHQUFlLEdBQUc1cUMsR0FBSCxDQUFPbkIsSUFBUCxDQUFZcVMsRUFBRSxDQUFDL0csT0FBZixFQUF3QjJnQyxRQUF4QixDQUFoQzs7QUFDQSxZQUFJSSxVQUFVLENBQUNoVixJQUFYLENBQWdCLFVBQVVpVixDQUFWLEVBQWEvcUMsQ0FBYixFQUFnQjtBQUFFLGlCQUFPLENBQUM2RCxVQUFVLENBQUNrbkMsQ0FBRCxFQUFJRixXQUFXLENBQUM3cUMsQ0FBRCxDQUFmLENBQWxCO0FBQXdDLFNBQTFFLENBQUosRUFBaUY7QUFDL0U7QUFDQTtBQUNBLGNBQUlnckMsU0FBUyxHQUFHbDZCLEVBQUUsQ0FBQzJpQixRQUFILEdBQ1o4TixPQUFPLENBQUNyakMsS0FBUixDQUFjNDNCLElBQWQsQ0FBbUIsVUFBVWw0QixDQUFWLEVBQWE7QUFBRSxtQkFBT3F0QyxtQkFBbUIsQ0FBQ3J0QyxDQUFELEVBQUlrdEMsVUFBSixDQUExQjtBQUE0QyxXQUE5RSxDQURZLEdBRVp2SixPQUFPLENBQUNyakMsS0FBUixLQUFrQnFqQyxPQUFPLENBQUM5ZCxRQUExQixJQUFzQ3duQixtQkFBbUIsQ0FBQzFKLE9BQU8sQ0FBQ3JqQyxLQUFULEVBQWdCNHNDLFVBQWhCLENBRjdEOztBQUdBLGNBQUlFLFNBQUosRUFBZTtBQUNiVixtQkFBTyxDQUFDeDVCLEVBQUQsRUFBSyxRQUFMLENBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQWxEYSxHQUFoQjs7QUFxREEsV0FBUzI1QixXQUFULENBQXNCMzVCLEVBQXRCLEVBQTBCeXdCLE9BQTFCLEVBQW1DNzNCLEVBQW5DLEVBQXVDO0FBQ3JDd2hDLHVCQUFtQixDQUFDcDZCLEVBQUQsRUFBS3l3QixPQUFMLEVBQWM3M0IsRUFBZCxDQUFuQjtBQUNBOztBQUNBLFFBQUl0QyxJQUFJLElBQUlFLE1BQVosRUFBb0I7QUFDbEJxUCxnQkFBVSxDQUFDLFlBQVk7QUFDckJ1MEIsMkJBQW1CLENBQUNwNkIsRUFBRCxFQUFLeXdCLE9BQUwsRUFBYzczQixFQUFkLENBQW5CO0FBQ0QsT0FGUyxFQUVQLENBRk8sQ0FBVjtBQUdEO0FBQ0Y7O0FBRUQsV0FBU3doQyxtQkFBVCxDQUE4QnA2QixFQUE5QixFQUFrQ3l3QixPQUFsQyxFQUEyQzczQixFQUEzQyxFQUErQztBQUM3QyxRQUFJeEwsS0FBSyxHQUFHcWpDLE9BQU8sQ0FBQ3JqQyxLQUFwQjtBQUNBLFFBQUlpdEMsVUFBVSxHQUFHcjZCLEVBQUUsQ0FBQzJpQixRQUFwQjs7QUFDQSxRQUFJMFgsVUFBVSxJQUFJLENBQUN4b0MsS0FBSyxDQUFDc0IsT0FBTixDQUFjL0YsS0FBZCxDQUFuQixFQUF5QztBQUN2Qyx3QkFBa0IsWUFBbEIsSUFBa0MrSyxJQUFJLENBQ3BDLGdDQUFpQ3M0QixPQUFPLENBQUNuZixVQUF6QyxHQUF1RCxNQUF2RCxHQUNBLGtEQURBLEdBQ3NEM2tCLE1BQU0sQ0FBQ2EsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJFLElBQTFCLENBQStCUCxLQUEvQixFQUFzQ1EsS0FBdEMsQ0FBNEMsQ0FBNUMsRUFBK0MsQ0FBQyxDQUFoRCxDQUZsQixFQUdwQ2dMLEVBSG9DLENBQXRDO0FBS0E7QUFDRDs7QUFDRCxRQUFJMnBCLFFBQUosRUFBYytYLE1BQWQ7O0FBQ0EsU0FBSyxJQUFJcHJDLENBQUMsR0FBRyxDQUFSLEVBQVdpQyxDQUFDLEdBQUc2TyxFQUFFLENBQUMvRyxPQUFILENBQVc5SixNQUEvQixFQUF1Q0QsQ0FBQyxHQUFHaUMsQ0FBM0MsRUFBOENqQyxDQUFDLEVBQS9DLEVBQW1EO0FBQ2pEb3JDLFlBQU0sR0FBR3Q2QixFQUFFLENBQUMvRyxPQUFILENBQVcvSixDQUFYLENBQVQ7O0FBQ0EsVUFBSW1yQyxVQUFKLEVBQWdCO0FBQ2Q5WCxnQkFBUSxHQUFHOXVCLFlBQVksQ0FBQ3JHLEtBQUQsRUFBUXdzQyxRQUFRLENBQUNVLE1BQUQsQ0FBaEIsQ0FBWixHQUF3QyxDQUFDLENBQXBEOztBQUNBLFlBQUlBLE1BQU0sQ0FBQy9YLFFBQVAsS0FBb0JBLFFBQXhCLEVBQWtDO0FBQ2hDK1gsZ0JBQU0sQ0FBQy9YLFFBQVAsR0FBa0JBLFFBQWxCO0FBQ0Q7QUFDRixPQUxELE1BS087QUFDTCxZQUFJeHZCLFVBQVUsQ0FBQzZtQyxRQUFRLENBQUNVLE1BQUQsQ0FBVCxFQUFtQmx0QyxLQUFuQixDQUFkLEVBQXlDO0FBQ3ZDLGNBQUk0UyxFQUFFLENBQUN1NkIsYUFBSCxLQUFxQnJyQyxDQUF6QixFQUE0QjtBQUMxQjhRLGNBQUUsQ0FBQ3U2QixhQUFILEdBQW1CcnJDLENBQW5CO0FBQ0Q7O0FBQ0Q7QUFDRDtBQUNGO0FBQ0Y7O0FBQ0QsUUFBSSxDQUFDbXJDLFVBQUwsRUFBaUI7QUFDZnI2QixRQUFFLENBQUN1NkIsYUFBSCxHQUFtQixDQUFDLENBQXBCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTSixtQkFBVCxDQUE4Qi9zQyxLQUE5QixFQUFxQzZMLE9BQXJDLEVBQThDO0FBQzVDLFdBQU9BLE9BQU8sQ0FBQzVGLEtBQVIsQ0FBYyxVQUFVNG1DLENBQVYsRUFBYTtBQUFFLGFBQU8sQ0FBQ2xuQyxVQUFVLENBQUNrbkMsQ0FBRCxFQUFJN3NDLEtBQUosQ0FBbEI7QUFBK0IsS0FBNUQsQ0FBUDtBQUNEOztBQUVELFdBQVN3c0MsUUFBVCxDQUFtQlUsTUFBbkIsRUFBMkI7QUFDekIsV0FBTyxZQUFZQSxNQUFaLEdBQ0hBLE1BQU0sQ0FBQ2pKLE1BREosR0FFSGlKLE1BQU0sQ0FBQ2x0QyxLQUZYO0FBR0Q7O0FBRUQsV0FBU3lzQyxrQkFBVCxDQUE2QnZtQyxDQUE3QixFQUFnQztBQUM5QkEsS0FBQyxDQUFDbUgsTUFBRixDQUFTZzNCLFNBQVQsR0FBcUIsSUFBckI7QUFDRDs7QUFFRCxXQUFTcUksZ0JBQVQsQ0FBMkJ4bUMsQ0FBM0IsRUFBOEI7QUFDNUI7QUFDQSxRQUFJLENBQUNBLENBQUMsQ0FBQ21ILE1BQUYsQ0FBU2czQixTQUFkLEVBQXlCO0FBQUU7QUFBUTs7QUFDbkNuK0IsS0FBQyxDQUFDbUgsTUFBRixDQUFTZzNCLFNBQVQsR0FBcUIsS0FBckI7QUFDQStILFdBQU8sQ0FBQ2xtQyxDQUFDLENBQUNtSCxNQUFILEVBQVcsT0FBWCxDQUFQO0FBQ0Q7O0FBRUQsV0FBUysrQixPQUFULENBQWtCeDVCLEVBQWxCLEVBQXNCa0IsSUFBdEIsRUFBNEI7QUFDMUIsUUFBSTVOLENBQUMsR0FBRzR1QixRQUFRLENBQUNzWSxXQUFULENBQXFCLFlBQXJCLENBQVI7QUFDQWxuQyxLQUFDLENBQUNtbkMsU0FBRixDQUFZdjVCLElBQVosRUFBa0IsSUFBbEIsRUFBd0IsSUFBeEI7QUFDQWxCLE1BQUUsQ0FBQzA2QixhQUFILENBQWlCcG5DLENBQWpCO0FBQ0Q7QUFFRDtBQUVBOzs7QUFDQSxXQUFTcW5DLFVBQVQsQ0FBcUIzOUIsS0FBckIsRUFBNEI7QUFDMUIsV0FBT0EsS0FBSyxDQUFDakIsaUJBQU4sS0FBNEIsQ0FBQ2lCLEtBQUssQ0FBQzVCLElBQVAsSUFBZSxDQUFDNEIsS0FBSyxDQUFDNUIsSUFBTixDQUFXNnFCLFVBQXZELElBQ0gwVSxVQUFVLENBQUMzOUIsS0FBSyxDQUFDakIsaUJBQU4sQ0FBd0J1UyxNQUF6QixDQURQLEdBRUh0UixLQUZKO0FBR0Q7O0FBRUQsTUFBSXk3QixJQUFJLEdBQUc7QUFDVGpuQyxRQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFld08sRUFBZixFQUFtQm9jLEdBQW5CLEVBQXdCcGYsS0FBeEIsRUFBK0I7QUFDbkMsVUFBSTVQLEtBQUssR0FBR2d2QixHQUFHLENBQUNodkIsS0FBaEI7QUFFQTRQLFdBQUssR0FBRzI5QixVQUFVLENBQUMzOUIsS0FBRCxDQUFsQjtBQUNBLFVBQUk0OUIsYUFBYSxHQUFHNTlCLEtBQUssQ0FBQzVCLElBQU4sSUFBYzRCLEtBQUssQ0FBQzVCLElBQU4sQ0FBVzZxQixVQUE3QztBQUNBLFVBQUk0VSxlQUFlLEdBQUc3NkIsRUFBRSxDQUFDODZCLGtCQUFILEdBQ3BCOTZCLEVBQUUsQ0FBQzhiLEtBQUgsQ0FBU2lmLE9BQVQsS0FBcUIsTUFBckIsR0FBOEIsRUFBOUIsR0FBbUMvNkIsRUFBRSxDQUFDOGIsS0FBSCxDQUFTaWYsT0FEOUM7O0FBRUEsVUFBSTN0QyxLQUFLLElBQUl3dEMsYUFBYixFQUE0QjtBQUMxQjU5QixhQUFLLENBQUM1QixJQUFOLENBQVdxOUIsSUFBWCxHQUFrQixJQUFsQjtBQUNBN0IsYUFBSyxDQUFDNTVCLEtBQUQsRUFBUSxZQUFZO0FBQ3ZCZ0QsWUFBRSxDQUFDOGIsS0FBSCxDQUFTaWYsT0FBVCxHQUFtQkYsZUFBbkI7QUFDRCxTQUZJLENBQUw7QUFHRCxPQUxELE1BS087QUFDTDc2QixVQUFFLENBQUM4YixLQUFILENBQVNpZixPQUFULEdBQW1CM3RDLEtBQUssR0FBR3l0QyxlQUFILEdBQXFCLE1BQTdDO0FBQ0Q7QUFDRixLQWhCUTtBQWtCVGpnQyxVQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFpQm9GLEVBQWpCLEVBQXFCb2MsR0FBckIsRUFBMEJwZixLQUExQixFQUFpQztBQUN2QyxVQUFJNVAsS0FBSyxHQUFHZ3ZCLEdBQUcsQ0FBQ2h2QixLQUFoQjtBQUNBLFVBQUl1bEIsUUFBUSxHQUFHeUosR0FBRyxDQUFDekosUUFBbkI7QUFFQTs7QUFDQSxVQUFJLENBQUN2bEIsS0FBRCxLQUFXLENBQUN1bEIsUUFBaEIsRUFBMEI7QUFBRTtBQUFROztBQUNwQzNWLFdBQUssR0FBRzI5QixVQUFVLENBQUMzOUIsS0FBRCxDQUFsQjtBQUNBLFVBQUk0OUIsYUFBYSxHQUFHNTlCLEtBQUssQ0FBQzVCLElBQU4sSUFBYzRCLEtBQUssQ0FBQzVCLElBQU4sQ0FBVzZxQixVQUE3Qzs7QUFDQSxVQUFJMlUsYUFBSixFQUFtQjtBQUNqQjU5QixhQUFLLENBQUM1QixJQUFOLENBQVdxOUIsSUFBWCxHQUFrQixJQUFsQjs7QUFDQSxZQUFJcnJDLEtBQUosRUFBVztBQUNUd3BDLGVBQUssQ0FBQzU1QixLQUFELEVBQVEsWUFBWTtBQUN2QmdELGNBQUUsQ0FBQzhiLEtBQUgsQ0FBU2lmLE9BQVQsR0FBbUIvNkIsRUFBRSxDQUFDODZCLGtCQUF0QjtBQUNELFdBRkksQ0FBTDtBQUdELFNBSkQsTUFJTztBQUNMakMsZUFBSyxDQUFDNzdCLEtBQUQsRUFBUSxZQUFZO0FBQ3ZCZ0QsY0FBRSxDQUFDOGIsS0FBSCxDQUFTaWYsT0FBVCxHQUFtQixNQUFuQjtBQUNELFdBRkksQ0FBTDtBQUdEO0FBQ0YsT0FYRCxNQVdPO0FBQ0wvNkIsVUFBRSxDQUFDOGIsS0FBSCxDQUFTaWYsT0FBVCxHQUFtQjN0QyxLQUFLLEdBQUc0UyxFQUFFLENBQUM4NkIsa0JBQU4sR0FBMkIsTUFBbkQ7QUFDRDtBQUNGLEtBeENRO0FBMENURSxVQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUNOaDdCLEVBRE0sRUFFTnl3QixPQUZNLEVBR056ekIsS0FITSxFQUlOc2QsUUFKTSxFQUtOc1AsU0FMTSxFQU1OO0FBQ0EsVUFBSSxDQUFDQSxTQUFMLEVBQWdCO0FBQ2Q1cEIsVUFBRSxDQUFDOGIsS0FBSCxDQUFTaWYsT0FBVCxHQUFtQi82QixFQUFFLENBQUM4NkIsa0JBQXRCO0FBQ0Q7QUFDRjtBQXBEUSxHQUFYO0FBdURBLE1BQUlHLGtCQUFrQixHQUFHO0FBQ3ZCcGdCLFNBQUssRUFBRTRlLFNBRGdCO0FBRXZCaEIsUUFBSSxFQUFFQTtBQUdSO0FBRUE7QUFDQTs7QUFSeUIsR0FBekI7QUFVQSxNQUFJeUMsZUFBZSxHQUFHO0FBQ3BCNWhDLFFBQUksRUFBRW5MLE1BRGM7QUFFcEJvcEMsVUFBTSxFQUFFcDBCLE9BRlk7QUFHcEI0d0IsT0FBRyxFQUFFNXdCLE9BSGU7QUFJcEJnNEIsUUFBSSxFQUFFaHRDLE1BSmM7QUFLcEIrUyxRQUFJLEVBQUUvUyxNQUxjO0FBTXBCOGxDLGNBQVUsRUFBRTlsQyxNQU5RO0FBT3BCaW1DLGNBQVUsRUFBRWptQyxNQVBRO0FBUXBCK2xDLGdCQUFZLEVBQUUvbEMsTUFSTTtBQVNwQmttQyxnQkFBWSxFQUFFbG1DLE1BVE07QUFVcEJnbUMsb0JBQWdCLEVBQUVobUMsTUFWRTtBQVdwQm1tQyxvQkFBZ0IsRUFBRW5tQyxNQVhFO0FBWXBCNm9DLGVBQVcsRUFBRTdvQyxNQVpPO0FBYXBCK29DLHFCQUFpQixFQUFFL29DLE1BYkM7QUFjcEI4b0MsaUJBQWEsRUFBRTlvQyxNQWRLO0FBZXBCdXBDLFlBQVEsRUFBRSxDQUFDL1gsTUFBRCxFQUFTeHhCLE1BQVQsRUFBaUJ4QixNQUFqQjtBQWZVLEdBQXRCLENBejhQcUIsQ0EyOVByQjtBQUNBOztBQUNBLFdBQVN5dUMsWUFBVCxDQUF1QnArQixLQUF2QixFQUE4QjtBQUM1QixRQUFJcStCLFdBQVcsR0FBR3IrQixLQUFLLElBQUlBLEtBQUssQ0FBQ3ZCLGdCQUFqQzs7QUFDQSxRQUFJNC9CLFdBQVcsSUFBSUEsV0FBVyxDQUFDN2pDLElBQVosQ0FBaUJ5QixPQUFqQixDQUF5QnFVLFFBQTVDLEVBQXNEO0FBQ3BELGFBQU84dEIsWUFBWSxDQUFDM3ZCLHNCQUFzQixDQUFDNHZCLFdBQVcsQ0FBQ2hnQyxRQUFiLENBQXZCLENBQW5CO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTzJCLEtBQVA7QUFDRDtBQUNGOztBQUVELFdBQVNzK0IscUJBQVQsQ0FBZ0NqeEIsSUFBaEMsRUFBc0M7QUFDcEMsUUFBSWpQLElBQUksR0FBRyxFQUFYO0FBQ0EsUUFBSW5DLE9BQU8sR0FBR29SLElBQUksQ0FBQ2pSLFFBQW5CLENBRm9DLENBR3BDOztBQUNBLFNBQUssSUFBSXJKLEdBQVQsSUFBZ0JrSixPQUFPLENBQUNnSCxTQUF4QixFQUFtQztBQUNqQzdFLFVBQUksQ0FBQ3JMLEdBQUQsQ0FBSixHQUFZc2EsSUFBSSxDQUFDdGEsR0FBRCxDQUFoQjtBQUNELEtBTm1DLENBT3BDO0FBQ0E7OztBQUNBLFFBQUk4YixTQUFTLEdBQUc1UyxPQUFPLENBQUM2UyxnQkFBeEI7O0FBQ0EsU0FBSyxJQUFJM0ssS0FBVCxJQUFrQjBLLFNBQWxCLEVBQTZCO0FBQzNCelEsVUFBSSxDQUFDOUssUUFBUSxDQUFDNlEsS0FBRCxDQUFULENBQUosR0FBd0IwSyxTQUFTLENBQUMxSyxLQUFELENBQWpDO0FBQ0Q7O0FBQ0QsV0FBTy9GLElBQVA7QUFDRDs7QUFFRCxXQUFTbWdDLFdBQVQsQ0FBc0JDLENBQXRCLEVBQXlCQyxRQUF6QixFQUFtQztBQUNqQyxRQUFJLGlCQUFpQi9sQyxJQUFqQixDQUFzQitsQyxRQUFRLENBQUN0Z0MsR0FBL0IsQ0FBSixFQUF5QztBQUN2QyxhQUFPcWdDLENBQUMsQ0FBQyxZQUFELEVBQWU7QUFDckJwNkIsYUFBSyxFQUFFcTZCLFFBQVEsQ0FBQ2hnQyxnQkFBVCxDQUEwQndFO0FBRFosT0FBZixDQUFSO0FBR0Q7QUFDRjs7QUFFRCxXQUFTeTdCLG1CQUFULENBQThCMStCLEtBQTlCLEVBQXFDO0FBQ25DLFdBQVFBLEtBQUssR0FBR0EsS0FBSyxDQUFDaEIsTUFBdEIsRUFBK0I7QUFDN0IsVUFBSWdCLEtBQUssQ0FBQzVCLElBQU4sQ0FBVzZxQixVQUFmLEVBQTJCO0FBQ3pCLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTMFYsV0FBVCxDQUFzQmovQixLQUF0QixFQUE2QmsvQixRQUE3QixFQUF1QztBQUNyQyxXQUFPQSxRQUFRLENBQUM3ckMsR0FBVCxLQUFpQjJNLEtBQUssQ0FBQzNNLEdBQXZCLElBQThCNnJDLFFBQVEsQ0FBQ3pnQyxHQUFULEtBQWlCdUIsS0FBSyxDQUFDdkIsR0FBNUQ7QUFDRDs7QUFFRCxNQUFJMGdDLFVBQVUsR0FBRztBQUNmdmlDLFFBQUksRUFBRSxZQURTO0FBRWY4SCxTQUFLLEVBQUU4NUIsZUFGUTtBQUdmNXRCLFlBQVEsRUFBRSxJQUhLO0FBS2Y5RixVQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFpQmcwQixDQUFqQixFQUFvQjtBQUMxQixVQUFJaHZCLE1BQU0sR0FBRyxJQUFiO0FBRUEsVUFBSW5SLFFBQVEsR0FBRyxLQUFLK1UsTUFBTCxDQUFZNU0sT0FBM0I7O0FBQ0EsVUFBSSxDQUFDbkksUUFBTCxFQUFlO0FBQ2I7QUFDRCxPQU55QixDQVExQjs7O0FBQ0FBLGNBQVEsR0FBR0EsUUFBUSxDQUFDaWEsTUFBVCxDQUFnQixVQUFVN2tCLENBQVYsRUFBYTtBQUFFLGVBQU9BLENBQUMsQ0FBQzBLLEdBQUYsSUFBU3FCLGtCQUFrQixDQUFDL0wsQ0FBRCxDQUFsQztBQUF3QyxPQUF2RSxDQUFYO0FBQ0E7O0FBQ0EsVUFBSSxDQUFDNEssUUFBUSxDQUFDbE0sTUFBZCxFQUFzQjtBQUNwQjtBQUNELE9BYnlCLENBZTFCOzs7QUFDQSxVQUFJLGtCQUFrQixZQUFsQixJQUFrQ2tNLFFBQVEsQ0FBQ2xNLE1BQVQsR0FBa0IsQ0FBeEQsRUFBMkQ7QUFDekRnSixZQUFJLENBQ0YsNERBQ0EsK0JBRkUsRUFHRixLQUFLeUIsT0FISCxDQUFKO0FBS0Q7O0FBRUQsVUFBSXVoQyxJQUFJLEdBQUcsS0FBS0EsSUFBaEIsQ0F4QjBCLENBMEIxQjs7QUFDQSxVQUFJLGtCQUFrQixZQUFsQixJQUNGQSxJQURFLElBQ01BLElBQUksS0FBSyxRQURmLElBQzJCQSxJQUFJLEtBQUssUUFEeEMsRUFFRTtBQUNBaGpDLFlBQUksQ0FDRixnQ0FBZ0NnakMsSUFEOUIsRUFFRixLQUFLdmhDLE9BRkgsQ0FBSjtBQUlEOztBQUVELFVBQUk2aEMsUUFBUSxHQUFHcGdDLFFBQVEsQ0FBQyxDQUFELENBQXZCLENBcEMwQixDQXNDMUI7QUFDQTs7QUFDQSxVQUFJcWdDLG1CQUFtQixDQUFDLEtBQUs5c0IsTUFBTixDQUF2QixFQUFzQztBQUNwQyxlQUFPNnNCLFFBQVA7QUFDRCxPQTFDeUIsQ0E0QzFCO0FBQ0E7OztBQUNBLFVBQUkvK0IsS0FBSyxHQUFHMCtCLFlBQVksQ0FBQ0ssUUFBRCxDQUF4QjtBQUNBOztBQUNBLFVBQUksQ0FBQy8rQixLQUFMLEVBQVk7QUFDVixlQUFPKytCLFFBQVA7QUFDRDs7QUFFRCxVQUFJLEtBQUtLLFFBQVQsRUFBbUI7QUFDakIsZUFBT1AsV0FBVyxDQUFDQyxDQUFELEVBQUlDLFFBQUosQ0FBbEI7QUFDRCxPQXREeUIsQ0F3RDFCO0FBQ0E7QUFDQTs7O0FBQ0EsVUFBSXRoQyxFQUFFLEdBQUcsa0JBQW1CLEtBQUtrVixJQUF4QixHQUFnQyxHQUF6QztBQUNBM1MsV0FBSyxDQUFDM00sR0FBTixHQUFZMk0sS0FBSyxDQUFDM00sR0FBTixJQUFhLElBQWIsR0FDUjJNLEtBQUssQ0FBQ04sU0FBTixHQUNFakMsRUFBRSxHQUFHLFNBRFAsR0FFRUEsRUFBRSxHQUFHdUMsS0FBSyxDQUFDdkIsR0FITCxHQUlSaE8sV0FBVyxDQUFDdVAsS0FBSyxDQUFDM00sR0FBUCxDQUFYLEdBQ0c1QixNQUFNLENBQUN1TyxLQUFLLENBQUMzTSxHQUFQLENBQU4sQ0FBa0JKLE9BQWxCLENBQTBCd0ssRUFBMUIsTUFBa0MsQ0FBbEMsR0FBc0N1QyxLQUFLLENBQUMzTSxHQUE1QyxHQUFrRG9LLEVBQUUsR0FBR3VDLEtBQUssQ0FBQzNNLEdBRGhFLEdBRUUyTSxLQUFLLENBQUMzTSxHQU5aO0FBUUEsVUFBSXFMLElBQUksR0FBRyxDQUFDc0IsS0FBSyxDQUFDdEIsSUFBTixLQUFlc0IsS0FBSyxDQUFDdEIsSUFBTixHQUFhLEVBQTVCLENBQUQsRUFBa0M2cUIsVUFBbEMsR0FBK0NxVixxQkFBcUIsQ0FBQyxJQUFELENBQS9FO0FBQ0EsVUFBSVMsV0FBVyxHQUFHLEtBQUt6dEIsTUFBdkI7QUFDQSxVQUFJc3RCLFFBQVEsR0FBR1IsWUFBWSxDQUFDVyxXQUFELENBQTNCLENBdEUwQixDQXdFMUI7QUFDQTs7QUFDQSxVQUFJci9CLEtBQUssQ0FBQ3RCLElBQU4sQ0FBVzZHLFVBQVgsSUFBeUJ2RixLQUFLLENBQUN0QixJQUFOLENBQVc2RyxVQUFYLENBQXNCK2lCLElBQXRCLENBQTJCLFVBQVUzTCxDQUFWLEVBQWE7QUFBRSxlQUFPQSxDQUFDLENBQUMvZixJQUFGLEtBQVcsTUFBbEI7QUFBMkIsT0FBckUsQ0FBN0IsRUFBcUc7QUFDbkdvRCxhQUFLLENBQUN0QixJQUFOLENBQVdxOUIsSUFBWCxHQUFrQixJQUFsQjtBQUNEOztBQUVELFVBQ0VtRCxRQUFRLElBQ1JBLFFBQVEsQ0FBQ3hnQyxJQURULElBRUEsQ0FBQ3VnQyxXQUFXLENBQUNqL0IsS0FBRCxFQUFRay9CLFFBQVIsQ0FGWixJQUdBLENBQUNwL0Isa0JBQWtCLENBQUNvL0IsUUFBRCxDQUhuQixJQUlBO0FBQ0EsUUFBRUEsUUFBUSxDQUFDNy9CLGlCQUFULElBQThCNi9CLFFBQVEsQ0FBQzcvQixpQkFBVCxDQUEyQnVTLE1BQTNCLENBQWtDbFMsU0FBbEUsQ0FORixFQU9FO0FBQ0E7QUFDQTtBQUNBLFlBQUlvdkIsT0FBTyxHQUFHb1EsUUFBUSxDQUFDeGdDLElBQVQsQ0FBYzZxQixVQUFkLEdBQTJCbjBCLE1BQU0sQ0FBQyxFQUFELEVBQUtzSixJQUFMLENBQS9DLENBSEEsQ0FJQTs7QUFDQSxZQUFJKy9CLElBQUksS0FBSyxRQUFiLEVBQXVCO0FBQ3JCO0FBQ0EsZUFBS1csUUFBTCxHQUFnQixJQUFoQjtBQUNBOXlCLHdCQUFjLENBQUN3aUIsT0FBRCxFQUFVLFlBQVYsRUFBd0IsWUFBWTtBQUNoRGhmLGtCQUFNLENBQUNzdkIsUUFBUCxHQUFrQixLQUFsQjtBQUNBdHZCLGtCQUFNLENBQUNyQixZQUFQO0FBQ0QsV0FIYSxDQUFkO0FBSUEsaUJBQU9vd0IsV0FBVyxDQUFDQyxDQUFELEVBQUlDLFFBQUosQ0FBbEI7QUFDRCxTQVJELE1BUU8sSUFBSU4sSUFBSSxLQUFLLFFBQWIsRUFBdUI7QUFDNUIsY0FBSTMrQixrQkFBa0IsQ0FBQ0UsS0FBRCxDQUF0QixFQUErQjtBQUM3QixtQkFBT3EvQixXQUFQO0FBQ0Q7O0FBQ0QsY0FBSUMsWUFBSjs7QUFDQSxjQUFJN0MsWUFBWSxHQUFHLFlBQVk7QUFBRTZDLHdCQUFZO0FBQUssV0FBbEQ7O0FBQ0FoekIsd0JBQWMsQ0FBQzVOLElBQUQsRUFBTyxZQUFQLEVBQXFCKzlCLFlBQXJCLENBQWQ7QUFDQW53Qix3QkFBYyxDQUFDNU4sSUFBRCxFQUFPLGdCQUFQLEVBQXlCKzlCLFlBQXpCLENBQWQ7QUFDQW53Qix3QkFBYyxDQUFDd2lCLE9BQUQsRUFBVSxZQUFWLEVBQXdCLFVBQVVxTixLQUFWLEVBQWlCO0FBQUVtRCx3QkFBWSxHQUFHbkQsS0FBZjtBQUF1QixXQUFsRSxDQUFkO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPNEMsUUFBUDtBQUNEO0FBR0g7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBbElpQixHQUFqQjtBQW9JQSxNQUFJcjZCLEtBQUssR0FBR3RQLE1BQU0sQ0FBQztBQUNqQnFKLE9BQUcsRUFBRWhOLE1BRFk7QUFFakI4dEMsYUFBUyxFQUFFOXRDO0FBRk0sR0FBRCxFQUdmK3NDLGVBSGUsQ0FBbEI7QUFLQSxTQUFPOTVCLEtBQUssQ0FBQys1QixJQUFiO0FBRUEsTUFBSWUsZUFBZSxHQUFHO0FBQ3BCOTZCLFNBQUssRUFBRUEsS0FEYTtBQUdwQm9HLFVBQU0sRUFBRSxTQUFTQSxNQUFULENBQWlCZzBCLENBQWpCLEVBQW9CO0FBQzFCLFVBQUlyZ0MsR0FBRyxHQUFHLEtBQUtBLEdBQUwsSUFBWSxLQUFLeVQsTUFBTCxDQUFZeFQsSUFBWixDQUFpQkQsR0FBN0IsSUFBb0MsTUFBOUM7QUFDQSxVQUFJck0sR0FBRyxHQUFHbkMsTUFBTSxDQUFDb0MsTUFBUCxDQUFjLElBQWQsQ0FBVjtBQUNBLFVBQUlvdEMsWUFBWSxHQUFHLEtBQUtBLFlBQUwsR0FBb0IsS0FBSzlnQyxRQUE1QztBQUNBLFVBQUkrZ0MsV0FBVyxHQUFHLEtBQUtoc0IsTUFBTCxDQUFZNU0sT0FBWixJQUF1QixFQUF6QztBQUNBLFVBQUluSSxRQUFRLEdBQUcsS0FBS0EsUUFBTCxHQUFnQixFQUEvQjtBQUNBLFVBQUlnaEMsY0FBYyxHQUFHZixxQkFBcUIsQ0FBQyxJQUFELENBQTFDOztBQUVBLFdBQUssSUFBSXBzQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHa3RDLFdBQVcsQ0FBQ2p0QyxNQUFoQyxFQUF3Q0QsQ0FBQyxFQUF6QyxFQUE2QztBQUMzQyxZQUFJdUIsQ0FBQyxHQUFHMnJDLFdBQVcsQ0FBQ2x0QyxDQUFELENBQW5COztBQUNBLFlBQUl1QixDQUFDLENBQUMwSyxHQUFOLEVBQVc7QUFDVCxjQUFJMUssQ0FBQyxDQUFDVixHQUFGLElBQVMsSUFBVCxJQUFpQjVCLE1BQU0sQ0FBQ3NDLENBQUMsQ0FBQ1YsR0FBSCxDQUFOLENBQWNKLE9BQWQsQ0FBc0IsU0FBdEIsTUFBcUMsQ0FBMUQsRUFBNkQ7QUFDM0QwTCxvQkFBUSxDQUFDckIsSUFBVCxDQUFjdkosQ0FBZDtBQUNBM0IsZUFBRyxDQUFDMkIsQ0FBQyxDQUFDVixHQUFILENBQUgsR0FBYVUsQ0FBYjtBQUNDLGFBQUNBLENBQUMsQ0FBQzJLLElBQUYsS0FBVzNLLENBQUMsQ0FBQzJLLElBQUYsR0FBUyxFQUFwQixDQUFELEVBQTBCNnFCLFVBQTFCLEdBQXVDb1csY0FBdkM7QUFDRixXQUpELE1BSU87QUFDTCxnQkFBSXRsQyxJQUFJLEdBQUd0RyxDQUFDLENBQUNnTCxnQkFBYjtBQUNBLGdCQUFJbkMsSUFBSSxHQUFHdkMsSUFBSSxHQUFJQSxJQUFJLENBQUNTLElBQUwsQ0FBVXlCLE9BQVYsQ0FBa0JLLElBQWxCLElBQTBCdkMsSUFBSSxDQUFDb0UsR0FBL0IsSUFBc0MsRUFBMUMsR0FBZ0QxSyxDQUFDLENBQUMwSyxHQUFqRTtBQUNBaEQsZ0JBQUksQ0FBRSxpREFBaURtQixJQUFqRCxHQUF3RCxHQUExRCxDQUFKO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFVBQUk2aUMsWUFBSixFQUFrQjtBQUNoQixZQUFJRyxJQUFJLEdBQUcsRUFBWDtBQUNBLFlBQUlDLE9BQU8sR0FBRyxFQUFkOztBQUNBLGFBQUssSUFBSTd2QixHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHeXZCLFlBQVksQ0FBQ2h0QyxNQUFyQyxFQUE2Q3VkLEdBQUcsRUFBaEQsRUFBb0Q7QUFDbEQsY0FBSTh2QixHQUFHLEdBQUdMLFlBQVksQ0FBQ3p2QixHQUFELENBQXRCO0FBQ0E4dkIsYUFBRyxDQUFDcGhDLElBQUosQ0FBUzZxQixVQUFULEdBQXNCb1csY0FBdEI7QUFDQUcsYUFBRyxDQUFDcGhDLElBQUosQ0FBU3FoQyxHQUFULEdBQWVELEdBQUcsQ0FBQ2poQyxHQUFKLENBQVFtaEMscUJBQVIsRUFBZjs7QUFDQSxjQUFJNXRDLEdBQUcsQ0FBQzB0QyxHQUFHLENBQUN6c0MsR0FBTCxDQUFQLEVBQWtCO0FBQ2hCdXNDLGdCQUFJLENBQUN0aUMsSUFBTCxDQUFVd2lDLEdBQVY7QUFDRCxXQUZELE1BRU87QUFDTEQsbUJBQU8sQ0FBQ3ZpQyxJQUFSLENBQWF3aUMsR0FBYjtBQUNEO0FBQ0Y7O0FBQ0QsYUFBS0YsSUFBTCxHQUFZZCxDQUFDLENBQUNyZ0MsR0FBRCxFQUFNLElBQU4sRUFBWW1oQyxJQUFaLENBQWI7QUFDQSxhQUFLQyxPQUFMLEdBQWVBLE9BQWY7QUFDRDs7QUFFRCxhQUFPZixDQUFDLENBQUNyZ0MsR0FBRCxFQUFNLElBQU4sRUFBWUUsUUFBWixDQUFSO0FBQ0QsS0E1Q21CO0FBOENwQnNoQyxnQkFBWSxFQUFFLFNBQVNBLFlBQVQsR0FBeUI7QUFDckM7QUFDQSxXQUFLbnVCLFNBQUwsQ0FDRSxLQUFLRixNQURQLEVBRUUsS0FBS2d1QixJQUZQLEVBR0UsS0FIRixFQUdTO0FBQ1AsVUFKRixDQUlPO0FBSlA7O0FBTUEsV0FBS2h1QixNQUFMLEdBQWMsS0FBS2d1QixJQUFuQjtBQUNELEtBdkRtQjtBQXlEcEJNLFdBQU8sRUFBRSxTQUFTQSxPQUFULEdBQW9CO0FBQzNCLFVBQUl2aEMsUUFBUSxHQUFHLEtBQUs4Z0MsWUFBcEI7QUFDQSxVQUFJRixTQUFTLEdBQUcsS0FBS0EsU0FBTCxJQUFtQixDQUFDLEtBQUszaUMsSUFBTCxJQUFhLEdBQWQsSUFBcUIsT0FBeEQ7O0FBQ0EsVUFBSSxDQUFDK0IsUUFBUSxDQUFDbE0sTUFBVixJQUFvQixDQUFDLEtBQUswdEMsT0FBTCxDQUFheGhDLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWUUsR0FBekIsRUFBOEIwZ0MsU0FBOUIsQ0FBekIsRUFBbUU7QUFDakU7QUFDRCxPQUwwQixDQU8zQjtBQUNBOzs7QUFDQTVnQyxjQUFRLENBQUNnQyxPQUFULENBQWlCeS9CLGNBQWpCO0FBQ0F6aEMsY0FBUSxDQUFDZ0MsT0FBVCxDQUFpQjAvQixjQUFqQjtBQUNBMWhDLGNBQVEsQ0FBQ2dDLE9BQVQsQ0FBaUIyL0IsZ0JBQWpCLEVBWDJCLENBYTNCO0FBQ0E7QUFDQTs7QUFDQSxXQUFLQyxPQUFMLEdBQWUvYSxRQUFRLENBQUNnYixJQUFULENBQWNDLFlBQTdCO0FBRUE5aEMsY0FBUSxDQUFDZ0MsT0FBVCxDQUFpQixVQUFVNU0sQ0FBVixFQUFhO0FBQzVCLFlBQUlBLENBQUMsQ0FBQzJLLElBQUYsQ0FBT2dpQyxLQUFYLEVBQWtCO0FBQ2hCLGNBQUlwOUIsRUFBRSxHQUFHdlAsQ0FBQyxDQUFDOEssR0FBWDtBQUNBLGNBQUlvN0IsQ0FBQyxHQUFHMzJCLEVBQUUsQ0FBQzhiLEtBQVg7QUFDQXVaLDRCQUFrQixDQUFDcjFCLEVBQUQsRUFBS2k4QixTQUFMLENBQWxCO0FBQ0F0RixXQUFDLENBQUMwRyxTQUFGLEdBQWMxRyxDQUFDLENBQUMyRyxlQUFGLEdBQW9CM0csQ0FBQyxDQUFDNEcsa0JBQUYsR0FBdUIsRUFBekQ7QUFDQXY5QixZQUFFLENBQUMvSSxnQkFBSCxDQUFvQjA5QixrQkFBcEIsRUFBd0MzMEIsRUFBRSxDQUFDdzlCLE9BQUgsR0FBYSxTQUFTbjNCLEVBQVQsQ0FBYS9TLENBQWIsRUFBZ0I7QUFDbkUsZ0JBQUksQ0FBQ0EsQ0FBRCxJQUFNLGFBQWFvQyxJQUFiLENBQWtCcEMsQ0FBQyxDQUFDbXFDLFlBQXBCLENBQVYsRUFBNkM7QUFDM0N6OUIsZ0JBQUUsQ0FBQ3NyQixtQkFBSCxDQUF1QnFKLGtCQUF2QixFQUEyQ3R1QixFQUEzQztBQUNBckcsZ0JBQUUsQ0FBQ3c5QixPQUFILEdBQWEsSUFBYjtBQUNBakksbUNBQXFCLENBQUN2MUIsRUFBRCxFQUFLaThCLFNBQUwsQ0FBckI7QUFDRDtBQUNGLFdBTkQ7QUFPRDtBQUNGLE9BZEQ7QUFlRCxLQTFGbUI7QUE0RnBCNTZCLFdBQU8sRUFBRTtBQUNQdzdCLGFBQU8sRUFBRSxTQUFTQSxPQUFULENBQWtCNzhCLEVBQWxCLEVBQXNCaThCLFNBQXRCLEVBQWlDO0FBQ3hDO0FBQ0EsWUFBSSxDQUFDMUgsYUFBTCxFQUFvQjtBQUNsQixpQkFBTyxLQUFQO0FBQ0Q7QUFDRDs7O0FBQ0EsWUFBSSxLQUFLbUosUUFBVCxFQUFtQjtBQUNqQixpQkFBTyxLQUFLQSxRQUFaO0FBQ0QsU0FSdUMsQ0FTeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsWUFBSTlqQixLQUFLLEdBQUc1WixFQUFFLENBQUMyOUIsU0FBSCxFQUFaOztBQUNBLFlBQUkzOUIsRUFBRSxDQUFDMnJCLGtCQUFQLEVBQTJCO0FBQ3pCM3JCLFlBQUUsQ0FBQzJyQixrQkFBSCxDQUFzQnR1QixPQUF0QixDQUE4QixVQUFVb3VCLEdBQVYsRUFBZTtBQUFFbUksdUJBQVcsQ0FBQ2hhLEtBQUQsRUFBUTZSLEdBQVIsQ0FBWDtBQUEwQixXQUF6RTtBQUNEOztBQUNEZ0ksZ0JBQVEsQ0FBQzdaLEtBQUQsRUFBUXFpQixTQUFSLENBQVI7QUFDQXJpQixhQUFLLENBQUNrQyxLQUFOLENBQVlpZixPQUFaLEdBQXNCLE1BQXRCO0FBQ0EsYUFBSzNzQixHQUFMLENBQVNpVixXQUFULENBQXFCekosS0FBckI7QUFDQSxZQUFJclYsSUFBSSxHQUFHa3hCLGlCQUFpQixDQUFDN2IsS0FBRCxDQUE1QjtBQUNBLGFBQUt4TCxHQUFMLENBQVNnVixXQUFULENBQXFCeEosS0FBckI7QUFDQSxlQUFRLEtBQUs4akIsUUFBTCxHQUFnQm41QixJQUFJLENBQUNneUIsWUFBN0I7QUFDRDtBQXpCTTtBQTVGVyxHQUF0Qjs7QUF5SEEsV0FBU3VHLGNBQVQsQ0FBeUJyc0MsQ0FBekIsRUFBNEI7QUFDMUI7QUFDQSxRQUFJQSxDQUFDLENBQUM4SyxHQUFGLENBQU1paUMsT0FBVixFQUFtQjtBQUNqQi9zQyxPQUFDLENBQUM4SyxHQUFGLENBQU1paUMsT0FBTjtBQUNEO0FBQ0Q7OztBQUNBLFFBQUkvc0MsQ0FBQyxDQUFDOEssR0FBRixDQUFNdzdCLFFBQVYsRUFBb0I7QUFDbEJ0bUMsT0FBQyxDQUFDOEssR0FBRixDQUFNdzdCLFFBQU47QUFDRDtBQUNGOztBQUVELFdBQVNnRyxjQUFULENBQXlCdHNDLENBQXpCLEVBQTRCO0FBQzFCQSxLQUFDLENBQUMySyxJQUFGLENBQU93aUMsTUFBUCxHQUFnQm50QyxDQUFDLENBQUM4SyxHQUFGLENBQU1taEMscUJBQU4sRUFBaEI7QUFDRDs7QUFFRCxXQUFTTSxnQkFBVCxDQUEyQnZzQyxDQUEzQixFQUE4QjtBQUM1QixRQUFJb3RDLE1BQU0sR0FBR3B0QyxDQUFDLENBQUMySyxJQUFGLENBQU9xaEMsR0FBcEI7QUFDQSxRQUFJbUIsTUFBTSxHQUFHbnRDLENBQUMsQ0FBQzJLLElBQUYsQ0FBT3dpQyxNQUFwQjtBQUNBLFFBQUlFLEVBQUUsR0FBR0QsTUFBTSxDQUFDRSxJQUFQLEdBQWNILE1BQU0sQ0FBQ0csSUFBOUI7QUFDQSxRQUFJQyxFQUFFLEdBQUdILE1BQU0sQ0FBQ0ksR0FBUCxHQUFhTCxNQUFNLENBQUNLLEdBQTdCOztBQUNBLFFBQUlILEVBQUUsSUFBSUUsRUFBVixFQUFjO0FBQ1p2dEMsT0FBQyxDQUFDMkssSUFBRixDQUFPZ2lDLEtBQVAsR0FBZSxJQUFmO0FBQ0EsVUFBSXpHLENBQUMsR0FBR2xtQyxDQUFDLENBQUM4SyxHQUFGLENBQU11Z0IsS0FBZDtBQUNBNmEsT0FBQyxDQUFDMEcsU0FBRixHQUFjMUcsQ0FBQyxDQUFDMkcsZUFBRixHQUFvQixlQUFlUSxFQUFmLEdBQW9CLEtBQXBCLEdBQTRCRSxFQUE1QixHQUFpQyxLQUFuRTtBQUNBckgsT0FBQyxDQUFDNEcsa0JBQUYsR0FBdUIsSUFBdkI7QUFDRDtBQUNGOztBQUVELE1BQUlXLGtCQUFrQixHQUFHO0FBQ3ZCckMsY0FBVSxFQUFFQSxVQURXO0FBRXZCSyxtQkFBZSxFQUFFQTtBQUduQjtBQUVBOztBQVB5QixHQUF6QjtBQVFBNXZCLEtBQUcsQ0FBQ3ZZLE1BQUosQ0FBV2UsV0FBWCxHQUF5QkEsV0FBekI7QUFDQXdYLEtBQUcsQ0FBQ3ZZLE1BQUosQ0FBV1UsYUFBWCxHQUEyQkEsYUFBM0I7QUFDQTZYLEtBQUcsQ0FBQ3ZZLE1BQUosQ0FBV1csY0FBWCxHQUE0QkEsY0FBNUI7QUFDQTRYLEtBQUcsQ0FBQ3ZZLE1BQUosQ0FBV2EsZUFBWCxHQUE2QkEsZUFBN0I7QUFDQTBYLEtBQUcsQ0FBQ3ZZLE1BQUosQ0FBV1ksZ0JBQVgsR0FBOEJBLGdCQUE5QixDQXR6UXFCLENBd3pRckI7O0FBQ0E3QyxRQUFNLENBQUN3YSxHQUFHLENBQUNyVCxPQUFKLENBQVlnSixVQUFiLEVBQXlCZzVCLGtCQUF6QixDQUFOO0FBQ0FucEMsUUFBTSxDQUFDd2EsR0FBRyxDQUFDclQsT0FBSixDQUFZeUksVUFBYixFQUF5Qnc4QixrQkFBekIsQ0FBTixDQTF6UXFCLENBNHpRckI7O0FBQ0E1eEIsS0FBRyxDQUFDOWUsU0FBSixDQUFjZ2hCLFNBQWQsR0FBMEIzWSxTQUFTLEdBQUdrekIsS0FBSCxHQUFXNTJCLElBQTlDLENBN3pRcUIsQ0ErelFyQjs7QUFDQW1hLEtBQUcsQ0FBQzllLFNBQUosQ0FBYzZzQixNQUFkLEdBQXVCLFVBQ3JCcmEsRUFEcUIsRUFFckJpTyxTQUZxQixFQUdyQjtBQUNBak8sTUFBRSxHQUFHQSxFQUFFLElBQUluSyxTQUFOLEdBQWtCeXNCLEtBQUssQ0FBQ3RpQixFQUFELENBQXZCLEdBQThCalQsU0FBbkM7QUFDQSxXQUFPa2lCLGNBQWMsQ0FBQyxJQUFELEVBQU9qUCxFQUFQLEVBQVdpTyxTQUFYLENBQXJCO0FBQ0QsR0FORCxDQWgwUXFCLENBdzBRckI7O0FBQ0E7OztBQUNBLE1BQUlwWSxTQUFKLEVBQWU7QUFDYmdRLGNBQVUsQ0FBQyxZQUFZO0FBQ3JCLFVBQUk5UixNQUFNLENBQUNJLFFBQVgsRUFBcUI7QUFDbkIsWUFBSUEsUUFBSixFQUFjO0FBQ1pBLGtCQUFRLENBQUN3ZCxJQUFULENBQWMsTUFBZCxFQUFzQnJGLEdBQXRCO0FBQ0QsU0FGRCxNQUVPLElBQ0wsa0JBQWtCLFlBQWxCLElBQ0Esa0JBQWtCLE1BRGxCLElBRUEzVixRQUhLLEVBSUw7QUFDQTZCLGlCQUFPLENBQUNBLE9BQU8sQ0FBQytMLElBQVIsR0FBZSxNQUFmLEdBQXdCLEtBQXpCLENBQVAsQ0FDRSwrRUFDQSx1Q0FGRjtBQUlEO0FBQ0Y7O0FBQ0QsVUFBSSxrQkFBa0IsWUFBbEIsSUFDRixrQkFBa0IsTUFEaEIsSUFFRnhRLE1BQU0sQ0FBQ0csYUFBUCxLQUF5QixLQUZ2QixJQUdGLE9BQU9zRSxPQUFQLEtBQW1CLFdBSHJCLEVBSUU7QUFDQUEsZUFBTyxDQUFDQSxPQUFPLENBQUMrTCxJQUFSLEdBQWUsTUFBZixHQUF3QixLQUF6QixDQUFQLENBQ0UsK0NBQ0EsdUVBREEsR0FFQSwwREFIRjtBQUtEO0FBQ0YsS0ExQlMsRUEwQlAsQ0ExQk8sQ0FBVjtBQTJCRDtBQUVEOzs7QUFFQSxNQUFJNDVCLFlBQVksR0FBRyx1QkFBbkI7QUFDQSxNQUFJQyxhQUFhLEdBQUcsd0JBQXBCO0FBRUEsTUFBSUMsVUFBVSxHQUFHcnVDLE1BQU0sQ0FBQyxVQUFVc3VDLFVBQVYsRUFBc0I7QUFDNUMsUUFBSUMsSUFBSSxHQUFHRCxVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWMvdEMsT0FBZCxDQUFzQjZ0QyxhQUF0QixFQUFxQyxNQUFyQyxDQUFYO0FBQ0EsUUFBSUksS0FBSyxHQUFHRixVQUFVLENBQUMsQ0FBRCxDQUFWLENBQWMvdEMsT0FBZCxDQUFzQjZ0QyxhQUF0QixFQUFxQyxNQUFyQyxDQUFaO0FBQ0EsV0FBTyxJQUFJN2UsTUFBSixDQUFXZ2YsSUFBSSxHQUFHLGVBQVAsR0FBeUJDLEtBQXBDLEVBQTJDLEdBQTNDLENBQVA7QUFDRCxHQUpzQixDQUF2Qjs7QUFRQSxXQUFTQyxTQUFULENBQ0VuakMsSUFERixFQUVFZ2pDLFVBRkYsRUFHRTtBQUNBLFFBQUlJLEtBQUssR0FBR0osVUFBVSxHQUFHRCxVQUFVLENBQUNDLFVBQUQsQ0FBYixHQUE0QkgsWUFBbEQ7O0FBQ0EsUUFBSSxDQUFDTyxLQUFLLENBQUNocEMsSUFBTixDQUFXNEYsSUFBWCxDQUFMLEVBQXVCO0FBQ3JCO0FBQ0Q7O0FBQ0QsUUFBSXFqQyxNQUFNLEdBQUcsRUFBYjtBQUNBLFFBQUlDLFNBQVMsR0FBRyxFQUFoQjtBQUNBLFFBQUkzMEIsU0FBUyxHQUFHeTBCLEtBQUssQ0FBQ3owQixTQUFOLEdBQWtCLENBQWxDO0FBQ0EsUUFBSXZRLEtBQUosRUFBV2hLLEtBQVgsRUFBa0JtdkMsVUFBbEI7O0FBQ0EsV0FBUW5sQyxLQUFLLEdBQUdnbEMsS0FBSyxDQUFDSSxJQUFOLENBQVd4akMsSUFBWCxDQUFoQixFQUFtQztBQUNqQzVMLFdBQUssR0FBR2dLLEtBQUssQ0FBQ2hLLEtBQWQsQ0FEaUMsQ0FFakM7O0FBQ0EsVUFBSUEsS0FBSyxHQUFHdWEsU0FBWixFQUF1QjtBQUNyQjIwQixpQkFBUyxDQUFDNWtDLElBQVYsQ0FBZTZrQyxVQUFVLEdBQUd2akMsSUFBSSxDQUFDMU4sS0FBTCxDQUFXcWMsU0FBWCxFQUFzQnZhLEtBQXRCLENBQTVCO0FBQ0FpdkMsY0FBTSxDQUFDM2tDLElBQVAsQ0FBWXpMLElBQUksQ0FBQ0MsU0FBTCxDQUFlcXdDLFVBQWYsQ0FBWjtBQUNELE9BTmdDLENBT2pDOzs7QUFDQSxVQUFJN1MsR0FBRyxHQUFHRCxZQUFZLENBQUNyeUIsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTaXpCLElBQVQsRUFBRCxDQUF0QjtBQUNBZ1MsWUFBTSxDQUFDM2tDLElBQVAsQ0FBYSxRQUFRZ3lCLEdBQVIsR0FBYyxHQUEzQjtBQUNBNFMsZUFBUyxDQUFDNWtDLElBQVYsQ0FBZTtBQUFFLG9CQUFZZ3lCO0FBQWQsT0FBZjtBQUNBL2hCLGVBQVMsR0FBR3ZhLEtBQUssR0FBR2dLLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU3ZLLE1BQTdCO0FBQ0Q7O0FBQ0QsUUFBSThhLFNBQVMsR0FBRzNPLElBQUksQ0FBQ25NLE1BQXJCLEVBQTZCO0FBQzNCeXZDLGVBQVMsQ0FBQzVrQyxJQUFWLENBQWU2a0MsVUFBVSxHQUFHdmpDLElBQUksQ0FBQzFOLEtBQUwsQ0FBV3FjLFNBQVgsQ0FBNUI7QUFDQTAwQixZQUFNLENBQUMza0MsSUFBUCxDQUFZekwsSUFBSSxDQUFDQyxTQUFMLENBQWVxd0MsVUFBZixDQUFaO0FBQ0Q7O0FBQ0QsV0FBTztBQUNMdnRCLGdCQUFVLEVBQUVxdEIsTUFBTSxDQUFDN3JDLElBQVAsQ0FBWSxHQUFaLENBRFA7QUFFTDZyQyxZQUFNLEVBQUVDO0FBRkgsS0FBUDtBQUlEO0FBRUQ7OztBQUVBLFdBQVNHLGFBQVQsQ0FBd0IvK0IsRUFBeEIsRUFBNEIvRyxPQUE1QixFQUFxQztBQUNuQyxRQUFJZCxJQUFJLEdBQUdjLE9BQU8sQ0FBQ2QsSUFBUixJQUFnQjIwQixRQUEzQjtBQUNBLFFBQUl6TCxXQUFXLEdBQUcrTSxnQkFBZ0IsQ0FBQ3B1QixFQUFELEVBQUssT0FBTCxDQUFsQzs7QUFDQSxRQUFJLGtCQUFrQixZQUFsQixJQUFrQ3FoQixXQUF0QyxFQUFtRDtBQUNqRCxVQUFJbnZCLEdBQUcsR0FBR3VzQyxTQUFTLENBQUNwZCxXQUFELEVBQWNwb0IsT0FBTyxDQUFDcWxDLFVBQXRCLENBQW5COztBQUNBLFVBQUlwc0MsR0FBSixFQUFTO0FBQ1BpRyxZQUFJLENBQ0YsYUFBYWtwQixXQUFiLEdBQTJCLE1BQTNCLEdBQ0Esb0RBREEsR0FFQSwwREFGQSxHQUdBLDZEQUpFLENBQUo7QUFNRDtBQUNGOztBQUNELFFBQUlBLFdBQUosRUFBaUI7QUFDZnJoQixRQUFFLENBQUNxaEIsV0FBSCxHQUFpQjl5QixJQUFJLENBQUNDLFNBQUwsQ0FBZTZ5QixXQUFmLENBQWpCO0FBQ0Q7O0FBQ0QsUUFBSTJkLFlBQVksR0FBRy9RLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssT0FBTCxFQUFjO0FBQU07QUFBcEIsS0FBakM7O0FBQ0EsUUFBSWcvQixZQUFKLEVBQWtCO0FBQ2hCaC9CLFFBQUUsQ0FBQ2cvQixZQUFILEdBQWtCQSxZQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU0MsT0FBVCxDQUFrQmovQixFQUFsQixFQUFzQjtBQUNwQixRQUFJNUUsSUFBSSxHQUFHLEVBQVg7O0FBQ0EsUUFBSTRFLEVBQUUsQ0FBQ3FoQixXQUFQLEVBQW9CO0FBQ2xCam1CLFVBQUksSUFBSSxpQkFBa0I0RSxFQUFFLENBQUNxaEIsV0FBckIsR0FBb0MsR0FBNUM7QUFDRDs7QUFDRCxRQUFJcmhCLEVBQUUsQ0FBQ2cvQixZQUFQLEVBQXFCO0FBQ25CNWpDLFVBQUksSUFBSSxXQUFZNEUsRUFBRSxDQUFDZy9CLFlBQWYsR0FBK0IsR0FBdkM7QUFDRDs7QUFDRCxXQUFPNWpDLElBQVA7QUFDRDs7QUFFRCxNQUFJOGpDLE9BQU8sR0FBRztBQUNacnNDLGNBQVUsRUFBRSxDQUFDLGFBQUQsQ0FEQTtBQUVaa3NDLGlCQUFhLEVBQUVBLGFBRkg7QUFHWkUsV0FBTyxFQUFFQTtBQUdYOztBQU5jLEdBQWQ7O0FBUUEsV0FBU0UsZUFBVCxDQUEwQm4vQixFQUExQixFQUE4Qi9HLE9BQTlCLEVBQXVDO0FBQ3JDLFFBQUlkLElBQUksR0FBR2MsT0FBTyxDQUFDZCxJQUFSLElBQWdCMjBCLFFBQTNCO0FBQ0EsUUFBSXVGLFdBQVcsR0FBR2pFLGdCQUFnQixDQUFDcHVCLEVBQUQsRUFBSyxPQUFMLENBQWxDOztBQUNBLFFBQUlxeUIsV0FBSixFQUFpQjtBQUNmO0FBQ0E7QUFDRSxZQUFJbmdDLEdBQUcsR0FBR3VzQyxTQUFTLENBQUNwTSxXQUFELEVBQWNwNUIsT0FBTyxDQUFDcWxDLFVBQXRCLENBQW5COztBQUNBLFlBQUlwc0MsR0FBSixFQUFTO0FBQ1BpRyxjQUFJLENBQ0YsYUFBYWs2QixXQUFiLEdBQTJCLE1BQTNCLEdBQ0Esb0RBREEsR0FFQSwwREFGQSxHQUdBLDZEQUpFLENBQUo7QUFNRDtBQUNGO0FBQ0RyeUIsUUFBRSxDQUFDcXlCLFdBQUgsR0FBaUI5akMsSUFBSSxDQUFDQyxTQUFMLENBQWV1akMsY0FBYyxDQUFDTSxXQUFELENBQTdCLENBQWpCO0FBQ0Q7O0FBRUQsUUFBSStNLFlBQVksR0FBR25SLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssT0FBTCxFQUFjO0FBQU07QUFBcEIsS0FBakM7O0FBQ0EsUUFBSW8vQixZQUFKLEVBQWtCO0FBQ2hCcC9CLFFBQUUsQ0FBQ28vQixZQUFILEdBQWtCQSxZQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU0MsU0FBVCxDQUFvQnIvQixFQUFwQixFQUF3QjtBQUN0QixRQUFJNUUsSUFBSSxHQUFHLEVBQVg7O0FBQ0EsUUFBSTRFLEVBQUUsQ0FBQ3F5QixXQUFQLEVBQW9CO0FBQ2xCajNCLFVBQUksSUFBSSxpQkFBa0I0RSxFQUFFLENBQUNxeUIsV0FBckIsR0FBb0MsR0FBNUM7QUFDRDs7QUFDRCxRQUFJcnlCLEVBQUUsQ0FBQ28vQixZQUFQLEVBQXFCO0FBQ25CaGtDLFVBQUksSUFBSSxZQUFhNEUsRUFBRSxDQUFDby9CLFlBQWhCLEdBQWdDLElBQXhDO0FBQ0Q7O0FBQ0QsV0FBT2hrQyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSWtrQyxPQUFPLEdBQUc7QUFDWnpzQyxjQUFVLEVBQUUsQ0FBQyxhQUFELENBREE7QUFFWmtzQyxpQkFBYSxFQUFFSSxlQUZIO0FBR1pGLFdBQU8sRUFBRUk7QUFHWDs7QUFOYyxHQUFkO0FBUUEsTUFBSUUsT0FBSjtBQUVBLE1BQUlDLEVBQUUsR0FBRztBQUNQQyxVQUFNLEVBQUUsU0FBU0EsTUFBVCxDQUFpQkMsSUFBakIsRUFBdUI7QUFDN0JILGFBQU8sR0FBR0EsT0FBTyxJQUFJcmQsUUFBUSxDQUFDNUksYUFBVCxDQUF1QixLQUF2QixDQUFyQjtBQUNBaW1CLGFBQU8sQ0FBQzlXLFNBQVIsR0FBb0JpWCxJQUFwQjtBQUNBLGFBQU9ILE9BQU8sQ0FBQy9iLFdBQWY7QUFDRDtBQUdIOztBQVJTLEdBQVQ7QUFVQSxNQUFJbWMsVUFBVSxHQUFHaHhDLE9BQU8sQ0FDdEIsOERBQ0Esa0NBRnNCLENBQXhCLENBNS9RcUIsQ0FpZ1JyQjtBQUNBOztBQUNBLE1BQUlpeEMsZ0JBQWdCLEdBQUdqeEMsT0FBTyxDQUM1Qix5REFENEIsQ0FBOUIsQ0FuZ1JxQixDQXVnUnJCO0FBQ0E7O0FBQ0EsTUFBSWt4QyxnQkFBZ0IsR0FBR2x4QyxPQUFPLENBQzVCLHdFQUNBLGtFQURBLEdBRUEsdUVBRkEsR0FHQSwyRUFIQSxHQUlBLGdCQUw0QixDQUE5QjtBQVFBOzs7O0FBSUE7Ozs7OztBQU9BOztBQUNBLE1BQUlteEMsU0FBUyxHQUFHLDJFQUFoQixDQTdoUnFCLENBOGhSckI7QUFDQTs7QUFDQSxNQUFJQyxNQUFNLEdBQUcsdUJBQWI7QUFDQSxNQUFJQyxZQUFZLEdBQUcsU0FBU0QsTUFBVCxHQUFrQixPQUFsQixHQUE0QkEsTUFBNUIsR0FBcUMsR0FBeEQ7QUFDQSxNQUFJRSxZQUFZLEdBQUcsSUFBSTFnQixNQUFKLENBQVksT0FBT3lnQixZQUFuQixDQUFuQjtBQUNBLE1BQUlFLGFBQWEsR0FBRyxZQUFwQjtBQUNBLE1BQUlyNUIsTUFBTSxHQUFHLElBQUkwWSxNQUFKLENBQVksVUFBVXlnQixZQUFWLEdBQXlCLFFBQXJDLENBQWI7QUFDQSxNQUFJRyxPQUFPLEdBQUcsb0JBQWQsQ0FyaVJxQixDQXNpUnJCOztBQUNBLE1BQUlDLE9BQU8sR0FBRyxRQUFkO0FBQ0EsTUFBSUMsa0JBQWtCLEdBQUcsT0FBekI7QUFFQSxNQUFJQyx5QkFBeUIsR0FBRyxLQUFoQztBQUNBLE1BQUkvdkMsT0FBSixDQUFZLFFBQVosRUFBc0IsVUFBVW9DLENBQVYsRUFBYTR0QyxDQUFiLEVBQWdCO0FBQ3BDRCw2QkFBeUIsR0FBR0MsQ0FBQyxLQUFLLEVBQWxDO0FBQ0QsR0FGRCxFQTNpUnFCLENBK2lSckI7O0FBQ0EsTUFBSUMsa0JBQWtCLEdBQUc3eEMsT0FBTyxDQUFDLHVCQUFELEVBQTBCLElBQTFCLENBQWhDO0FBQ0EsTUFBSTh4QyxPQUFPLEdBQUcsRUFBZDtBQUVBLE1BQUlDLFdBQVcsR0FBRztBQUNoQixZQUFRLEdBRFE7QUFFaEIsWUFBUSxHQUZRO0FBR2hCLGNBQVUsR0FITTtBQUloQixhQUFTLEdBSk87QUFLaEIsYUFBUyxJQUxPO0FBTWhCLFlBQVE7QUFOUSxHQUFsQjtBQVFBLE1BQUlDLFdBQVcsR0FBRyx1QkFBbEI7QUFDQSxNQUFJQyx1QkFBdUIsR0FBRyw4QkFBOUIsQ0E1alJxQixDQThqUnJCOztBQUNBLE1BQUlDLGtCQUFrQixHQUFHbHlDLE9BQU8sQ0FBQyxjQUFELEVBQWlCLElBQWpCLENBQWhDOztBQUNBLE1BQUlteUMsd0JBQXdCLEdBQUcsVUFBVTNsQyxHQUFWLEVBQWV1a0MsSUFBZixFQUFxQjtBQUFFLFdBQU92a0MsR0FBRyxJQUFJMGxDLGtCQUFrQixDQUFDMWxDLEdBQUQsQ0FBekIsSUFBa0N1a0MsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZLElBQXJEO0FBQTRELEdBQWxIOztBQUVBLFdBQVNxQixVQUFULENBQXFCM3pDLEtBQXJCLEVBQTRCNHpDLG9CQUE1QixFQUFrRDtBQUNoRCxRQUFJQyxFQUFFLEdBQUdELG9CQUFvQixHQUFHSix1QkFBSCxHQUE2QkQsV0FBMUQ7QUFDQSxXQUFPdnpDLEtBQUssQ0FBQ21ELE9BQU4sQ0FBYzB3QyxFQUFkLEVBQWtCLFVBQVV2bkMsS0FBVixFQUFpQjtBQUFFLGFBQU9nbkMsV0FBVyxDQUFDaG5DLEtBQUQsQ0FBbEI7QUFBNEIsS0FBakUsQ0FBUDtBQUNEOztBQUVELFdBQVN3bkMsU0FBVCxDQUFvQnhCLElBQXBCLEVBQTBCem1DLE9BQTFCLEVBQW1DO0FBQ2pDLFFBQUlrb0MsS0FBSyxHQUFHLEVBQVo7QUFDQSxRQUFJQyxVQUFVLEdBQUdub0MsT0FBTyxDQUFDbW9DLFVBQXpCO0FBQ0EsUUFBSUMsYUFBYSxHQUFHcG9DLE9BQU8sQ0FBQzBtQyxVQUFSLElBQXNCdHRDLEVBQTFDO0FBQ0EsUUFBSWl2QyxtQkFBbUIsR0FBR3JvQyxPQUFPLENBQUMybUMsZ0JBQVIsSUFBNEJ2dEMsRUFBdEQ7QUFDQSxRQUFJM0MsS0FBSyxHQUFHLENBQVo7QUFDQSxRQUFJcUssSUFBSixFQUFVd25DLE9BQVY7O0FBQ0EsV0FBTzdCLElBQVAsRUFBYTtBQUNYM2xDLFVBQUksR0FBRzJsQyxJQUFQLENBRFcsQ0FFWDs7QUFDQSxVQUFJLENBQUM2QixPQUFELElBQVksQ0FBQ2Ysa0JBQWtCLENBQUNlLE9BQUQsQ0FBbkMsRUFBOEM7QUFDNUMsWUFBSUMsT0FBTyxHQUFHOUIsSUFBSSxDQUFDL3ZDLE9BQUwsQ0FBYSxHQUFiLENBQWQ7O0FBQ0EsWUFBSTZ4QyxPQUFPLEtBQUssQ0FBaEIsRUFBbUI7QUFDakI7QUFDQSxjQUFJcEIsT0FBTyxDQUFDMXFDLElBQVIsQ0FBYWdxQyxJQUFiLENBQUosRUFBd0I7QUFDdEIsZ0JBQUkrQixVQUFVLEdBQUcvQixJQUFJLENBQUMvdkMsT0FBTCxDQUFhLEtBQWIsQ0FBakI7O0FBRUEsZ0JBQUk4eEMsVUFBVSxJQUFJLENBQWxCLEVBQXFCO0FBQ25CLGtCQUFJeG9DLE9BQU8sQ0FBQ3lvQyxpQkFBWixFQUErQjtBQUM3QnpvQyx1QkFBTyxDQUFDbW5DLE9BQVIsQ0FBZ0JWLElBQUksQ0FBQ2lDLFNBQUwsQ0FBZSxDQUFmLEVBQWtCRixVQUFsQixDQUFoQjtBQUNEOztBQUNERyxxQkFBTyxDQUFDSCxVQUFVLEdBQUcsQ0FBZCxDQUFQO0FBQ0E7QUFDRDtBQUNGLFdBWmdCLENBY2pCOzs7QUFDQSxjQUFJcEIsa0JBQWtCLENBQUMzcUMsSUFBbkIsQ0FBd0JncUMsSUFBeEIsQ0FBSixFQUFtQztBQUNqQyxnQkFBSW1DLGNBQWMsR0FBR25DLElBQUksQ0FBQy92QyxPQUFMLENBQWEsSUFBYixDQUFyQjs7QUFFQSxnQkFBSWt5QyxjQUFjLElBQUksQ0FBdEIsRUFBeUI7QUFDdkJELHFCQUFPLENBQUNDLGNBQWMsR0FBRyxDQUFsQixDQUFQO0FBQ0E7QUFDRDtBQUNGLFdBdEJnQixDQXdCakI7OztBQUNBLGNBQUlDLFlBQVksR0FBR3BDLElBQUksQ0FBQ2htQyxLQUFMLENBQVd5bUMsT0FBWCxDQUFuQjs7QUFDQSxjQUFJMkIsWUFBSixFQUFrQjtBQUNoQkYsbUJBQU8sQ0FBQ0UsWUFBWSxDQUFDLENBQUQsQ0FBWixDQUFnQjN5QyxNQUFqQixDQUFQO0FBQ0E7QUFDRCxXQTdCZ0IsQ0ErQmpCOzs7QUFDQSxjQUFJNHlDLFdBQVcsR0FBR3JDLElBQUksQ0FBQ2htQyxLQUFMLENBQVdtTixNQUFYLENBQWxCOztBQUNBLGNBQUlrN0IsV0FBSixFQUFpQjtBQUNmLGdCQUFJQyxRQUFRLEdBQUd0eUMsS0FBZjtBQUNBa3lDLG1CQUFPLENBQUNHLFdBQVcsQ0FBQyxDQUFELENBQVgsQ0FBZTV5QyxNQUFoQixDQUFQO0FBQ0E4eUMsdUJBQVcsQ0FBQ0YsV0FBVyxDQUFDLENBQUQsQ0FBWixFQUFpQkMsUUFBakIsRUFBMkJ0eUMsS0FBM0IsQ0FBWDtBQUNBO0FBQ0QsV0F0Q2dCLENBd0NqQjs7O0FBQ0EsY0FBSXd5QyxhQUFhLEdBQUdDLGFBQWEsRUFBakM7O0FBQ0EsY0FBSUQsYUFBSixFQUFtQjtBQUNqQkUsMEJBQWMsQ0FBQ0YsYUFBRCxDQUFkOztBQUNBLGdCQUFJcEIsd0JBQXdCLENBQUNTLE9BQUQsRUFBVTdCLElBQVYsQ0FBNUIsRUFBNkM7QUFDM0NrQyxxQkFBTyxDQUFDLENBQUQsQ0FBUDtBQUNEOztBQUNEO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJdG1DLElBQUksR0FBSSxLQUFLLENBQWpCO0FBQUEsWUFBcUIrbUMsSUFBSSxHQUFJLEtBQUssQ0FBbEM7QUFBQSxZQUFzQ2pULElBQUksR0FBSSxLQUFLLENBQW5EOztBQUNBLFlBQUlvUyxPQUFPLElBQUksQ0FBZixFQUFrQjtBQUNoQmEsY0FBSSxHQUFHM0MsSUFBSSxDQUFDOXhDLEtBQUwsQ0FBVzR6QyxPQUFYLENBQVA7O0FBQ0EsaUJBQ0UsQ0FBQzM2QixNQUFNLENBQUNuUixJQUFQLENBQVkyc0MsSUFBWixDQUFELElBQ0EsQ0FBQ3BDLFlBQVksQ0FBQ3ZxQyxJQUFiLENBQWtCMnNDLElBQWxCLENBREQsSUFFQSxDQUFDakMsT0FBTyxDQUFDMXFDLElBQVIsQ0FBYTJzQyxJQUFiLENBRkQsSUFHQSxDQUFDaEMsa0JBQWtCLENBQUMzcUMsSUFBbkIsQ0FBd0Iyc0MsSUFBeEIsQ0FKSCxFQUtFO0FBQ0E7QUFDQWpULGdCQUFJLEdBQUdpVCxJQUFJLENBQUMxeUMsT0FBTCxDQUFhLEdBQWIsRUFBa0IsQ0FBbEIsQ0FBUDs7QUFDQSxnQkFBSXkvQixJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQUU7QUFBTzs7QUFDdkJvUyxtQkFBTyxJQUFJcFMsSUFBWDtBQUNBaVQsZ0JBQUksR0FBRzNDLElBQUksQ0FBQzl4QyxLQUFMLENBQVc0ekMsT0FBWCxDQUFQO0FBQ0Q7O0FBQ0RsbUMsY0FBSSxHQUFHb2tDLElBQUksQ0FBQ2lDLFNBQUwsQ0FBZSxDQUFmLEVBQWtCSCxPQUFsQixDQUFQO0FBQ0FJLGlCQUFPLENBQUNKLE9BQUQsQ0FBUDtBQUNEOztBQUVELFlBQUlBLE9BQU8sR0FBRyxDQUFkLEVBQWlCO0FBQ2ZsbUMsY0FBSSxHQUFHb2tDLElBQVA7QUFDQUEsY0FBSSxHQUFHLEVBQVA7QUFDRDs7QUFFRCxZQUFJem1DLE9BQU8sQ0FBQ3FwQyxLQUFSLElBQWlCaG5DLElBQXJCLEVBQTJCO0FBQ3pCckMsaUJBQU8sQ0FBQ3FwQyxLQUFSLENBQWNobkMsSUFBZDtBQUNEO0FBQ0YsT0FoRkQsTUFnRk87QUFDTCxZQUFJaW5DLFlBQVksR0FBRyxDQUFuQjtBQUNBLFlBQUlDLFVBQVUsR0FBR2pCLE9BQU8sQ0FBQ255QyxXQUFSLEVBQWpCO0FBQ0EsWUFBSXF6QyxZQUFZLEdBQUdoQyxPQUFPLENBQUMrQixVQUFELENBQVAsS0FBd0IvQixPQUFPLENBQUMrQixVQUFELENBQVAsR0FBc0IsSUFBSWpqQixNQUFKLENBQVcsb0JBQW9CaWpCLFVBQXBCLEdBQWlDLFNBQTVDLEVBQXVELEdBQXZELENBQTlDLENBQW5CO0FBQ0EsWUFBSUUsTUFBTSxHQUFHaEQsSUFBSSxDQUFDbnZDLE9BQUwsQ0FBYWt5QyxZQUFiLEVBQTJCLFVBQVVFLEdBQVYsRUFBZXJuQyxJQUFmLEVBQXFCdUwsTUFBckIsRUFBNkI7QUFDbkUwN0Isc0JBQVksR0FBRzE3QixNQUFNLENBQUMxWCxNQUF0Qjs7QUFDQSxjQUFJLENBQUNxeEMsa0JBQWtCLENBQUNnQyxVQUFELENBQW5CLElBQW1DQSxVQUFVLEtBQUssVUFBdEQsRUFBa0U7QUFDaEVsbkMsZ0JBQUksR0FBR0EsSUFBSSxDQUNSL0ssT0FESSxDQUNJLHFCQURKLEVBQzJCLElBRDNCLEVBQ2lDO0FBRGpDLGFBRUpBLE9BRkksQ0FFSSwyQkFGSixFQUVpQyxJQUZqQyxDQUFQO0FBR0Q7O0FBQ0QsY0FBSXV3Qyx3QkFBd0IsQ0FBQzBCLFVBQUQsRUFBYWxuQyxJQUFiLENBQTVCLEVBQWdEO0FBQzlDQSxnQkFBSSxHQUFHQSxJQUFJLENBQUMxTixLQUFMLENBQVcsQ0FBWCxDQUFQO0FBQ0Q7O0FBQ0QsY0FBSXFMLE9BQU8sQ0FBQ3FwQyxLQUFaLEVBQW1CO0FBQ2pCcnBDLG1CQUFPLENBQUNxcEMsS0FBUixDQUFjaG5DLElBQWQ7QUFDRDs7QUFDRCxpQkFBTyxFQUFQO0FBQ0QsU0FkWSxDQUFiO0FBZUE1TCxhQUFLLElBQUlnd0MsSUFBSSxDQUFDdndDLE1BQUwsR0FBY3V6QyxNQUFNLENBQUN2ekMsTUFBOUI7QUFDQXV3QyxZQUFJLEdBQUdnRCxNQUFQO0FBQ0FULG1CQUFXLENBQUNPLFVBQUQsRUFBYTl5QyxLQUFLLEdBQUc2eUMsWUFBckIsRUFBbUM3eUMsS0FBbkMsQ0FBWDtBQUNEOztBQUVELFVBQUlnd0MsSUFBSSxLQUFLM2xDLElBQWIsRUFBbUI7QUFDakJkLGVBQU8sQ0FBQ3FwQyxLQUFSLElBQWlCcnBDLE9BQU8sQ0FBQ3FwQyxLQUFSLENBQWM1QyxJQUFkLENBQWpCOztBQUNBLFlBQUksa0JBQWtCLFlBQWxCLElBQWtDLENBQUN5QixLQUFLLENBQUNoeUMsTUFBekMsSUFBbUQ4SixPQUFPLENBQUNkLElBQS9ELEVBQXFFO0FBQ25FYyxpQkFBTyxDQUFDZCxJQUFSLENBQWMsNkNBQTZDdW5DLElBQTdDLEdBQW9ELElBQWxFO0FBQ0Q7O0FBQ0Q7QUFDRDtBQUNGLEtBekhnQyxDQTJIakM7OztBQUNBdUMsZUFBVzs7QUFFWCxhQUFTTCxPQUFULENBQWtCM3pDLENBQWxCLEVBQXFCO0FBQ25CeUIsV0FBSyxJQUFJekIsQ0FBVDtBQUNBeXhDLFVBQUksR0FBR0EsSUFBSSxDQUFDaUMsU0FBTCxDQUFlMXpDLENBQWYsQ0FBUDtBQUNEOztBQUVELGFBQVNrMEMsYUFBVCxHQUEwQjtBQUN4QixVQUFJeHdDLEtBQUssR0FBRyt0QyxJQUFJLENBQUNobUMsS0FBTCxDQUFXdW1DLFlBQVgsQ0FBWjs7QUFDQSxVQUFJdHVDLEtBQUosRUFBVztBQUNULFlBQUkrSCxLQUFLLEdBQUc7QUFDVmdwQixpQkFBTyxFQUFFL3dCLEtBQUssQ0FBQyxDQUFELENBREo7QUFFVjJYLGVBQUssRUFBRSxFQUZHO0FBR1YzWCxlQUFLLEVBQUVqQztBQUhHLFNBQVo7QUFLQWt5QyxlQUFPLENBQUNqd0MsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTeEMsTUFBVixDQUFQO0FBQ0EsWUFBSTY0QixHQUFKLEVBQVN2SCxJQUFUOztBQUNBLGVBQU8sRUFBRXVILEdBQUcsR0FBRzBYLElBQUksQ0FBQ2htQyxLQUFMLENBQVd3bUMsYUFBWCxDQUFSLE1BQXVDemYsSUFBSSxHQUFHaWYsSUFBSSxDQUFDaG1DLEtBQUwsQ0FBV29tQyxTQUFYLENBQTlDLENBQVAsRUFBNkU7QUFDM0U4QixpQkFBTyxDQUFDbmhCLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUXR4QixNQUFULENBQVA7QUFDQXVLLGVBQUssQ0FBQzRQLEtBQU4sQ0FBWXRQLElBQVosQ0FBaUJ5bUIsSUFBakI7QUFDRDs7QUFDRCxZQUFJdUgsR0FBSixFQUFTO0FBQ1B0dUIsZUFBSyxDQUFDa3BDLFVBQU4sR0FBbUI1YSxHQUFHLENBQUMsQ0FBRCxDQUF0QjtBQUNBNFosaUJBQU8sQ0FBQzVaLEdBQUcsQ0FBQyxDQUFELENBQUgsQ0FBTzc0QixNQUFSLENBQVA7QUFDQXVLLGVBQUssQ0FBQ3N1QixHQUFOLEdBQVl0NEIsS0FBWjtBQUNBLGlCQUFPZ0ssS0FBUDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxhQUFTMG9DLGNBQVQsQ0FBeUIxb0MsS0FBekIsRUFBZ0M7QUFDOUIsVUFBSWdwQixPQUFPLEdBQUdocEIsS0FBSyxDQUFDZ3BCLE9BQXBCO0FBQ0EsVUFBSWtnQixVQUFVLEdBQUdscEMsS0FBSyxDQUFDa3BDLFVBQXZCOztBQUVBLFVBQUl4QixVQUFKLEVBQWdCO0FBQ2QsWUFBSUcsT0FBTyxLQUFLLEdBQVosSUFBbUIxQixnQkFBZ0IsQ0FBQ25kLE9BQUQsQ0FBdkMsRUFBa0Q7QUFDaER1ZixxQkFBVyxDQUFDVixPQUFELENBQVg7QUFDRDs7QUFDRCxZQUFJRCxtQkFBbUIsQ0FBQzVlLE9BQUQsQ0FBbkIsSUFBZ0M2ZSxPQUFPLEtBQUs3ZSxPQUFoRCxFQUF5RDtBQUN2RHVmLHFCQUFXLENBQUN2ZixPQUFELENBQVg7QUFDRDtBQUNGOztBQUVELFVBQUltZ0IsS0FBSyxHQUFHeEIsYUFBYSxDQUFDM2UsT0FBRCxDQUFiLElBQTBCLENBQUMsQ0FBQ2tnQixVQUF4QztBQUVBLFVBQUl6eEMsQ0FBQyxHQUFHdUksS0FBSyxDQUFDNFAsS0FBTixDQUFZbmEsTUFBcEI7QUFDQSxVQUFJbWEsS0FBSyxHQUFHLElBQUl6WCxLQUFKLENBQVVWLENBQVYsQ0FBWjs7QUFDQSxXQUFLLElBQUlqQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaUMsQ0FBcEIsRUFBdUJqQyxDQUFDLEVBQXhCLEVBQTRCO0FBQzFCLFlBQUl1TyxJQUFJLEdBQUcvRCxLQUFLLENBQUM0UCxLQUFOLENBQVlwYSxDQUFaLENBQVgsQ0FEMEIsQ0FFMUI7O0FBQ0EsWUFBSW94Qyx5QkFBeUIsSUFBSTdpQyxJQUFJLENBQUMsQ0FBRCxDQUFKLENBQVE5TixPQUFSLENBQWdCLElBQWhCLE1BQTBCLENBQUMsQ0FBNUQsRUFBK0Q7QUFDN0QsY0FBSThOLElBQUksQ0FBQyxDQUFELENBQUosS0FBWSxFQUFoQixFQUFvQjtBQUFFLG1CQUFPQSxJQUFJLENBQUMsQ0FBRCxDQUFYO0FBQWlCOztBQUN2QyxjQUFJQSxJQUFJLENBQUMsQ0FBRCxDQUFKLEtBQVksRUFBaEIsRUFBb0I7QUFBRSxtQkFBT0EsSUFBSSxDQUFDLENBQUQsQ0FBWDtBQUFpQjs7QUFDdkMsY0FBSUEsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZLEVBQWhCLEVBQW9CO0FBQUUsbUJBQU9BLElBQUksQ0FBQyxDQUFELENBQVg7QUFBaUI7QUFDeEM7O0FBQ0QsWUFBSXJRLEtBQUssR0FBR3FRLElBQUksQ0FBQyxDQUFELENBQUosSUFBV0EsSUFBSSxDQUFDLENBQUQsQ0FBZixJQUFzQkEsSUFBSSxDQUFDLENBQUQsQ0FBMUIsSUFBaUMsRUFBN0M7QUFDQSxZQUFJdWpDLG9CQUFvQixHQUFHdGUsT0FBTyxLQUFLLEdBQVosSUFBbUJqbEIsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZLE1BQS9CLEdBQ3ZCeEUsT0FBTyxDQUFDNnBDLDJCQURlLEdBRXZCN3BDLE9BQU8sQ0FBQytuQyxvQkFGWjtBQUdBMTNCLGFBQUssQ0FBQ3BhLENBQUQsQ0FBTCxHQUFXO0FBQ1RvSyxjQUFJLEVBQUVtRSxJQUFJLENBQUMsQ0FBRCxDQUREO0FBRVRyUSxlQUFLLEVBQUUyekMsVUFBVSxDQUFDM3pDLEtBQUQsRUFBUTR6QyxvQkFBUjtBQUZSLFNBQVg7QUFJRDs7QUFFRCxVQUFJLENBQUM2QixLQUFMLEVBQVk7QUFDVjFCLGFBQUssQ0FBQ25uQyxJQUFOLENBQVc7QUFBRW1CLGFBQUcsRUFBRXVuQixPQUFQO0FBQWdCcWdCLHVCQUFhLEVBQUVyZ0IsT0FBTyxDQUFDdHpCLFdBQVIsRUFBL0I7QUFBc0RrYSxlQUFLLEVBQUVBO0FBQTdELFNBQVg7QUFDQWk0QixlQUFPLEdBQUc3ZSxPQUFWO0FBQ0Q7O0FBRUQsVUFBSXpwQixPQUFPLENBQUN0SCxLQUFaLEVBQW1CO0FBQ2pCc0gsZUFBTyxDQUFDdEgsS0FBUixDQUFjK3dCLE9BQWQsRUFBdUJwWixLQUF2QixFQUE4QnU1QixLQUE5QixFQUFxQ25wQyxLQUFLLENBQUMvSCxLQUEzQyxFQUFrRCtILEtBQUssQ0FBQ3N1QixHQUF4RDtBQUNEO0FBQ0Y7O0FBRUQsYUFBU2lhLFdBQVQsQ0FBc0J2ZixPQUF0QixFQUErQi93QixLQUEvQixFQUFzQ3EyQixHQUF0QyxFQUEyQztBQUN6QyxVQUFJeVUsR0FBSixFQUFTdUcsaUJBQVQ7O0FBQ0EsVUFBSXJ4QyxLQUFLLElBQUksSUFBYixFQUFtQjtBQUFFQSxhQUFLLEdBQUdqQyxLQUFSO0FBQWdCOztBQUNyQyxVQUFJczRCLEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQUVBLFdBQUcsR0FBR3Q0QixLQUFOO0FBQWM7O0FBRWpDLFVBQUlnekIsT0FBSixFQUFhO0FBQ1hzZ0IseUJBQWlCLEdBQUd0Z0IsT0FBTyxDQUFDdHpCLFdBQVIsRUFBcEI7QUFDRCxPQVB3QyxDQVN6Qzs7O0FBQ0EsVUFBSXN6QixPQUFKLEVBQWE7QUFDWCxhQUFLK1osR0FBRyxHQUFHMEUsS0FBSyxDQUFDaHlDLE1BQU4sR0FBZSxDQUExQixFQUE2QnN0QyxHQUFHLElBQUksQ0FBcEMsRUFBdUNBLEdBQUcsRUFBMUMsRUFBOEM7QUFDNUMsY0FBSTBFLEtBQUssQ0FBQzFFLEdBQUQsQ0FBTCxDQUFXc0csYUFBWCxLQUE2QkMsaUJBQWpDLEVBQW9EO0FBQ2xEO0FBQ0Q7QUFDRjtBQUNGLE9BTkQsTUFNTztBQUNMO0FBQ0F2RyxXQUFHLEdBQUcsQ0FBTjtBQUNEOztBQUVELFVBQUlBLEdBQUcsSUFBSSxDQUFYLEVBQWM7QUFDWjtBQUNBLGFBQUssSUFBSXZ0QyxDQUFDLEdBQUdpeUMsS0FBSyxDQUFDaHlDLE1BQU4sR0FBZSxDQUE1QixFQUErQkQsQ0FBQyxJQUFJdXRDLEdBQXBDLEVBQXlDdnRDLENBQUMsRUFBMUMsRUFBOEM7QUFDNUMsY0FBSSxrQkFBa0IsWUFBbEIsS0FDREEsQ0FBQyxHQUFHdXRDLEdBQUosSUFBVyxDQUFDL1osT0FEWCxLQUVGenBCLE9BQU8sQ0FBQ2QsSUFGVixFQUdFO0FBQ0FjLG1CQUFPLENBQUNkLElBQVIsQ0FDRyxVQUFXZ3BDLEtBQUssQ0FBQ2p5QyxDQUFELENBQUwsQ0FBU2lNLEdBQXBCLEdBQTJCLDRCQUQ5QjtBQUdEOztBQUNELGNBQUlsQyxPQUFPLENBQUMrdUIsR0FBWixFQUFpQjtBQUNmL3VCLG1CQUFPLENBQUMrdUIsR0FBUixDQUFZbVosS0FBSyxDQUFDanlDLENBQUQsQ0FBTCxDQUFTaU0sR0FBckIsRUFBMEJ4SixLQUExQixFQUFpQ3EyQixHQUFqQztBQUNEO0FBQ0YsU0FkVyxDQWdCWjs7O0FBQ0FtWixhQUFLLENBQUNoeUMsTUFBTixHQUFlc3RDLEdBQWY7QUFDQThFLGVBQU8sR0FBRzlFLEdBQUcsSUFBSTBFLEtBQUssQ0FBQzFFLEdBQUcsR0FBRyxDQUFQLENBQUwsQ0FBZXRoQyxHQUFoQztBQUNELE9BbkJELE1BbUJPLElBQUk2bkMsaUJBQWlCLEtBQUssSUFBMUIsRUFBZ0M7QUFDckMsWUFBSS9wQyxPQUFPLENBQUN0SCxLQUFaLEVBQW1CO0FBQ2pCc0gsaUJBQU8sQ0FBQ3RILEtBQVIsQ0FBYyt3QixPQUFkLEVBQXVCLEVBQXZCLEVBQTJCLElBQTNCLEVBQWlDL3dCLEtBQWpDLEVBQXdDcTJCLEdBQXhDO0FBQ0Q7QUFDRixPQUpNLE1BSUEsSUFBSWdiLGlCQUFpQixLQUFLLEdBQTFCLEVBQStCO0FBQ3BDLFlBQUkvcEMsT0FBTyxDQUFDdEgsS0FBWixFQUFtQjtBQUNqQnNILGlCQUFPLENBQUN0SCxLQUFSLENBQWMrd0IsT0FBZCxFQUF1QixFQUF2QixFQUEyQixLQUEzQixFQUFrQy93QixLQUFsQyxFQUF5Q3EyQixHQUF6QztBQUNEOztBQUNELFlBQUkvdUIsT0FBTyxDQUFDK3VCLEdBQVosRUFBaUI7QUFDZi91QixpQkFBTyxDQUFDK3VCLEdBQVIsQ0FBWXRGLE9BQVosRUFBcUIvd0IsS0FBckIsRUFBNEJxMkIsR0FBNUI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUVEOzs7QUFFQSxNQUFJaWIsSUFBSSxHQUFHLFdBQVg7QUFDQSxNQUFJQyxLQUFLLEdBQUcsV0FBWjtBQUNBLE1BQUlDLFVBQVUsR0FBRyw4QkFBakI7QUFDQSxNQUFJQyxhQUFhLEdBQUcsZ0NBQXBCO0FBQ0EsTUFBSUMsYUFBYSxHQUFHLFVBQXBCO0FBRUEsTUFBSUMsS0FBSyxHQUFHLFFBQVo7QUFDQSxNQUFJQyxNQUFNLEdBQUcsYUFBYjtBQUNBLE1BQUlDLFVBQVUsR0FBRyxVQUFqQjtBQUVBLE1BQUlDLGdCQUFnQixHQUFHenpDLE1BQU0sQ0FBQ3d2QyxFQUFFLENBQUNDLE1BQUosQ0FBN0IsQ0FqMVJxQixDQW0xUnJCOztBQUNBLE1BQUlpRSxNQUFKO0FBQ0EsTUFBSXBGLFVBQUo7QUFDQSxNQUFJcUYsVUFBSjtBQUNBLE1BQUlDLGFBQUo7QUFDQSxNQUFJQyxjQUFKO0FBQ0EsTUFBSUMsZ0JBQUo7QUFDQSxNQUFJQyxtQkFBSjtBQUNBLE1BQUlDLHVCQUFKOztBQUlBLFdBQVNDLGdCQUFULENBQ0U5b0MsR0FERixFQUVFbU8sS0FGRixFQUdFdE4sTUFIRixFQUlFO0FBQ0EsV0FBTztBQUNMa0YsVUFBSSxFQUFFLENBREQ7QUFFTC9GLFNBQUcsRUFBRUEsR0FGQTtBQUdMa3lCLGVBQVMsRUFBRS9qQixLQUhOO0FBSUw4akIsY0FBUSxFQUFFOFcsWUFBWSxDQUFDNTZCLEtBQUQsQ0FKakI7QUFLTHROLFlBQU0sRUFBRUEsTUFMSDtBQU1MWCxjQUFRLEVBQUU7QUFOTCxLQUFQO0FBUUQ7QUFFRDs7Ozs7QUFHQSxXQUFTOG9DLEtBQVQsQ0FDRWoxQixRQURGLEVBRUVqVyxPQUZGLEVBR0U7QUFDQXlxQyxVQUFNLEdBQUd6cUMsT0FBTyxDQUFDZCxJQUFSLElBQWdCMjBCLFFBQXpCO0FBRUFnWCxvQkFBZ0IsR0FBRzdxQyxPQUFPLENBQUMrb0IsUUFBUixJQUFvQjN2QixFQUF2QztBQUNBMHhDLHVCQUFtQixHQUFHOXFDLE9BQU8sQ0FBQ25FLFdBQVIsSUFBdUJ6QyxFQUE3QztBQUNBMnhDLDJCQUF1QixHQUFHL3FDLE9BQU8sQ0FBQ3JFLGVBQVIsSUFBMkJ2QyxFQUFyRDtBQUVBc3hDLGNBQVUsR0FBRzVXLG1CQUFtQixDQUFDOXpCLE9BQU8sQ0FBQ3pHLE9BQVQsRUFBa0IsZUFBbEIsQ0FBaEM7QUFDQW94QyxpQkFBYSxHQUFHN1csbUJBQW1CLENBQUM5ekIsT0FBTyxDQUFDekcsT0FBVCxFQUFrQixrQkFBbEIsQ0FBbkM7QUFDQXF4QyxrQkFBYyxHQUFHOVcsbUJBQW1CLENBQUM5ekIsT0FBTyxDQUFDekcsT0FBVCxFQUFrQixtQkFBbEIsQ0FBcEM7QUFFQThyQyxjQUFVLEdBQUdybEMsT0FBTyxDQUFDcWxDLFVBQXJCO0FBRUEsUUFBSTZDLEtBQUssR0FBRyxFQUFaO0FBQ0EsUUFBSWlELGtCQUFrQixHQUFHbnJDLE9BQU8sQ0FBQ21yQyxrQkFBUixLQUErQixLQUF4RDtBQUNBLFFBQUlDLElBQUo7QUFDQSxRQUFJQyxhQUFKO0FBQ0EsUUFBSXZmLE1BQU0sR0FBRyxLQUFiO0FBQ0EsUUFBSXdmLEtBQUssR0FBRyxLQUFaO0FBQ0EsUUFBSUMsTUFBTSxHQUFHLEtBQWI7O0FBRUEsYUFBU0MsUUFBVCxDQUFtQjlyQyxHQUFuQixFQUF3QjtBQUN0QixVQUFJLENBQUM2ckMsTUFBTCxFQUFhO0FBQ1hBLGNBQU0sR0FBRyxJQUFUO0FBQ0FkLGNBQU0sQ0FBQy9xQyxHQUFELENBQU47QUFDRDtBQUNGOztBQUVELGFBQVMrckMsWUFBVCxDQUF1QkMsT0FBdkIsRUFBZ0M7QUFDOUI7QUFDQSxVQUFJQSxPQUFPLENBQUNwZixHQUFaLEVBQWlCO0FBQ2ZSLGNBQU0sR0FBRyxLQUFUO0FBQ0Q7O0FBQ0QsVUFBSStlLGdCQUFnQixDQUFDYSxPQUFPLENBQUN4cEMsR0FBVCxDQUFwQixFQUFtQztBQUNqQ29wQyxhQUFLLEdBQUcsS0FBUjtBQUNELE9BUDZCLENBUTlCOzs7QUFDQSxXQUFLLElBQUlyMUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzIwQyxjQUFjLENBQUMxMEMsTUFBbkMsRUFBMkNELENBQUMsRUFBNUMsRUFBZ0Q7QUFDOUMyMEMsc0JBQWMsQ0FBQzMwQyxDQUFELENBQWQsQ0FBa0J5MUMsT0FBbEIsRUFBMkIxckMsT0FBM0I7QUFDRDtBQUNGOztBQUVEaW9DLGFBQVMsQ0FBQ2h5QixRQUFELEVBQVc7QUFDbEIvVyxVQUFJLEVBQUV1ckMsTUFEWTtBQUVsQnRDLGdCQUFVLEVBQUVub0MsT0FBTyxDQUFDbW9DLFVBRkY7QUFHbEJ6QixnQkFBVSxFQUFFMW1DLE9BQU8sQ0FBQzBtQyxVQUhGO0FBSWxCQyxzQkFBZ0IsRUFBRTNtQyxPQUFPLENBQUMybUMsZ0JBSlI7QUFLbEJvQiwwQkFBb0IsRUFBRS9uQyxPQUFPLENBQUMrbkMsb0JBTFo7QUFNbEI4QixpQ0FBMkIsRUFBRTdwQyxPQUFPLENBQUM2cEMsMkJBTm5CO0FBT2xCcEIsdUJBQWlCLEVBQUV6b0MsT0FBTyxDQUFDMnJDLFFBUFQ7QUFRbEJqekMsV0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZ0J3SixHQUFoQixFQUFxQm1PLEtBQXJCLEVBQTRCdTVCLEtBQTVCLEVBQW1DO0FBQ3hDO0FBQ0E7QUFDQSxZQUFJbG5DLEVBQUUsR0FBSTJvQyxhQUFhLElBQUlBLGFBQWEsQ0FBQzNvQyxFQUFoQyxJQUF1Q3FvQyx1QkFBdUIsQ0FBQzdvQyxHQUFELENBQXZFLENBSHdDLENBS3hDOztBQUNBOztBQUNBLFlBQUk3RSxJQUFJLElBQUlxRixFQUFFLEtBQUssS0FBbkIsRUFBMEI7QUFDeEIyTixlQUFLLEdBQUd1N0IsYUFBYSxDQUFDdjdCLEtBQUQsQ0FBckI7QUFDRDs7QUFFRCxZQUFJcTdCLE9BQU8sR0FBR1YsZ0JBQWdCLENBQUM5b0MsR0FBRCxFQUFNbU8sS0FBTixFQUFhZzdCLGFBQWIsQ0FBOUI7O0FBQ0EsWUFBSTNvQyxFQUFKLEVBQVE7QUFDTmdwQyxpQkFBTyxDQUFDaHBDLEVBQVIsR0FBYUEsRUFBYjtBQUNEOztBQUVELFlBQUltcEMsY0FBYyxDQUFDSCxPQUFELENBQWQsSUFBMkIsQ0FBQ3h0QyxpQkFBaUIsRUFBakQsRUFBcUQ7QUFDbkR3dEMsaUJBQU8sQ0FBQ0ksU0FBUixHQUFvQixJQUFwQjtBQUNBLDRCQUFrQixZQUFsQixJQUFrQ3JCLE1BQU0sQ0FDdEMsdUVBQ0Esc0VBREEsR0FFQSxHQUZBLEdBRU12b0MsR0FGTixHQUVZLEdBRlosR0FFa0IsK0JBSG9CLENBQXhDO0FBS0QsU0F2QnVDLENBeUJ4Qzs7O0FBQ0EsYUFBSyxJQUFJak0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzAwQyxhQUFhLENBQUN6MEMsTUFBbEMsRUFBMENELENBQUMsRUFBM0MsRUFBK0M7QUFDN0N5MUMsaUJBQU8sR0FBR2YsYUFBYSxDQUFDMTBDLENBQUQsQ0FBYixDQUFpQnkxQyxPQUFqQixFQUEwQjFyQyxPQUExQixLQUFzQzByQyxPQUFoRDtBQUNEOztBQUVELFlBQUksQ0FBQzVmLE1BQUwsRUFBYTtBQUNYaWdCLG9CQUFVLENBQUNMLE9BQUQsQ0FBVjs7QUFDQSxjQUFJQSxPQUFPLENBQUNwZixHQUFaLEVBQWlCO0FBQ2ZSLGtCQUFNLEdBQUcsSUFBVDtBQUNEO0FBQ0Y7O0FBQ0QsWUFBSStlLGdCQUFnQixDQUFDYSxPQUFPLENBQUN4cEMsR0FBVCxDQUFwQixFQUFtQztBQUNqQ29wQyxlQUFLLEdBQUcsSUFBUjtBQUNEOztBQUNELFlBQUl4ZixNQUFKLEVBQVk7QUFDVmtnQix5QkFBZSxDQUFDTixPQUFELENBQWY7QUFDRCxTQUZELE1BRU8sSUFBSSxDQUFDQSxPQUFPLENBQUNPLFNBQWIsRUFBd0I7QUFDN0I7QUFDQUMsb0JBQVUsQ0FBQ1IsT0FBRCxDQUFWO0FBQ0FTLG1CQUFTLENBQUNULE9BQUQsQ0FBVDtBQUNBVSxxQkFBVyxDQUFDVixPQUFELENBQVgsQ0FKNkIsQ0FLN0I7O0FBQ0FXLHdCQUFjLENBQUNYLE9BQUQsRUFBVTFyQyxPQUFWLENBQWQ7QUFDRDs7QUFFRCxpQkFBU3NzQyxvQkFBVCxDQUErQnZsQyxFQUEvQixFQUFtQztBQUNqQztBQUNFLGdCQUFJQSxFQUFFLENBQUM3RSxHQUFILEtBQVcsTUFBWCxJQUFxQjZFLEVBQUUsQ0FBQzdFLEdBQUgsS0FBVyxVQUFwQyxFQUFnRDtBQUM5Q3NwQyxzQkFBUSxDQUNOLGlCQUFrQnprQyxFQUFFLENBQUM3RSxHQUFyQixHQUE0Qiw2Q0FBNUIsR0FDQSx5QkFGTSxDQUFSO0FBSUQ7O0FBQ0QsZ0JBQUk2RSxFQUFFLENBQUNvdEIsUUFBSCxDQUFZdjlCLGNBQVosQ0FBMkIsT0FBM0IsQ0FBSixFQUF5QztBQUN2QzQwQyxzQkFBUSxDQUNOLGlFQUNBLCtCQUZNLENBQVI7QUFJRDtBQUNGO0FBQ0YsU0FqRXVDLENBbUV4Qzs7O0FBQ0EsWUFBSSxDQUFDSixJQUFMLEVBQVc7QUFDVEEsY0FBSSxHQUFHTSxPQUFQO0FBQ0FZLDhCQUFvQixDQUFDbEIsSUFBRCxDQUFwQjtBQUNELFNBSEQsTUFHTyxJQUFJLENBQUNsRCxLQUFLLENBQUNoeUMsTUFBWCxFQUFtQjtBQUN4QjtBQUNBLGNBQUlrMUMsSUFBSSxDQUFDbUIsRUFBTCxLQUFZYixPQUFPLENBQUNjLE1BQVIsSUFBa0JkLE9BQU8sQ0FBQ2UsSUFBdEMsQ0FBSixFQUFpRDtBQUMvQ0gsZ0NBQW9CLENBQUNaLE9BQUQsQ0FBcEI7QUFDQWdCLDBCQUFjLENBQUN0QixJQUFELEVBQU87QUFDbkJyWSxpQkFBRyxFQUFFMlksT0FBTyxDQUFDYyxNQURNO0FBRW5CRyxtQkFBSyxFQUFFakI7QUFGWSxhQUFQLENBQWQ7QUFJRCxXQU5ELE1BTU87QUFDTEYsb0JBQVEsQ0FDTixpRUFDQSw4Q0FEQSxHQUVBLHNDQUhNLENBQVI7QUFLRDtBQUNGOztBQUNELFlBQUlILGFBQWEsSUFBSSxDQUFDSyxPQUFPLENBQUNJLFNBQTlCLEVBQXlDO0FBQ3ZDLGNBQUlKLE9BQU8sQ0FBQ2MsTUFBUixJQUFrQmQsT0FBTyxDQUFDZSxJQUE5QixFQUFvQztBQUNsQ0csK0JBQW1CLENBQUNsQixPQUFELEVBQVVMLGFBQVYsQ0FBbkI7QUFDRCxXQUZELE1BRU8sSUFBSUssT0FBTyxDQUFDbUIsU0FBWixFQUF1QjtBQUFFO0FBQzlCeEIseUJBQWEsQ0FBQ3JYLEtBQWQsR0FBc0IsS0FBdEI7QUFDQSxnQkFBSTN6QixJQUFJLEdBQUdxckMsT0FBTyxDQUFDb0IsVUFBUixJQUFzQixXQUFqQztBQUE2QyxhQUFDekIsYUFBYSxDQUFDejBCLFdBQWQsS0FBOEJ5MEIsYUFBYSxDQUFDejBCLFdBQWQsR0FBNEIsRUFBMUQsQ0FBRCxFQUFnRXZXLElBQWhFLElBQXdFcXJDLE9BQXhFO0FBQzlDLFdBSE0sTUFHQTtBQUNMTCx5QkFBYSxDQUFDanBDLFFBQWQsQ0FBdUJyQixJQUF2QixDQUE0QjJxQyxPQUE1QjtBQUNBQSxtQkFBTyxDQUFDM29DLE1BQVIsR0FBaUJzb0MsYUFBakI7QUFDRDtBQUNGOztBQUNELFlBQUksQ0FBQ3pCLEtBQUwsRUFBWTtBQUNWeUIsdUJBQWEsR0FBR0ssT0FBaEI7QUFDQXhELGVBQUssQ0FBQ25uQyxJQUFOLENBQVcycUMsT0FBWDtBQUNELFNBSEQsTUFHTztBQUNMRCxzQkFBWSxDQUFDQyxPQUFELENBQVo7QUFDRDtBQUNGLE9BaEhpQjtBQWtIbEIzYyxTQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFnQjtBQUNuQjtBQUNBLFlBQUkyYyxPQUFPLEdBQUd4RCxLQUFLLENBQUNBLEtBQUssQ0FBQ2h5QyxNQUFOLEdBQWUsQ0FBaEIsQ0FBbkI7QUFDQSxZQUFJNjJDLFFBQVEsR0FBR3JCLE9BQU8sQ0FBQ3RwQyxRQUFSLENBQWlCc3BDLE9BQU8sQ0FBQ3RwQyxRQUFSLENBQWlCbE0sTUFBakIsR0FBMEIsQ0FBM0MsQ0FBZjs7QUFDQSxZQUFJNjJDLFFBQVEsSUFBSUEsUUFBUSxDQUFDOWtDLElBQVQsS0FBa0IsQ0FBOUIsSUFBbUM4a0MsUUFBUSxDQUFDMXFDLElBQVQsS0FBa0IsR0FBckQsSUFBNEQsQ0FBQ2lwQyxLQUFqRSxFQUF3RTtBQUN0RUksaUJBQU8sQ0FBQ3RwQyxRQUFSLENBQWlCSixHQUFqQjtBQUNELFNBTmtCLENBT25COzs7QUFDQWttQyxhQUFLLENBQUNoeUMsTUFBTixJQUFnQixDQUFoQjtBQUNBbTFDLHFCQUFhLEdBQUduRCxLQUFLLENBQUNBLEtBQUssQ0FBQ2h5QyxNQUFOLEdBQWUsQ0FBaEIsQ0FBckI7QUFDQXUxQyxvQkFBWSxDQUFDQyxPQUFELENBQVo7QUFDRCxPQTdIaUI7QUErSGxCckMsV0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZ0JobkMsSUFBaEIsRUFBc0I7QUFDM0IsWUFBSSxDQUFDZ3BDLGFBQUwsRUFBb0I7QUFDbEI7QUFDRSxnQkFBSWhwQyxJQUFJLEtBQUs0VCxRQUFiLEVBQXVCO0FBQ3JCdTFCLHNCQUFRLENBQ04sb0VBRE0sQ0FBUjtBQUdELGFBSkQsTUFJTyxJQUFLbnBDLElBQUksR0FBR0EsSUFBSSxDQUFDcXhCLElBQUwsRUFBWixFQUEwQjtBQUMvQjhYLHNCQUFRLENBQ0wsWUFBWW5wQyxJQUFaLEdBQW1CLDBDQURkLENBQVI7QUFHRDtBQUNGO0FBQ0Q7QUFDRCxTQWQwQixDQWUzQjs7QUFDQTs7O0FBQ0EsWUFBSWhGLElBQUksSUFDTmd1QyxhQUFhLENBQUNucEMsR0FBZCxLQUFzQixVQURwQixJQUVGbXBDLGFBQWEsQ0FBQ2xYLFFBQWQsQ0FBdUJtTyxXQUF2QixLQUF1Q2pnQyxJQUZ6QyxFQUdFO0FBQ0E7QUFDRDs7QUFDRCxZQUFJRCxRQUFRLEdBQUdpcEMsYUFBYSxDQUFDanBDLFFBQTdCO0FBQ0FDLFlBQUksR0FBR2lwQyxLQUFLLElBQUlqcEMsSUFBSSxDQUFDcXhCLElBQUwsRUFBVCxHQUNIc1osU0FBUyxDQUFDM0IsYUFBRCxDQUFULEdBQTJCaHBDLElBQTNCLEdBQWtDbW9DLGdCQUFnQixDQUFDbm9DLElBQUQsQ0FEL0MsQ0FFTDtBQUZLLFVBR0g4b0Msa0JBQWtCLElBQUkvb0MsUUFBUSxDQUFDbE0sTUFBL0IsR0FBd0MsR0FBeEMsR0FBOEMsRUFIbEQ7O0FBSUEsWUFBSW1NLElBQUosRUFBVTtBQUNSLGNBQUlwSixHQUFKOztBQUNBLGNBQUksQ0FBQzZ5QixNQUFELElBQVd6cEIsSUFBSSxLQUFLLEdBQXBCLEtBQTRCcEosR0FBRyxHQUFHdXNDLFNBQVMsQ0FBQ25qQyxJQUFELEVBQU9nakMsVUFBUCxDQUEzQyxDQUFKLEVBQW9FO0FBQ2xFampDLG9CQUFRLENBQUNyQixJQUFULENBQWM7QUFDWmtILGtCQUFJLEVBQUUsQ0FETTtBQUVab1Esd0JBQVUsRUFBRXBmLEdBQUcsQ0FBQ29mLFVBRko7QUFHWnF0QixvQkFBTSxFQUFFenNDLEdBQUcsQ0FBQ3lzQyxNQUhBO0FBSVpyakMsa0JBQUksRUFBRUE7QUFKTSxhQUFkO0FBTUQsV0FQRCxNQU9PLElBQUlBLElBQUksS0FBSyxHQUFULElBQWdCLENBQUNELFFBQVEsQ0FBQ2xNLE1BQTFCLElBQW9Da00sUUFBUSxDQUFDQSxRQUFRLENBQUNsTSxNQUFULEdBQWtCLENBQW5CLENBQVIsQ0FBOEJtTSxJQUE5QixLQUF1QyxHQUEvRSxFQUFvRjtBQUN6RkQsb0JBQVEsQ0FBQ3JCLElBQVQsQ0FBYztBQUNaa0gsa0JBQUksRUFBRSxDQURNO0FBRVo1RixrQkFBSSxFQUFFQTtBQUZNLGFBQWQ7QUFJRDtBQUNGO0FBQ0YsT0EzS2lCO0FBNEtsQjhrQyxhQUFPLEVBQUUsU0FBU0EsT0FBVCxDQUFrQjlrQyxJQUFsQixFQUF3QjtBQUMvQmdwQyxxQkFBYSxDQUFDanBDLFFBQWQsQ0FBdUJyQixJQUF2QixDQUE0QjtBQUMxQmtILGNBQUksRUFBRSxDQURvQjtBQUUxQjVGLGNBQUksRUFBRUEsSUFGb0I7QUFHMUJjLG1CQUFTLEVBQUU7QUFIZSxTQUE1QjtBQUtEO0FBbExpQixLQUFYLENBQVQ7QUFvTEEsV0FBT2lvQyxJQUFQO0FBQ0Q7O0FBRUQsV0FBU1csVUFBVCxDQUFxQmhsQyxFQUFyQixFQUF5QjtBQUN2QixRQUFJb3VCLGdCQUFnQixDQUFDcHVCLEVBQUQsRUFBSyxPQUFMLENBQWhCLElBQWlDLElBQXJDLEVBQTJDO0FBQ3pDQSxRQUFFLENBQUN1bEIsR0FBSCxHQUFTLElBQVQ7QUFDRDtBQUNGOztBQUVELFdBQVMwZixlQUFULENBQTBCamxDLEVBQTFCLEVBQThCO0FBQzVCLFFBQUk3TyxDQUFDLEdBQUc2TyxFQUFFLENBQUNxdEIsU0FBSCxDQUFhbCtCLE1BQXJCOztBQUNBLFFBQUlnQyxDQUFKLEVBQU87QUFDTCxVQUFJbVksS0FBSyxHQUFHdEosRUFBRSxDQUFDc0osS0FBSCxHQUFXLElBQUl6WCxLQUFKLENBQVVWLENBQVYsQ0FBdkI7O0FBQ0EsV0FBSyxJQUFJakMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2lDLENBQXBCLEVBQXVCakMsQ0FBQyxFQUF4QixFQUE0QjtBQUMxQm9hLGFBQUssQ0FBQ3BhLENBQUQsQ0FBTCxHQUFXO0FBQ1RvSyxjQUFJLEVBQUUwRyxFQUFFLENBQUNxdEIsU0FBSCxDQUFhbitCLENBQWIsRUFBZ0JvSyxJQURiO0FBRVRsTSxlQUFLLEVBQUVtQixJQUFJLENBQUNDLFNBQUwsQ0FBZXdSLEVBQUUsQ0FBQ3F0QixTQUFILENBQWFuK0IsQ0FBYixFQUFnQjlCLEtBQS9CO0FBRkUsU0FBWDtBQUlEO0FBQ0YsS0FSRCxNQVFPLElBQUksQ0FBQzRTLEVBQUUsQ0FBQ3VsQixHQUFSLEVBQWE7QUFDbEI7QUFDQXZsQixRQUFFLENBQUNpdEIsS0FBSCxHQUFXLElBQVg7QUFDRDtBQUNGOztBQUVELFdBQVNxWSxjQUFULENBQXlCWCxPQUF6QixFQUFrQzFyQyxPQUFsQyxFQUEyQztBQUN6Q2l0QyxjQUFVLENBQUN2QixPQUFELENBQVYsQ0FEeUMsQ0FHekM7QUFDQTs7QUFDQUEsV0FBTyxDQUFDMVgsS0FBUixHQUFnQixDQUFDMFgsT0FBTyxDQUFDNTBDLEdBQVQsSUFBZ0IsQ0FBQzQwQyxPQUFPLENBQUN0WCxTQUFSLENBQWtCbCtCLE1BQW5EO0FBRUFnM0MsY0FBVSxDQUFDeEIsT0FBRCxDQUFWO0FBQ0F5QixlQUFXLENBQUN6QixPQUFELENBQVg7QUFDQTBCLG9CQUFnQixDQUFDMUIsT0FBRCxDQUFoQjs7QUFDQSxTQUFLLElBQUl6MUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3kwQyxVQUFVLENBQUN4MEMsTUFBL0IsRUFBdUNELENBQUMsRUFBeEMsRUFBNEM7QUFDMUN5MUMsYUFBTyxHQUFHaEIsVUFBVSxDQUFDejBDLENBQUQsQ0FBVixDQUFjeTFDLE9BQWQsRUFBdUIxckMsT0FBdkIsS0FBbUMwckMsT0FBN0M7QUFDRDs7QUFDRDJCLGdCQUFZLENBQUMzQixPQUFELENBQVo7QUFDRDs7QUFFRCxXQUFTdUIsVUFBVCxDQUFxQmxtQyxFQUFyQixFQUF5QjtBQUN2QixRQUFJZ3NCLEdBQUcsR0FBR2lDLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssS0FBTCxDQUF4Qjs7QUFDQSxRQUFJZ3NCLEdBQUosRUFBUztBQUNQLFVBQUksa0JBQWtCLFlBQWxCLElBQWtDaHNCLEVBQUUsQ0FBQzdFLEdBQUgsS0FBVyxVQUFqRCxFQUE2RDtBQUMzRHVvQyxjQUFNLENBQUMscUVBQUQsQ0FBTjtBQUNEOztBQUNEMWpDLFFBQUUsQ0FBQ2pRLEdBQUgsR0FBU2k4QixHQUFUO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTbWEsVUFBVCxDQUFxQm5tQyxFQUFyQixFQUF5QjtBQUN2QixRQUFJb2MsR0FBRyxHQUFHNlIsY0FBYyxDQUFDanVCLEVBQUQsRUFBSyxLQUFMLENBQXhCOztBQUNBLFFBQUlvYyxHQUFKLEVBQVM7QUFDUHBjLFFBQUUsQ0FBQ29jLEdBQUgsR0FBU0EsR0FBVDtBQUNBcGMsUUFBRSxDQUFDK2pCLFFBQUgsR0FBY3dpQixVQUFVLENBQUN2bUMsRUFBRCxDQUF4QjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU21sQyxVQUFULENBQXFCbmxDLEVBQXJCLEVBQXlCO0FBQ3ZCLFFBQUlnc0IsR0FBSjs7QUFDQSxRQUFLQSxHQUFHLEdBQUdvQyxnQkFBZ0IsQ0FBQ3B1QixFQUFELEVBQUssT0FBTCxDQUEzQixFQUEyQztBQUN6QyxVQUFJOU4sR0FBRyxHQUFHczBDLFFBQVEsQ0FBQ3hhLEdBQUQsQ0FBbEI7O0FBQ0EsVUFBSTk1QixHQUFKLEVBQVM7QUFDUEosY0FBTSxDQUFDa08sRUFBRCxFQUFLOU4sR0FBTCxDQUFOO0FBQ0QsT0FGRCxNQUVPO0FBQ0x3eEMsY0FBTSxDQUNILCtCQUErQjFYLEdBRDVCLENBQU47QUFHRDtBQUNGO0FBQ0Y7O0FBSUQsV0FBU3dhLFFBQVQsQ0FBbUJ4YSxHQUFuQixFQUF3QjtBQUN0QixRQUFJeWEsT0FBTyxHQUFHemEsR0FBRyxDQUFDdHlCLEtBQUosQ0FBVXlwQyxVQUFWLENBQWQ7O0FBQ0EsUUFBSSxDQUFDc0QsT0FBTCxFQUFjO0FBQUU7QUFBUTs7QUFDeEIsUUFBSXYwQyxHQUFHLEdBQUcsRUFBVjtBQUNBQSxPQUFHLENBQUN3MEMsR0FBSixHQUFVRCxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVc5WixJQUFYLEVBQVY7QUFDQSxRQUFJZ2EsS0FBSyxHQUFHRixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVc5WixJQUFYLEdBQWtCcDhCLE9BQWxCLENBQTBCOHlDLGFBQTFCLEVBQXlDLEVBQXpDLENBQVo7QUFDQSxRQUFJdUQsYUFBYSxHQUFHRCxLQUFLLENBQUNqdEMsS0FBTixDQUFZMHBDLGFBQVosQ0FBcEI7O0FBQ0EsUUFBSXdELGFBQUosRUFBbUI7QUFDakIxMEMsU0FBRyxDQUFDeTBDLEtBQUosR0FBWUEsS0FBSyxDQUFDcDJDLE9BQU4sQ0FBYzZ5QyxhQUFkLEVBQTZCLEVBQTdCLENBQVo7QUFDQWx4QyxTQUFHLENBQUMyMEMsU0FBSixHQUFnQkQsYUFBYSxDQUFDLENBQUQsQ0FBYixDQUFpQmphLElBQWpCLEVBQWhCOztBQUNBLFVBQUlpYSxhQUFhLENBQUMsQ0FBRCxDQUFqQixFQUFzQjtBQUNwQjEwQyxXQUFHLENBQUM0MEMsU0FBSixHQUFnQkYsYUFBYSxDQUFDLENBQUQsQ0FBYixDQUFpQmphLElBQWpCLEVBQWhCO0FBQ0Q7QUFDRixLQU5ELE1BTU87QUFDTHo2QixTQUFHLENBQUN5MEMsS0FBSixHQUFZQSxLQUFaO0FBQ0Q7O0FBQ0QsV0FBT3owQyxHQUFQO0FBQ0Q7O0FBRUQsV0FBU2t6QyxTQUFULENBQW9CcGxDLEVBQXBCLEVBQXdCO0FBQ3RCLFFBQUlnc0IsR0FBRyxHQUFHb0MsZ0JBQWdCLENBQUNwdUIsRUFBRCxFQUFLLE1BQUwsQ0FBMUI7O0FBQ0EsUUFBSWdzQixHQUFKLEVBQVM7QUFDUGhzQixRQUFFLENBQUN3bEMsRUFBSCxHQUFReFosR0FBUjtBQUNBMlosb0JBQWMsQ0FBQzNsQyxFQUFELEVBQUs7QUFDakJnc0IsV0FBRyxFQUFFQSxHQURZO0FBRWpCNFosYUFBSyxFQUFFNWxDO0FBRlUsT0FBTCxDQUFkO0FBSUQsS0FORCxNQU1PO0FBQ0wsVUFBSW91QixnQkFBZ0IsQ0FBQ3B1QixFQUFELEVBQUssUUFBTCxDQUFoQixJQUFrQyxJQUF0QyxFQUE0QztBQUMxQ0EsVUFBRSxDQUFDMGxDLElBQUgsR0FBVSxJQUFWO0FBQ0Q7O0FBQ0QsVUFBSUQsTUFBTSxHQUFHclgsZ0JBQWdCLENBQUNwdUIsRUFBRCxFQUFLLFdBQUwsQ0FBN0I7O0FBQ0EsVUFBSXlsQyxNQUFKLEVBQVk7QUFDVnpsQyxVQUFFLENBQUN5bEMsTUFBSCxHQUFZQSxNQUFaO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVNJLG1CQUFULENBQThCN2xDLEVBQTlCLEVBQWtDaEUsTUFBbEMsRUFBMEM7QUFDeEMsUUFBSXl3QixJQUFJLEdBQUdzYSxlQUFlLENBQUMvcUMsTUFBTSxDQUFDWCxRQUFSLENBQTFCOztBQUNBLFFBQUlveEIsSUFBSSxJQUFJQSxJQUFJLENBQUMrWSxFQUFqQixFQUFxQjtBQUNuQkcsb0JBQWMsQ0FBQ2xaLElBQUQsRUFBTztBQUNuQlQsV0FBRyxFQUFFaHNCLEVBQUUsQ0FBQ3lsQyxNQURXO0FBRW5CRyxhQUFLLEVBQUU1bEM7QUFGWSxPQUFQLENBQWQ7QUFJRCxLQUxELE1BS087QUFDTDBqQyxZQUFNLENBQ0osUUFBUTFqQyxFQUFFLENBQUN5bEMsTUFBSCxHQUFhLGNBQWN6bEMsRUFBRSxDQUFDeWxDLE1BQWpCLEdBQTBCLEdBQXZDLEdBQThDLE1BQXRELElBQWdFLEdBQWhFLEdBQ0EsbUJBREEsR0FDdUJ6bEMsRUFBRSxDQUFDN0UsR0FEMUIsR0FDaUMsK0JBRjdCLENBQU47QUFJRDtBQUNGOztBQUVELFdBQVM0ckMsZUFBVCxDQUEwQjFyQyxRQUExQixFQUFvQztBQUNsQyxRQUFJbk0sQ0FBQyxHQUFHbU0sUUFBUSxDQUFDbE0sTUFBakI7O0FBQ0EsV0FBT0QsQ0FBQyxFQUFSLEVBQVk7QUFDVixVQUFJbU0sUUFBUSxDQUFDbk0sQ0FBRCxDQUFSLENBQVlnUyxJQUFaLEtBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGVBQU83RixRQUFRLENBQUNuTSxDQUFELENBQWY7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJLGtCQUFrQixZQUFsQixJQUFrQ21NLFFBQVEsQ0FBQ25NLENBQUQsQ0FBUixDQUFZb00sSUFBWixLQUFxQixHQUEzRCxFQUFnRTtBQUM5RG9vQyxnQkFBTSxDQUNKLFlBQWFyb0MsUUFBUSxDQUFDbk0sQ0FBRCxDQUFSLENBQVlvTSxJQUFaLENBQWlCcXhCLElBQWpCLEVBQWIsR0FBd0Msa0NBQXhDLEdBQ0Esa0JBRkksQ0FBTjtBQUlEOztBQUNEdHhCLGdCQUFRLENBQUNKLEdBQVQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBUzBxQyxjQUFULENBQXlCM2xDLEVBQXpCLEVBQTZCZ25DLFNBQTdCLEVBQXdDO0FBQ3RDLFFBQUksQ0FBQ2huQyxFQUFFLENBQUNpbkMsWUFBUixFQUFzQjtBQUNwQmpuQyxRQUFFLENBQUNpbkMsWUFBSCxHQUFrQixFQUFsQjtBQUNEOztBQUNEam5DLE1BQUUsQ0FBQ2luQyxZQUFILENBQWdCanRDLElBQWhCLENBQXFCZ3RDLFNBQXJCO0FBQ0Q7O0FBRUQsV0FBUzNCLFdBQVQsQ0FBc0JybEMsRUFBdEIsRUFBMEI7QUFDeEIsUUFBSW9JLE9BQU8sR0FBR2dtQixnQkFBZ0IsQ0FBQ3B1QixFQUFELEVBQUssUUFBTCxDQUE5Qjs7QUFDQSxRQUFJb0ksT0FBTyxJQUFJLElBQWYsRUFBcUI7QUFDbkJwSSxRQUFFLENBQUN0TSxJQUFILEdBQVUsSUFBVjtBQUNEO0FBQ0Y7O0FBRUQsV0FBUzB5QyxXQUFULENBQXNCcG1DLEVBQXRCLEVBQTBCO0FBQ3hCLFFBQUlBLEVBQUUsQ0FBQzdFLEdBQUgsS0FBVyxNQUFmLEVBQXVCO0FBQ3JCNkUsUUFBRSxDQUFDa25DLFFBQUgsR0FBY2paLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssTUFBTCxDQUE1Qjs7QUFDQSxVQUFJLGtCQUFrQixZQUFsQixJQUFrQ0EsRUFBRSxDQUFDalEsR0FBekMsRUFBOEM7QUFDNUMyekMsY0FBTSxDQUNKLHNFQUNBLGtEQURBLEdBRUEsNENBSEksQ0FBTjtBQUtEO0FBQ0YsS0FURCxNQVNPO0FBQ0wsVUFBSW9DLFNBQUo7O0FBQ0EsVUFBSTlsQyxFQUFFLENBQUM3RSxHQUFILEtBQVcsVUFBZixFQUEyQjtBQUN6QjJxQyxpQkFBUyxHQUFHMVgsZ0JBQWdCLENBQUNwdUIsRUFBRCxFQUFLLE9BQUwsQ0FBNUI7QUFDQTs7QUFDQSxZQUFJLGtCQUFrQixZQUFsQixJQUFrQzhsQyxTQUF0QyxFQUFpRDtBQUMvQ3BDLGdCQUFNLENBQ0osdUVBQ0EseUVBREEsR0FFQSxrRUFGQSxHQUdBLHNCQUpJLEVBS0osSUFMSSxDQUFOO0FBT0Q7O0FBQ0QxakMsVUFBRSxDQUFDOGxDLFNBQUgsR0FBZUEsU0FBUyxJQUFJMVgsZ0JBQWdCLENBQUNwdUIsRUFBRCxFQUFLLFlBQUwsQ0FBNUM7QUFDRCxPQWJELE1BYU8sSUFBSzhsQyxTQUFTLEdBQUcxWCxnQkFBZ0IsQ0FBQ3B1QixFQUFELEVBQUssWUFBTCxDQUFqQyxFQUFzRDtBQUMzRDtBQUNBLFlBQUksa0JBQWtCLFlBQWxCLElBQWtDQSxFQUFFLENBQUNvdEIsUUFBSCxDQUFZLE9BQVosQ0FBdEMsRUFBNEQ7QUFDMURzVyxnQkFBTSxDQUNKLDBEQUEyRDFqQyxFQUFFLENBQUM3RSxHQUE5RCxHQUFxRSxJQUFyRSxHQUNBLGtFQURBLEdBRUEsaUNBSEksRUFJSixJQUpJLENBQU47QUFNRDs7QUFDRDZFLFVBQUUsQ0FBQzhsQyxTQUFILEdBQWVBLFNBQWY7QUFDRDs7QUFDRCxVQUFJQyxVQUFVLEdBQUc5WCxjQUFjLENBQUNqdUIsRUFBRCxFQUFLLE1BQUwsQ0FBL0I7O0FBQ0EsVUFBSStsQyxVQUFKLEVBQWdCO0FBQ2QvbEMsVUFBRSxDQUFDK2xDLFVBQUgsR0FBZ0JBLFVBQVUsS0FBSyxJQUFmLEdBQXNCLFdBQXRCLEdBQW9DQSxVQUFwRCxDQURjLENBRWQ7QUFDQTs7QUFDQSxZQUFJL2xDLEVBQUUsQ0FBQzdFLEdBQUgsS0FBVyxVQUFYLElBQXlCLENBQUM2RSxFQUFFLENBQUM4bEMsU0FBakMsRUFBNEM7QUFDMUM1WSxpQkFBTyxDQUFDbHRCLEVBQUQsRUFBSyxNQUFMLEVBQWErbEMsVUFBYixDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBU00sZ0JBQVQsQ0FBMkJybUMsRUFBM0IsRUFBK0I7QUFDN0IsUUFBSXl3QixPQUFKOztBQUNBLFFBQUtBLE9BQU8sR0FBR3hDLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssSUFBTCxDQUE3QixFQUEwQztBQUN4Q0EsUUFBRSxDQUFDc0wsU0FBSCxHQUFlbWxCLE9BQWY7QUFDRDs7QUFDRCxRQUFJckMsZ0JBQWdCLENBQUNwdUIsRUFBRCxFQUFLLGlCQUFMLENBQWhCLElBQTJDLElBQS9DLEVBQXFEO0FBQ25EQSxRQUFFLENBQUNtYixjQUFILEdBQW9CLElBQXBCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTbXJCLFlBQVQsQ0FBdUJ0bUMsRUFBdkIsRUFBMkI7QUFDekIsUUFBSWhSLElBQUksR0FBR2dSLEVBQUUsQ0FBQ3F0QixTQUFkO0FBQ0EsUUFBSW4rQixDQUFKLEVBQU9pQyxDQUFQLEVBQVVtSSxJQUFWLEVBQWdCb3hCLE9BQWhCLEVBQXlCdDlCLEtBQXpCLEVBQWdDbzlCLFNBQWhDLEVBQTJDMmMsTUFBM0M7O0FBQ0EsU0FBS2o0QyxDQUFDLEdBQUcsQ0FBSixFQUFPaUMsQ0FBQyxHQUFHbkMsSUFBSSxDQUFDRyxNQUFyQixFQUE2QkQsQ0FBQyxHQUFHaUMsQ0FBakMsRUFBb0NqQyxDQUFDLEVBQXJDLEVBQXlDO0FBQ3ZDb0ssVUFBSSxHQUFHb3hCLE9BQU8sR0FBRzE3QixJQUFJLENBQUNFLENBQUQsQ0FBSixDQUFRb0ssSUFBekI7QUFDQWxNLFdBQUssR0FBRzRCLElBQUksQ0FBQ0UsQ0FBRCxDQUFKLENBQVE5QixLQUFoQjs7QUFDQSxVQUFJODFDLEtBQUssQ0FBQ3h0QyxJQUFOLENBQVc0RCxJQUFYLENBQUosRUFBc0I7QUFDcEI7QUFDQTBHLFVBQUUsQ0FBQ29uQyxXQUFILEdBQWlCLElBQWpCLENBRm9CLENBR3BCOztBQUNBNWMsaUJBQVMsR0FBRzZjLGNBQWMsQ0FBQy90QyxJQUFELENBQTFCOztBQUNBLFlBQUlreEIsU0FBSixFQUFlO0FBQ2JseEIsY0FBSSxHQUFHQSxJQUFJLENBQUMvSSxPQUFMLENBQWFpekMsVUFBYixFQUF5QixFQUF6QixDQUFQO0FBQ0Q7O0FBQ0QsWUFBSUQsTUFBTSxDQUFDN3RDLElBQVAsQ0FBWTRELElBQVosQ0FBSixFQUF1QjtBQUFFO0FBQ3ZCQSxjQUFJLEdBQUdBLElBQUksQ0FBQy9JLE9BQUwsQ0FBYWd6QyxNQUFiLEVBQXFCLEVBQXJCLENBQVA7QUFDQW4yQyxlQUFLLEdBQUcyK0IsWUFBWSxDQUFDMytCLEtBQUQsQ0FBcEI7QUFDQSs1QyxnQkFBTSxHQUFHLEtBQVQ7O0FBQ0EsY0FBSTNjLFNBQUosRUFBZTtBQUNiLGdCQUFJQSxTQUFTLENBQUN6bkIsSUFBZCxFQUFvQjtBQUNsQm9rQyxvQkFBTSxHQUFHLElBQVQ7QUFDQTd0QyxrQkFBSSxHQUFHaEosUUFBUSxDQUFDZ0osSUFBRCxDQUFmOztBQUNBLGtCQUFJQSxJQUFJLEtBQUssV0FBYixFQUEwQjtBQUFFQSxvQkFBSSxHQUFHLFdBQVA7QUFBcUI7QUFDbEQ7O0FBQ0QsZ0JBQUlreEIsU0FBUyxDQUFDOGMsS0FBZCxFQUFxQjtBQUNuQmh1QyxrQkFBSSxHQUFHaEosUUFBUSxDQUFDZ0osSUFBRCxDQUFmO0FBQ0Q7O0FBQ0QsZ0JBQUlreEIsU0FBUyxDQUFDdmYsSUFBZCxFQUFvQjtBQUNsQnVpQix3QkFBVSxDQUNSeHRCLEVBRFEsRUFFUCxZQUFhMVAsUUFBUSxDQUFDZ0osSUFBRCxDQUZkLEVBR1JzMUIsaUJBQWlCLENBQUN4aEMsS0FBRCxFQUFRLFFBQVIsQ0FIVCxDQUFWO0FBS0Q7QUFDRjs7QUFDRCxjQUFJKzVDLE1BQU0sSUFDUixDQUFDbm5DLEVBQUUsQ0FBQ3NMLFNBQUosSUFBaUJ5NEIsbUJBQW1CLENBQUMvakMsRUFBRSxDQUFDN0UsR0FBSixFQUFTNkUsRUFBRSxDQUFDb3RCLFFBQUgsQ0FBWWxzQixJQUFyQixFQUEyQjVILElBQTNCLENBRHRDLEVBRUc7QUFDRDB6QixtQkFBTyxDQUFDaHRCLEVBQUQsRUFBSzFHLElBQUwsRUFBV2xNLEtBQVgsQ0FBUDtBQUNELFdBSkQsTUFJTztBQUNMOC9CLG1CQUFPLENBQUNsdEIsRUFBRCxFQUFLMUcsSUFBTCxFQUFXbE0sS0FBWCxDQUFQO0FBQ0Q7QUFDRixTQTVCRCxNQTRCTyxJQUFJNjFDLElBQUksQ0FBQ3Z0QyxJQUFMLENBQVU0RCxJQUFWLENBQUosRUFBcUI7QUFBRTtBQUM1QkEsY0FBSSxHQUFHQSxJQUFJLENBQUMvSSxPQUFMLENBQWEweUMsSUFBYixFQUFtQixFQUFuQixDQUFQO0FBQ0F6VixvQkFBVSxDQUFDeHRCLEVBQUQsRUFBSzFHLElBQUwsRUFBV2xNLEtBQVgsRUFBa0JvOUIsU0FBbEIsRUFBNkIsS0FBN0IsRUFBb0NrWixNQUFwQyxDQUFWO0FBQ0QsU0FITSxNQUdBO0FBQUU7QUFDUHBxQyxjQUFJLEdBQUdBLElBQUksQ0FBQy9JLE9BQUwsQ0FBYTJ5QyxLQUFiLEVBQW9CLEVBQXBCLENBQVAsQ0FESyxDQUVMOztBQUNBLGNBQUlxRSxRQUFRLEdBQUdqdUMsSUFBSSxDQUFDSSxLQUFMLENBQVc0cEMsS0FBWCxDQUFmO0FBQ0EsY0FBSS9WLEdBQUcsR0FBR2dhLFFBQVEsSUFBSUEsUUFBUSxDQUFDLENBQUQsQ0FBOUI7O0FBQ0EsY0FBSWhhLEdBQUosRUFBUztBQUNQajBCLGdCQUFJLEdBQUdBLElBQUksQ0FBQzFMLEtBQUwsQ0FBVyxDQUFYLEVBQWMsRUFBRTIvQixHQUFHLENBQUNwK0IsTUFBSixHQUFhLENBQWYsQ0FBZCxDQUFQO0FBQ0Q7O0FBQ0RtK0Isc0JBQVksQ0FBQ3R0QixFQUFELEVBQUsxRyxJQUFMLEVBQVdveEIsT0FBWCxFQUFvQnQ5QixLQUFwQixFQUEyQm1nQyxHQUEzQixFQUFnQy9DLFNBQWhDLENBQVo7O0FBQ0EsY0FBSSxrQkFBa0IsWUFBbEIsSUFBa0NseEIsSUFBSSxLQUFLLE9BQS9DLEVBQXdEO0FBQ3REa3VDLDhCQUFrQixDQUFDeG5DLEVBQUQsRUFBSzVTLEtBQUwsQ0FBbEI7QUFDRDtBQUNGO0FBQ0YsT0FwREQsTUFvRE87QUFDTDtBQUNBO0FBQ0UsY0FBSThFLEdBQUcsR0FBR3VzQyxTQUFTLENBQUNyeEMsS0FBRCxFQUFRa3hDLFVBQVIsQ0FBbkI7O0FBQ0EsY0FBSXBzQyxHQUFKLEVBQVM7QUFDUHd4QyxrQkFBTSxDQUNKcHFDLElBQUksR0FBRyxLQUFQLEdBQWVsTSxLQUFmLEdBQXVCLE1BQXZCLEdBQ0Esb0RBREEsR0FFQSwwREFGQSxHQUdBLHVEQUpJLENBQU47QUFNRDtBQUNGO0FBQ0Q4L0IsZUFBTyxDQUFDbHRCLEVBQUQsRUFBSzFHLElBQUwsRUFBVy9LLElBQUksQ0FBQ0MsU0FBTCxDQUFlcEIsS0FBZixDQUFYLENBQVAsQ0FiSyxDQWNMO0FBQ0E7O0FBQ0EsWUFBSSxDQUFDNFMsRUFBRSxDQUFDc0wsU0FBSixJQUNBaFMsSUFBSSxLQUFLLE9BRFQsSUFFQXlxQyxtQkFBbUIsQ0FBQy9qQyxFQUFFLENBQUM3RSxHQUFKLEVBQVM2RSxFQUFFLENBQUNvdEIsUUFBSCxDQUFZbHNCLElBQXJCLEVBQTJCNUgsSUFBM0IsQ0FGdkIsRUFFeUQ7QUFDdkQwekIsaUJBQU8sQ0FBQ2h0QixFQUFELEVBQUsxRyxJQUFMLEVBQVcsTUFBWCxDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBU2l0QyxVQUFULENBQXFCdm1DLEVBQXJCLEVBQXlCO0FBQ3ZCLFFBQUloRSxNQUFNLEdBQUdnRSxFQUFiOztBQUNBLFdBQU9oRSxNQUFQLEVBQWU7QUFDYixVQUFJQSxNQUFNLENBQUMwcUMsR0FBUCxLQUFlMzVDLFNBQW5CLEVBQThCO0FBQzVCLGVBQU8sSUFBUDtBQUNEOztBQUNEaVAsWUFBTSxHQUFHQSxNQUFNLENBQUNBLE1BQWhCO0FBQ0Q7O0FBQ0QsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsV0FBU3FyQyxjQUFULENBQXlCL3RDLElBQXpCLEVBQStCO0FBQzdCLFFBQUlJLEtBQUssR0FBR0osSUFBSSxDQUFDSSxLQUFMLENBQVc4cEMsVUFBWCxDQUFaOztBQUNBLFFBQUk5cEMsS0FBSixFQUFXO0FBQ1QsVUFBSTlILEdBQUcsR0FBRyxFQUFWO0FBQ0E4SCxXQUFLLENBQUMyRCxPQUFOLENBQWMsVUFBVTFLLENBQVYsRUFBYTtBQUFFZixXQUFHLENBQUNlLENBQUMsQ0FBQy9FLEtBQUYsQ0FBUSxDQUFSLENBQUQsQ0FBSCxHQUFrQixJQUFsQjtBQUF5QixPQUF0RDtBQUNBLGFBQU9nRSxHQUFQO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTc3lDLFlBQVQsQ0FBdUI1NkIsS0FBdkIsRUFBOEI7QUFDNUIsUUFBSXhhLEdBQUcsR0FBRyxFQUFWOztBQUNBLFNBQUssSUFBSUksQ0FBQyxHQUFHLENBQVIsRUFBV2lDLENBQUMsR0FBR21ZLEtBQUssQ0FBQ25hLE1BQTFCLEVBQWtDRCxDQUFDLEdBQUdpQyxDQUF0QyxFQUF5Q2pDLENBQUMsRUFBMUMsRUFBOEM7QUFDNUMsVUFDRSxrQkFBa0IsWUFBbEIsSUFDQUosR0FBRyxDQUFDd2EsS0FBSyxDQUFDcGEsQ0FBRCxDQUFMLENBQVNvSyxJQUFWLENBREgsSUFDc0IsQ0FBQ2hELElBRHZCLElBQytCLENBQUNFLE1BRmxDLEVBR0U7QUFDQWt0QyxjQUFNLENBQUMsMEJBQTBCcDZCLEtBQUssQ0FBQ3BhLENBQUQsQ0FBTCxDQUFTb0ssSUFBcEMsQ0FBTjtBQUNEOztBQUNEeEssU0FBRyxDQUFDd2EsS0FBSyxDQUFDcGEsQ0FBRCxDQUFMLENBQVNvSyxJQUFWLENBQUgsR0FBcUJnUSxLQUFLLENBQUNwYSxDQUFELENBQUwsQ0FBUzlCLEtBQTlCO0FBQ0Q7O0FBQ0QsV0FBTzBCLEdBQVA7QUFDRCxHQS81U29CLENBaTZTckI7OztBQUNBLFdBQVNtM0MsU0FBVCxDQUFvQmptQyxFQUFwQixFQUF3QjtBQUN0QixXQUFPQSxFQUFFLENBQUM3RSxHQUFILEtBQVcsUUFBWCxJQUF1QjZFLEVBQUUsQ0FBQzdFLEdBQUgsS0FBVyxPQUF6QztBQUNEOztBQUVELFdBQVMycEMsY0FBVCxDQUF5QjlrQyxFQUF6QixFQUE2QjtBQUMzQixXQUNFQSxFQUFFLENBQUM3RSxHQUFILEtBQVcsT0FBWCxJQUNDNkUsRUFBRSxDQUFDN0UsR0FBSCxLQUFXLFFBQVgsS0FDQyxDQUFDNkUsRUFBRSxDQUFDb3RCLFFBQUgsQ0FBWWxzQixJQUFiLElBQ0FsQixFQUFFLENBQUNvdEIsUUFBSCxDQUFZbHNCLElBQVosS0FBcUIsaUJBRnRCLENBRkg7QUFPRDs7QUFFRCxNQUFJdW1DLE9BQU8sR0FBRyxjQUFkO0FBQ0EsTUFBSUMsVUFBVSxHQUFHLFNBQWpCO0FBRUE7O0FBQ0EsV0FBUzdDLGFBQVQsQ0FBd0J2N0IsS0FBeEIsRUFBK0I7QUFDN0IsUUFBSXBYLEdBQUcsR0FBRyxFQUFWOztBQUNBLFNBQUssSUFBSWhELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdvYSxLQUFLLENBQUNuYSxNQUExQixFQUFrQ0QsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxVQUFJdXhCLElBQUksR0FBR25YLEtBQUssQ0FBQ3BhLENBQUQsQ0FBaEI7O0FBQ0EsVUFBSSxDQUFDdTRDLE9BQU8sQ0FBQy94QyxJQUFSLENBQWErcUIsSUFBSSxDQUFDbm5CLElBQWxCLENBQUwsRUFBOEI7QUFDNUJtbkIsWUFBSSxDQUFDbm5CLElBQUwsR0FBWW1uQixJQUFJLENBQUNubkIsSUFBTCxDQUFVL0ksT0FBVixDQUFrQm0zQyxVQUFsQixFQUE4QixFQUE5QixDQUFaO0FBQ0F4MUMsV0FBRyxDQUFDOEgsSUFBSixDQUFTeW1CLElBQVQ7QUFDRDtBQUNGOztBQUNELFdBQU92dUIsR0FBUDtBQUNEOztBQUVELFdBQVNzMUMsa0JBQVQsQ0FBNkJ4bkMsRUFBN0IsRUFBaUM1UyxLQUFqQyxFQUF3QztBQUN0QyxRQUFJdTZDLEdBQUcsR0FBRzNuQyxFQUFWOztBQUNBLFdBQU8ybkMsR0FBUCxFQUFZO0FBQ1YsVUFBSUEsR0FBRyxDQUFDakIsR0FBSixJQUFXaUIsR0FBRyxDQUFDaEIsS0FBSixLQUFjdjVDLEtBQTdCLEVBQW9DO0FBQ2xDczJDLGNBQU0sQ0FDSixNQUFPMWpDLEVBQUUsQ0FBQzdFLEdBQVYsR0FBaUIsYUFBakIsR0FBaUMvTixLQUFqQyxHQUF5QyxPQUF6QyxHQUNBLCtEQURBLEdBRUEsaUVBRkEsR0FHQSxvRUFIQSxHQUlBLG1GQUxJLENBQU47QUFPRDs7QUFDRHU2QyxTQUFHLEdBQUdBLEdBQUcsQ0FBQzNyQyxNQUFWO0FBQ0Q7QUFDRjtBQUVEOztBQUVBOzs7Ozs7Ozs7OztBQVVBLFdBQVM0ckMsZ0JBQVQsQ0FBMkI1bkMsRUFBM0IsRUFBK0IvRyxPQUEvQixFQUF3QztBQUN0QyxRQUFJK0csRUFBRSxDQUFDN0UsR0FBSCxLQUFXLE9BQWYsRUFBd0I7QUFDdEIsVUFBSXJNLEdBQUcsR0FBR2tSLEVBQUUsQ0FBQ290QixRQUFiOztBQUNBLFVBQUksQ0FBQ3QrQixHQUFHLENBQUMsU0FBRCxDQUFSLEVBQXFCO0FBQ25CO0FBQ0Q7O0FBRUQsVUFBSTBoQyxXQUFKOztBQUNBLFVBQUkxaEMsR0FBRyxDQUFDLE9BQUQsQ0FBSCxJQUFnQkEsR0FBRyxDQUFDLGFBQUQsQ0FBdkIsRUFBd0M7QUFDdEMwaEMsbUJBQVcsR0FBR3ZDLGNBQWMsQ0FBQ2p1QixFQUFELEVBQUssTUFBTCxDQUE1QjtBQUNEOztBQUNELFVBQUksQ0FBQ2xSLEdBQUcsQ0FBQ29TLElBQUwsSUFBYSxDQUFDc3ZCLFdBQWQsSUFBNkIxaEMsR0FBRyxDQUFDLFFBQUQsQ0FBcEMsRUFBZ0Q7QUFDOUMwaEMsbUJBQVcsR0FBRyxNQUFPMWhDLEdBQUcsQ0FBQyxRQUFELENBQVYsR0FBd0IsUUFBdEM7QUFDRDs7QUFFRCxVQUFJMGhDLFdBQUosRUFBaUI7QUFDZixZQUFJcVgsV0FBVyxHQUFHelosZ0JBQWdCLENBQUNwdUIsRUFBRCxFQUFLLE1BQUwsRUFBYSxJQUFiLENBQWxDO0FBQ0EsWUFBSThuQyxnQkFBZ0IsR0FBR0QsV0FBVyxHQUFJLFFBQVFBLFdBQVIsR0FBc0IsR0FBMUIsR0FBaUMsRUFBbkU7QUFDQSxZQUFJRSxPQUFPLEdBQUczWixnQkFBZ0IsQ0FBQ3B1QixFQUFELEVBQUssUUFBTCxFQUFlLElBQWYsQ0FBaEIsSUFBd0MsSUFBdEQ7QUFDQSxZQUFJZ29DLGVBQWUsR0FBRzVaLGdCQUFnQixDQUFDcHVCLEVBQUQsRUFBSyxXQUFMLEVBQWtCLElBQWxCLENBQXRDLENBSmUsQ0FLZjs7QUFDQSxZQUFJaW9DLE9BQU8sR0FBR0MsZUFBZSxDQUFDbG9DLEVBQUQsQ0FBN0IsQ0FOZSxDQU9mOztBQUNBbWxDLGtCQUFVLENBQUM4QyxPQUFELENBQVY7QUFDQTlhLGtCQUFVLENBQUM4YSxPQUFELEVBQVUsTUFBVixFQUFrQixVQUFsQixDQUFWO0FBQ0EzQyxzQkFBYyxDQUFDMkMsT0FBRCxFQUFVaHZDLE9BQVYsQ0FBZDtBQUNBZ3ZDLGVBQU8sQ0FBQy9DLFNBQVIsR0FBb0IsSUFBcEIsQ0FYZSxDQVdXOztBQUMxQitDLGVBQU8sQ0FBQ3pDLEVBQVIsR0FBYSxNQUFNaFYsV0FBTixHQUFvQixnQkFBcEIsR0FBdUNzWCxnQkFBcEQ7QUFDQW5DLHNCQUFjLENBQUNzQyxPQUFELEVBQVU7QUFDdEJqYyxhQUFHLEVBQUVpYyxPQUFPLENBQUN6QyxFQURTO0FBRXRCSSxlQUFLLEVBQUVxQztBQUZlLFNBQVYsQ0FBZCxDQWJlLENBaUJmOztBQUNBLFlBQUlFLE9BQU8sR0FBR0QsZUFBZSxDQUFDbG9DLEVBQUQsQ0FBN0I7QUFDQW91Qix3QkFBZ0IsQ0FBQytaLE9BQUQsRUFBVSxPQUFWLEVBQW1CLElBQW5CLENBQWhCO0FBQ0FoYixrQkFBVSxDQUFDZ2IsT0FBRCxFQUFVLE1BQVYsRUFBa0IsT0FBbEIsQ0FBVjtBQUNBN0Msc0JBQWMsQ0FBQzZDLE9BQUQsRUFBVWx2QyxPQUFWLENBQWQ7QUFDQTBzQyxzQkFBYyxDQUFDc0MsT0FBRCxFQUFVO0FBQ3RCamMsYUFBRyxFQUFFLE1BQU13RSxXQUFOLEdBQW9CLGFBQXBCLEdBQW9Dc1gsZ0JBRG5CO0FBRXRCbEMsZUFBSyxFQUFFdUM7QUFGZSxTQUFWLENBQWQsQ0F0QmUsQ0EwQmY7O0FBQ0EsWUFBSUMsT0FBTyxHQUFHRixlQUFlLENBQUNsb0MsRUFBRCxDQUE3QjtBQUNBb3VCLHdCQUFnQixDQUFDZ2EsT0FBRCxFQUFVLE9BQVYsRUFBbUIsSUFBbkIsQ0FBaEI7QUFDQWpiLGtCQUFVLENBQUNpYixPQUFELEVBQVUsT0FBVixFQUFtQjVYLFdBQW5CLENBQVY7QUFDQThVLHNCQUFjLENBQUM4QyxPQUFELEVBQVVudkMsT0FBVixDQUFkO0FBQ0Ewc0Msc0JBQWMsQ0FBQ3NDLE9BQUQsRUFBVTtBQUN0QmpjLGFBQUcsRUFBRTZiLFdBRGlCO0FBRXRCakMsZUFBSyxFQUFFd0M7QUFGZSxTQUFWLENBQWQ7O0FBS0EsWUFBSUwsT0FBSixFQUFhO0FBQ1hFLGlCQUFPLENBQUN2QyxJQUFSLEdBQWUsSUFBZjtBQUNELFNBRkQsTUFFTyxJQUFJc0MsZUFBSixFQUFxQjtBQUMxQkMsaUJBQU8sQ0FBQ3hDLE1BQVIsR0FBaUJ1QyxlQUFqQjtBQUNEOztBQUVELGVBQU9DLE9BQVA7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsV0FBU0MsZUFBVCxDQUEwQmxvQyxFQUExQixFQUE4QjtBQUM1QixXQUFPaWtDLGdCQUFnQixDQUFDamtDLEVBQUUsQ0FBQzdFLEdBQUosRUFBUzZFLEVBQUUsQ0FBQ3F0QixTQUFILENBQWF6L0IsS0FBYixFQUFULEVBQStCb1MsRUFBRSxDQUFDaEUsTUFBbEMsQ0FBdkI7QUFDRDs7QUFFRCxNQUFJcXNDLE9BQU8sR0FBRztBQUNaVCxvQkFBZ0IsRUFBRUE7QUFETixHQUFkO0FBSUEsTUFBSVUsU0FBUyxHQUFHLENBQ2RwSixPQURjLEVBRWRJLE9BRmMsRUFHZCtJLE9BSGMsQ0FBaEI7QUFNQTs7QUFFQSxXQUFTL3NDLElBQVQsQ0FBZTBFLEVBQWYsRUFBbUJtcUIsR0FBbkIsRUFBd0I7QUFDdEIsUUFBSUEsR0FBRyxDQUFDLzhCLEtBQVIsRUFBZTtBQUNiNC9CLGFBQU8sQ0FBQ2h0QixFQUFELEVBQUssYUFBTCxFQUFxQixRQUFTbXFCLEdBQUcsQ0FBQy84QixLQUFiLEdBQXNCLEdBQTNDLENBQVA7QUFDRDtBQUNGO0FBRUQ7OztBQUVBLFdBQVNzeUMsSUFBVCxDQUFlMS9CLEVBQWYsRUFBbUJtcUIsR0FBbkIsRUFBd0I7QUFDdEIsUUFBSUEsR0FBRyxDQUFDLzhCLEtBQVIsRUFBZTtBQUNiNC9CLGFBQU8sQ0FBQ2h0QixFQUFELEVBQUssV0FBTCxFQUFtQixRQUFTbXFCLEdBQUcsQ0FBQy84QixLQUFiLEdBQXNCLEdBQXpDLENBQVA7QUFDRDtBQUNGOztBQUVELE1BQUltN0MsWUFBWSxHQUFHO0FBQ2pCMXRCLFNBQUssRUFBRUEsS0FEVTtBQUVqQnZmLFFBQUksRUFBRUEsSUFGVztBQUdqQm9rQyxRQUFJLEVBQUVBO0FBR1I7O0FBTm1CLEdBQW5CO0FBUUEsTUFBSThJLFdBQVcsR0FBRztBQUNoQnBILGNBQVUsRUFBRSxJQURJO0FBRWhCNXVDLFdBQU8sRUFBRTgxQyxTQUZPO0FBR2hCcm1DLGNBQVUsRUFBRXNtQyxZQUhJO0FBSWhCdm1CLFlBQVEsRUFBRUEsUUFKTTtBQUtoQjJkLGNBQVUsRUFBRUEsVUFMSTtBQU1oQjdxQyxlQUFXLEVBQUVBLFdBTkc7QUFPaEI4cUMsb0JBQWdCLEVBQUVBLGdCQVBGO0FBUWhCbnJDLGlCQUFhLEVBQUVBLGFBUkM7QUFTaEJHLG1CQUFlLEVBQUVBLGVBVEQ7QUFVaEIvQixjQUFVLEVBQUVOLGFBQWEsQ0FBQysxQyxTQUFEO0FBVlQsR0FBbEI7QUFhQTs7QUFFQSxNQUFJRyxXQUFKO0FBQ0EsTUFBSUMscUJBQUo7QUFFQSxNQUFJQyxtQkFBbUIsR0FBRzM0QyxNQUFNLENBQUM0NEMsZUFBRCxDQUFoQztBQUVBOzs7Ozs7Ozs7Ozs7QUFXQSxXQUFTQyxRQUFULENBQW1CeEUsSUFBbkIsRUFBeUJwckMsT0FBekIsRUFBa0M7QUFDaEMsUUFBSSxDQUFDb3JDLElBQUwsRUFBVztBQUFFO0FBQVE7O0FBQ3JCb0UsZUFBVyxHQUFHRSxtQkFBbUIsQ0FBQzF2QyxPQUFPLENBQUNwRyxVQUFSLElBQXNCLEVBQXZCLENBQWpDO0FBQ0E2MUMseUJBQXFCLEdBQUd6dkMsT0FBTyxDQUFDeEUsYUFBUixJQUF5QnBDLEVBQWpELENBSGdDLENBSWhDOztBQUNBeTJDLGdCQUFZLENBQUN6RSxJQUFELENBQVosQ0FMZ0MsQ0FNaEM7O0FBQ0EwRSxtQkFBZSxDQUFDMUUsSUFBRCxFQUFPLEtBQVAsQ0FBZjtBQUNEOztBQUVELFdBQVN1RSxlQUFULENBQTBCbDJDLElBQTFCLEVBQWdDO0FBQzlCLFdBQU8vRCxPQUFPLENBQ1osNkRBQ0MrRCxJQUFJLEdBQUcsTUFBTUEsSUFBVCxHQUFnQixFQURyQixDQURZLENBQWQ7QUFJRDs7QUFFRCxXQUFTbzJDLFlBQVQsQ0FBdUJqc0MsSUFBdkIsRUFBNkI7QUFDM0JBLFFBQUksQ0FBQ21zQyxNQUFMLEdBQWM5c0MsUUFBUSxDQUFDVyxJQUFELENBQXRCOztBQUNBLFFBQUlBLElBQUksQ0FBQ3FFLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxVQUNFLENBQUN3bkMscUJBQXFCLENBQUM3ckMsSUFBSSxDQUFDMUIsR0FBTixDQUF0QixJQUNBMEIsSUFBSSxDQUFDMUIsR0FBTCxLQUFhLE1BRGIsSUFFQTBCLElBQUksQ0FBQ3V3QixRQUFMLENBQWMsaUJBQWQsS0FBb0MsSUFIdEMsRUFJRTtBQUNBO0FBQ0Q7O0FBQ0QsV0FBSyxJQUFJbCtCLENBQUMsR0FBRyxDQUFSLEVBQVdpQyxDQUFDLEdBQUcwTCxJQUFJLENBQUN4QixRQUFMLENBQWNsTSxNQUFsQyxFQUEwQ0QsQ0FBQyxHQUFHaUMsQ0FBOUMsRUFBaURqQyxDQUFDLEVBQWxELEVBQXNEO0FBQ3BELFlBQUl3TixLQUFLLEdBQUdHLElBQUksQ0FBQ3hCLFFBQUwsQ0FBY25NLENBQWQsQ0FBWjtBQUNBNDVDLG9CQUFZLENBQUNwc0MsS0FBRCxDQUFaOztBQUNBLFlBQUksQ0FBQ0EsS0FBSyxDQUFDc3NDLE1BQVgsRUFBbUI7QUFDakJuc0MsY0FBSSxDQUFDbXNDLE1BQUwsR0FBYyxLQUFkO0FBQ0Q7QUFDRjs7QUFDRCxVQUFJbnNDLElBQUksQ0FBQ29xQyxZQUFULEVBQXVCO0FBQ3JCLGFBQUssSUFBSXY2QixHQUFHLEdBQUcsQ0FBVixFQUFhdThCLEdBQUcsR0FBR3BzQyxJQUFJLENBQUNvcUMsWUFBTCxDQUFrQjkzQyxNQUExQyxFQUFrRHVkLEdBQUcsR0FBR3U4QixHQUF4RCxFQUE2RHY4QixHQUFHLEVBQWhFLEVBQW9FO0FBQ2xFLGNBQUlrNUIsS0FBSyxHQUFHL29DLElBQUksQ0FBQ29xQyxZQUFMLENBQWtCdjZCLEdBQWxCLEVBQXVCazVCLEtBQW5DO0FBQ0FrRCxzQkFBWSxDQUFDbEQsS0FBRCxDQUFaOztBQUNBLGNBQUksQ0FBQ0EsS0FBSyxDQUFDb0QsTUFBWCxFQUFtQjtBQUNqQm5zQyxnQkFBSSxDQUFDbXNDLE1BQUwsR0FBYyxLQUFkO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTRCxlQUFULENBQTBCbHNDLElBQTFCLEVBQWdDc2EsT0FBaEMsRUFBeUM7QUFDdkMsUUFBSXRhLElBQUksQ0FBQ3FFLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixVQUFJckUsSUFBSSxDQUFDbXNDLE1BQUwsSUFBZW5zQyxJQUFJLENBQUNuSixJQUF4QixFQUE4QjtBQUM1Qm1KLFlBQUksQ0FBQ3FzQyxXQUFMLEdBQW1CL3hCLE9BQW5CO0FBQ0QsT0FIa0IsQ0FJbkI7QUFDQTtBQUNBOzs7QUFDQSxVQUFJdGEsSUFBSSxDQUFDbXNDLE1BQUwsSUFBZW5zQyxJQUFJLENBQUN4QixRQUFMLENBQWNsTSxNQUE3QixJQUF1QyxFQUN6QzBOLElBQUksQ0FBQ3hCLFFBQUwsQ0FBY2xNLE1BQWQsS0FBeUIsQ0FBekIsSUFDQTBOLElBQUksQ0FBQ3hCLFFBQUwsQ0FBYyxDQUFkLEVBQWlCNkYsSUFBakIsS0FBMEIsQ0FGZSxDQUEzQyxFQUdHO0FBQ0RyRSxZQUFJLENBQUNzc0MsVUFBTCxHQUFrQixJQUFsQjtBQUNBO0FBQ0QsT0FORCxNQU1PO0FBQ0x0c0MsWUFBSSxDQUFDc3NDLFVBQUwsR0FBa0IsS0FBbEI7QUFDRDs7QUFDRCxVQUFJdHNDLElBQUksQ0FBQ3hCLFFBQVQsRUFBbUI7QUFDakIsYUFBSyxJQUFJbk0sQ0FBQyxHQUFHLENBQVIsRUFBV2lDLENBQUMsR0FBRzBMLElBQUksQ0FBQ3hCLFFBQUwsQ0FBY2xNLE1BQWxDLEVBQTBDRCxDQUFDLEdBQUdpQyxDQUE5QyxFQUFpRGpDLENBQUMsRUFBbEQsRUFBc0Q7QUFDcEQ2NUMseUJBQWUsQ0FBQ2xzQyxJQUFJLENBQUN4QixRQUFMLENBQWNuTSxDQUFkLENBQUQsRUFBbUJpb0IsT0FBTyxJQUFJLENBQUMsQ0FBQ3RhLElBQUksQ0FBQzZwQyxHQUFyQyxDQUFmO0FBQ0Q7QUFDRjs7QUFDRCxVQUFJN3BDLElBQUksQ0FBQ29xQyxZQUFULEVBQXVCO0FBQ3JCLGFBQUssSUFBSXY2QixHQUFHLEdBQUcsQ0FBVixFQUFhdThCLEdBQUcsR0FBR3BzQyxJQUFJLENBQUNvcUMsWUFBTCxDQUFrQjkzQyxNQUExQyxFQUFrRHVkLEdBQUcsR0FBR3U4QixHQUF4RCxFQUE2RHY4QixHQUFHLEVBQWhFLEVBQW9FO0FBQ2xFcThCLHlCQUFlLENBQUNsc0MsSUFBSSxDQUFDb3FDLFlBQUwsQ0FBa0J2NkIsR0FBbEIsRUFBdUJrNUIsS0FBeEIsRUFBK0J6dUIsT0FBL0IsQ0FBZjtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELFdBQVNqYixRQUFULENBQW1CVyxJQUFuQixFQUF5QjtBQUN2QixRQUFJQSxJQUFJLENBQUNxRSxJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFBRTtBQUNyQixhQUFPLEtBQVA7QUFDRDs7QUFDRCxRQUFJckUsSUFBSSxDQUFDcUUsSUFBTCxLQUFjLENBQWxCLEVBQXFCO0FBQUU7QUFDckIsYUFBTyxJQUFQO0FBQ0Q7O0FBQ0QsV0FBTyxDQUFDLEVBQUVyRSxJQUFJLENBQUMwb0IsR0FBTCxJQUNSLENBQUMxb0IsSUFBSSxDQUFDdXFDLFdBQU4sSUFBcUI7QUFDckIsS0FBQ3ZxQyxJQUFJLENBQUMyb0MsRUFETixJQUNZLENBQUMzb0MsSUFBSSxDQUFDNnBDLEdBRGxCLElBQ3lCO0FBQ3pCLEtBQUNyM0MsWUFBWSxDQUFDd04sSUFBSSxDQUFDMUIsR0FBTixDQUZiLElBRTJCO0FBQzNCdXRDLHlCQUFxQixDQUFDN3JDLElBQUksQ0FBQzFCLEdBQU4sQ0FIckIsSUFHbUM7QUFDbkMsS0FBQ2l1QywwQkFBMEIsQ0FBQ3ZzQyxJQUFELENBSjNCLElBS0FsUSxNQUFNLENBQUMrRixJQUFQLENBQVltSyxJQUFaLEVBQWtCeEosS0FBbEIsQ0FBd0JvMUMsV0FBeEIsQ0FOTSxDQUFSO0FBUUQ7O0FBRUQsV0FBU1csMEJBQVQsQ0FBcUN2c0MsSUFBckMsRUFBMkM7QUFDekMsV0FBT0EsSUFBSSxDQUFDYixNQUFaLEVBQW9CO0FBQ2xCYSxVQUFJLEdBQUdBLElBQUksQ0FBQ2IsTUFBWjs7QUFDQSxVQUFJYSxJQUFJLENBQUMxQixHQUFMLEtBQWEsVUFBakIsRUFBNkI7QUFDM0IsZUFBTyxLQUFQO0FBQ0Q7O0FBQ0QsVUFBSTBCLElBQUksQ0FBQzZwQyxHQUFULEVBQWM7QUFDWixlQUFPLElBQVA7QUFDRDtBQUNGOztBQUNELFdBQU8sS0FBUDtBQUNEO0FBRUQ7OztBQUVBLE1BQUkyQyxPQUFPLEdBQUcsMkNBQWQ7QUFDQSxNQUFJQyxZQUFZLEdBQUcsOEZBQW5CLENBL3NUcUIsQ0FpdFRyQjs7QUFDQSxNQUFJOTBDLFFBQVEsR0FBRztBQUNiKzBDLE9BQUcsRUFBRSxFQURRO0FBRWJDLE9BQUcsRUFBRSxDQUZRO0FBR2I1UyxTQUFLLEVBQUUsRUFITTtBQUliNlMsU0FBSyxFQUFFLEVBSk07QUFLYkMsTUFBRSxFQUFFLEVBTFM7QUFNYjNMLFFBQUksRUFBRSxFQU5PO0FBT2JwUSxTQUFLLEVBQUUsRUFQTTtBQVFiZ2MsUUFBSSxFQUFFLEVBUk87QUFTYixjQUFVLENBQUMsQ0FBRCxFQUFJLEVBQUo7QUFURyxHQUFmLENBbHRUcUIsQ0E4dFRyQjs7QUFDQSxNQUFJQyxRQUFRLEdBQUc7QUFDYkwsT0FBRyxFQUFFLFFBRFE7QUFFYkMsT0FBRyxFQUFFLEtBRlE7QUFHYjVTLFNBQUssRUFBRSxPQUhNO0FBSWI2UyxTQUFLLEVBQUUsR0FKTTtBQUtiO0FBQ0FDLE1BQUUsRUFBRSxDQUFDLElBQUQsRUFBTyxTQUFQLENBTlM7QUFPYjNMLFFBQUksRUFBRSxDQUFDLE1BQUQsRUFBUyxXQUFULENBUE87QUFRYnBRLFNBQUssRUFBRSxDQUFDLE9BQUQsRUFBVSxZQUFWLENBUk07QUFTYmdjLFFBQUksRUFBRSxDQUFDLE1BQUQsRUFBUyxXQUFULENBVE87QUFVYixjQUFVLENBQUMsV0FBRCxFQUFjLFFBQWQ7QUFWRyxHQUFmLENBL3RUcUIsQ0E0dVRyQjtBQUNBO0FBQ0E7O0FBQ0EsTUFBSUUsUUFBUSxHQUFHLFVBQVU3QyxTQUFWLEVBQXFCO0FBQUUsV0FBUSxRQUFRQSxTQUFSLEdBQW9CLGVBQTVCO0FBQStDLEdBQXJGOztBQUVBLE1BQUk4QyxZQUFZLEdBQUc7QUFDakJDLFFBQUksRUFBRSwyQkFEVztBQUVqQnJjLFdBQU8sRUFBRSwwQkFGUTtBQUdqQnNjLFFBQUksRUFBRUgsUUFBUSxDQUFDLHdDQUFELENBSEc7QUFJakJJLFFBQUksRUFBRUosUUFBUSxDQUFDLGlCQUFELENBSkc7QUFLakIzL0IsU0FBSyxFQUFFMi9CLFFBQVEsQ0FBQyxrQkFBRCxDQUxFO0FBTWpCSyxPQUFHLEVBQUVMLFFBQVEsQ0FBQyxnQkFBRCxDQU5JO0FBT2pCTSxRQUFJLEVBQUVOLFFBQVEsQ0FBQyxpQkFBRCxDQVBHO0FBUWpCOUwsUUFBSSxFQUFFOEwsUUFBUSxDQUFDLDJDQUFELENBUkc7QUFTakJqYyxVQUFNLEVBQUVpYyxRQUFRLENBQUMsMkNBQUQsQ0FUQztBQVVqQmxjLFNBQUssRUFBRWtjLFFBQVEsQ0FBQywyQ0FBRDtBQVZFLEdBQW5COztBQWFBLFdBQVNPLFdBQVQsQ0FDRXZjLE1BREYsRUFFRXQyQixRQUZGLEVBR0VZLElBSEYsRUFJRTtBQUNBLFFBQUlqRyxHQUFHLEdBQUdxRixRQUFRLEdBQUcsWUFBSCxHQUFrQixNQUFwQzs7QUFDQSxTQUFLLElBQUkrQixJQUFULElBQWlCdTBCLE1BQWpCLEVBQXlCO0FBQ3ZCMzdCLFNBQUcsSUFBSSxPQUFPb0gsSUFBUCxHQUFjLEtBQWQsR0FBdUIrd0MsVUFBVSxDQUFDL3dDLElBQUQsRUFBT3UwQixNQUFNLENBQUN2MEIsSUFBRCxDQUFiLENBQWpDLEdBQXlELEdBQWhFO0FBQ0Q7O0FBQ0QsV0FBT3BILEdBQUcsQ0FBQ3RFLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLElBQW1CLEdBQTFCO0FBQ0Q7O0FBRUQsV0FBU3k4QyxVQUFULENBQ0Uvd0MsSUFERixFQUVFaWIsT0FGRixFQUdFO0FBQ0EsUUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWixhQUFPLGNBQVA7QUFDRDs7QUFFRCxRQUFJMWlCLEtBQUssQ0FBQ3NCLE9BQU4sQ0FBY29oQixPQUFkLENBQUosRUFBNEI7QUFDMUIsYUFBUSxNQUFPQSxPQUFPLENBQUN6bEIsR0FBUixDQUFZLFVBQVV5bEIsT0FBVixFQUFtQjtBQUFFLGVBQU84MUIsVUFBVSxDQUFDL3dDLElBQUQsRUFBT2liLE9BQVAsQ0FBakI7QUFBbUMsT0FBcEUsRUFBc0V6aEIsSUFBdEUsQ0FBMkUsR0FBM0UsQ0FBUCxHQUEwRixHQUFsRztBQUNEOztBQUVELFFBQUl3M0MsWUFBWSxHQUFHaEIsWUFBWSxDQUFDNXpDLElBQWIsQ0FBa0I2ZSxPQUFPLENBQUNubkIsS0FBMUIsQ0FBbkI7QUFDQSxRQUFJbTlDLG9CQUFvQixHQUFHbEIsT0FBTyxDQUFDM3pDLElBQVIsQ0FBYTZlLE9BQU8sQ0FBQ25uQixLQUFyQixDQUEzQjs7QUFFQSxRQUFJLENBQUNtbkIsT0FBTyxDQUFDaVcsU0FBYixFQUF3QjtBQUN0QixVQUFJOGYsWUFBWSxJQUFJQyxvQkFBcEIsRUFBMEM7QUFDeEMsZUFBT2gyQixPQUFPLENBQUNubkIsS0FBZjtBQUNEO0FBQ0Q7OztBQUNBLGFBQVEsc0JBQXVCbW5CLE9BQU8sQ0FBQ25uQixLQUEvQixHQUF3QyxHQUFoRCxDQUxzQixDQUsrQjtBQUN0RCxLQU5ELE1BTU87QUFDTCxVQUFJa2pDLElBQUksR0FBRyxFQUFYO0FBQ0EsVUFBSWthLGVBQWUsR0FBRyxFQUF0QjtBQUNBLFVBQUk5M0MsSUFBSSxHQUFHLEVBQVg7O0FBQ0EsV0FBSyxJQUFJM0MsR0FBVCxJQUFnQndrQixPQUFPLENBQUNpVyxTQUF4QixFQUFtQztBQUNqQyxZQUFJc2YsWUFBWSxDQUFDLzVDLEdBQUQsQ0FBaEIsRUFBdUI7QUFDckJ5NkMseUJBQWUsSUFBSVYsWUFBWSxDQUFDLzVDLEdBQUQsQ0FBL0IsQ0FEcUIsQ0FFckI7O0FBQ0EsY0FBSXlFLFFBQVEsQ0FBQ3pFLEdBQUQsQ0FBWixFQUFtQjtBQUNqQjJDLGdCQUFJLENBQUNzSCxJQUFMLENBQVVqSyxHQUFWO0FBQ0Q7QUFDRixTQU5ELE1BTU8sSUFBSUEsR0FBRyxLQUFLLE9BQVosRUFBcUI7QUFDMUIsY0FBSXk2QixTQUFTLEdBQUlqVyxPQUFPLENBQUNpVyxTQUF6QjtBQUNBZ2dCLHlCQUFlLElBQUlYLFFBQVEsQ0FDekIsQ0FBQyxNQUFELEVBQVMsT0FBVCxFQUFrQixLQUFsQixFQUF5QixNQUF6QixFQUNHdjBCLE1BREgsQ0FDVSxVQUFVbTFCLFdBQVYsRUFBdUI7QUFBRSxtQkFBTyxDQUFDamdCLFNBQVMsQ0FBQ2lnQixXQUFELENBQWpCO0FBQWlDLFdBRHBFLEVBRUczN0MsR0FGSCxDQUVPLFVBQVUyN0MsV0FBVixFQUF1QjtBQUFFLG1CQUFRLFlBQVlBLFdBQVosR0FBMEIsS0FBbEM7QUFBMkMsV0FGM0UsRUFHRzMzQyxJQUhILENBR1EsSUFIUixDQUR5QixDQUEzQjtBQU1ELFNBUk0sTUFRQTtBQUNMSixjQUFJLENBQUNzSCxJQUFMLENBQVVqSyxHQUFWO0FBQ0Q7QUFDRjs7QUFDRCxVQUFJMkMsSUFBSSxDQUFDdkQsTUFBVCxFQUFpQjtBQUNmbWhDLFlBQUksSUFBSW9hLFlBQVksQ0FBQ2g0QyxJQUFELENBQXBCO0FBQ0QsT0F6QkksQ0EwQkw7OztBQUNBLFVBQUk4M0MsZUFBSixFQUFxQjtBQUNuQmxhLFlBQUksSUFBSWthLGVBQVI7QUFDRDs7QUFDRCxVQUFJRyxXQUFXLEdBQUdMLFlBQVksR0FDekIsWUFBYS8xQixPQUFPLENBQUNubkIsS0FBckIsR0FBOEIsVUFETCxHQUUxQm05QyxvQkFBb0IsR0FDakIsYUFBY2gyQixPQUFPLENBQUNubkIsS0FBdEIsR0FBK0IsV0FEZCxHQUVsQm1uQixPQUFPLENBQUNubkIsS0FKZDtBQUtBOztBQUNBLGFBQVEsc0JBQXNCa2pDLElBQXRCLEdBQTZCcWEsV0FBN0IsR0FBMkMsR0FBbkQ7QUFDRDtBQUNGOztBQUVELFdBQVNELFlBQVQsQ0FBdUJoNEMsSUFBdkIsRUFBNkI7QUFDM0IsV0FBUSwrQkFBZ0NBLElBQUksQ0FBQzVELEdBQUwsQ0FBUzg3QyxhQUFULEVBQXdCOTNDLElBQXhCLENBQTZCLElBQTdCLENBQWhDLEdBQXNFLGVBQTlFO0FBQ0Q7O0FBRUQsV0FBUzgzQyxhQUFULENBQXdCNzZDLEdBQXhCLEVBQTZCO0FBQzNCLFFBQUk4NkMsTUFBTSxHQUFHN3FCLFFBQVEsQ0FBQ2p3QixHQUFELEVBQU0sRUFBTixDQUFyQjs7QUFDQSxRQUFJODZDLE1BQUosRUFBWTtBQUNWLGFBQVEsc0JBQXNCQSxNQUE5QjtBQUNEOztBQUNELFFBQUlDLE9BQU8sR0FBR3QyQyxRQUFRLENBQUN6RSxHQUFELENBQXRCO0FBQ0EsUUFBSWc3QyxPQUFPLEdBQUduQixRQUFRLENBQUM3NUMsR0FBRCxDQUF0QjtBQUNBLFdBQ0UsdUJBQ0N4QixJQUFJLENBQUNDLFNBQUwsQ0FBZXVCLEdBQWYsQ0FERCxHQUN3QixHQUR4QixHQUVDeEIsSUFBSSxDQUFDQyxTQUFMLENBQWVzOEMsT0FBZixDQUZELEdBRTRCLEdBRjVCLEdBR0EsYUFIQSxHQUlBLEVBSkEsR0FJTXY4QyxJQUFJLENBQUNDLFNBQUwsQ0FBZXU4QyxPQUFmLENBSk4sR0FLQSxHQU5GO0FBUUQ7QUFFRDs7O0FBRUEsV0FBU3JpQyxFQUFULENBQWExSSxFQUFiLEVBQWlCbXFCLEdBQWpCLEVBQXNCO0FBQ3BCLFFBQUksa0JBQWtCLFlBQWxCLElBQWtDQSxHQUFHLENBQUNLLFNBQTFDLEVBQXFEO0FBQ25EcnlCLFVBQUksQ0FBQyxtREFBRCxDQUFKO0FBQ0Q7O0FBQ0Q2SCxNQUFFLENBQUNnckMsYUFBSCxHQUFtQixVQUFVMWEsSUFBVixFQUFnQjtBQUFFLGFBQVEsUUFBUUEsSUFBUixHQUFlLEdBQWYsR0FBc0JuRyxHQUFHLENBQUMvOEIsS0FBMUIsR0FBbUMsR0FBM0M7QUFBa0QsS0FBdkY7QUFDRDtBQUVEOzs7QUFFQSxXQUFTNjlDLE1BQVQsQ0FBaUJqckMsRUFBakIsRUFBcUJtcUIsR0FBckIsRUFBMEI7QUFDeEJucUIsTUFBRSxDQUFDa3JDLFFBQUgsR0FBYyxVQUFVNWEsSUFBVixFQUFnQjtBQUM1QixhQUFRLFFBQVFBLElBQVIsR0FBZSxJQUFmLEdBQXVCdHdCLEVBQUUsQ0FBQzdFLEdBQTFCLEdBQWlDLElBQWpDLEdBQXlDZ3ZCLEdBQUcsQ0FBQy84QixLQUE3QyxHQUFzRCxHQUF0RCxJQUE2RCs4QixHQUFHLENBQUNLLFNBQUosSUFBaUJMLEdBQUcsQ0FBQ0ssU0FBSixDQUFjem5CLElBQS9CLEdBQXNDLE1BQXRDLEdBQStDLE9BQTVHLEtBQXdIb25CLEdBQUcsQ0FBQ0ssU0FBSixJQUFpQkwsR0FBRyxDQUFDSyxTQUFKLENBQWN2ZixJQUEvQixHQUFzQyxPQUF0QyxHQUFnRCxFQUF4SyxJQUE4SyxHQUF0TDtBQUNELEtBRkQ7QUFHRDtBQUVEOzs7QUFFQSxNQUFJa2dDLGNBQWMsR0FBRztBQUNuQnppQyxNQUFFLEVBQUVBLEVBRGU7QUFFbkJsWCxRQUFJLEVBQUV5NUMsTUFGYTtBQUduQkcsU0FBSyxFQUFFajVDO0FBR1Q7O0FBTnFCLEdBQXJCOztBQVFBLE1BQUlrNUMsWUFBWSxHQUFHLFNBQVNBLFlBQVQsQ0FBdUJweUMsT0FBdkIsRUFBZ0M7QUFDakQsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS2QsSUFBTCxHQUFZYyxPQUFPLENBQUNkLElBQVIsSUFBZ0IyMEIsUUFBNUI7QUFDQSxTQUFLNlcsVUFBTCxHQUFrQjVXLG1CQUFtQixDQUFDOXpCLE9BQU8sQ0FBQ3pHLE9BQVQsRUFBa0IsZUFBbEIsQ0FBckM7QUFDQSxTQUFLODRDLFVBQUwsR0FBa0J2ZSxtQkFBbUIsQ0FBQzl6QixPQUFPLENBQUN6RyxPQUFULEVBQWtCLFNBQWxCLENBQXJDO0FBQ0EsU0FBS3lQLFVBQUwsR0FBa0JuUSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxFQUFELEVBQUtxNUMsY0FBTCxDQUFQLEVBQTZCbHlDLE9BQU8sQ0FBQ2dKLFVBQXJDLENBQXhCO0FBQ0EsUUFBSXhOLGFBQWEsR0FBR3dFLE9BQU8sQ0FBQ3hFLGFBQVIsSUFBeUJwQyxFQUE3Qzs7QUFDQSxTQUFLazVDLGNBQUwsR0FBc0IsVUFBVXZyQyxFQUFWLEVBQWM7QUFBRSxhQUFPLENBQUN2TCxhQUFhLENBQUN1TCxFQUFFLENBQUM3RSxHQUFKLENBQXJCO0FBQWdDLEtBQXRFOztBQUNBLFNBQUtxd0MsTUFBTCxHQUFjLENBQWQ7QUFDQSxTQUFLbjBCLGVBQUwsR0FBdUIsRUFBdkI7QUFDRCxHQVZEOztBQWNBLFdBQVNvMEIsUUFBVCxDQUNFQyxHQURGLEVBRUV6eUMsT0FGRixFQUdFO0FBQ0EsUUFBSTB5QyxLQUFLLEdBQUcsSUFBSU4sWUFBSixDQUFpQnB5QyxPQUFqQixDQUFaO0FBQ0EsUUFBSXEzQixJQUFJLEdBQUdvYixHQUFHLEdBQUdFLFVBQVUsQ0FBQ0YsR0FBRCxFQUFNQyxLQUFOLENBQWIsR0FBNEIsV0FBMUM7QUFDQSxXQUFPO0FBQ0xua0MsWUFBTSxFQUFHLHVCQUF1QjhvQixJQUF2QixHQUE4QixHQURsQztBQUVMaloscUJBQWUsRUFBRXMwQixLQUFLLENBQUN0MEI7QUFGbEIsS0FBUDtBQUlEOztBQUVELFdBQVN1MEIsVUFBVCxDQUFxQjVyQyxFQUFyQixFQUF5QjJyQyxLQUF6QixFQUFnQztBQUM5QixRQUFJM3JDLEVBQUUsQ0FBQ21wQyxVQUFILElBQWlCLENBQUNucEMsRUFBRSxDQUFDNnJDLGVBQXpCLEVBQTBDO0FBQ3hDLGFBQU9DLFNBQVMsQ0FBQzlyQyxFQUFELEVBQUsyckMsS0FBTCxDQUFoQjtBQUNELEtBRkQsTUFFTyxJQUFJM3JDLEVBQUUsQ0FBQ3RNLElBQUgsSUFBVyxDQUFDc00sRUFBRSxDQUFDK3JDLGFBQW5CLEVBQWtDO0FBQ3ZDLGFBQU9DLE9BQU8sQ0FBQ2hzQyxFQUFELEVBQUsyckMsS0FBTCxDQUFkO0FBQ0QsS0FGTSxNQUVBLElBQUkzckMsRUFBRSxDQUFDMG1DLEdBQUgsSUFBVSxDQUFDMW1DLEVBQUUsQ0FBQ2lzQyxZQUFsQixFQUFnQztBQUNyQyxhQUFPQyxNQUFNLENBQUNsc0MsRUFBRCxFQUFLMnJDLEtBQUwsQ0FBYjtBQUNELEtBRk0sTUFFQSxJQUFJM3JDLEVBQUUsQ0FBQ3dsQyxFQUFILElBQVMsQ0FBQ3hsQyxFQUFFLENBQUNtc0MsV0FBakIsRUFBOEI7QUFDbkMsYUFBT0MsS0FBSyxDQUFDcHNDLEVBQUQsRUFBSzJyQyxLQUFMLENBQVo7QUFDRCxLQUZNLE1BRUEsSUFBSTNyQyxFQUFFLENBQUM3RSxHQUFILEtBQVcsVUFBWCxJQUF5QixDQUFDNkUsRUFBRSxDQUFDK2xDLFVBQWpDLEVBQTZDO0FBQ2xELGFBQU9zRyxXQUFXLENBQUNyc0MsRUFBRCxFQUFLMnJDLEtBQUwsQ0FBWCxJQUEwQixRQUFqQztBQUNELEtBRk0sTUFFQSxJQUFJM3JDLEVBQUUsQ0FBQzdFLEdBQUgsS0FBVyxNQUFmLEVBQXVCO0FBQzVCLGFBQU9teEMsT0FBTyxDQUFDdHNDLEVBQUQsRUFBSzJyQyxLQUFMLENBQWQ7QUFDRCxLQUZNLE1BRUE7QUFDTDtBQUNBLFVBQUlyYixJQUFKOztBQUNBLFVBQUl0d0IsRUFBRSxDQUFDc0wsU0FBUCxFQUFrQjtBQUNoQmdsQixZQUFJLEdBQUdpYyxZQUFZLENBQUN2c0MsRUFBRSxDQUFDc0wsU0FBSixFQUFldEwsRUFBZixFQUFtQjJyQyxLQUFuQixDQUFuQjtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUl2d0MsSUFBSSxHQUFHNEUsRUFBRSxDQUFDaXRCLEtBQUgsR0FBV2xnQyxTQUFYLEdBQXVCeS9DLFNBQVMsQ0FBQ3hzQyxFQUFELEVBQUsyckMsS0FBTCxDQUEzQztBQUVBLFlBQUl0d0MsUUFBUSxHQUFHMkUsRUFBRSxDQUFDbWIsY0FBSCxHQUFvQixJQUFwQixHQUEyQmt4QixXQUFXLENBQUNyc0MsRUFBRCxFQUFLMnJDLEtBQUwsRUFBWSxJQUFaLENBQXJEO0FBQ0FyYixZQUFJLEdBQUcsU0FBVXR3QixFQUFFLENBQUM3RSxHQUFiLEdBQW9CLEdBQXBCLElBQTJCQyxJQUFJLEdBQUksTUFBTUEsSUFBVixHQUFrQixFQUFqRCxLQUF3REMsUUFBUSxHQUFJLE1BQU1BLFFBQVYsR0FBc0IsRUFBdEYsSUFBNEYsR0FBbkc7QUFDRCxPQVZJLENBV0w7OztBQUNBLFdBQUssSUFBSW5NLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5OEMsS0FBSyxDQUFDaEksVUFBTixDQUFpQngwQyxNQUFyQyxFQUE2Q0QsQ0FBQyxFQUE5QyxFQUFrRDtBQUNoRG9oQyxZQUFJLEdBQUdxYixLQUFLLENBQUNoSSxVQUFOLENBQWlCejBDLENBQWpCLEVBQW9COFEsRUFBcEIsRUFBd0Jzd0IsSUFBeEIsQ0FBUDtBQUNEOztBQUNELGFBQU9BLElBQVA7QUFDRDtBQUNGLEdBLzZUb0IsQ0FpN1RyQjs7O0FBQ0EsV0FBU3diLFNBQVQsQ0FBb0I5ckMsRUFBcEIsRUFBd0IyckMsS0FBeEIsRUFBK0I7QUFDN0IzckMsTUFBRSxDQUFDNnJDLGVBQUgsR0FBcUIsSUFBckI7QUFDQUYsU0FBSyxDQUFDdDBCLGVBQU4sQ0FBc0JyZCxJQUF0QixDQUE0Qix1QkFBd0I0eEMsVUFBVSxDQUFDNXJDLEVBQUQsRUFBSzJyQyxLQUFMLENBQWxDLEdBQWlELEdBQTdFO0FBQ0EsV0FBUSxTQUFTQSxLQUFLLENBQUN0MEIsZUFBTixDQUFzQmxvQixNQUF0QixHQUErQixDQUF4QyxLQUE4QzZRLEVBQUUsQ0FBQ2twQyxXQUFILEdBQWlCLE9BQWpCLEdBQTJCLEVBQXpFLElBQStFLEdBQXZGO0FBQ0QsR0F0N1RvQixDQXc3VHJCOzs7QUFDQSxXQUFTOEMsT0FBVCxDQUFrQmhzQyxFQUFsQixFQUFzQjJyQyxLQUF0QixFQUE2QjtBQUMzQjNyQyxNQUFFLENBQUMrckMsYUFBSCxHQUFtQixJQUFuQjs7QUFDQSxRQUFJL3JDLEVBQUUsQ0FBQ3dsQyxFQUFILElBQVMsQ0FBQ3hsQyxFQUFFLENBQUNtc0MsV0FBakIsRUFBOEI7QUFDNUIsYUFBT0MsS0FBSyxDQUFDcHNDLEVBQUQsRUFBSzJyQyxLQUFMLENBQVo7QUFDRCxLQUZELE1BRU8sSUFBSTNyQyxFQUFFLENBQUNrcEMsV0FBUCxFQUFvQjtBQUN6QixVQUFJbjVDLEdBQUcsR0FBRyxFQUFWO0FBQ0EsVUFBSWlNLE1BQU0sR0FBR2dFLEVBQUUsQ0FBQ2hFLE1BQWhCOztBQUNBLGFBQU9BLE1BQVAsRUFBZTtBQUNiLFlBQUlBLE1BQU0sQ0FBQzBxQyxHQUFYLEVBQWdCO0FBQ2QzMkMsYUFBRyxHQUFHaU0sTUFBTSxDQUFDak0sR0FBYjtBQUNBO0FBQ0Q7O0FBQ0RpTSxjQUFNLEdBQUdBLE1BQU0sQ0FBQ0EsTUFBaEI7QUFDRDs7QUFDRCxVQUFJLENBQUNqTSxHQUFMLEVBQVU7QUFDUiwwQkFBa0IsWUFBbEIsSUFBa0M0N0MsS0FBSyxDQUFDeHpDLElBQU4sQ0FDaEMsc0RBRGdDLENBQWxDO0FBR0EsZUFBT3l6QyxVQUFVLENBQUM1ckMsRUFBRCxFQUFLMnJDLEtBQUwsQ0FBakI7QUFDRDs7QUFDRCxhQUFRLFFBQVNDLFVBQVUsQ0FBQzVyQyxFQUFELEVBQUsyckMsS0FBTCxDQUFuQixHQUFrQyxHQUFsQyxHQUF5Q0EsS0FBSyxDQUFDSCxNQUFOLEVBQXpDLEdBQTJELEdBQTNELEdBQWlFejdDLEdBQWpFLEdBQXVFLEdBQS9FO0FBQ0QsS0FqQk0sTUFpQkE7QUFDTCxhQUFPKzdDLFNBQVMsQ0FBQzlyQyxFQUFELEVBQUsyckMsS0FBTCxDQUFoQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU1MsS0FBVCxDQUNFcHNDLEVBREYsRUFFRTJyQyxLQUZGLEVBR0VjLE1BSEYsRUFJRUMsUUFKRixFQUtFO0FBQ0Exc0MsTUFBRSxDQUFDbXNDLFdBQUgsR0FBaUIsSUFBakIsQ0FEQSxDQUN1Qjs7QUFDdkIsV0FBT1EsZUFBZSxDQUFDM3NDLEVBQUUsQ0FBQ2luQyxZQUFILENBQWdCcjVDLEtBQWhCLEVBQUQsRUFBMEIrOUMsS0FBMUIsRUFBaUNjLE1BQWpDLEVBQXlDQyxRQUF6QyxDQUF0QjtBQUNEOztBQUVELFdBQVNDLGVBQVQsQ0FDRUMsVUFERixFQUVFakIsS0FGRixFQUdFYyxNQUhGLEVBSUVDLFFBSkYsRUFLRTtBQUNBLFFBQUksQ0FBQ0UsVUFBVSxDQUFDejlDLE1BQWhCLEVBQXdCO0FBQ3RCLGFBQU91OUMsUUFBUSxJQUFJLE1BQW5CO0FBQ0Q7O0FBRUQsUUFBSTFGLFNBQVMsR0FBRzRGLFVBQVUsQ0FBQzFpQyxLQUFYLEVBQWhCOztBQUNBLFFBQUk4OEIsU0FBUyxDQUFDaGIsR0FBZCxFQUFtQjtBQUNqQixhQUFRLE1BQU9nYixTQUFTLENBQUNoYixHQUFqQixHQUF3QixJQUF4QixHQUFnQzZnQixhQUFhLENBQUM3RixTQUFTLENBQUNwQixLQUFYLENBQTdDLEdBQWtFLEdBQWxFLEdBQXlFK0csZUFBZSxDQUFDQyxVQUFELEVBQWFqQixLQUFiLEVBQW9CYyxNQUFwQixFQUE0QkMsUUFBNUIsQ0FBaEc7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFRLEtBQU1HLGFBQWEsQ0FBQzdGLFNBQVMsQ0FBQ3BCLEtBQVgsQ0FBM0I7QUFDRCxLQVZELENBWUE7OztBQUNBLGFBQVNpSCxhQUFULENBQXdCN3NDLEVBQXhCLEVBQTRCO0FBQzFCLGFBQU95c0MsTUFBTSxHQUNUQSxNQUFNLENBQUN6c0MsRUFBRCxFQUFLMnJDLEtBQUwsQ0FERyxHQUVUM3JDLEVBQUUsQ0FBQ3RNLElBQUgsR0FDRXM0QyxPQUFPLENBQUNoc0MsRUFBRCxFQUFLMnJDLEtBQUwsQ0FEVCxHQUVFQyxVQUFVLENBQUM1ckMsRUFBRCxFQUFLMnJDLEtBQUwsQ0FKaEI7QUFLRDtBQUNGOztBQUVELFdBQVNPLE1BQVQsQ0FDRWxzQyxFQURGLEVBRUUyckMsS0FGRixFQUdFYyxNQUhGLEVBSUVLLFNBSkYsRUFLRTtBQUNBLFFBQUk5Z0IsR0FBRyxHQUFHaHNCLEVBQUUsQ0FBQzBtQyxHQUFiO0FBQ0EsUUFBSUMsS0FBSyxHQUFHM21DLEVBQUUsQ0FBQzJtQyxLQUFmO0FBQ0EsUUFBSUUsU0FBUyxHQUFHN21DLEVBQUUsQ0FBQzZtQyxTQUFILEdBQWdCLE1BQU83bUMsRUFBRSxDQUFDNm1DLFNBQTFCLEdBQXdDLEVBQXhEO0FBQ0EsUUFBSUMsU0FBUyxHQUFHOW1DLEVBQUUsQ0FBQzhtQyxTQUFILEdBQWdCLE1BQU85bUMsRUFBRSxDQUFDOG1DLFNBQTFCLEdBQXdDLEVBQXhEOztBQUVBLFFBQUksa0JBQWtCLFlBQWxCLElBQ0Y2RSxLQUFLLENBQUNKLGNBQU4sQ0FBcUJ2ckMsRUFBckIsQ0FERSxJQUVGQSxFQUFFLENBQUM3RSxHQUFILEtBQVcsTUFGVCxJQUdGNkUsRUFBRSxDQUFDN0UsR0FBSCxLQUFXLFVBSFQsSUFJRixDQUFDNkUsRUFBRSxDQUFDalEsR0FKTixFQUtFO0FBQ0E0N0MsV0FBSyxDQUFDeHpDLElBQU4sQ0FDRSxNQUFPNkgsRUFBRSxDQUFDN0UsR0FBVixHQUFpQixXQUFqQixHQUErQndyQyxLQUEvQixHQUF1QyxNQUF2QyxHQUFnRDNhLEdBQWhELEdBQXNELHFDQUF0RCxHQUNBLG1DQURBLEdBRUEsMERBSEYsRUFJRTtBQUFLO0FBSlA7QUFNRDs7QUFFRGhzQixNQUFFLENBQUNpc0MsWUFBSCxHQUFrQixJQUFsQixDQXBCQSxDQW9Cd0I7O0FBQ3hCLFdBQU8sQ0FBQ2EsU0FBUyxJQUFJLElBQWQsSUFBc0IsSUFBdEIsR0FBNkI5Z0IsR0FBN0IsR0FBbUMsSUFBbkMsR0FDTCxXQURLLEdBQ1MyYSxLQURULEdBQ2lCRSxTQURqQixHQUM2QkMsU0FEN0IsR0FDeUMsSUFEekMsR0FFSCxTQUZHLEdBRVUsQ0FBQzJGLE1BQU0sSUFBSWIsVUFBWCxFQUF1QjVyQyxFQUF2QixFQUEyQjJyQyxLQUEzQixDQUZWLEdBR0wsSUFIRjtBQUlEOztBQUVELFdBQVNhLFNBQVQsQ0FBb0J4c0MsRUFBcEIsRUFBd0IyckMsS0FBeEIsRUFBK0I7QUFDN0IsUUFBSXZ3QyxJQUFJLEdBQUcsR0FBWCxDQUQ2QixDQUc3QjtBQUNBOztBQUNBLFFBQUk0RyxJQUFJLEdBQUcrcUMsYUFBYSxDQUFDL3NDLEVBQUQsRUFBSzJyQyxLQUFMLENBQXhCOztBQUNBLFFBQUkzcEMsSUFBSixFQUFVO0FBQUU1RyxVQUFJLElBQUk0RyxJQUFJLEdBQUcsR0FBZjtBQUFxQixLQU5KLENBUTdCOzs7QUFDQSxRQUFJaEMsRUFBRSxDQUFDalEsR0FBUCxFQUFZO0FBQ1ZxTCxVQUFJLElBQUksU0FBVTRFLEVBQUUsQ0FBQ2pRLEdBQWIsR0FBb0IsR0FBNUI7QUFDRCxLQVg0QixDQVk3Qjs7O0FBQ0EsUUFBSWlRLEVBQUUsQ0FBQ29jLEdBQVAsRUFBWTtBQUNWaGhCLFVBQUksSUFBSSxTQUFVNEUsRUFBRSxDQUFDb2MsR0FBYixHQUFvQixHQUE1QjtBQUNEOztBQUNELFFBQUlwYyxFQUFFLENBQUMrakIsUUFBUCxFQUFpQjtBQUNmM29CLFVBQUksSUFBSSxnQkFBUjtBQUNELEtBbEI0QixDQW1CN0I7OztBQUNBLFFBQUk0RSxFQUFFLENBQUN1bEIsR0FBUCxFQUFZO0FBQ1ZucUIsVUFBSSxJQUFJLFdBQVI7QUFDRCxLQXRCNEIsQ0F1QjdCOzs7QUFDQSxRQUFJNEUsRUFBRSxDQUFDc0wsU0FBUCxFQUFrQjtBQUNoQmxRLFVBQUksSUFBSSxXQUFZNEUsRUFBRSxDQUFDN0UsR0FBZixHQUFzQixLQUE5QjtBQUNELEtBMUI0QixDQTJCN0I7OztBQUNBLFNBQUssSUFBSWpNLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5OEMsS0FBSyxDQUFDTCxVQUFOLENBQWlCbjhDLE1BQXJDLEVBQTZDRCxDQUFDLEVBQTlDLEVBQWtEO0FBQ2hEa00sVUFBSSxJQUFJdXdDLEtBQUssQ0FBQ0wsVUFBTixDQUFpQnA4QyxDQUFqQixFQUFvQjhRLEVBQXBCLENBQVI7QUFDRCxLQTlCNEIsQ0ErQjdCOzs7QUFDQSxRQUFJQSxFQUFFLENBQUNzSixLQUFQLEVBQWM7QUFDWmxPLFVBQUksSUFBSSxZQUFhNHhDLFFBQVEsQ0FBQ2h0QyxFQUFFLENBQUNzSixLQUFKLENBQXJCLEdBQW1DLElBQTNDO0FBQ0QsS0FsQzRCLENBbUM3Qjs7O0FBQ0EsUUFBSXRKLEVBQUUsQ0FBQ29CLEtBQVAsRUFBYztBQUNaaEcsVUFBSSxJQUFJLGVBQWdCNHhDLFFBQVEsQ0FBQ2h0QyxFQUFFLENBQUNvQixLQUFKLENBQXhCLEdBQXNDLElBQTlDO0FBQ0QsS0F0QzRCLENBdUM3Qjs7O0FBQ0EsUUFBSXBCLEVBQUUsQ0FBQzZ0QixNQUFQLEVBQWU7QUFDYnp5QixVQUFJLElBQUtndkMsV0FBVyxDQUFDcHFDLEVBQUUsQ0FBQzZ0QixNQUFKLEVBQVksS0FBWixFQUFtQjhkLEtBQUssQ0FBQ3h6QyxJQUF6QixDQUFaLEdBQThDLEdBQXREO0FBQ0Q7O0FBQ0QsUUFBSTZILEVBQUUsQ0FBQyt0QixZQUFQLEVBQXFCO0FBQ25CM3lCLFVBQUksSUFBS2d2QyxXQUFXLENBQUNwcUMsRUFBRSxDQUFDK3RCLFlBQUosRUFBa0IsSUFBbEIsRUFBd0I0ZCxLQUFLLENBQUN4ekMsSUFBOUIsQ0FBWixHQUFtRCxHQUEzRDtBQUNELEtBN0M0QixDQThDN0I7QUFDQTs7O0FBQ0EsUUFBSTZILEVBQUUsQ0FBQytsQyxVQUFILElBQWlCLENBQUMvbEMsRUFBRSxDQUFDOGxDLFNBQXpCLEVBQW9DO0FBQ2xDMXFDLFVBQUksSUFBSSxVQUFXNEUsRUFBRSxDQUFDK2xDLFVBQWQsR0FBNEIsR0FBcEM7QUFDRCxLQWxENEIsQ0FtRDdCOzs7QUFDQSxRQUFJL2xDLEVBQUUsQ0FBQzZQLFdBQVAsRUFBb0I7QUFDbEJ6VSxVQUFJLElBQUs2eEMsY0FBYyxDQUFDanRDLEVBQUUsQ0FBQzZQLFdBQUosRUFBaUI4N0IsS0FBakIsQ0FBZixHQUEwQyxHQUFsRDtBQUNELEtBdEQ0QixDQXVEN0I7OztBQUNBLFFBQUkzckMsRUFBRSxDQUFDNmEsS0FBUCxFQUFjO0FBQ1p6ZixVQUFJLElBQUksa0JBQW1CNEUsRUFBRSxDQUFDNmEsS0FBSCxDQUFTenRCLEtBQTVCLEdBQXFDLFlBQXJDLEdBQXFENFMsRUFBRSxDQUFDNmEsS0FBSCxDQUFTTyxRQUE5RCxHQUEwRSxjQUExRSxHQUE0RnBiLEVBQUUsQ0FBQzZhLEtBQUgsQ0FBU3ZKLFVBQXJHLEdBQW1ILElBQTNIO0FBQ0QsS0ExRDRCLENBMkQ3Qjs7O0FBQ0EsUUFBSXRSLEVBQUUsQ0FBQ21iLGNBQVAsRUFBdUI7QUFDckIsVUFBSUEsY0FBYyxHQUFHK3hCLGlCQUFpQixDQUFDbHRDLEVBQUQsRUFBSzJyQyxLQUFMLENBQXRDOztBQUNBLFVBQUl4d0IsY0FBSixFQUFvQjtBQUNsQi9mLFlBQUksSUFBSStmLGNBQWMsR0FBRyxHQUF6QjtBQUNEO0FBQ0Y7O0FBQ0QvZixRQUFJLEdBQUdBLElBQUksQ0FBQzdLLE9BQUwsQ0FBYSxJQUFiLEVBQW1CLEVBQW5CLElBQXlCLEdBQWhDLENBbEU2QixDQW1FN0I7O0FBQ0EsUUFBSXlQLEVBQUUsQ0FBQ2tyQyxRQUFQLEVBQWlCO0FBQ2Y5dkMsVUFBSSxHQUFHNEUsRUFBRSxDQUFDa3JDLFFBQUgsQ0FBWTl2QyxJQUFaLENBQVA7QUFDRCxLQXRFNEIsQ0F1RTdCOzs7QUFDQSxRQUFJNEUsRUFBRSxDQUFDZ3JDLGFBQVAsRUFBc0I7QUFDcEI1dkMsVUFBSSxHQUFHNEUsRUFBRSxDQUFDZ3JDLGFBQUgsQ0FBaUI1dkMsSUFBakIsQ0FBUDtBQUNEOztBQUNELFdBQU9BLElBQVA7QUFDRDs7QUFFRCxXQUFTMnhDLGFBQVQsQ0FBd0Ivc0MsRUFBeEIsRUFBNEIyckMsS0FBNUIsRUFBbUM7QUFDakMsUUFBSTNwQyxJQUFJLEdBQUdoQyxFQUFFLENBQUNpQyxVQUFkOztBQUNBLFFBQUksQ0FBQ0QsSUFBTCxFQUFXO0FBQUU7QUFBUTs7QUFDckIsUUFBSTlQLEdBQUcsR0FBRyxjQUFWO0FBQ0EsUUFBSWk3QyxVQUFVLEdBQUcsS0FBakI7QUFDQSxRQUFJaitDLENBQUosRUFBT2lDLENBQVAsRUFBVWc1QixHQUFWLEVBQWVpakIsV0FBZjs7QUFDQSxTQUFLbCtDLENBQUMsR0FBRyxDQUFKLEVBQU9pQyxDQUFDLEdBQUc2USxJQUFJLENBQUM3UyxNQUFyQixFQUE2QkQsQ0FBQyxHQUFHaUMsQ0FBakMsRUFBb0NqQyxDQUFDLEVBQXJDLEVBQXlDO0FBQ3ZDaTdCLFNBQUcsR0FBR25vQixJQUFJLENBQUM5UyxDQUFELENBQVY7QUFDQWsrQyxpQkFBVyxHQUFHLElBQWQ7QUFDQSxVQUFJQyxHQUFHLEdBQUcxQixLQUFLLENBQUMxcEMsVUFBTixDQUFpQmtvQixHQUFHLENBQUM3d0IsSUFBckIsQ0FBVjs7QUFDQSxVQUFJK3pDLEdBQUosRUFBUztBQUNQO0FBQ0E7QUFDQUQsbUJBQVcsR0FBRyxDQUFDLENBQUNDLEdBQUcsQ0FBQ3J0QyxFQUFELEVBQUttcUIsR0FBTCxFQUFVd2hCLEtBQUssQ0FBQ3h6QyxJQUFoQixDQUFuQjtBQUNEOztBQUNELFVBQUlpMUMsV0FBSixFQUFpQjtBQUNmRCxrQkFBVSxHQUFHLElBQWI7QUFDQWo3QyxXQUFHLElBQUksYUFBY2k0QixHQUFHLENBQUM3d0IsSUFBbEIsR0FBMEIsZUFBMUIsR0FBNkM2d0IsR0FBRyxDQUFDTyxPQUFqRCxHQUE0RCxJQUE1RCxJQUFvRVAsR0FBRyxDQUFDLzhCLEtBQUosR0FBYSxhQUFjKzhCLEdBQUcsQ0FBQy84QixLQUFsQixHQUEyQixlQUEzQixHQUE4Q21CLElBQUksQ0FBQ0MsU0FBTCxDQUFlMjdCLEdBQUcsQ0FBQy84QixLQUFuQixDQUEzRCxHQUF5RixFQUE3SixLQUFvSys4QixHQUFHLENBQUNvRCxHQUFKLEdBQVcsWUFBYXBELEdBQUcsQ0FBQ29ELEdBQWpCLEdBQXdCLElBQW5DLEdBQTJDLEVBQS9NLEtBQXNOcEQsR0FBRyxDQUFDSyxTQUFKLEdBQWlCLGdCQUFpQmo4QixJQUFJLENBQUNDLFNBQUwsQ0FBZTI3QixHQUFHLENBQUNLLFNBQW5CLENBQWxDLEdBQW9FLEVBQTFSLElBQWdTLElBQXZTO0FBQ0Q7QUFDRjs7QUFDRCxRQUFJMmlCLFVBQUosRUFBZ0I7QUFDZCxhQUFPajdDLEdBQUcsQ0FBQ3RFLEtBQUosQ0FBVSxDQUFWLEVBQWEsQ0FBQyxDQUFkLElBQW1CLEdBQTFCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTcy9DLGlCQUFULENBQTRCbHRDLEVBQTVCLEVBQWdDMnJDLEtBQWhDLEVBQXVDO0FBQ3JDLFFBQUlELEdBQUcsR0FBRzFyQyxFQUFFLENBQUMzRSxRQUFILENBQVksQ0FBWixDQUFWOztBQUNBLFFBQUksa0JBQWtCLFlBQWxCLEtBQ0YyRSxFQUFFLENBQUMzRSxRQUFILENBQVlsTSxNQUFaLEtBQXVCLENBQXZCLElBQTRCdThDLEdBQUcsQ0FBQ3hxQyxJQUFKLEtBQWEsQ0FEdkMsQ0FBSixFQUVHO0FBQ0R5cUMsV0FBSyxDQUFDeHpDLElBQU4sQ0FBVyxpRUFBWDtBQUNEOztBQUNELFFBQUl1ekMsR0FBRyxDQUFDeHFDLElBQUosS0FBYSxDQUFqQixFQUFvQjtBQUNsQixVQUFJb3NDLGVBQWUsR0FBRzdCLFFBQVEsQ0FBQ0MsR0FBRCxFQUFNQyxLQUFLLENBQUMxeUMsT0FBWixDQUE5QjtBQUNBLGFBQVEsdUNBQXdDcTBDLGVBQWUsQ0FBQzlsQyxNQUF4RCxHQUFrRSxxQkFBbEUsR0FBMkY4bEMsZUFBZSxDQUFDajJCLGVBQWhCLENBQWdDdm9CLEdBQWhDLENBQW9DLFVBQVV3aEMsSUFBVixFQUFnQjtBQUFFLGVBQVEsZ0JBQWdCQSxJQUFoQixHQUF1QixHQUEvQjtBQUFzQyxPQUE1RixFQUE4Rng5QixJQUE5RixDQUFtRyxHQUFuRyxDQUEzRixHQUFzTSxJQUE5TTtBQUNEO0FBQ0Y7O0FBRUQsV0FBU202QyxjQUFULENBQ0VuZ0MsS0FERixFQUVFNitCLEtBRkYsRUFHRTtBQUNBLFdBQVEscUJBQXNCaC9DLE1BQU0sQ0FBQytGLElBQVAsQ0FBWW9hLEtBQVosRUFBbUJoZSxHQUFuQixDQUF1QixVQUFVaUIsR0FBVixFQUFlO0FBQ2hFLGFBQU93OUMsYUFBYSxDQUFDeDlDLEdBQUQsRUFBTStjLEtBQUssQ0FBQy9jLEdBQUQsQ0FBWCxFQUFrQjQ3QyxLQUFsQixDQUFwQjtBQUNELEtBRjJCLEVBRXpCNzRDLElBRnlCLENBRXBCLEdBRm9CLENBQXRCLEdBRVUsSUFGbEI7QUFHRDs7QUFFRCxXQUFTeTZDLGFBQVQsQ0FDRXg5QyxHQURGLEVBRUVpUSxFQUZGLEVBR0UyckMsS0FIRixFQUlFO0FBQ0EsUUFBSTNyQyxFQUFFLENBQUMwbUMsR0FBSCxJQUFVLENBQUMxbUMsRUFBRSxDQUFDaXNDLFlBQWxCLEVBQWdDO0FBQzlCLGFBQU91QixnQkFBZ0IsQ0FBQ3o5QyxHQUFELEVBQU1pUSxFQUFOLEVBQVUyckMsS0FBVixDQUF2QjtBQUNEOztBQUNELFFBQUkxN0MsRUFBRSxHQUFHLGNBQWU5QixNQUFNLENBQUM2UixFQUFFLENBQUM4bEMsU0FBSixDQUFyQixHQUF1QyxJQUF2QyxHQUNQLFNBRE8sSUFDTTlsQyxFQUFFLENBQUM3RSxHQUFILEtBQVcsVUFBWCxHQUNUNkUsRUFBRSxDQUFDd2xDLEVBQUgsR0FDSXhsQyxFQUFFLENBQUN3bEMsRUFBSixHQUFVLEdBQVYsSUFBaUI2RyxXQUFXLENBQUNyc0MsRUFBRCxFQUFLMnJDLEtBQUwsQ0FBWCxJQUEwQixXQUEzQyxJQUEwRCxZQUQ3RCxHQUVFVSxXQUFXLENBQUNyc0MsRUFBRCxFQUFLMnJDLEtBQUwsQ0FBWCxJQUEwQixXQUhuQixHQUlUQyxVQUFVLENBQUM1ckMsRUFBRCxFQUFLMnJDLEtBQUwsQ0FMUCxJQUtzQixHQUwvQjtBQU1BLFdBQVEsVUFBVTU3QyxHQUFWLEdBQWdCLE1BQWhCLEdBQXlCRSxFQUF6QixHQUE4QixHQUF0QztBQUNEOztBQUVELFdBQVN1OUMsZ0JBQVQsQ0FDRXo5QyxHQURGLEVBRUVpUSxFQUZGLEVBR0UyckMsS0FIRixFQUlFO0FBQ0EsUUFBSTNmLEdBQUcsR0FBR2hzQixFQUFFLENBQUMwbUMsR0FBYjtBQUNBLFFBQUlDLEtBQUssR0FBRzNtQyxFQUFFLENBQUMybUMsS0FBZjtBQUNBLFFBQUlFLFNBQVMsR0FBRzdtQyxFQUFFLENBQUM2bUMsU0FBSCxHQUFnQixNQUFPN21DLEVBQUUsQ0FBQzZtQyxTQUExQixHQUF3QyxFQUF4RDtBQUNBLFFBQUlDLFNBQVMsR0FBRzltQyxFQUFFLENBQUM4bUMsU0FBSCxHQUFnQixNQUFPOW1DLEVBQUUsQ0FBQzhtQyxTQUExQixHQUF3QyxFQUF4RDtBQUNBOW1DLE1BQUUsQ0FBQ2lzQyxZQUFILEdBQWtCLElBQWxCLENBTEEsQ0FLd0I7O0FBQ3hCLFdBQU8sU0FBU2pnQixHQUFULEdBQWUsSUFBZixHQUNMLFdBREssR0FDUzJhLEtBRFQsR0FDaUJFLFNBRGpCLEdBQzZCQyxTQUQ3QixHQUN5QyxJQUR6QyxHQUVILFNBRkcsR0FFVXlHLGFBQWEsQ0FBQ3g5QyxHQUFELEVBQU1pUSxFQUFOLEVBQVUyckMsS0FBVixDQUZ2QixHQUdMLElBSEY7QUFJRDs7QUFFRCxXQUFTVSxXQUFULENBQ0Vyc0MsRUFERixFQUVFMnJDLEtBRkYsRUFHRThCLFNBSEYsRUFJRUMsYUFKRixFQUtFQyxVQUxGLEVBTUU7QUFDQSxRQUFJdHlDLFFBQVEsR0FBRzJFLEVBQUUsQ0FBQzNFLFFBQWxCOztBQUNBLFFBQUlBLFFBQVEsQ0FBQ2xNLE1BQWIsRUFBcUI7QUFDbkIsVUFBSXkrQyxJQUFJLEdBQUd2eUMsUUFBUSxDQUFDLENBQUQsQ0FBbkIsQ0FEbUIsQ0FFbkI7O0FBQ0EsVUFBSUEsUUFBUSxDQUFDbE0sTUFBVCxLQUFvQixDQUFwQixJQUNGeStDLElBQUksQ0FBQ2xILEdBREgsSUFFRmtILElBQUksQ0FBQ3p5QyxHQUFMLEtBQWEsVUFGWCxJQUdGeXlDLElBQUksQ0FBQ3p5QyxHQUFMLEtBQWEsTUFIZixFQUlFO0FBQ0EsZUFBTyxDQUFDdXlDLGFBQWEsSUFBSTlCLFVBQWxCLEVBQThCZ0MsSUFBOUIsRUFBb0NqQyxLQUFwQyxDQUFQO0FBQ0Q7O0FBQ0QsVUFBSXB3QixpQkFBaUIsR0FBR2t5QixTQUFTLEdBQzdCSSxvQkFBb0IsQ0FBQ3h5QyxRQUFELEVBQVdzd0MsS0FBSyxDQUFDSixjQUFqQixDQURTLEdBRTdCLENBRko7QUFHQSxVQUFJOEIsR0FBRyxHQUFHTSxVQUFVLElBQUlHLE9BQXhCO0FBQ0EsYUFBUSxNQUFPenlDLFFBQVEsQ0FBQ3ZNLEdBQVQsQ0FBYSxVQUFVMkIsQ0FBVixFQUFhO0FBQUUsZUFBTzQ4QyxHQUFHLENBQUM1OEMsQ0FBRCxFQUFJazdDLEtBQUosQ0FBVjtBQUF1QixPQUFuRCxFQUFxRDc0QyxJQUFyRCxDQUEwRCxHQUExRCxDQUFQLEdBQXlFLEdBQXpFLElBQWdGeW9CLGlCQUFpQixHQUFJLE1BQU1BLGlCQUFWLEdBQStCLEVBQWhJLENBQVI7QUFDRDtBQUNGLEdBOXNVb0IsQ0FndFVyQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU3N5QixvQkFBVCxDQUNFeHlDLFFBREYsRUFFRWt3QyxjQUZGLEVBR0U7QUFDQSxRQUFJcjVDLEdBQUcsR0FBRyxDQUFWOztBQUNBLFNBQUssSUFBSWhELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdtTSxRQUFRLENBQUNsTSxNQUE3QixFQUFxQ0QsQ0FBQyxFQUF0QyxFQUEwQztBQUN4QyxVQUFJOFEsRUFBRSxHQUFHM0UsUUFBUSxDQUFDbk0sQ0FBRCxDQUFqQjs7QUFDQSxVQUFJOFEsRUFBRSxDQUFDa0IsSUFBSCxLQUFZLENBQWhCLEVBQW1CO0FBQ2pCO0FBQ0Q7O0FBQ0QsVUFBSTZzQyxrQkFBa0IsQ0FBQy90QyxFQUFELENBQWxCLElBQ0NBLEVBQUUsQ0FBQ2luQyxZQUFILElBQW1Cam5DLEVBQUUsQ0FBQ2luQyxZQUFILENBQWdCamlCLElBQWhCLENBQXFCLFVBQVV2MEIsQ0FBVixFQUFhO0FBQUUsZUFBT3M5QyxrQkFBa0IsQ0FBQ3Q5QyxDQUFDLENBQUNtMUMsS0FBSCxDQUF6QjtBQUFxQyxPQUF6RSxDQUR4QixFQUNxRztBQUNuRzF6QyxXQUFHLEdBQUcsQ0FBTjtBQUNBO0FBQ0Q7O0FBQ0QsVUFBSXE1QyxjQUFjLENBQUN2ckMsRUFBRCxDQUFkLElBQ0NBLEVBQUUsQ0FBQ2luQyxZQUFILElBQW1Cam5DLEVBQUUsQ0FBQ2luQyxZQUFILENBQWdCamlCLElBQWhCLENBQXFCLFVBQVV2MEIsQ0FBVixFQUFhO0FBQUUsZUFBTzg2QyxjQUFjLENBQUM5NkMsQ0FBQyxDQUFDbTFDLEtBQUgsQ0FBckI7QUFBaUMsT0FBckUsQ0FEeEIsRUFDaUc7QUFDL0YxekMsV0FBRyxHQUFHLENBQU47QUFDRDtBQUNGOztBQUNELFdBQU9BLEdBQVA7QUFDRDs7QUFFRCxXQUFTNjdDLGtCQUFULENBQTZCL3RDLEVBQTdCLEVBQWlDO0FBQy9CLFdBQU9BLEVBQUUsQ0FBQzBtQyxHQUFILEtBQVczNUMsU0FBWCxJQUF3QmlULEVBQUUsQ0FBQzdFLEdBQUgsS0FBVyxVQUFuQyxJQUFpRDZFLEVBQUUsQ0FBQzdFLEdBQUgsS0FBVyxNQUFuRTtBQUNEOztBQUVELFdBQVMyeUMsT0FBVCxDQUFrQmp4QyxJQUFsQixFQUF3Qjh1QyxLQUF4QixFQUErQjtBQUM3QixRQUFJOXVDLElBQUksQ0FBQ3FFLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixhQUFPMHFDLFVBQVUsQ0FBQy91QyxJQUFELEVBQU84dUMsS0FBUCxDQUFqQjtBQUNEOztBQUFDLFFBQUk5dUMsSUFBSSxDQUFDcUUsSUFBTCxLQUFjLENBQWQsSUFBbUJyRSxJQUFJLENBQUNULFNBQTVCLEVBQXVDO0FBQ3ZDLGFBQU80eEMsVUFBVSxDQUFDbnhDLElBQUQsQ0FBakI7QUFDRCxLQUZDLE1BRUs7QUFDTCxhQUFPb3hDLE9BQU8sQ0FBQ3B4QyxJQUFELENBQWQ7QUFDRDtBQUNGOztBQUVELFdBQVNveEMsT0FBVCxDQUFrQjN5QyxJQUFsQixFQUF3QjtBQUN0QixXQUFRLFNBQVNBLElBQUksQ0FBQzRGLElBQUwsS0FBYyxDQUFkLEdBQ2I1RixJQUFJLENBQUNnVyxVQURRLENBQ0c7QUFESCxNQUViNDhCLHdCQUF3QixDQUFDMy9DLElBQUksQ0FBQ0MsU0FBTCxDQUFlOE0sSUFBSSxDQUFDQSxJQUFwQixDQUFELENBRnBCLElBRW1ELEdBRjNEO0FBR0Q7O0FBRUQsV0FBUzB5QyxVQUFULENBQXFCNU4sT0FBckIsRUFBOEI7QUFDNUIsV0FBUSxRQUFTN3hDLElBQUksQ0FBQ0MsU0FBTCxDQUFlNHhDLE9BQU8sQ0FBQzlrQyxJQUF2QixDQUFULEdBQXlDLEdBQWpEO0FBQ0Q7O0FBRUQsV0FBU2d4QyxPQUFULENBQWtCdHNDLEVBQWxCLEVBQXNCMnJDLEtBQXRCLEVBQTZCO0FBQzNCLFFBQUl6RSxRQUFRLEdBQUdsbkMsRUFBRSxDQUFDa25DLFFBQUgsSUFBZSxXQUE5QjtBQUNBLFFBQUk3ckMsUUFBUSxHQUFHZ3hDLFdBQVcsQ0FBQ3JzQyxFQUFELEVBQUsyckMsS0FBTCxDQUExQjtBQUNBLFFBQUl6NUMsR0FBRyxHQUFHLFFBQVFnMUMsUUFBUixJQUFvQjdyQyxRQUFRLEdBQUksTUFBTUEsUUFBVixHQUFzQixFQUFsRCxDQUFWO0FBQ0EsUUFBSWlPLEtBQUssR0FBR3RKLEVBQUUsQ0FBQ3NKLEtBQUgsSUFBYSxNQUFPdEosRUFBRSxDQUFDc0osS0FBSCxDQUFTeGEsR0FBVCxDQUFhLFVBQVVvQyxDQUFWLEVBQWE7QUFBRSxhQUFTWixRQUFRLENBQUNZLENBQUMsQ0FBQ29JLElBQUgsQ0FBVCxHQUFxQixHQUFyQixHQUE0QnBJLENBQUMsQ0FBQzlELEtBQXRDO0FBQWdELEtBQTVFLEVBQThFMEYsSUFBOUUsQ0FBbUYsR0FBbkYsQ0FBUCxHQUFrRyxHQUEzSDtBQUNBLFFBQUlxN0MsT0FBTyxHQUFHbnVDLEVBQUUsQ0FBQ290QixRQUFILENBQVksUUFBWixDQUFkOztBQUNBLFFBQUksQ0FBQzlqQixLQUFLLElBQUk2a0MsT0FBVixLQUFzQixDQUFDOXlDLFFBQTNCLEVBQXFDO0FBQ25DbkosU0FBRyxJQUFJLE9BQVA7QUFDRDs7QUFDRCxRQUFJb1gsS0FBSixFQUFXO0FBQ1RwWCxTQUFHLElBQUksTUFBTW9YLEtBQWI7QUFDRDs7QUFDRCxRQUFJNmtDLE9BQUosRUFBYTtBQUNYajhDLFNBQUcsSUFBSSxDQUFDb1gsS0FBSyxHQUFHLEVBQUgsR0FBUSxPQUFkLElBQXlCLEdBQXpCLEdBQStCNmtDLE9BQXRDO0FBQ0Q7O0FBQ0QsV0FBT2o4QyxHQUFHLEdBQUcsR0FBYjtBQUNELEdBbnhVb0IsQ0FxeFVyQjs7O0FBQ0EsV0FBU3E2QyxZQUFULENBQ0U2QixhQURGLEVBRUVwdUMsRUFGRixFQUdFMnJDLEtBSEYsRUFJRTtBQUNBLFFBQUl0d0MsUUFBUSxHQUFHMkUsRUFBRSxDQUFDbWIsY0FBSCxHQUFvQixJQUFwQixHQUEyQmt4QixXQUFXLENBQUNyc0MsRUFBRCxFQUFLMnJDLEtBQUwsRUFBWSxJQUFaLENBQXJEO0FBQ0EsV0FBUSxRQUFReUMsYUFBUixHQUF3QixHQUF4QixHQUErQjVCLFNBQVMsQ0FBQ3hzQyxFQUFELEVBQUsyckMsS0FBTCxDQUF4QyxJQUF3RHR3QyxRQUFRLEdBQUksTUFBTUEsUUFBVixHQUFzQixFQUF0RixJQUE0RixHQUFwRztBQUNEOztBQUVELFdBQVMyeEMsUUFBVCxDQUFtQjVyQyxLQUFuQixFQUEwQjtBQUN4QixRQUFJbFAsR0FBRyxHQUFHLEVBQVY7O0FBQ0EsU0FBSyxJQUFJaEQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2tTLEtBQUssQ0FBQ2pTLE1BQTFCLEVBQWtDRCxDQUFDLEVBQW5DLEVBQXVDO0FBQ3JDLFVBQUk2VCxJQUFJLEdBQUczQixLQUFLLENBQUNsUyxDQUFELENBQWhCO0FBQ0E7O0FBQ0E7QUFDRWdELFdBQUcsSUFBSSxPQUFRNlEsSUFBSSxDQUFDekosSUFBYixHQUFxQixLQUFyQixHQUE4QjQwQyx3QkFBd0IsQ0FBQ25yQyxJQUFJLENBQUMzVixLQUFOLENBQXRELEdBQXNFLEdBQTdFO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPOEUsR0FBRyxDQUFDdEUsS0FBSixDQUFVLENBQVYsRUFBYSxDQUFDLENBQWQsQ0FBUDtBQUNELEdBenlVb0IsQ0EyeVVyQjs7O0FBQ0EsV0FBU3NnRCx3QkFBVCxDQUFtQzV5QyxJQUFuQyxFQUF5QztBQUN2QyxXQUFPQSxJQUFJLENBQ1IvSyxPQURJLENBQ0ksU0FESixFQUNlLFNBRGYsRUFFSkEsT0FGSSxDQUVJLFNBRkosRUFFZSxTQUZmLENBQVA7QUFHRDtBQUVEO0FBRUE7QUFDQTs7O0FBQ0EsTUFBSTg5QyxtQkFBbUIsR0FBRyxJQUFJOXVCLE1BQUosQ0FBVyxRQUFRLENBQzNDLDRFQUNBLHFFQURBLEdBRUEsc0RBSDJDLEVBSTNDdHdCLEtBSjJDLENBSXJDLEdBSnFDLEVBSWhDNkQsSUFKZ0MsQ0FJM0IsU0FKMkIsQ0FBUixHQUlOLEtBSkwsQ0FBMUIsQ0F0elVxQixDQTR6VXJCOztBQUNBLE1BQUl3N0MsZ0JBQWdCLEdBQUcsSUFBSS91QixNQUFKLENBQVcsUUFDaEMsb0JBRHdDLENBRXhDdHdCLEtBRndDLENBRWxDLEdBRmtDLEVBRTdCNkQsSUFGNkIsQ0FFeEIsdUJBRndCLENBQVIsR0FFVyxtQkFGdEIsQ0FBdkIsQ0E3elVxQixDQWkwVXJCOztBQUNBLE1BQUl5N0MsYUFBYSxHQUFHLGdHQUFwQixDQWwwVXFCLENBbzBVckI7O0FBQ0EsV0FBU0MsWUFBVCxDQUF1QjlDLEdBQXZCLEVBQTRCO0FBQzFCLFFBQUkrQyxNQUFNLEdBQUcsRUFBYjs7QUFDQSxRQUFJL0MsR0FBSixFQUFTO0FBQ1BnRCxlQUFTLENBQUNoRCxHQUFELEVBQU0rQyxNQUFOLENBQVQ7QUFDRDs7QUFDRCxXQUFPQSxNQUFQO0FBQ0Q7O0FBRUQsV0FBU0MsU0FBVCxDQUFvQjd4QyxJQUFwQixFQUEwQjR4QyxNQUExQixFQUFrQztBQUNoQyxRQUFJNXhDLElBQUksQ0FBQ3FFLElBQUwsS0FBYyxDQUFsQixFQUFxQjtBQUNuQixXQUFLLElBQUk1SCxJQUFULElBQWlCdUQsSUFBSSxDQUFDdXdCLFFBQXRCLEVBQWdDO0FBQzlCLFlBQUk4VixLQUFLLENBQUN4dEMsSUFBTixDQUFXNEQsSUFBWCxDQUFKLEVBQXNCO0FBQ3BCLGNBQUlsTSxLQUFLLEdBQUd5UCxJQUFJLENBQUN1d0IsUUFBTCxDQUFjOXpCLElBQWQsQ0FBWjs7QUFDQSxjQUFJbE0sS0FBSixFQUFXO0FBQ1QsZ0JBQUlrTSxJQUFJLEtBQUssT0FBYixFQUFzQjtBQUNwQnExQyxzQkFBUSxDQUFDOXhDLElBQUQsRUFBUSxhQUFhelAsS0FBYixHQUFxQixJQUE3QixFQUFvQ3FoRCxNQUFwQyxDQUFSO0FBQ0QsYUFGRCxNQUVPLElBQUl4TCxJQUFJLENBQUN2dEMsSUFBTCxDQUFVNEQsSUFBVixDQUFKLEVBQXFCO0FBQzFCczFDLHdCQUFVLENBQUN4aEQsS0FBRCxFQUFTa00sSUFBSSxHQUFHLEtBQVAsR0FBZWxNLEtBQWYsR0FBdUIsSUFBaEMsRUFBdUNxaEQsTUFBdkMsQ0FBVjtBQUNELGFBRk0sTUFFQTtBQUNMSSw2QkFBZSxDQUFDemhELEtBQUQsRUFBU2tNLElBQUksR0FBRyxLQUFQLEdBQWVsTSxLQUFmLEdBQXVCLElBQWhDLEVBQXVDcWhELE1BQXZDLENBQWY7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFDRCxVQUFJNXhDLElBQUksQ0FBQ3hCLFFBQVQsRUFBbUI7QUFDakIsYUFBSyxJQUFJbk0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJOLElBQUksQ0FBQ3hCLFFBQUwsQ0FBY2xNLE1BQWxDLEVBQTBDRCxDQUFDLEVBQTNDLEVBQStDO0FBQzdDdy9DLG1CQUFTLENBQUM3eEMsSUFBSSxDQUFDeEIsUUFBTCxDQUFjbk0sQ0FBZCxDQUFELEVBQW1CdS9DLE1BQW5CLENBQVQ7QUFDRDtBQUNGO0FBQ0YsS0FwQkQsTUFvQk8sSUFBSTV4QyxJQUFJLENBQUNxRSxJQUFMLEtBQWMsQ0FBbEIsRUFBcUI7QUFDMUIydEMscUJBQWUsQ0FBQ2h5QyxJQUFJLENBQUN5VSxVQUFOLEVBQWtCelUsSUFBSSxDQUFDdkIsSUFBdkIsRUFBNkJtekMsTUFBN0IsQ0FBZjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU0csVUFBVCxDQUFxQjVpQixHQUFyQixFQUEwQjF3QixJQUExQixFQUFnQ216QyxNQUFoQyxFQUF3QztBQUN0QyxRQUFJSyxPQUFPLEdBQUc5aUIsR0FBRyxDQUFDejdCLE9BQUosQ0FBWWcrQyxhQUFaLEVBQTJCLEVBQTNCLENBQWQ7QUFDQSxRQUFJUSxZQUFZLEdBQUdELE9BQU8sQ0FBQ3AxQyxLQUFSLENBQWM0MEMsZ0JBQWQsQ0FBbkI7O0FBQ0EsUUFBSVMsWUFBWSxJQUFJRCxPQUFPLENBQUNsK0MsTUFBUixDQUFlbStDLFlBQVksQ0FBQ3IvQyxLQUFiLEdBQXFCLENBQXBDLE1BQTJDLEdBQS9ELEVBQW9FO0FBQ2xFKytDLFlBQU0sQ0FBQ3owQyxJQUFQLENBQ0UsNkRBQ0EsSUFEQSxHQUNRKzBDLFlBQVksQ0FBQyxDQUFELENBRHBCLEdBQzJCLG1CQUQzQixHQUNrRHp6QyxJQUFJLENBQUNxeEIsSUFBTCxFQUZwRDtBQUlEOztBQUNEa2lCLG1CQUFlLENBQUM3aUIsR0FBRCxFQUFNMXdCLElBQU4sRUFBWW16QyxNQUFaLENBQWY7QUFDRDs7QUFFRCxXQUFTRSxRQUFULENBQW1COXhDLElBQW5CLEVBQXlCdkIsSUFBekIsRUFBK0JtekMsTUFBL0IsRUFBdUM7QUFDckNJLG1CQUFlLENBQUNoeUMsSUFBSSxDQUFDNnBDLEdBQUwsSUFBWSxFQUFiLEVBQWlCcHJDLElBQWpCLEVBQXVCbXpDLE1BQXZCLENBQWY7QUFDQU8sbUJBQWUsQ0FBQ255QyxJQUFJLENBQUM4cEMsS0FBTixFQUFhLGFBQWIsRUFBNEJyckMsSUFBNUIsRUFBa0NtekMsTUFBbEMsQ0FBZjtBQUNBTyxtQkFBZSxDQUFDbnlDLElBQUksQ0FBQ2dxQyxTQUFOLEVBQWlCLGdCQUFqQixFQUFtQ3ZyQyxJQUFuQyxFQUF5Q216QyxNQUF6QyxDQUFmO0FBQ0FPLG1CQUFlLENBQUNueUMsSUFBSSxDQUFDaXFDLFNBQU4sRUFBaUIsZ0JBQWpCLEVBQW1DeHJDLElBQW5DLEVBQXlDbXpDLE1BQXpDLENBQWY7QUFDRDs7QUFFRCxXQUFTTyxlQUFULENBQ0VDLEtBREYsRUFFRS90QyxJQUZGLEVBR0U1RixJQUhGLEVBSUVtekMsTUFKRixFQUtFO0FBQ0EsUUFBSSxPQUFPUSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFVBQUk7QUFDRixZQUFJeDlDLFFBQUosQ0FBYyxTQUFTdzlDLEtBQVQsR0FBaUIsSUFBL0I7QUFDRCxPQUZELENBRUUsT0FBTzM3QyxDQUFQLEVBQVU7QUFDVm03QyxjQUFNLENBQUN6MEMsSUFBUCxDQUFhLGFBQWFrSCxJQUFiLEdBQW9CLEtBQXBCLEdBQTRCK3RDLEtBQTVCLEdBQW9DLG9CQUFwQyxHQUE0RDN6QyxJQUFJLENBQUNxeEIsSUFBTCxFQUF6RTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTa2lCLGVBQVQsQ0FBMEI3aUIsR0FBMUIsRUFBK0Ixd0IsSUFBL0IsRUFBcUNtekMsTUFBckMsRUFBNkM7QUFDM0MsUUFBSTtBQUNGLFVBQUloOUMsUUFBSixDQUFjLFlBQVl1NkIsR0FBMUI7QUFDRCxLQUZELENBRUUsT0FBTzE0QixDQUFQLEVBQVU7QUFDVixVQUFJeTdDLFlBQVksR0FBRy9pQixHQUFHLENBQUN6N0IsT0FBSixDQUFZZytDLGFBQVosRUFBMkIsRUFBM0IsRUFBK0I3MEMsS0FBL0IsQ0FBcUMyMEMsbUJBQXJDLENBQW5COztBQUNBLFVBQUlVLFlBQUosRUFBa0I7QUFDaEJOLGNBQU0sQ0FBQ3owQyxJQUFQLENBQ0Usc0RBQ0EsSUFEQSxHQUNRKzBDLFlBQVksQ0FBQyxDQUFELENBRHBCLEdBQzJCLHdCQUQzQixHQUN1RHp6QyxJQUFJLENBQUNxeEIsSUFBTCxFQUZ6RDtBQUlELE9BTEQsTUFLTztBQUNMOGhCLGNBQU0sQ0FBQ3owQyxJQUFQLENBQ0UseUJBQTBCMUcsQ0FBQyxDQUFDNDdDLE9BQTVCLEdBQXVDLFNBQXZDLEdBQ0EsTUFEQSxHQUNTbGpCLEdBRFQsR0FDZSxNQURmLEdBRUEsb0JBRkEsR0FFd0Ixd0IsSUFBSSxDQUFDcXhCLElBQUwsRUFGeEIsR0FFdUMsSUFIekM7QUFLRDtBQUNGO0FBQ0Y7QUFFRDs7O0FBRUEsV0FBU3dpQixjQUFULENBQXlCN2UsSUFBekIsRUFBK0JtZSxNQUEvQixFQUF1QztBQUNyQyxRQUFJO0FBQ0YsYUFBTyxJQUFJaDlDLFFBQUosQ0FBYTYrQixJQUFiLENBQVA7QUFDRCxLQUZELENBRUUsT0FBT2hzQixHQUFQLEVBQVk7QUFDWm1xQyxZQUFNLENBQUN6MEMsSUFBUCxDQUFZO0FBQUVzSyxXQUFHLEVBQUVBLEdBQVA7QUFBWWdzQixZQUFJLEVBQUVBO0FBQWxCLE9BQVo7QUFDQSxhQUFPbitCLElBQVA7QUFDRDtBQUNGOztBQUVELFdBQVNpOUMseUJBQVQsQ0FBb0NDLE9BQXBDLEVBQTZDO0FBQzNDLFFBQUluL0MsS0FBSyxHQUFHdkQsTUFBTSxDQUFDb0MsTUFBUCxDQUFjLElBQWQsQ0FBWjtBQUVBLFdBQU8sU0FBU3VnRCxrQkFBVCxDQUNMcGdDLFFBREssRUFFTGpXLE9BRkssRUFHTEwsRUFISyxFQUlMO0FBQ0FLLGFBQU8sR0FBR25ILE1BQU0sQ0FBQyxFQUFELEVBQUttSCxPQUFMLENBQWhCO0FBQ0EsVUFBSXMyQyxPQUFPLEdBQUd0MkMsT0FBTyxDQUFDZCxJQUFSLElBQWdCQSxJQUE5QjtBQUNBLGFBQU9jLE9BQU8sQ0FBQ2QsSUFBZjtBQUVBOztBQUNBO0FBQ0U7QUFDQSxZQUFJO0FBQ0YsY0FBSTFHLFFBQUosQ0FBYSxVQUFiO0FBQ0QsU0FGRCxDQUVFLE9BQU82QixDQUFQLEVBQVU7QUFDVixjQUFJQSxDQUFDLENBQUM3RixRQUFGLEdBQWFpTSxLQUFiLENBQW1CLGlCQUFuQixDQUFKLEVBQTJDO0FBQ3pDNjFDLG1CQUFPLENBQ0wsaUVBQ0EsdUVBREEsR0FFQSxrRUFGQSxHQUdBLGlFQUhBLEdBSUEsa0NBTEssQ0FBUDtBQU9EO0FBQ0Y7QUFDRixPQXJCRCxDQXVCQTs7QUFDQSxVQUFJeC9DLEdBQUcsR0FBR2tKLE9BQU8sQ0FBQ3FsQyxVQUFSLEdBQ05ud0MsTUFBTSxDQUFDOEssT0FBTyxDQUFDcWxDLFVBQVQsQ0FBTixHQUE2QnB2QixRQUR2QixHQUVOQSxRQUZKOztBQUdBLFVBQUloZixLQUFLLENBQUNILEdBQUQsQ0FBVCxFQUFnQjtBQUNkLGVBQU9HLEtBQUssQ0FBQ0gsR0FBRCxDQUFaO0FBQ0QsT0E3QkQsQ0ErQkE7OztBQUNBLFVBQUl5L0MsUUFBUSxHQUFHSCxPQUFPLENBQUNuZ0MsUUFBRCxFQUFXalcsT0FBWCxDQUF0QixDQWhDQSxDQWtDQTs7QUFDQTtBQUNFLFlBQUl1MkMsUUFBUSxDQUFDZixNQUFULElBQW1CZSxRQUFRLENBQUNmLE1BQVQsQ0FBZ0J0L0MsTUFBdkMsRUFBK0M7QUFDN0NvZ0QsaUJBQU8sQ0FDTCxrQ0FBa0NyZ0MsUUFBbEMsR0FBNkMsTUFBN0MsR0FDQXNnQyxRQUFRLENBQUNmLE1BQVQsQ0FBZ0IzL0MsR0FBaEIsQ0FBb0IsVUFBVXdFLENBQVYsRUFBYTtBQUFFLG1CQUFRLE9BQU9BLENBQWY7QUFBb0IsV0FBdkQsRUFBeURSLElBQXpELENBQThELElBQTlELENBREEsR0FDc0UsSUFGakUsRUFHTDhGLEVBSEssQ0FBUDtBQUtEOztBQUNELFlBQUk0MkMsUUFBUSxDQUFDQyxJQUFULElBQWlCRCxRQUFRLENBQUNDLElBQVQsQ0FBY3RnRCxNQUFuQyxFQUEyQztBQUN6Q3FnRCxrQkFBUSxDQUFDQyxJQUFULENBQWNweUMsT0FBZCxDQUFzQixVQUFVMUUsR0FBVixFQUFlO0FBQUUsbUJBQU9QLEdBQUcsQ0FBQ08sR0FBRCxFQUFNQyxFQUFOLENBQVY7QUFBc0IsV0FBN0Q7QUFDRDtBQUNGLE9BOUNELENBZ0RBOztBQUNBLFVBQUkxRyxHQUFHLEdBQUcsRUFBVjtBQUNBLFVBQUl3OUMsV0FBVyxHQUFHLEVBQWxCO0FBQ0F4OUMsU0FBRyxDQUFDc1YsTUFBSixHQUFhMm5DLGNBQWMsQ0FBQ0ssUUFBUSxDQUFDaG9DLE1BQVYsRUFBa0Jrb0MsV0FBbEIsQ0FBM0I7QUFDQXg5QyxTQUFHLENBQUNtbEIsZUFBSixHQUFzQm00QixRQUFRLENBQUNuNEIsZUFBVCxDQUF5QnZvQixHQUF6QixDQUE2QixVQUFVd2hDLElBQVYsRUFBZ0I7QUFDakUsZUFBTzZlLGNBQWMsQ0FBQzdlLElBQUQsRUFBT29mLFdBQVAsQ0FBckI7QUFDRCxPQUZxQixDQUF0QixDQXBEQSxDQXdEQTtBQUNBO0FBQ0E7O0FBQ0E7O0FBQ0E7QUFDRSxZQUFJLENBQUMsQ0FBQ0YsUUFBUSxDQUFDZixNQUFWLElBQW9CLENBQUNlLFFBQVEsQ0FBQ2YsTUFBVCxDQUFnQnQvQyxNQUF0QyxLQUFpRHVnRCxXQUFXLENBQUN2Z0QsTUFBakUsRUFBeUU7QUFDdkVvZ0QsaUJBQU8sQ0FDTCw0Q0FDQUcsV0FBVyxDQUFDNWdELEdBQVosQ0FBZ0IsVUFBVXN0QixHQUFWLEVBQWU7QUFDN0IsZ0JBQUk5WCxHQUFHLEdBQUc4WCxHQUFHLENBQUM5WCxHQUFkO0FBQ0EsZ0JBQUlnc0IsSUFBSSxHQUFHbFUsR0FBRyxDQUFDa1UsSUFBZjtBQUVBLG1CQUFTaHNCLEdBQUcsQ0FBQzdXLFFBQUosRUFBRCxHQUFtQixTQUFuQixHQUErQjZpQyxJQUEvQixHQUFzQyxJQUE5QztBQUNILFdBTEMsRUFLQ3g5QixJQUxELENBS00sSUFMTixDQUZLLEVBUUw4RixFQVJLLENBQVA7QUFVRDtBQUNGO0FBRUQsYUFBUTFJLEtBQUssQ0FBQ0gsR0FBRCxDQUFMLEdBQWFtQyxHQUFyQjtBQUNELEtBaEZEO0FBaUZEO0FBRUQ7OztBQUVBLFdBQVN5OUMscUJBQVQsQ0FBZ0NDLFdBQWhDLEVBQTZDO0FBQzNDLFdBQU8sU0FBU0MsY0FBVCxDQUF5QnJILFdBQXpCLEVBQXNDO0FBQzNDLGVBQVM2RyxPQUFULENBQ0VuZ0MsUUFERixFQUVFalcsT0FGRixFQUdFO0FBQ0EsWUFBSTYyQyxZQUFZLEdBQUduakQsTUFBTSxDQUFDb0MsTUFBUCxDQUFjeTVDLFdBQWQsQ0FBbkI7QUFDQSxZQUFJaUcsTUFBTSxHQUFHLEVBQWI7QUFDQSxZQUFJZ0IsSUFBSSxHQUFHLEVBQVg7O0FBQ0FLLG9CQUFZLENBQUMzM0MsSUFBYixHQUFvQixVQUFVUSxHQUFWLEVBQWVQLEdBQWYsRUFBb0I7QUFDdEMsV0FBQ0EsR0FBRyxHQUFHcTNDLElBQUgsR0FBVWhCLE1BQWQsRUFBc0J6MEMsSUFBdEIsQ0FBMkJyQixHQUEzQjtBQUNELFNBRkQ7O0FBSUEsWUFBSU0sT0FBSixFQUFhO0FBQ1g7QUFDQSxjQUFJQSxPQUFPLENBQUN6RyxPQUFaLEVBQXFCO0FBQ25CczlDLHdCQUFZLENBQUN0OUMsT0FBYixHQUNFLENBQUNnMkMsV0FBVyxDQUFDaDJDLE9BQVosSUFBdUIsRUFBeEIsRUFBNEJJLE1BQTVCLENBQW1DcUcsT0FBTyxDQUFDekcsT0FBM0MsQ0FERjtBQUVELFdBTFUsQ0FNWDs7O0FBQ0EsY0FBSXlHLE9BQU8sQ0FBQ2dKLFVBQVosRUFBd0I7QUFDdEI2dEMsd0JBQVksQ0FBQzd0QyxVQUFiLEdBQTBCblEsTUFBTSxDQUM5Qm5GLE1BQU0sQ0FBQ29DLE1BQVAsQ0FBY3k1QyxXQUFXLENBQUN2bUMsVUFBWixJQUEwQixJQUF4QyxDQUQ4QixFQUU5QmhKLE9BQU8sQ0FBQ2dKLFVBRnNCLENBQWhDO0FBSUQsV0FaVSxDQWFYOzs7QUFDQSxlQUFLLElBQUlsUyxHQUFULElBQWdCa0osT0FBaEIsRUFBeUI7QUFDdkIsZ0JBQUlsSixHQUFHLEtBQUssU0FBUixJQUFxQkEsR0FBRyxLQUFLLFlBQWpDLEVBQStDO0FBQzdDKy9DLDBCQUFZLENBQUMvL0MsR0FBRCxDQUFaLEdBQW9Ca0osT0FBTyxDQUFDbEosR0FBRCxDQUEzQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxZQUFJeS9DLFFBQVEsR0FBR0ksV0FBVyxDQUFDMWdDLFFBQUQsRUFBVzRnQyxZQUFYLENBQTFCO0FBQ0E7QUFDRXJCLGdCQUFNLENBQUN6MEMsSUFBUCxDQUFZM0ksS0FBWixDQUFrQm85QyxNQUFsQixFQUEwQkQsWUFBWSxDQUFDZ0IsUUFBUSxDQUFDOUQsR0FBVixDQUF0QztBQUNEO0FBQ0Q4RCxnQkFBUSxDQUFDZixNQUFULEdBQWtCQSxNQUFsQjtBQUNBZSxnQkFBUSxDQUFDQyxJQUFULEdBQWdCQSxJQUFoQjtBQUNBLGVBQU9ELFFBQVA7QUFDRDs7QUFFRCxhQUFPO0FBQ0xILGVBQU8sRUFBRUEsT0FESjtBQUVMQywwQkFBa0IsRUFBRUYseUJBQXlCLENBQUNDLE9BQUQ7QUFGeEMsT0FBUDtBQUlELEtBOUNEO0FBK0NEO0FBRUQ7QUFFQTtBQUNBO0FBQ0E7OztBQUNBLE1BQUlRLGNBQWMsR0FBR0YscUJBQXFCLENBQUMsU0FBU0MsV0FBVCxDQUN6QzFnQyxRQUR5QyxFQUV6Q2pXLE9BRnlDLEVBR3pDO0FBQ0EsUUFBSXl5QyxHQUFHLEdBQUd2SCxLQUFLLENBQUNqMUIsUUFBUSxDQUFDeWQsSUFBVCxFQUFELEVBQWtCMXpCLE9BQWxCLENBQWY7O0FBQ0EsUUFBSUEsT0FBTyxDQUFDNHZDLFFBQVIsS0FBcUIsS0FBekIsRUFBZ0M7QUFDOUJBLGNBQVEsQ0FBQzZDLEdBQUQsRUFBTXp5QyxPQUFOLENBQVI7QUFDRDs7QUFDRCxRQUFJcTNCLElBQUksR0FBR21iLFFBQVEsQ0FBQ0MsR0FBRCxFQUFNenlDLE9BQU4sQ0FBbkI7QUFDQSxXQUFPO0FBQ0x5eUMsU0FBRyxFQUFFQSxHQURBO0FBRUxsa0MsWUFBTSxFQUFFOG9CLElBQUksQ0FBQzlvQixNQUZSO0FBR0w2UCxxQkFBZSxFQUFFaVosSUFBSSxDQUFDalo7QUFIakIsS0FBUDtBQUtELEdBZHlDLENBQTFDO0FBZ0JBOztBQUVBLE1BQUkwSSxLQUFLLEdBQUc4dkIsY0FBYyxDQUFDckgsV0FBRCxDQUExQjtBQUNBLE1BQUk4RyxrQkFBa0IsR0FBR3Z2QixLQUFLLENBQUN1dkIsa0JBQS9CO0FBRUE7QUFFQTs7QUFDQSxNQUFJUyxHQUFKOztBQUNBLFdBQVNDLGVBQVQsQ0FBMEJDLElBQTFCLEVBQWdDO0FBQzlCRixPQUFHLEdBQUdBLEdBQUcsSUFBSTd0QixRQUFRLENBQUM1SSxhQUFULENBQXVCLEtBQXZCLENBQWI7QUFDQXkyQixPQUFHLENBQUN0bkIsU0FBSixHQUFnQnduQixJQUFJLEdBQUcsa0JBQUgsR0FBd0IsaUJBQTVDO0FBQ0EsV0FBT0YsR0FBRyxDQUFDdG5CLFNBQUosQ0FBYzk0QixPQUFkLENBQXNCLE9BQXRCLElBQWlDLENBQXhDO0FBQ0QsR0FwbFZvQixDQXNsVnJCOzs7QUFDQSxNQUFJcXhDLG9CQUFvQixHQUFHbnJDLFNBQVMsR0FBR202QyxlQUFlLENBQUMsS0FBRCxDQUFsQixHQUE0QixLQUFoRSxDQXZsVnFCLENBd2xWckI7O0FBQ0EsTUFBSWxOLDJCQUEyQixHQUFHanRDLFNBQVMsR0FBR202QyxlQUFlLENBQUMsSUFBRCxDQUFsQixHQUEyQixLQUF0RTtBQUVBOztBQUVBLE1BQUlFLFlBQVksR0FBR2xnRCxNQUFNLENBQUMsVUFBVW1LLEVBQVYsRUFBYztBQUN0QyxRQUFJNkYsRUFBRSxHQUFHc2lCLEtBQUssQ0FBQ25vQixFQUFELENBQWQ7QUFDQSxXQUFPNkYsRUFBRSxJQUFJQSxFQUFFLENBQUN5b0IsU0FBaEI7QUFDRCxHQUh3QixDQUF6QjtBQUtBLE1BQUkwbkIsS0FBSyxHQUFHN2pDLEdBQUcsQ0FBQzllLFNBQUosQ0FBYzZzQixNQUExQjs7QUFDQS9OLEtBQUcsQ0FBQzllLFNBQUosQ0FBYzZzQixNQUFkLEdBQXVCLFVBQ3JCcmEsRUFEcUIsRUFFckJpTyxTQUZxQixFQUdyQjtBQUNBak8sTUFBRSxHQUFHQSxFQUFFLElBQUlzaUIsS0FBSyxDQUFDdGlCLEVBQUQsQ0FBaEI7QUFFQTs7QUFDQSxRQUFJQSxFQUFFLEtBQUtraUIsUUFBUSxDQUFDZ2IsSUFBaEIsSUFBd0JsOUIsRUFBRSxLQUFLa2lCLFFBQVEsQ0FBQ2t1QixlQUE1QyxFQUE2RDtBQUMzRCx3QkFBa0IsWUFBbEIsSUFBa0NqNEMsSUFBSSxDQUNwQywwRUFEb0MsQ0FBdEM7QUFHQSxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJYyxPQUFPLEdBQUcsS0FBS0csUUFBbkIsQ0FYQSxDQVlBOztBQUNBLFFBQUksQ0FBQ0gsT0FBTyxDQUFDdU8sTUFBYixFQUFxQjtBQUNuQixVQUFJMEgsUUFBUSxHQUFHalcsT0FBTyxDQUFDaVcsUUFBdkI7O0FBQ0EsVUFBSUEsUUFBSixFQUFjO0FBQ1osWUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXhCLEVBQWtDO0FBQ2hDLGNBQUlBLFFBQVEsQ0FBQ3RlLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBM0IsRUFBZ0M7QUFDOUJzZSxvQkFBUSxHQUFHZ2hDLFlBQVksQ0FBQ2hoQyxRQUFELENBQXZCO0FBQ0E7O0FBQ0EsZ0JBQUksa0JBQWtCLFlBQWxCLElBQWtDLENBQUNBLFFBQXZDLEVBQWlEO0FBQy9DL1csa0JBQUksQ0FDRCw2Q0FBOENjLE9BQU8sQ0FBQ2lXLFFBRHJELEVBRUYsSUFGRSxDQUFKO0FBSUQ7QUFDRjtBQUNGLFNBWEQsTUFXTyxJQUFJQSxRQUFRLENBQUM0WixRQUFiLEVBQXVCO0FBQzVCNVosa0JBQVEsR0FBR0EsUUFBUSxDQUFDdVosU0FBcEI7QUFDRCxTQUZNLE1BRUE7QUFDTDtBQUNFdHdCLGdCQUFJLENBQUMsNkJBQTZCK1csUUFBOUIsRUFBd0MsSUFBeEMsQ0FBSjtBQUNEO0FBQ0QsaUJBQU8sSUFBUDtBQUNEO0FBQ0YsT0FwQkQsTUFvQk8sSUFBSWxQLEVBQUosRUFBUTtBQUNia1AsZ0JBQVEsR0FBR21oQyxZQUFZLENBQUNyd0MsRUFBRCxDQUF2QjtBQUNEOztBQUNELFVBQUlrUCxRQUFKLEVBQWM7QUFDWjtBQUNBLFlBQUksa0JBQWtCLFlBQWxCLElBQWtDbmIsTUFBTSxDQUFDSyxXQUF6QyxJQUF3RG1TLElBQTVELEVBQWtFO0FBQ2hFQSxjQUFJLENBQUMsU0FBRCxDQUFKO0FBQ0Q7O0FBRUQsWUFBSTZWLEdBQUcsR0FBR2t6QixrQkFBa0IsQ0FBQ3BnQyxRQUFELEVBQVc7QUFDckM4eEIsOEJBQW9CLEVBQUVBLG9CQURlO0FBRXJDOEIscUNBQTJCLEVBQUVBLDJCQUZRO0FBR3JDeEUsb0JBQVUsRUFBRXJsQyxPQUFPLENBQUNxbEMsVUFIaUI7QUFJckNzRyxrQkFBUSxFQUFFM3JDLE9BQU8sQ0FBQzJyQztBQUptQixTQUFYLEVBS3pCLElBTHlCLENBQTVCO0FBTUEsWUFBSXA5QixNQUFNLEdBQUc0VSxHQUFHLENBQUM1VSxNQUFqQjtBQUNBLFlBQUk2UCxlQUFlLEdBQUcrRSxHQUFHLENBQUMvRSxlQUExQjtBQUNBcGUsZUFBTyxDQUFDdU8sTUFBUixHQUFpQkEsTUFBakI7QUFDQXZPLGVBQU8sQ0FBQ29lLGVBQVIsR0FBMEJBLGVBQTFCO0FBRUE7O0FBQ0EsWUFBSSxrQkFBa0IsWUFBbEIsSUFBa0N0akIsTUFBTSxDQUFDSyxXQUF6QyxJQUF3RG1TLElBQTVELEVBQWtFO0FBQ2hFQSxjQUFJLENBQUMsYUFBRCxDQUFKO0FBQ0FDLGlCQUFPLENBQUUsU0FBVSxLQUFLNEksS0FBZixHQUF3QixVQUExQixFQUF1QyxTQUF2QyxFQUFrRCxhQUFsRCxDQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUNELFdBQU8rZ0MsS0FBSyxDQUFDeGlELElBQU4sQ0FBVyxJQUFYLEVBQWlCcVMsRUFBakIsRUFBcUJpTyxTQUFyQixDQUFQO0FBQ0QsR0FsRUQ7QUFvRUE7Ozs7OztBQUlBLFdBQVNvaUMsWUFBVCxDQUF1QnJ3QyxFQUF2QixFQUEyQjtBQUN6QixRQUFJQSxFQUFFLENBQUNzd0MsU0FBUCxFQUFrQjtBQUNoQixhQUFPdHdDLEVBQUUsQ0FBQ3N3QyxTQUFWO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSUMsU0FBUyxHQUFHcnVCLFFBQVEsQ0FBQzVJLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBaEI7QUFDQWkzQixlQUFTLENBQUNsdEIsV0FBVixDQUFzQnJqQixFQUFFLENBQUMyOUIsU0FBSCxDQUFhLElBQWIsQ0FBdEI7QUFDQSxhQUFPNFMsU0FBUyxDQUFDOW5CLFNBQWpCO0FBQ0Q7QUFDRjs7QUFFRG5jLEtBQUcsQ0FBQytpQyxPQUFKLEdBQWNDLGtCQUFkO0FBRUEsU0FBT2hqQyxHQUFQO0FBRUMsQ0E3clZBLENBQUQsQyIsImZpbGUiOiIuL3NyYy92ZW5kb3IvdnVlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuNS4xN1xuICogKGMpIDIwMTQtMjAxOCBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuVnVlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxudmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcbmZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgcmV0dXJuIHYgPT09IHRydWVcbn1cblxuZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICByZXR1cm4gdiA9PT0gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHxcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbidcbiAgKVxufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHJhdyB0eXBlIHN0cmluZyBvZiBhIHZhbHVlIGUuZy4gW29iamVjdCBPYmplY3RdXG4gKi9cbnZhciBfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiB0b1Jhd1R5cGUgKHZhbHVlKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbi8qKlxuICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xufVxuXG5mdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdmFsIGlzIGEgdmFsaWQgYXJyYXkgaW5kZXguXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KFN0cmluZyh2YWwpKTtcbiAgcmV0dXJuIG4gPj0gMCAmJiBNYXRoLmZsb29yKG4pID09PSBuICYmIGlzRmluaXRlKHZhbClcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG59XG5cbi8qKlxuICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gKiBpcyBpbiB0aGF0IG1hcC5cbiAqL1xuZnVuY3Rpb24gbWFrZU1hcCAoXG4gIHN0cixcbiAgZXhwZWN0c0xvd2VyQ2FzZVxuKSB7XG4gIHZhciBtYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGlzdFtpXV0gPSB0cnVlO1xuICB9XG4gIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgPyBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsLnRvTG93ZXJDYXNlKCldOyB9XG4gICAgOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG52YXIgaXNCdWlsdEluVGFnID0gbWFrZU1hcCgnc2xvdCxjb21wb25lbnQnLCB0cnVlKTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGF0dHJpYnV0ZSBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlIChhcnIsIGl0ZW0pIHtcbiAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgb2JqZWN0IGhhcyB0aGUgcHJvcGVydHkuXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24gKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkIChmbikge1xuICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuICovXG52YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbnZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShjYW1lbGl6ZVJFLCBmdW5jdGlvbiAoXywgYykgeyByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnOyB9KVxufSk7XG5cbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xudmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG59KTtcblxuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG52YXIgaHlwaGVuYXRlUkUgPSAvXFxCKFtBLVpdKS9nO1xudmFyIGh5cGhlbmF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdC4uLiBlLmcuXG4gKiBQaGFudG9tSlMgMS54LiBUZWNobmljYWxseSB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZSBzaW5jZSBuYXRpdmUgYmluZCBpc1xuICogbm93IG1vcmUgcGVyZm9ybWFudCBpbiBtb3N0IGJyb3dzZXJzLCBidXQgcmVtb3ZpbmcgaXQgd291bGQgYmUgYnJlYWtpbmcgZm9yXG4gKiBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvclxuICogYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHBvbHlmaWxsQmluZCAoZm4sIGN0eCkge1xuICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBsXG4gICAgICA/IGwgPiAxXG4gICAgICAgID8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG4gICAgICAgIDogZm4uY2FsbChjdHgsIGEpXG4gICAgICA6IGZuLmNhbGwoY3R4KVxuICB9XG5cbiAgYm91bmRGbi5fbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICByZXR1cm4gYm91bmRGblxufVxuXG5mdW5jdGlvbiBuYXRpdmVCaW5kIChmbiwgY3R4KSB7XG4gIHJldHVybiBmbi5iaW5kKGN0eClcbn1cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICA/IG5hdGl2ZUJpbmRcbiAgOiBwb2x5ZmlsbEJpbmQ7XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBQZXJmb3JtIG5vIG9wZXJhdGlvbi5cbiAqIFN0dWJiaW5nIGFyZ3MgdG8gbWFrZSBGbG93IGhhcHB5IHdpdGhvdXQgbGVhdmluZyB1c2VsZXNzIHRyYW5zcGlsZWQgY29kZVxuICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pXG4gKi9cbmZ1bmN0aW9uIG5vb3AgKGEsIGIsIGMpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKGEsIGIsIGMpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vKipcbiAqIFJldHVybiBzYW1lIHZhbHVlXG4gKi9cbnZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhdGljIGtleXMgc3RyaW5nIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAqL1xuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICByZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuICB9LCBbXSkuam9pbignLCcpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG4gKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gKi9cbmZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG4gIHZhciBpc09iamVjdEIgPSBpc09iamVjdChiKTtcbiAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGlzQXJyYXlBID0gQXJyYXkuaXNBcnJheShhKTtcbiAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChlLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIHJldHVybiBrZXlzQS5sZW5ndGggPT09IGtleXNCLmxlbmd0aCAmJiBrZXlzQS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvb3NlSW5kZXhPZiAoYXJyLCB2YWwpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufVxuXG4vKipcbiAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5cbnZhciBBU1NFVF9UWVBFUyA9IFtcbiAgJ2NvbXBvbmVudCcsXG4gICdkaXJlY3RpdmUnLFxuICAnZmlsdGVyJ1xuXTtcblxudmFyIExJRkVDWUNMRV9IT09LUyA9IFtcbiAgJ2JlZm9yZUNyZWF0ZScsXG4gICdjcmVhdGVkJyxcbiAgJ2JlZm9yZU1vdW50JyxcbiAgJ21vdW50ZWQnLFxuICAnYmVmb3JlVXBkYXRlJyxcbiAgJ3VwZGF0ZWQnLFxuICAnYmVmb3JlRGVzdHJveScsXG4gICdkZXN0cm95ZWQnLFxuICAnYWN0aXZhdGVkJyxcbiAgJ2RlYWN0aXZhdGVkJyxcbiAgJ2Vycm9yQ2FwdHVyZWQnXG5dO1xuXG4vKiAgKi9cblxudmFyIGNvbmZpZyA9ICh7XG4gIC8qKlxuICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICovXG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuICAgKi9cbiAgcHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICovXG4gIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAvKipcbiAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICovXG4gIGVycm9ySGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAqL1xuICB3YXJuSGFuZGxlcjogbnVsbCxcblxuICAvKipcbiAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAqL1xuICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSByZWdpc3RlcmVkIGFzIGFcbiAgICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZFRhZzogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgaXNVbmtub3duRWxlbWVudDogbm8sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXNwYWNlIG9mIGFuIGVsZW1lbnRcbiAgICovXG4gIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAvKipcbiAgICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cbiAgICovXG4gIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgKi9cbiAgbXVzdFVzZVByb3A6IG5vLFxuXG4gIC8qKlxuICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgKi9cbiAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1Ncbn0pXG5cbi8qICAqL1xuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcbiAgdmFyIGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZGVmIChvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIHZhbHVlOiB2YWwsXG4gICAgZW51bWVyYWJsZTogISFlbnVtZXJhYmxlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xudmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5mdW5jdGlvbiBwYXJzZVBhdGggKHBhdGgpIHtcbiAgaWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghb2JqKSB7IHJldHVybiB9XG4gICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cbn1cblxuLyogICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xudmFyIGhhc1Byb3RvID0gJ19fcHJvdG9fXycgaW4ge307XG5cbi8vIEJyb3dzZXIgZW52aXJvbm1lbnQgc25pZmZpbmdcbnZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbnZhciBpbldlZXggPSB0eXBlb2YgV1hFbnZpcm9ubWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgISFXWEVudmlyb25tZW50LnBsYXRmb3JtO1xudmFyIHdlZXhQbGF0Zm9ybSA9IGluV2VleCAmJiBXWEVudmlyb25tZW50LnBsYXRmb3JtLnRvTG93ZXJDYXNlKCk7XG52YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbnZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG52YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbnZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbnZhciBpc0FuZHJvaWQgPSAoVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMCkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKTtcbnZhciBpc0lPUyA9IChVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpKSB8fCAod2VleFBsYXRmb3JtID09PSAnaW9zJyk7XG52YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuLy8gRmlyZWZveCBoYXMgYSBcIndhdGNoXCIgZnVuY3Rpb24gb24gT2JqZWN0LnByb3RvdHlwZS4uLlxudmFyIG5hdGl2ZVdhdGNoID0gKHt9KS53YXRjaDtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICB0cnkge1xuICAgIHZhciBvcHRzID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywgKHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcbnZhciBfaXNTZXJ2ZXI7XG52YXIgaXNTZXJ2ZXJSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghaW5Ccm93c2VyICYmICFpbldlZXggJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIGRldGVjdCBwcmVzZW5jZSBvZiB2dWUtc2VydmVyLXJlbmRlcmVyIGFuZCBhdm9pZFxuICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgX2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9pc1NlcnZlclxufTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG52YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbn1cblxudmFyIGhhc1N5bWJvbCA9XG4gIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuaWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcbiAgLy8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG4gIF9TZXQgPSBTZXQ7XG59IGVsc2Uge1xuICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gIF9TZXQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICB0aGlzLnNldFtrZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICB0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTZXQ7XG4gIH0oKSk7XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiA9IG5vb3A7XG52YXIgdGlwID0gbm9vcDtcbnZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG52YXIgZm9ybWF0Q29tcG9uZW50TmFtZSA9IChub29wKTtcblxue1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG4gIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgdm5vZGUudGFnLFxuICAgIHZub2RlLmRhdGEsXG4gICAgdm5vZGUuY2hpbGRyZW4sXG4gICAgdm5vZGUudGV4dCxcbiAgICB2bm9kZS5lbG0sXG4gICAgdm5vZGUuY29udGV4dCxcbiAgICB2bm9kZS5jb21wb25lbnRPcHRpb25zLFxuICAgIHZub2RlLmFzeW5jRmFjdG9yeVxuICApO1xuICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgY2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG4gIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gIGNsb25lZC5mbkNvbnRleHQgPSB2bm9kZS5mbkNvbnRleHQ7XG4gIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gIHJldHVybiBjbG9uZWRcbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcblxudmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXTtcblxuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIHZhciBvYiA9IHRoaXMuX19vYl9fO1xuICAgIHZhciBpbnNlcnRlZDtcbiAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgY2FzZSAncHVzaCc6XG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gKiB1cGRhdGUgY29tcHV0YXRpb24uXG4gKi9cbnZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuZnVuY3Rpb24gdG9nZ2xlT2JzZXJ2aW5nICh2YWx1ZSkge1xuICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBpcyBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoIHVwZGF0ZXMuXG4gKi9cbnZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICB0aGlzLnZtQ291bnQgPSAwO1xuICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuICAgICAgPyBwcm90b0F1Z21lbnRcbiAgICAgIDogY29weUF1Z21lbnQ7XG4gICAgYXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndhbGsodmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIFdhbGsgdGhyb3VnaCBlYWNoIHByb3BlcnR5IGFuZCBjb252ZXJ0IHRoZW0gaW50b1xuICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWZpbmVSZWFjdGl2ZShvYmosIGtleXNbaV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgc2hvdWxkT2JzZXJ2ZSAmJlxuICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgIE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG4gICAgIXZhbHVlLl9pc1Z1ZVxuICApIHtcbiAgICBvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG4gIH1cbiAgaWYgKGFzUm9vdERhdGEgJiYgb2IpIHtcbiAgICBvYi52bUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIG9iXG59XG5cbi8qKlxuICogRGVmaW5lIGEgcmVhY3RpdmUgcHJvcGVydHkgb24gYW4gT2JqZWN0LlxuICovXG5mdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSAoXG4gIG9iaixcbiAga2V5LFxuICB2YWwsXG4gIGN1c3RvbVNldHRlcixcbiAgc2hhbGxvd1xuKSB7XG4gIHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cbiAgdmFyIHByb3BlcnR5ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgdmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcbiAgaWYgKCFnZXR0ZXIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhbCA9IG9ialtrZXldO1xuICB9XG4gIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cbiAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gcmVhY3RpdmVHZXR0ZXIgKCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgIGRlcC5kZXBlbmQoKTtcbiAgICAgICAgaWYgKGNoaWxkT2IpIHtcbiAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKVxuICApIHtcbiAgICB3YXJuKChcIkNhbm5vdCBzZXQgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6IFwiICsgKCh0YXJnZXQpKSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgIHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICB2YXIgb2IgPSAodGFyZ2V0KS5fX29iX187XG4gIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnYXQgcnVudGltZSAtIGRlY2xhcmUgaXQgdXBmcm9udCBpbiB0aGUgZGF0YSBvcHRpb24uJ1xuICAgICk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmICghb2IpIHtcbiAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICByZXR1cm4gdmFsXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsICh0YXJnZXQsIGtleSkge1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldCkpXG4gICkge1xuICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBkZWxldGUgdGFyZ2V0W2tleV07XG4gIGlmICghb2IpIHtcbiAgICByZXR1cm5cbiAgfVxuICBvYi5kZXAubm90aWZ5KCk7XG59XG5cbi8qKlxuICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuICovXG5mdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgZm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGUgPSB2YWx1ZVtpXTtcbiAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgZGVwZW5kQXJyYXkoZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0sIHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgOiBwYXJlbnRWYWw7XG4gICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5zdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm1cbikge1xuICBpZiAoIXZtKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGFzc2VydE9iamVjdFR5cGUoa2V5LCBjaGlsZFZhbCwgdm0pO1xuICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICBpZiAocGFyZW50VmFsID09PSBuYXRpdmVXYXRjaCkgeyBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7IH1cbiAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuICB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG4gIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgcmV0dXJuIHJldFxufTtcbnN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuLyoqXG4gKiBEZWZhdWx0IHN0cmF0ZWd5LlxuICovXG52YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgcmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcbiAgICA/IHBhcmVudFZhbFxuICAgIDogY2hpbGRWYWxcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgdmFsaWRhdGVDb21wb25lbnROYW1lKGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb21wb25lbnROYW1lIChuYW1lKSB7XG4gIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAnYW5kIG11c3Qgc3RhcnQgd2l0aCBhIGxldHRlci4nXG4gICAgKTtcbiAgfVxuICBpZiAoaXNCdWlsdEluVGFnKG5hbWUpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKG5hbWUpKSB7XG4gICAgd2FybihcbiAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgJ2lkOiAnICsgbmFtZVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zLCB2bSkge1xuICB2YXIgcHJvcHMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGksIHZhbCwgbmFtZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKGluamVjdCkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gIHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuICBpZiAoZGlycykge1xuICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICB2YXIgZGVmID0gZGlyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYsIHVwZGF0ZTogZGVmIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGUgKG5hbWUsIHZhbHVlLCB2bSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJcIiArIG5hbWUgKyBcIlxcXCI6IGV4cGVjdGVkIGFuIE9iamVjdCwgXCIgK1xuICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGJvb2xlYW4gY2FzdGluZ1xuICB2YXIgYm9vbGVhbkluZGV4ID0gZ2V0VHlwZUluZGV4KEJvb2xlYW4sIHByb3AudHlwZSk7XG4gIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgIGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICBpZiAoc3RyaW5nSW5kZXggPCAwIHx8IGJvb2xlYW5JbmRleCA8IHN0cmluZ0luZGV4KSB7XG4gICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRPYnNlcnZlID0gc2hvdWxkT2JzZXJ2ZTtcbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHByZXZTaG91bGRPYnNlcnZlKTtcbiAgfVxuICB7XG4gICAgYXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuICovXG5mdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gIC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuICB2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG4gICAgd2FybihcbiAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcbiAgICAgICd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgaWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICB2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICB9XG4gIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgcmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICBcIkludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXFxcIlwiICsgbmFtZSArIFwiXFxcIi5cIiArXG4gICAgICBcIiBFeHBlY3RlZCBcIiArIChleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpKSArXG4gICAgICBcIiwgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICBpZiAodmFsaWRhdG9yKSB7XG4gICAgaWYgKCF2YWxpZGF0b3IodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cbmZ1bmN0aW9uIGFzc2VydFR5cGUgKHZhbHVlLCB0eXBlKSB7XG4gIHZhciB2YWxpZDtcbiAgdmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gIGlmIChzaW1wbGVDaGVja1JFLnRlc3QoZXhwZWN0ZWRUeXBlKSkge1xuICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gZm9yIHByaW1pdGl2ZSB3cmFwcGVyIG9iamVjdHNcbiAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgIHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB2YWxpZCxcbiAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICB9XG59XG5cbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG4gIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcbn1cblxuZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICByZXR1cm4gZ2V0VHlwZShhKSA9PT0gZ2V0VHlwZShiKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVHlwZXMpKSB7XG4gICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTFcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZXhwZWN0ZWRUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmICh2bSkge1xuICAgIHZhciBjdXIgPSB2bTtcbiAgICB3aGlsZSAoKGN1ciA9IGN1ci4kcGFyZW50KSkge1xuICAgICAgdmFyIGhvb2tzID0gY3VyLiRvcHRpb25zLmVycm9yQ2FwdHVyZWQ7XG4gICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY2FwdHVyZSkgeyByZXR1cm4gfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgfVxuICB9XG4gIGxvZ0Vycm9yKGVyciwgdm0sIGluZm8pO1xufVxuXG5mdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICB7XG4gICAgd2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICgoaW5Ccm93c2VyIHx8IGluV2VleCkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qICAqL1xuLyogZ2xvYmFscyBNZXNzYWdlQ2hhbm5lbCAqL1xuXG52YXIgY2FsbGJhY2tzID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIGNvcGllcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29waWVzW2ldKCk7XG4gIH1cbn1cblxuLy8gSGVyZSB3ZSBoYXZlIGFzeW5jIGRlZmVycmluZyB3cmFwcGVycyB1c2luZyBib3RoIG1pY3JvdGFza3MgYW5kIChtYWNybykgdGFza3MuXG4vLyBJbiA8IDIuNCB3ZSB1c2VkIG1pY3JvdGFza3MgZXZlcnl3aGVyZSwgYnV0IHRoZXJlIGFyZSBzb21lIHNjZW5hcmlvcyB3aGVyZVxuLy8gbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4vLyBzZXF1ZW50aWFsIGV2ZW50cyAoZS5nLiAjNDUyMSwgIzY2OTApIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZVxuLy8gZXZlbnQgKCM2NTY2KS4gSG93ZXZlciwgdXNpbmcgKG1hY3JvKSB0YXNrcyBldmVyeXdoZXJlIGFsc28gaGFzIHN1YnRsZSBwcm9ibGVtc1xuLy8gd2hlbiBzdGF0ZSBpcyBjaGFuZ2VkIHJpZ2h0IGJlZm9yZSByZXBhaW50IChlLmcuICM2ODEzLCBvdXQtaW4gdHJhbnNpdGlvbnMpLlxuLy8gSGVyZSB3ZSB1c2UgbWljcm90YXNrIGJ5IGRlZmF1bHQsIGJ1dCBleHBvc2UgYSB3YXkgdG8gZm9yY2UgKG1hY3JvKSB0YXNrIHdoZW5cbi8vIG5lZWRlZCAoZS5nLiBpbiBldmVudCBoYW5kbGVycyBhdHRhY2hlZCBieSB2LW9uKS5cbnZhciBtaWNyb1RpbWVyRnVuYztcbnZhciBtYWNyb1RpbWVyRnVuYztcbnZhciB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcblxuLy8gRGV0ZXJtaW5lIChtYWNybykgdGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8vIFRlY2huaWNhbGx5IHNldEltbWVkaWF0ZSBzaG91bGQgYmUgdGhlIGlkZWFsIGNob2ljZSwgYnV0IGl0J3Mgb25seSBhdmFpbGFibGVcbi8vIGluIElFLiBUaGUgb25seSBwb2x5ZmlsbCB0aGF0IGNvbnNpc3RlbnRseSBxdWV1ZXMgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCBET01cbi8vIGV2ZW50cyB0cmlnZ2VyZWQgaW4gdGhlIHNhbWUgbG9vcCBpcyBieSB1c2luZyBNZXNzYWdlQ2hhbm5lbC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKHNldEltbWVkaWF0ZSkpIHtcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZsdXNoQ2FsbGJhY2tzKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gIGlzTmF0aXZlKE1lc3NhZ2VDaGFubmVsKSB8fFxuICAvLyBQaGFudG9tSlNcbiAgTWVzc2FnZUNoYW5uZWwudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTWVzc2FnZUNoYW5uZWxDb25zdHJ1Y3Rvcl0nXG4pKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHZhciBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaENhbGxiYWNrcztcbiAgbWFjcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSgxKTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZmx1c2hDYWxsYmFja3MsIDApO1xuICB9O1xufVxuXG4vLyBEZXRlcm1pbmUgbWljcm90YXNrIGRlZmVyIGltcGxlbWVudGF0aW9uLlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICB2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBtaWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgIC8vIGluIHByb2JsZW1hdGljIFVJV2ViVmlld3MsIFByb21pc2UudGhlbiBkb2Vzbid0IGNvbXBsZXRlbHkgYnJlYWssIGJ1dFxuICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgLy8gbmVlZHMgdG8gZG8gc29tZSBvdGhlciB3b3JrLCBlLmcuIGhhbmRsZSBhIHRpbWVyLiBUaGVyZWZvcmUgd2UgY2FuXG4gICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIGZhbGxiYWNrIHRvIG1hY3JvXG4gIG1pY3JvVGltZXJGdW5jID0gbWFjcm9UaW1lckZ1bmM7XG59XG5cbi8qKlxuICogV3JhcCBhIGZ1bmN0aW9uIHNvIHRoYXQgaWYgYW55IGNvZGUgaW5zaWRlIHRyaWdnZXJzIHN0YXRlIGNoYW5nZSxcbiAqIHRoZSBjaGFuZ2VzIGFyZSBxdWV1ZWQgdXNpbmcgYSAobWFjcm8pIHRhc2sgaW5zdGVhZCBvZiBhIG1pY3JvdGFzay5cbiAqL1xuZnVuY3Rpb24gd2l0aE1hY3JvVGFzayAoZm4pIHtcbiAgcmV0dXJuIGZuLl93aXRoVGFzayB8fCAoZm4uX3dpdGhUYXNrID0gZnVuY3Rpb24gKCkge1xuICAgIHVzZU1hY3JvVGFzayA9IHRydWU7XG4gICAgdmFyIHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG4gICAgcmV0dXJuIHJlc1xuICB9KVxufVxuXG5mdW5jdGlvbiBuZXh0VGljayAoY2IsIGN0eCkge1xuICB2YXIgX3Jlc29sdmU7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiLmNhbGwoY3R4KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZShjdHgpO1xuICAgIH1cbiAgfSk7XG4gIGlmICghcGVuZGluZykge1xuICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgIGlmICh1c2VNYWNyb1Rhc2spIHtcbiAgICAgIG1hY3JvVGltZXJGdW5jKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pY3JvVGltZXJGdW5jKCk7XG4gICAgfVxuICB9XG4gIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBtYXJrO1xudmFyIG1lYXN1cmU7XG5cbntcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbntcbiAgdmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcbiAgICAnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcbiAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcbiAgICAncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuICApO1xuXG4gIHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIHdhcm4oXG4gICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAnU2VlOiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJyxcbiAgICAgIHRhcmdldFxuICAgICk7XG4gIH07XG5cbiAgdmFyIGhhc1Byb3h5ID1cbiAgICB0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb3h5KTtcblxuICBpZiAoaGFzUHJveHkpIHtcbiAgICB2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhLGV4YWN0Jyk7XG4gICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuICAgICAgICAgIHdhcm4oKFwiQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuXCIgKyBrZXkpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciBoYXNIYW5kbGVyID0ge1xuICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgdmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG4gICAgICB2YXIgaXNBbGxvd2VkID0gYWxsb3dlZEdsb2JhbHMoa2V5KSB8fCBrZXkuY2hhckF0KDApID09PSAnXyc7XG4gICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0SGFuZGxlciA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgIHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgIH1cbiAgfTtcblxuICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgaWYgKGhhc1Byb3h5KSB7XG4gICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2VcbiAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG4gICAgICAgID8gZ2V0SGFuZGxlclxuICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcbiAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICBzZWVuT2JqZWN0cy5jbGVhcigpO1xufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICB2YXIgaSwga2V5cztcbiAgdmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcbiAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gIG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG4gIG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBvbmNlOiBvbmNlJCQxLFxuICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZVxuICB9XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcbiAgZnVuY3Rpb24gaW52b2tlciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNsb25lZFtpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG4gICAgICByZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbiAgaW52b2tlci5mbnMgPSBmbnM7XG4gIHJldHVybiBpbnZva2VyXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGRlZiwgY3VyLCBvbGQsIGV2ZW50O1xuICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICBkZWYgPSBjdXIgPSBvbltuYW1lXTtcbiAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1VuZGVmKGN1cikpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgaWYgKGlzVW5kZWYoY3VyLmZucykpIHtcbiAgICAgICAgY3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcbiAgICAgIH1cbiAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcbiAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICByZW1vdmUkJDEoZXZlbnQubmFtZSwgb2xkT25bbmFtZV0sIGV2ZW50LmNhcHR1cmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICBpZiAoZGVmIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICBkZWYgPSBkZWYuZGF0YS5ob29rIHx8IChkZWYuZGF0YS5ob29rID0ge30pO1xuICB9XG4gIHZhciBpbnZva2VyO1xuICB2YXIgb2xkSG9vayA9IGRlZltob29rS2V5XTtcblxuICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIC8vIGltcG9ydGFudDogcmVtb3ZlIG1lcmdlZCBob29rIHRvIGVuc3VyZSBpdCdzIGNhbGxlZCBvbmx5IG9uY2VcbiAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgIHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICB9XG5cbiAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbd3JhcHBlZEhvb2tdKTtcbiAgfSBlbHNlIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob2xkSG9vay5mbnMpICYmIGlzVHJ1ZShvbGRIb29rLm1lcmdlZCkpIHtcbiAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgaW52b2tlciA9IG9sZEhvb2s7XG4gICAgICBpbnZva2VyLmZucy5wdXNoKHdyYXBwZWRIb29rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgcGxhaW4gaG9va1xuICAgICAgaW52b2tlciA9IGNyZWF0ZUZuSW52b2tlcihbb2xkSG9vaywgd3JhcHBlZEhvb2tdKTtcbiAgICB9XG4gIH1cblxuICBpbnZva2VyLm1lcmdlZCA9IHRydWU7XG4gIGRlZltob29rS2V5XSA9IGludm9rZXI7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgZGF0YSxcbiAgQ3RvcixcbiAgdGFnXG4pIHtcbiAgLy8gd2UgYXJlIG9ubHkgZXh0cmFjdGluZyByYXcgdmFsdWVzIGhlcmUuXG4gIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAvLyBjb21wb25lbnQgaXRzZWxmLlxuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgIHZhciBhbHRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcbiAgICAgICk7XG4gICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgIGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICBpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKHJlcy5jb21wb25lbnQpICYmIHR5cGVvZiByZXMuY29tcG9uZW50LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICBmYWN0b3J5LmVycm9yQ29tcCA9IGVuc3VyZUN0b3IocmVzLmVycm9yLCBiYXNlQ3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgZmFjdG9yeS5sb2FkaW5nQ29tcCA9IGVuc3VyZUN0b3IocmVzLmxvYWRpbmcsIGJhc2VDdG9yKTtcbiAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVzLmRlbGF5IHx8IDIwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGVmKHJlcy50aW1lb3V0KSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICAgIFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMgPSBmYWxzZTtcbiAgICAvLyByZXR1cm4gaW4gY2FzZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5XG4gICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgPyBmYWN0b3J5LmxvYWRpbmdDb21wXG4gICAgICA6IGZhY3RvcnkucmVzb2x2ZWRcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gIHJldHVybiBub2RlLmlzQ29tbWVudCAmJiBub2RlLmFzeW5jRmFjdG9yeVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiAoaXNEZWYoYy5jb21wb25lbnRPcHRpb25zKSB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYykpKSB7XG4gICAgICAgIHJldHVybiBjXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgLy8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG4gIHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuICB9XG59XG5cbnZhciB0YXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlKSB7XG4gIGlmIChvbmNlKSB7XG4gICAgdGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LiRvbihldmVudCwgZm4pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgdGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgdm0sXG4gIGxpc3RlbmVycyxcbiAgb2xkTGlzdGVuZXJzXG4pIHtcbiAgdGFyZ2V0ID0gdm07XG4gIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgdm0pO1xuICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuICAgICAgaWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGZ1bmN0aW9uIG9uICgpIHtcbiAgICAgIHZtLiRvZmYoZXZlbnQsIG9uKTtcbiAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBvbi5mbiA9IGZuO1xuICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb2ZmKGV2ZW50W2ldLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKCFjYnMpIHtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoIWZuKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgaWYgKGZuKSB7XG4gICAgICAvLyBzcGVjaWZpYyBoYW5kbGVyXG4gICAgICB2YXIgY2I7XG4gICAgICB2YXIgaSQxID0gY2JzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpJDEtLSkge1xuICAgICAgICBjYiA9IGNic1tpJDFdO1xuICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgIGNicy5zcGxpY2UoaSQxLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cblxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIGNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAvLyByZW1vdmUgc2xvdCBhdHRyaWJ1dGUgaWYgdGhlIG5vZGUgaXMgcmVzb2x2ZWQgYXMgYSBWdWUgc2xvdCBub2RlXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnNsb3QpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgfVxuICAgIC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgZGF0YSAmJiBkYXRhLnNsb3QgIT0gbnVsbFxuICAgICkge1xuICAgICAgdmFyIG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICB2YXIgc2xvdCA9IChzbG90c1tuYW1lXSB8fCAoc2xvdHNbbmFtZV0gPSBbXSkpO1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICBzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgZm9yICh2YXIgbmFtZSQxIGluIHNsb3RzKSB7XG4gICAgaWYgKHNsb3RzW25hbWUkMV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG5mdW5jdGlvbiBpc1doaXRlc3BhY2UgKG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTY29wZWRTbG90cyAoXG4gIGZucywgLy8gc2VlIGZsb3cvdm5vZGVcbiAgcmVzXG4pIHtcbiAgcmVzID0gcmVzIHx8IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZuc1tpXSkpIHtcbiAgICAgIHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1tmbnNbaV0ua2V5XSA9IGZuc1tpXS5mbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGFjdGl2ZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgfVxuXG4gIHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG4gIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgdm0uJGNoaWxkcmVuID0gW107XG4gIHZtLiRyZWZzID0ge307XG5cbiAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICB2bS5faW5hY3RpdmUgPSBudWxsO1xuICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICB2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG4gICAgfVxuICAgIHZhciBwcmV2RWwgPSB2bS4kZWw7XG4gICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICB2YXIgcHJldkFjdGl2ZUluc3RhbmNlID0gYWN0aXZlSW5zdGFuY2U7XG4gICAgYWN0aXZlSW5zdGFuY2UgPSB2bTtcbiAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAvLyBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyBpcyBpbmplY3RlZCBpbiBlbnRyeSBwb2ludHNcbiAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgLy8gaW5pdGlhbCByZW5kZXJcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcbiAgICAgICAgdm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtLFxuICAgICAgICB2bS4kb3B0aW9ucy5fcmVmRWxtXG4gICAgICApO1xuICAgICAgLy8gbm8gbmVlZCBmb3IgdGhlIHJlZiBub2RlcyBhZnRlciBpbml0aWFsIHBhdGNoXG4gICAgICAvLyB0aGlzIHByZXZlbnRzIGtlZXBpbmcgYSBkZXRhY2hlZCBET00gdHJlZSBpbiBtZW1vcnkgKCM1ODUxKVxuICAgICAgdm0uJG9wdGlvbnMuX3BhcmVudEVsbSA9IHZtLiRvcHRpb25zLl9yZWZFbG0gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGVzXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuICAgIC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSB2bTtcbiAgICB9XG4gICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgIGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICB2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcbiAgICB9XG4gICAgLy8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuICAgIC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG4gICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgcmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcbiAgICB9XG4gICAgLy8gdGVhcmRvd24gd2F0Y2hlcnNcbiAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cbiAgICBpZiAodm0uX2RhdGEuX19vYl9fKSB7XG4gICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgIH1cbiAgICAvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cbiAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgIHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gcmVsZWFzZSBjaXJjdWxhciByZWZlcmVuY2UgKCM2NzU5KVxuICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuICB2bSxcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIHZtLiRlbCA9IGVsO1xuICBpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICB2YXIgaWQgPSB2bS5fdWlkO1xuICAgICAgdmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgdmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyBuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gIC8vIHNpbmNlIHRoZSB3YXRjaGVyJ3MgaW5pdGlhbCBwYXRjaCBtYXkgY2FsbCAkZm9yY2VVcGRhdGUgKGUuZy4gaW5zaWRlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCdzIG1vdW50ZWQgaG9vayksIHdoaWNoIHJlbGllcyBvbiB2bS5fd2F0Y2hlciBiZWluZyBhbHJlYWR5IGRlZmluZWRcbiAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgbnVsbCwgdHJ1ZSAvKiBpc1JlbmRlcldhdGNoZXIgKi8pO1xuICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAvLyBtYW51YWxseSBtb3VudGVkIGluc3RhbmNlLCBjYWxsIG1vdW50ZWQgb24gc2VsZlxuICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICB2bS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgfVxuICByZXR1cm4gdm1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICB2bSxcbiAgcHJvcHNEYXRhLFxuICBsaXN0ZW5lcnMsXG4gIHBhcmVudFZub2RlLFxuICByZW5kZXJDaGlsZHJlblxuKSB7XG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAvLyB1cGRhdGUgcHJvcHNcbiAgaWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzO1xuICAgIHZhciBwcm9wS2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICB2YXIgcHJvcE9wdGlvbnMgPSB2bS4kb3B0aW9ucy5wcm9wczsgLy8gd3RmIGZsb3c/XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgbGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0O1xuICB2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG5cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICBpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICBpZiAoZGlyZWN0KSB7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gdHJ1ZTtcbiAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG4gIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgcHVzaFRhcmdldCgpO1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbiAgcG9wVGFyZ2V0KCk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG52YXIgcXVldWUgPSBbXTtcbnZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xudmFyIGhhcyA9IHt9O1xudmFyIGNpcmN1bGFyID0ge307XG52YXIgd2FpdGluZyA9IGZhbHNlO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cbiAqL1xuZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gIGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgaGFzID0ge307XG4gIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG4gIHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gIHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuICAvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3NcbiAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgY2FsbFVwZGF0ZWRIb29rcyh1cGRhdGVkUXVldWUpO1xuXG4gIC8vIGRldnRvb2wgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyAocXVldWUpIHtcbiAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgaWYgKHZtLl93YXRjaGVyID09PSB3YXRjaGVyICYmIHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQgKHZtKSB7XG4gIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xufVxuXG5mdW5jdGlvbiBjYWxsQWN0aXZhdGVkSG9va3MgKHF1ZXVlKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQocXVldWVbaV0sIHRydWUgLyogdHJ1ZSAqLyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG4gKiBwdXNoZWQgd2hlbiB0aGUgcXVldWUgaXMgYmVpbmcgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG4gIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPiBpbmRleCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKGkgKyAxLCAwLCB3YXRjaGVyKTtcbiAgICB9XG4gICAgLy8gcXVldWUgdGhlIGZsdXNoXG4gICAgaWYgKCF3YWl0aW5nKSB7XG4gICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgIG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHVpZCQxID0gMDtcblxuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqL1xudmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGNiLFxuICBvcHRpb25zLFxuICBpc1JlbmRlcldhdGNoZXJcbikge1xuICB0aGlzLnZtID0gdm07XG4gIGlmIChpc1JlbmRlcldhdGNoZXIpIHtcbiAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gIH1cbiAgdm0uX3dhdGNoZXJzLnB1c2godGhpcyk7XG4gIC8vIG9wdGlvbnNcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICB0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcbiAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgfVxuICB0aGlzLmNiID0gY2I7XG4gIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgdGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcbiAgdGhpcy5kZXBzID0gW107XG4gIHRoaXMubmV3RGVwcyA9IFtdO1xuICB0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG4gIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5leHByZXNzaW9uID0gZXhwT3JGbi50b1N0cmluZygpO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB3YXRjaGluZyBwYXRoOiBcXFwiXCIgKyBleHBPckZuICsgXCJcXFwiIFwiICtcbiAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgJ0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogdGhpcy5nZXQoKTtcbn07XG5cbi8qKlxuICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuICBwdXNoVGFyZ2V0KHRoaXMpO1xuICB2YXIgdmFsdWU7XG4gIHZhciB2bSA9IHRoaXMudm07XG4gIHRyeSB7XG4gICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICBpZiAodGhpcy5kZWVwKSB7XG4gICAgICB0cmF2ZXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICAgIHRoaXMuY2xlYW51cERlcHMoKTtcbiAgfVxuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgLy8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICB0aGlzLmRlZXBcbiAgICApIHtcbiAgICAgIC8vIHNldCBuZXcgdmFsdWVcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBpZiAodGhpcy51c2VyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBoYW5kbGVFcnJvcihlLCB0aGlzLnZtLCAoXCJjYWxsYmFjayBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgdmFsdWUgb2YgdGhlIHdhdGNoZXIuXG4gKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24gZXZhbHVhdGUgKCkge1xuICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSB2bSdzIHdhdGNoZXIgbGlzdFxuICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vKiAgKi9cblxudmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV1cbiAgfTtcbiAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICB0aGlzW3NvdXJjZUtleV1ba2V5XSA9IHZhbDtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuXG5mdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG4gIHZtLl93YXRjaGVycyA9IFtdO1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zO1xuICBpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG4gIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgaWYgKG9wdHMuZGF0YSkge1xuICAgIGluaXREYXRhKHZtKTtcbiAgfSBlbHNlIHtcbiAgICBvYnNlcnZlKHZtLl9kYXRhID0ge30sIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG4gIH1cbiAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICBpZiAob3B0cy53YXRjaCAmJiBvcHRzLndhdGNoICE9PSBuYXRpdmVXYXRjaCkge1xuICAgIGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFByb3BzICh2bSwgcHJvcHNPcHRpb25zKSB7XG4gIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gIHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuICAvLyBjYWNoZSBwcm9wIGtleXMgc28gdGhhdCBmdXR1cmUgcHJvcHMgdXBkYXRlcyBjYW4gaXRlcmF0ZSB1c2luZyBBcnJheVxuICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgdmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcbiAgdmFyIGlzUm9vdCA9ICF2bS4kcGFyZW50O1xuICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgaWYgKCFpc1Jvb3QpIHtcbiAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICB9XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBpZiAoaXNSZXNlcnZlZEF0dHJpYnV0ZShoeXBoZW5hdGVkS2V5KSB8fFxuICAgICAgICAgIGNvbmZpZy5pc1Jlc2VydmVkQXR0cihoeXBoZW5hdGVkS2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIlxcXCJcIiArIGh5cGhlbmF0ZWRLZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHZtLiRwYXJlbnQgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgIFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcbiAgICAgICAgICAgIFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICB2YXIgZGF0YSA9IHZtLiRvcHRpb25zLmRhdGE7XG4gIGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG4gICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICB7XG4gICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICBwdXNoVGFyZ2V0KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJkYXRhKClcIik7XG4gICAgcmV0dXJuIHt9XG4gIH0gZmluYWxseSB7XG4gICAgcG9wVGFyZ2V0KCk7XG4gIH1cbn1cblxudmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgdmFyIGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcblxuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgdmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgaW4gdm0uJGRhdGEpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgfSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIHByb3AuXCIpLCB2bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkIChcbiAgdGFyZ2V0LFxuICBrZXksXG4gIHVzZXJEZWZcbikge1xuICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgaWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgIDogdXNlckRlZjtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcbiAgfSBlbHNlIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgIDogdXNlckRlZi5nZXRcbiAgICAgIDogbm9vcDtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcbiAgICAgID8gdXNlckRlZi5zZXRcbiAgICAgIDogbm9vcDtcbiAgfVxuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIHtcbiAgICAgIGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuICAgICAgICAgIFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggYW4gZXhpc3RpbmcgVnVlIGluc3RhbmNlIG1ldGhvZC4gXCIgK1xuICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyIChcbiAgdm0sXG4gIGV4cE9yRm4sXG4gIGhhbmRsZXIsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gIC8vIHRoZSBvYmplY3QgaGVyZS5cbiAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG4gIHZhciBwcm9wc0RlZiA9IHt9O1xuICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICB7XG4gICAgZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcbiAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9O1xuICAgIHByb3BzRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICBWdWUucHJvdG90eXBlLiRzZXQgPSBzZXQ7XG4gIFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucylcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gIHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgaWYgKHByb3ZpZGUpIHtcbiAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBwcm92aWRlLmNhbGwodm0pXG4gICAgICA6IHByb3ZpZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG4gIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICBpZiAocmVzdWx0KSB7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIFwiICtcbiAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcbiAgaWYgKGluamVjdCkge1xuICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW5qZWN0LCBrZXkpLmVudW1lcmFibGVcbiAgICAgIH0pXG4gICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBoYXNPd24oc291cmNlLl9wcm92aWRlZCwgcHJvdmlkZUtleSkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm4oKFwiSW5qZWN0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBub3QgZm91bmRcIiksIHZtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gIHZhbCxcbiAgcmVuZGVyXG4pIHtcbiAgdmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICByZXQgPSBuZXcgQXJyYXkodmFsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgIHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzRGVmKHJldCkpIHtcbiAgICAocmV0KS5faXNWTGlzdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICovXG5mdW5jdGlvbiByZW5kZXJTbG90IChcbiAgbmFtZSxcbiAgZmFsbGJhY2ssXG4gIHByb3BzLFxuICBiaW5kT2JqZWN0XG4pIHtcbiAgdmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuICB2YXIgbm9kZXM7XG4gIGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3RcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2Rlcykge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3ROb2Rlcy5fcmVuZGVyZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICAgIFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIG5vZGVzID0gc2xvdE5vZGVzIHx8IGZhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHRhcmdldCA9IHByb3BzICYmIHByb3BzLnNsb3Q7XG4gIGlmICh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy4kY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnLCB7IHNsb3Q6IHRhcmdldCB9LCBub2RlcylcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZXNcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcbiAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaXNLZXlOb3RNYXRjaCAoZXhwZWN0LCBhY3R1YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICB9XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuICogZXhwb3NlZCBhcyBWdWUucHJvdG90eXBlLl9rXG4gKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAqL1xuZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG4gIGV2ZW50S2V5Q29kZSxcbiAga2V5LFxuICBidWlsdEluS2V5Q29kZSxcbiAgZXZlbnRLZXlOYW1lLFxuICBidWlsdEluS2V5TmFtZVxuKSB7XG4gIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2goYnVpbHRJbktleU5hbWUsIGV2ZW50S2V5TmFtZSlcbiAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgcmV0dXJuIGlzS2V5Tm90TWF0Y2gobWFwcGVkS2V5Q29kZSwgZXZlbnRLZXlDb2RlKVxuICB9IGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcbiAgZGF0YSxcbiAgdGFnLFxuICB2YWx1ZSxcbiAgYXNQcm9wLFxuICBpc1N5bmNcbikge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ3YtYmluZCB3aXRob3V0IGFyZ3VtZW50IGV4cGVjdHMgYW4gT2JqZWN0IG9yIEFycmF5IHZhbHVlJyxcbiAgICAgICAgdGhpc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2g7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgga2V5ICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAga2V5ID09PSAnc3R5bGUnIHx8XG4gICAgICAgICAgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICA/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcbiAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShrZXkgaW4gaGFzaCkpIHtcbiAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgaWYgKGlzU3luYykge1xuICAgICAgICAgICAgdmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICB2YWx1ZVtrZXldID0gJGV2ZW50O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuICovXG5mdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICBpbmRleCxcbiAgaXNJbkZvclxuKSB7XG4gIHZhciBjYWNoZWQgPSB0aGlzLl9zdGF0aWNUcmVlcyB8fCAodGhpcy5fc3RhdGljVHJlZXMgPSBbXSk7XG4gIHZhciB0cmVlID0gY2FjaGVkW2luZGV4XTtcbiAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gIC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiB0cmVlXG4gIH1cbiAgLy8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgIHRoaXMuX3JlbmRlclByb3h5LFxuICAgIG51bGwsXG4gICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICApO1xuICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICByZXR1cm4gdHJlZVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cbiAqL1xuZnVuY3Rpb24gbWFya09uY2UgKFxuICB0cmVlLFxuICBpbmRleCxcbiAga2V5XG4pIHtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX29uY2VfX1wiICsgaW5kZXggKyAoa2V5ID8gKFwiX1wiICsga2V5KSA6IFwiXCIpKSwgdHJ1ZSk7XG4gIHJldHVybiB0cmVlXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMgKFxuICB0cmVlLFxuICBrZXksXG4gIGlzT25jZVxuKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gIG5vZGUua2V5ID0ga2V5O1xuICBub2RlLmlzT25jZSA9IGlzT25jZTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMgKGRhdGEsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm07XG4gIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgY29udGV4dFZtID0gT2JqZWN0LmNyZWF0ZShwYXJlbnQpO1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNvbnRleHQgdm0gcGFzc2VkIGluIGlzIGEgZnVuY3Rpb25hbCBjb250ZXh0IGFzIHdlbGwuXG4gICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgLy8gcmVhbCBjb250ZXh0IGluc3RhbmNlLlxuICAgIGNvbnRleHRWbSA9IHBhcmVudDtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBwYXJlbnQgPSBwYXJlbnQuX29yaWdpbmFsO1xuICB9XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCk7IH07XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IGRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSAmJiAhQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgdm5vZGUuZm5Db250ZXh0ID0gcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZub2RlXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gIH1cbn1cblxuaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG4gIEN0b3IsXG4gIHByb3BzRGF0YSxcbiAgZGF0YSxcbiAgY29udGV4dFZtLFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICB2YXIgcHJvcHMgPSB7fTtcbiAgdmFyIHByb3BPcHRpb25zID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzRGVmKHByb3BPcHRpb25zKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwgZW1wdHlPYmplY3QpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cbiAgICBpZiAoaXNEZWYoZGF0YS5wcm9wcykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5wcm9wcyk7IH1cbiAgfVxuXG4gIHZhciByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KFxuICAgIGRhdGEsXG4gICAgcHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGV4dFZtLFxuICAgIEN0b3JcbiAgKTtcblxuICB2YXIgdm5vZGUgPSBvcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIHJlbmRlckNvbnRleHQuX2MsIHJlbmRlckNvbnRleHQpO1xuXG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5KHZub2Rlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCAodm5vZGUsIGRhdGEsIGNvbnRleHRWbSwgb3B0aW9ucykge1xuICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgLy8gdGhhdCBzaG91bGQgbm90IGJlIG1hdGNoZWQgdG8gbWF0Y2guXG4gIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICBjbG9uZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gIGNsb25lLmZuT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGlmIChkYXRhLnNsb3QpIHtcbiAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgfVxuICByZXR1cm4gY2xvbmVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuXG5cblxuLy8gUmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBob29rIHRvIHdlZXggbmF0aXZlIHJlbmRlciBlbmdpbmUuXG4vLyBUaGUgaG9vayB3aWxsIGJlIHRyaWdnZXJlZCBieSBuYXRpdmUsIG5vdCBqYXZhc2NyaXB0LlxuXG5cbi8vIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBjb21wb25lbnQgdG8gd2VleCBuYXRpdmUgcmVuZGVyIGVuZ2luZS5cblxuLyogICovXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYW5rczEwMTAwL3dlZXgtbmF0aXZlLWRpcmVjdGl2ZS90cmVlL21hc3Rlci9jb21wb25lbnRcblxuLy8gbGlzdGVuaW5nIG9uIG5hdGl2ZSBjYWxsYmFja1xuXG4vKiAgKi9cblxuLyogICovXG5cbi8vIGlubGluZSBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG52YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCAoXG4gICAgdm5vZGUsXG4gICAgaHlkcmF0aW5nLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG1cbiAgKSB7XG4gICAgaWYgKFxuICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlXG4gICAgKSB7XG4gICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgIHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICBjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcbiAgICAgICAgdm5vZGUsXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLFxuICAgICAgICBwYXJlbnRFbG0sXG4gICAgICAgIHJlZkVsbVxuICAgICAgKTtcbiAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgfVxuICB9LFxuXG4gIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICBjaGlsZCxcbiAgICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgIHZub2RlLCAvLyBuZXcgcGFyZW50IHZub2RlXG4gICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICk7XG4gIH0sXG5cbiAgaW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayhjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICBpZiAoY29udGV4dC5faXNNb3VudGVkKSB7XG4gICAgICAgIC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgIC8vIGNoYW5nZSwgc28gZGlyZWN0bHkgd2Fsa2luZyB0aGUgdHJlZSBoZXJlIG1heSBjYWxsIGFjdGl2YXRlZCBob29rc1xuICAgICAgICAvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgcXVldWVBY3RpdmF0ZWRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIHRydWUgLyogZGlyZWN0ICovKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmIChpc1VuZGVmKEN0b3IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG4gIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICBDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuICB9XG5cbiAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAvLyByZWplY3QuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKTtcblxuICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciB2bm9kZVxuICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgdmFyIHZub2RlID0gbmV3IFZOb2RlKFxuICAgIChcInZ1ZS1jb21wb25lbnQtXCIgKyAoQ3Rvci5jaWQpICsgKG5hbWUgPyAoXCItXCIgKyBuYW1lKSA6ICcnKSksXG4gICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9LFxuICAgIGFzeW5jRmFjdG9yeVxuICApO1xuXG4gIC8vIFdlZXggc3BlY2lmaWM6IGludm9rZSByZWN5Y2xlLWxpc3Qgb3B0aW1pemVkIEByZW5kZXIgZnVuY3Rpb24gZm9yXG4gIC8vIGV4dHJhY3RpbmcgY2VsbC1zbG90IHRlbXBsYXRlLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vSGFua3MxMDEwMC93ZWV4LW5hdGl2ZS1kaXJlY3RpdmUvdHJlZS9tYXN0ZXIvY29tcG9uZW50XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50LCAvLyBhY3RpdmVJbnN0YW5jZSBpbiBsaWZlY3ljbGUgc3RhdGVcbiAgcGFyZW50RWxtLFxuICByZWZFbG1cbikge1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcbiAgICBfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuICB9O1xuICAvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICBpZiAoaXNEZWYoaW5saW5lVGVtcGxhdGUpKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbiAgcmV0dXJuIG5ldyB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5zdGFsbENvbXBvbmVudEhvb2tzIChkYXRhKSB7XG4gIHZhciBob29rcyA9IGRhdGEuaG9vayB8fCAoZGF0YS5ob29rID0ge30pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgaG9va3Nba2V5XSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgfVxufVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cbmZ1bmN0aW9uIHRyYW5zZm9ybU1vZGVsIChvcHRpb25zLCBkYXRhKSB7XG4gIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICB2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gIGlmIChpc0RlZihvbltldmVudF0pKSB7XG4gICAgb25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuICB9IGVsc2Uge1xuICAgIG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcbnZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIGNvbnRleHQsXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIG5vcm1hbGl6YXRpb25UeXBlLFxuICBhbHdheXNOb3JtYWxpemVcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCBpc1ByaW1pdGl2ZShkYXRhKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgbm9ybWFsaXphdGlvblR5cGUgPSBBTFdBWVNfTk9STUFMSVpFO1xuICB9XG4gIHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZVxuKSB7XG4gIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEua2V5KSAmJiAhaXNQcmltaXRpdmUoZGF0YS5rZXkpXG4gICkge1xuICAgIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICd1c2Ugc3RyaW5nL251bWJlciB2YWx1ZSBpbnN0ZWFkLicsXG4gICAgICAgIGNvbnRleHRcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pICYmXG4gICAgdHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG4gICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgfVxuICBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcbiAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9XG4gIHZhciB2bm9kZSwgbnM7XG4gIGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuICAgIHZhciBDdG9yO1xuICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgaWYgKGNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAgICAgY29uZmlnLnBhcnNlUGxhdGZvcm1UYWdOYW1lKHRhZyksIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRGVmKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkge1xuICAgICAgLy8gY29tcG9uZW50XG4gICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuICAgICAgLy8gcGFyZW50IG5vcm1hbGl6ZXMgY2hpbGRyZW5cbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICB0YWcsIGRhdGEsIGNoaWxkcmVuLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfSBlbHNlIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgIGlmIChpc0RlZihkYXRhKSkgeyByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKTsgfVxuICAgIHJldHVybiB2bm9kZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMsIGZvcmNlKSB7XG4gIHZub2RlLm5zID0gbnM7XG4gIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgIG5zID0gdW5kZWZpbmVkO1xuICAgIGZvcmNlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgKFxuICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gcmVmICM1MzE4XG4vLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHBhcmVudCByZS1yZW5kZXIgd2hlbiBkZWVwIGJpbmRpbmdzIGxpa2UgOnN0eWxlIGFuZFxuLy8gOmNsYXNzIGFyZSB1c2VkIG9uIHNsb3Qgbm9kZXNcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gIGlmIChpc09iamVjdChkYXRhLnN0eWxlKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICB9XG4gIGlmIChpc09iamVjdChkYXRhLmNsYXNzKSkge1xuICAgIHRyYXZlcnNlKGRhdGEuY2xhc3MpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICB2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gIHZhciBwYXJlbnRWbm9kZSA9IHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuICB2YXIgcmVuZGVyQ29udGV4dCA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmNvbnRleHQ7XG4gIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gIHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuICAvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgLy8gJGF0dHJzICYgJGxpc3RlbmVycyBhcmUgZXhwb3NlZCBmb3IgZWFzaWVyIEhPQyBjcmVhdGlvbi5cbiAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIC8vIHJlc2V0IF9yZW5kZXJlZCBmbGFnIG9uIHNsb3RzIGZvciBkdXBsaWNhdGUgc2xvdCBjaGVja1xuICAgIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2bS4kc2xvdHMpIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHZtLiRzbG90c1trZXldLl9yZW5kZXJlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfcGFyZW50Vm5vZGUpIHtcbiAgICAgIHZtLiRzY29wZWRTbG90cyA9IF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzIHx8IGVtcHR5T2JqZWN0O1xuICAgIH1cblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIHtcbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZub2RlID0gdm0uJG9wdGlvbnMucmVuZGVyRXJyb3IuY2FsbCh2bS5fcmVuZGVyUHJveHksIHZtLiRjcmVhdGVFbGVtZW50LCBlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJFcnJvclwiKTtcbiAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xufVxuXG4vKiAgKi9cblxudmFyIHVpZCQzID0gMDtcblxuZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhIHVpZFxuICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgdmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBlbmRUYWcgPSBcInZ1ZS1wZXJmLWVuZDpcIiArICh2bS5fdWlkKTtcbiAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgIH1cblxuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgaW5pdFByb3h5KHZtKTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgIH1cblxuICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICBvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBvcHRzLl9wYXJlbnRWbm9kZSA9IHBhcmVudFZub2RlO1xuICBvcHRzLl9wYXJlbnRFbG0gPSBvcHRpb25zLl9wYXJlbnRFbG07XG4gIG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcblxuICB2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gcGFyZW50Vm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgb3B0cy5wcm9wc0RhdGEgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xuICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZztcblxuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUpO1xuc3RhdGVNaXhpbihWdWUpO1xuZXZlbnRzTWl4aW4oVnVlKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSk7XG5yZW5kZXJNaXhpbihWdWUpO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgdmFyIGluc3RhbGxlZFBsdWdpbnMgPSAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKSk7XG4gICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBsdWdpbi5pbnN0YWxsLmFwcGx5KHBsdWdpbiwgYXJncyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGluc3RhbGxlZFBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgIHJldHVybiB0aGlzXG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0TWl4aW4kMSAoVnVlKSB7XG4gIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG4gIC8qKlxuICAgKiBFYWNoIGluc3RhbmNlIGNvbnN0cnVjdG9yLCBpbmNsdWRpbmcgVnVlLCBoYXMgYSB1bmlxdWVcbiAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICovXG4gIFZ1ZS5jaWQgPSAwO1xuICB2YXIgY2lkID0gMTtcblxuICAvKipcbiAgICogQ2xhc3MgaW5oZXJpdGFuY2VcbiAgICovXG4gIFZ1ZS5leHRlbmQgPSBmdW5jdGlvbiAoZXh0ZW5kT3B0aW9ucykge1xuICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgdmFyIFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgdmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgIHJldHVybiBjYWNoZWRDdG9yc1tTdXBlcklkXVxuICAgIH1cblxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSkge1xuICAgICAgdmFsaWRhdGVDb21wb25lbnROYW1lKG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gIHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxufVxuXG5mdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uaW5kZXhPZihuYW1lKSA+IC0xXG4gIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4uc3BsaXQoJywnKS5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZSAoa2VlcEFsaXZlSW5zdGFuY2UsIGZpbHRlcikge1xuICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgdmFyIGtleXMgPSBrZWVwQWxpdmVJbnN0YW5jZS5rZXlzO1xuICB2YXIgX3Zub2RlID0ga2VlcEFsaXZlSW5zdGFuY2UuX3Zub2RlO1xuICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICB2YXIgY2FjaGVkTm9kZSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZE5vZGUpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleSwga2V5cywgX3Zub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5IChcbiAgY2FjaGUsXG4gIGtleSxcbiAga2V5cyxcbiAgY3VycmVudFxuKSB7XG4gIHZhciBjYWNoZWQkJDEgPSBjYWNoZVtrZXldO1xuICBpZiAoY2FjaGVkJCQxICYmICghY3VycmVudCB8fCBjYWNoZWQkJDEudGFnICE9PSBjdXJyZW50LnRhZykpIHtcbiAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZVtrZXldID0gbnVsbDtcbiAgcmVtb3ZlKGtleXMsIGtleSk7XG59XG5cbnZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XTtcblxudmFyIEtlZXBBbGl2ZSA9IHtcbiAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICBhYnN0cmFjdDogdHJ1ZSxcblxuICBwcm9wczoge1xuICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBleGNsdWRlOiBwYXR0ZXJuVHlwZXMsXG4gICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24gY3JlYXRlZCAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gIH0sXG5cbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMkMS5jYWNoZSwga2V5LCB0aGlzJDEua2V5cyk7XG4gICAgfVxuICB9LFxuXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSk7XG4gICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMkMSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcbiAgICB2YXIgc2xvdCA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICB2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMpIHtcbiAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcbiAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgIHZhciBleGNsdWRlID0gcmVmLmV4Y2x1ZGU7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAvLyBleGNsdWRlZFxuICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9XG5cbiAgICAgIHZhciByZWYkMSA9IHRoaXM7XG4gICAgICB2YXIgY2FjaGUgPSByZWYkMS5jYWNoZTtcbiAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAvLyBzYW1lIGNvbnN0cnVjdG9yIG1heSBnZXQgcmVnaXN0ZXJlZCBhcyBkaWZmZXJlbnQgbG9jYWwgY29tcG9uZW50c1xuICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgID8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuICAgICAgICA6IHZub2RlLmtleTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgfVxufVxuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAge1xuICAgIGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cbiAgLy8gZXhwb3NlZCB1dGlsIG1ldGhvZHMuXG4gIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICBWdWUudXRpbCA9IHtcbiAgICB3YXJuOiB3YXJuLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZVxuICB9O1xuXG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgQVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfSk7XG5cbiAgLy8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgVnVlLm9wdGlvbnMuX2Jhc2UgPSBWdWU7XG5cbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuICBpbml0VXNlKFZ1ZSk7XG4gIGluaXRNaXhpbiQxKFZ1ZSk7XG4gIGluaXRFeHRlbmQoVnVlKTtcbiAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICB9XG59KTtcblxuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gIHZhbHVlOiBGdW5jdGlvbmFsUmVuZGVyQ29udGV4dFxufSk7XG5cblZ1ZS52ZXJzaW9uID0gJzIuNS4xNyc7XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBhcmUgcmVzZXJ2ZWQgZm9yIHdlYiBiZWNhdXNlIHRoZXkgYXJlIGRpcmVjdGx5IGNvbXBpbGVkIGF3YXlcbi8vIGR1cmluZyB0ZW1wbGF0ZSBjb21waWxhdGlvblxudmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xudmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xudmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICByZXR1cm4gKFxuICAgIChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxufVxuXG5mdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuICByZXR1cm4ge1xuICAgIHN0YXRpY0NsYXNzOiBjb25jYXQoY2hpbGQuc3RhdGljQ2xhc3MsIHBhcmVudC5zdGF0aWNDbGFzcyksXG4gICAgY2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgIDogcGFyZW50LmNsYXNzXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2xhc3MgKFxuICBzdGF0aWNDbGFzcyxcbiAgZHluYW1pY0NsYXNzXG4pIHtcbiAgaWYgKGlzRGVmKHN0YXRpY0NsYXNzKSB8fCBpc0RlZihkeW5hbWljQ2xhc3MpKSB7XG4gICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gY29uY2F0IChhLCBiKSB7XG4gIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNsYXNzICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpXG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICByZXR1cm4gJydcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgdmFyIHN0cmluZ2lmaWVkO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChpc0RlZihzdHJpbmdpZmllZCA9IHN0cmluZ2lmeUNsYXNzKHZhbHVlW2ldKSkgJiYgc3RyaW5naWZpZWQgIT09ICcnKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlPYmplY3QgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlW2tleV0pIHtcbiAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgcmVzICs9IGtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIG5hbWVzcGFjZU1hcCA9IHtcbiAgc3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbn07XG5cbnZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG4gICdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUscGljdHVyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcbiAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgJ3Msc2FtcCxzbWFsbCxzcGFuLHN0cm9uZyxzdWIsc3VwLHRpbWUsdSx2YXIsd2JyLGFyZWEsYXVkaW8sbWFwLHRyYWNrLHZpZGVvLCcgK1xuICAnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG4gICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgJ2J1dHRvbixkYXRhbGlzdCxmaWVsZHNldCxmb3JtLGlucHV0LGxhYmVsLGxlZ2VuZCxtZXRlcixvcHRncm91cCxvcHRpb24sJyArXG4gICdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAnY29udGVudCxlbGVtZW50LHNoYWRvdyx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdCdcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG52YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG52YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcbn07XG5cbmZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgcmV0dXJuICdzdmcnXG4gIH1cbiAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gIC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcbiAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgcmV0dXJuICdtYXRoJ1xuICB9XG59XG5cbnZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgIHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cbiAgfVxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICBlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuICAgICkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuICB9XG59XG5cbnZhciBpc1RleHRJbnB1dFR5cGUgPSBtYWtlTWFwKCd0ZXh0LG51bWJlcixwYXNzd29yZCxzZWFyY2gsZW1haWwsdGVsLHVybCcpO1xuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoc2NvcGVJZCwgJycpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAoXywgdm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gIH0sXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICByZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfVxuICB9LFxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95ICh2bm9kZSkge1xuICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlclJlZiAodm5vZGUsIGlzUmVtb3ZhbCkge1xuICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gIGlmICghaXNEZWYoa2V5KSkgeyByZXR1cm4gfVxuXG4gIHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG4gIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gIHZhciByZWZzID0gdm0uJHJlZnM7XG4gIGlmIChpc1JlbW92YWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICByZW1vdmUocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVmc1trZXldID0gcmVmO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFZpcnR1YWwgRE9NIHBhdGNoaW5nIGFsZ29yaXRobSBiYXNlZCBvbiBTbmFiYmRvbSBieVxuICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcGFsZGVwaW5kL3NuYWJiZG9tL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqXG4gKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG4gKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAqL1xuXG52YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG52YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuZnVuY3Rpb24gc2FtZVZub2RlIChhLCBiKSB7XG4gIHJldHVybiAoXG4gICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgIChcbiAgICAgICAgYS50YWcgPT09IGIudGFnICYmXG4gICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgIHNhbWVJbnB1dFR5cGUoYSwgYilcbiAgICAgICkgfHwgKFxuICAgICAgICBpc1RydWUoYS5pc0FzeW5jUGxhY2Vob2xkZXIpICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgKVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG4gIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpO1xuICB2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IGlzVGV4dElucHV0VHlwZSh0eXBlQSkgJiYgaXNUZXh0SW5wdXRUeXBlKHR5cGVCKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgdmFyIGksIGtleTtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICBpZiAoaXNEZWYoa2V5KSkgeyBtYXBba2V5XSA9IGk7IH1cbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgdmFyIGksIGo7XG4gIHZhciBjYnMgPSB7fTtcblxuICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgdmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoaXNEZWYobW9kdWxlc1tqXVtob29rc1tpXV0pKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVOb2RlKGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQkJDEgKHZub2RlLCBpblZQcmUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgIWluVlByZSAmJlxuICAgICAgIXZub2RlLm5zICYmXG4gICAgICAhKFxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICBjb25maWcuaWdub3JlZEVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGlnbm9yZSkge1xuICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICA/IGlnbm9yZS50ZXN0KHZub2RlLnRhZylcbiAgICAgICAgICAgIDogaWdub3JlID09PSB2bm9kZS50YWdcbiAgICAgICAgfSlcbiAgICAgICkgJiZcbiAgICAgIGNvbmZpZy5pc1Vua25vd25FbGVtZW50KHZub2RlLnRhZylcbiAgICApXG4gIH1cblxuICB2YXIgY3JlYXRpbmdFbG1JblZQcmUgPSAwO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgdm5vZGUsXG4gICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgIHBhcmVudEVsbSxcbiAgICByZWZFbG0sXG4gICAgbmVzdGVkLFxuICAgIG93bmVyQXJyYXksXG4gICAgaW5kZXhcbiAgKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgIC8vIFRoaXMgdm5vZGUgd2FzIHVzZWQgaW4gYSBwcmV2aW91cyByZW5kZXIhXG4gICAgICAvLyBub3cgaXQncyB1c2VkIGFzIGEgbmV3IG5vZGUsIG92ZXJ3cml0aW5nIGl0cyBlbG0gd291bGQgY2F1c2VcbiAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgIC8vIHJlZmVyZW5jZSBub2RlLiBJbnN0ZWFkLCB3ZSBjbG9uZSB0aGUgbm9kZSBvbi1kZW1hbmQgYmVmb3JlIGNyZWF0aW5nXG4gICAgICAvLyBhc3NvY2lhdGVkIERPTSBlbGVtZW50IGZvciBpdC5cbiAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICB9XG5cbiAgICB2bm9kZS5pc1Jvb3RJbnNlcnQgPSAhbmVzdGVkOyAvLyBmb3IgdHJhbnNpdGlvbiBlbnRlciBjaGVja1xuICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGNyZWF0aW5nRWxtSW5WUHJlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG4gICAgICAgICAgICAncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG4gICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgdmFyIGkgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgdmFyIGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcbiAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgICB9XG4gICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgLy8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG4gICAgICAvLyBjb21wb25lbnQgYWxzbyBoYXMgc2V0IHRoZSBwbGFjZWhvbGRlciB2bm9kZSdzIGVsbS5cbiAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICBpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcbiAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KSkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbXB0eSBjb21wb25lbnQgcm9vdC5cbiAgICAgIC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBpbnZva2UgdGhlIGluc2VydCBob29rXG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaTtcbiAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgLy8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgdmFyIGlubmVyTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgIGlubmVyTm9kZSA9IGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZiQkMSkge1xuICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICBpZiAoaXNEZWYocmVmJCQxKSkge1xuICAgICAgICBpZiAocmVmJCQxLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbiAodm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKGNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmVsbSwgbnVsbCwgdHJ1ZSwgY2hpbGRyZW4sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKFN0cmluZyh2bm9kZS50ZXh0KSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzUGF0Y2hhYmxlICh2bm9kZSkge1xuICAgIHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0RlZih2bm9kZS50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VDcmVhdGVIb29rcyAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgaWYgKGlzRGVmKGkuY3JlYXRlKSkgeyBpLmNyZWF0ZShlbXB0eU5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuZm5TY29wZUlkKSkge1xuICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICBpZiAoaXNEZWYoaSA9IGFjdGl2ZUluc3RhbmNlKSAmJlxuICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcbiAgICApIHtcbiAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgY3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIGZhbHNlLCB2bm9kZXMsIHN0YXJ0SWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcbiAgICBpZiAoaXNEZWYocm0pIHx8IGlzRGVmKHZub2RlLmRhdGEpKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG4gICAgICBpZiAoaXNEZWYocm0pKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3RseSByZW1vdmluZ1xuICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgfVxuICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGlzRGVmKGkgPSBpLl92bm9kZSkgJiYgaXNEZWYoaS5kYXRhKSkge1xuICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMucmVtb3ZlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5yZW1vdmUpKSB7XG4gICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZU5vZGUodm5vZGUuZWxtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDaGlsZHJlbiAocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgdmFyIG5ld1N0YXJ0SWR4ID0gMDtcbiAgICB2YXIgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgIHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gICAgdmFyIG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICB2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICAgIHZhciBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAge1xuICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRW5kVm5vZGUuZWxtKSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgbGVmdFxuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgaWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSlcbiAgICAgICAgICA/IG9sZEtleVRvSWR4W25ld1N0YXJ0Vm5vZGUua2V5XVxuICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGVUb01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEdXBsaWNhdGVLZXlzIChjaGlsZHJlbikge1xuICAgIHZhciBzZWVuS2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2bm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleTtcbiAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgIGlmIChzZWVuS2V5c1trZXldKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuS2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdmFyIGMgPSBvbGRDaFtpXTtcbiAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblxuICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgaHlkcmF0ZShvbGRWbm9kZS5lbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHJldXNlIGVsZW1lbnQgZm9yIHN0YXRpYyB0cmVlcy5cbiAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cbiAgICAvLyByZXNldCBieSB0aGUgaG90LXJlbG9hZC1hcGkgYW5kIHdlIG5lZWQgdG8gZG8gYSBwcm9wZXIgcmUtcmVuZGVyLlxuICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgKSB7XG4gICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSkgeyBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgICBpZiAoaXNVbmRlZih2bm9kZS50ZXh0KSkge1xuICAgICAgaWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgfSBlbHNlIGlmIChpc0RlZihjaCkpIHtcbiAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cbiAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZENoKSkge1xuICAgICAgICByZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgdm5vZGUudGV4dCk7XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnBvc3RwYXRjaCkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayAodm5vZGUsIHF1ZXVlLCBpbml0aWFsKSB7XG4gICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICBpZiAoaXNUcnVlKGluaXRpYWwpICYmIGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgIHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gIC8vIGxpc3Qgb2YgbW9kdWxlcyB0aGF0IGNhbiBza2lwIGNyZWF0ZSBob29rIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB0aGV5XG4gIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAvLyBkZWVwIHVwZGF0ZXMgKCM3MDYzKS5cbiAgdmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgdm5vZGUuZWxtID0gZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpICYmIGlzRGVmKHZub2RlLmFzeW5jRmFjdG9yeSkpIHtcbiAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2xpZW50IGlubmVySFRNTDogJywgZWxtLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgYW5kIGNvbXBhcmUgY2hpbGRyZW4gbGlzdHNcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjaGlsZE5vZGUgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBhY3R1YWwgY2hpbGROb2RlcyBsaXN0IGlzXG4gICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoIHx8IGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgaWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcbiAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZ1bGxJbnZva2UgJiYgZGF0YVsnY2xhc3MnXSkge1xuICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICBpZiAoaXNEZWYodm5vZGUudGFnKSkge1xuICAgICAgcmV0dXJuIHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHwgKFxuICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICB2bm9kZS50YWcudG9Mb3dlckNhc2UoKSA9PT0gKG5vZGUudGFnTmFtZSAmJiBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSlcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5LCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgLy8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgLy8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG4gICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzUmVhbEVsZW1lbnQpIHtcbiAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgLy8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cbiAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgb2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcbiAgICAgICAgICAgIGh5ZHJhdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuICAgICAgICAgICAgaWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBvbGRWbm9kZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2luZyBleGlzdGluZyBlbGVtZW50XG4gICAgICAgIHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICBjcmVhdGVFbG0oXG4gICAgICAgICAgdm5vZGUsXG4gICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtJDEsXG4gICAgICAgICAgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcbiAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgYW5jZXN0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgIC8vIGludm9rZSBpbnNlcnQgaG9va3MgdGhhdCBtYXkgaGF2ZSBiZWVuIG1lcmdlZCBieSBjcmVhdGUgaG9va3MuXG4gICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGFuY2VzdG9yLmRhdGEuaG9vay5pbnNlcnQ7XG4gICAgICAgICAgICAgIGlmIChpbnNlcnQubWVyZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDwgaW5zZXJ0LmZucy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQuZm5zW2kkMl0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlc3Ryb3kgb2xkIG5vZGVcbiAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0kMSwgW29sZFZub2RlXSwgMCwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaXNJbml0aWFsUGF0Y2gpO1xuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gIGNyZWF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcbiAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICBkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuICAgIHVwZGF0ZURpcmVjdGl2ZXModm5vZGUsIGVtcHR5Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcbiAgICB9XG4gICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dXG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBvcHRzID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIGtleSwgY3VyLCBvbGQ7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRBdHRycyA9IG9sZFZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYoYXR0cnMuX19vYl9fKSkge1xuICAgIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICBjdXIgPSBhdHRyc1trZXldO1xuICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuICAgIH1cbiAgfVxuICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICB9XG4gIGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG4gICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgLy8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCdcbiAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgOiBrZXk7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICBrZXkgPT09ICdwbGFjZWhvbGRlcicgJiYgIWVsLl9faWVwaFxuICAgICkge1xuICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgfTtcbiAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICB9XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn1cblxuLyogICovXG5cbnZhciB2YWxpZERpdmlzaW9uQ2hhclJFID0gL1tcXHcpLitcXC1fJFxcXV0vO1xuXG5mdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgdmFyIGluRG91YmxlID0gZmFsc2U7XG4gIHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG4gIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gIHZhciBjdXJseSA9IDA7XG4gIHZhciBzcXVhcmUgPSAwO1xuICB2YXIgcGFyZW4gPSAwO1xuICB2YXIgbGFzdEZpbHRlckluZGV4ID0gMDtcbiAgdmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgIHByZXYgPSBjO1xuICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgIGlmIChjID09PSAweDI3ICYmIHByZXYgIT09IDB4NUMpIHsgaW5TaW5nbGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoaW5UZW1wbGF0ZVN0cmluZykge1xuICAgICAgaWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgIGlmIChjID09PSAweDJmICYmIHByZXYgIT09IDB4NUMpIHsgaW5SZWdleCA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSArIDEpICE9PSAweDdDICYmXG4gICAgICBleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcbiAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICkge1xuICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG4gICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgY2FzZSAweDYwOiBpblRlbXBsYXRlU3RyaW5nID0gdHJ1ZTsgYnJlYWsgLy8gYFxuICAgICAgICBjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG4gICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgY2FzZSAweDVCOiBzcXVhcmUrKzsgYnJlYWsgICAgICAgICAgICAgICAgLy8gW1xuICAgICAgICBjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG4gICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgY2FzZSAweDdEOiBjdXJseS0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgfVxuICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICB2YXIgcCA9ICh2b2lkIDApO1xuICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICBmb3IgKDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBwID0gZXhwLmNoYXJBdChqKTtcbiAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICB9IGVsc2UgaWYgKGxhc3RGaWx0ZXJJbmRleCAhPT0gMCkge1xuICAgIHB1c2hGaWx0ZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hGaWx0ZXIgKCkge1xuICAgIChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG4gICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gIH1cblxuICBpZiAoZmlsdGVycykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByZXNzaW9uID0gd3JhcEZpbHRlcihleHByZXNzaW9uLCBmaWx0ZXJzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhwcmVzc2lvblxufVxuXG5mdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICB2YXIgaSA9IGZpbHRlci5pbmRleE9mKCcoJyk7XG4gIGlmIChpIDwgMCkge1xuICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIGZpbHRlciArIFwiXFxcIikoXCIgKyBleHAgKyBcIilcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgcmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgKGFyZ3MgIT09ICcpJyA/ICcsJyArIGFyZ3MgOiBhcmdzKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgZWwucGxhaW4gPSBmYWxzZTtcbn1cblxuLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG5mdW5jdGlvbiBhZGRSYXdBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgZWwuYXR0cnNMaXN0LnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZERpcmVjdGl2ZSAoXG4gIGVsLFxuICBuYW1lLFxuICByYXdOYW1lLFxuICB2YWx1ZSxcbiAgYXJnLFxuICBtb2RpZmllcnNcbikge1xuICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhZGRIYW5kbGVyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICBtb2RpZmllcnMsXG4gIGltcG9ydGFudCxcbiAgd2FyblxuKSB7XG4gIG1vZGlmaWVycyA9IG1vZGlmaWVycyB8fCBlbXB0eU9iamVjdDtcbiAgLy8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICkge1xuICAgIHdhcm4oXG4gICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgJ1Bhc3NpdmUgaGFuZGxlciBjYW5cXCd0IHByZXZlbnQgZGVmYXVsdCBldmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgaWYgKG1vZGlmaWVycy5jYXB0dXJlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgIG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuICB9XG4gIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICBuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAobW9kaWZpZXJzLnBhc3NpdmUpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgbmFtZSA9ICcmJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIHBhc3NpdmVcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAvLyB0aGUgb25seSB0YXJnZXQgZW52cyB0aGF0IGhhdmUgcmlnaHQvbWlkZGxlIGNsaWNrcy5cbiAgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICBpZiAobW9kaWZpZXJzLnJpZ2h0KSB7XG4gICAgICBuYW1lID0gJ2NvbnRleHRtZW51JztcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudHM7XG4gIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gIH1cblxuICB2YXIgbmV3SGFuZGxlciA9IHtcbiAgICB2YWx1ZTogdmFsdWUudHJpbSgpXG4gIH07XG4gIGlmIChtb2RpZmllcnMgIT09IGVtcHR5T2JqZWN0KSB7XG4gICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gIH1cblxuICB2YXIgaGFuZGxlcnMgPSBldmVudHNbbmFtZV07XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcbiAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgIGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gIH1cblxuICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICBnZXRTdGF0aWNcbikge1xuICB2YXIgZHluYW1pY1ZhbHVlID1cbiAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgfSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgdmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gIGVsLFxuICBuYW1lLFxuICByZW1vdmVGcm9tTWFwXG4pIHtcbiAgdmFyIHZhbDtcbiAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICB9XG4gIHJldHVybiB2YWxcbn1cblxuLyogICovXG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgdmFyIGJhc2VWYWx1ZUV4cHJlc3Npb24gPSAnJCR2JztcbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG4gIGlmICh0cmltKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID1cbiAgICAgIFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG4gICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAvLyBGaXggaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS9wdWxsLzc3MzBcbiAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXG4gIHZhbCA9IHZhbC50cmltKCk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICBpZiAoaW5kZXgkMSA+IC0xKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAga2V5OiAnXCInICsgdmFsLnNsaWNlKGluZGV4JDEgKyAxKSArICdcIidcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgIGtleTogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0ciA9IHZhbDtcbiAgaW5kZXgkMSA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcblxuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgfSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcbiAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwOiB2YWwuc2xpY2UoMCwgZXhwcmVzc2lvblBvcyksXG4gICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gbmV4dCAoKSB7XG4gIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG59XG5cbmZ1bmN0aW9uIGVvZiAoKSB7XG4gIHJldHVybiBpbmRleCQxID49IGxlblxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0IChjaHIpIHtcbiAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcbn1cblxuZnVuY3Rpb24gcGFyc2VCcmFja2V0IChjaHIpIHtcbiAgdmFyIGluQnJhY2tldCA9IDE7XG4gIGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2hyID09PSAweDVCKSB7IGluQnJhY2tldCsrOyB9XG4gICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgIGlmIChpbkJyYWNrZXQgPT09IDApIHtcbiAgICAgIGV4cHJlc3Npb25FbmRQb3MgPSBpbmRleCQxO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuICB2YXIgc3RyaW5nUXVvdGUgPSBjaHI7XG4gIHdoaWxlICghZW9mKCkpIHtcbiAgICBjaHIgPSBuZXh0KCk7XG4gICAgaWYgKGNociA9PT0gc3RyaW5nUXVvdGUpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgd2FybiQxO1xuXG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxudmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG52YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuZnVuY3Rpb24gbW9kZWwgKFxuICBlbCxcbiAgZGlyLFxuICBfd2FyblxuKSB7XG4gIHdhcm4kMSA9IF93YXJuO1xuICB2YXIgdmFsdWUgPSBkaXIudmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuICB2YXIgdGFnID0gZWwudGFnO1xuICB2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cbiAge1xuICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgIC8vIHZhbHVlIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgIHdhcm4kMShcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgdHlwZT1cXFwiZmlsZVxcXCI+OlxcblwiICtcbiAgICAgICAgXCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgZ2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcbiAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgIHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgKVxuICApO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICBcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgXCJ2YXIgJCR2PVwiICsgKG51bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nKSArIFwiLFwiICtcbiAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgXCJpZigkJGVsLmNoZWNrZWQpeyQkaTwwJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuY29uY2F0KFskJHZdKScpKSArIFwiKX1cIiArXG4gICAgICBcImVsc2V7JCRpPi0xJiYoXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKScpKSArIFwiKX1cIiArXG4gICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgIG51bGwsIHRydWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgdmFsdWVCaW5kaW5nID0gbnVtYmVyID8gKFwiX24oXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIilcIikgOiB2YWx1ZUJpbmRpbmc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICBcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuICAgIFwiLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXFxcIl92YWx1ZVxcXCIgaW4gbyA/IG8uX3ZhbHVlIDogby52YWx1ZTtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gIHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG4gIHZhciBjb2RlID0gXCJ2YXIgJCRzZWxlY3RlZFZhbCA9IFwiICsgc2VsZWN0ZWRWYWwgKyBcIjtcIjtcbiAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gIGVsLFxuICB2YWx1ZSxcbiAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgLy8gZXhjZXB0IGZvciBpbnB1dHMgd2l0aCB2LWJpbmQ6dHlwZVxuICB7XG4gICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgIHZhciB0eXBlQmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuICAgIGlmICh2YWx1ZSQxICYmICF0eXBlQmluZGluZykge1xuICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgd2FybiQxKFxuICAgICAgICBiaW5kaW5nICsgXCI9XFxcIlwiICsgdmFsdWUkMSArIFwiXFxcIiBjb25mbGljdHMgd2l0aCB2LW1vZGVsIG9uIHRoZSBzYW1lIGVsZW1lbnQgXCIgK1xuICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcbiAgdmFyIGxhenkgPSByZWYubGF6eTtcbiAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gIHZhciB0cmltID0gcmVmLnRyaW07XG4gIHZhciBuZWVkQ29tcG9zaXRpb25HdWFyZCA9ICFsYXp5ICYmIHR5cGUgIT09ICdyYW5nZSc7XG4gIHZhciBldmVudCA9IGxhenlcbiAgICA/ICdjaGFuZ2UnXG4gICAgOiB0eXBlID09PSAncmFuZ2UnXG4gICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICA6ICdpbnB1dCc7XG5cbiAgdmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCI7XG4gIH1cbiAgaWYgKG51bWJlcikge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgfVxuXG4gIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gIGlmIChuZWVkQ29tcG9zaXRpb25HdWFyZCkge1xuICAgIGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG4gIH1cblxuICBhZGRQcm9wKGVsLCAndmFsdWUnLCAoXCIoXCIgKyB2YWx1ZSArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2JsdXInLCAnJGZvcmNlVXBkYXRlKCknKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgIHZhciBldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG4gICAgb25bZXZlbnRdID0gW10uY29uY2F0KG9uW1JBTkdFX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcbiAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICB9XG4gIC8vIFRoaXMgd2FzIG9yaWdpbmFsbHkgaW50ZW5kZWQgdG8gZml4ICM0NTIxIGJ1dCBubyBsb25nZXIgbmVjZXNzYXJ5XG4gIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0RlZihvbltDSEVDS0JPWF9SQURJT19UT0tFTl0pKSB7XG4gICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICB9XG59XG5cbnZhciB0YXJnZXQkMTtcblxuZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKSB7XG4gIHZhciBfdGFyZ2V0ID0gdGFyZ2V0JDE7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICBpZiAocmVzICE9PSBudWxsKSB7XG4gICAgICByZW1vdmUkMihldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGQkMSAoXG4gIGV2ZW50LFxuICBoYW5kbGVyLFxuICBvbmNlJCQxLFxuICBjYXB0dXJlLFxuICBwYXNzaXZlXG4pIHtcbiAgaGFuZGxlciA9IHdpdGhNYWNyb1Rhc2soaGFuZGxlcik7XG4gIGlmIChvbmNlJCQxKSB7IGhhbmRsZXIgPSBjcmVhdGVPbmNlSGFuZGxlcihoYW5kbGVyLCBldmVudCwgY2FwdHVyZSk7IH1cbiAgdGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLFxuICAgIHN1cHBvcnRzUGFzc2l2ZVxuICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgOiBjYXB0dXJlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSQyIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIGNhcHR1cmUsXG4gIF90YXJnZXRcbikge1xuICAoX3RhcmdldCB8fCB0YXJnZXQkMSkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICBldmVudCxcbiAgICBoYW5kbGVyLl93aXRoVGFzayB8fCBoYW5kbGVyLFxuICAgIGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG4gIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gIHRhcmdldCQxID0gdm5vZGUuZWxtO1xuICBub3JtYWxpemVFdmVudHMob24pO1xuICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIHZub2RlLmNvbnRleHQpO1xuICB0YXJnZXQkMSA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG4gIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gIC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXNcbiAgLy8gbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG4gIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgLy8gIzYxNTdcbiAgLy8gd29yayBhcm91bmQgSUUgYnVnIHdoZW4gYWNjZXNzaW5nIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW4gYW4gaWZyYW1lXG4gIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gIHJldHVybiBub3RJbkZvY3VzICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gIHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgdmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG4gIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgaWYgKG1vZGlmaWVycy5sYXp5KSB7XG4gICAgICAvLyBpbnB1dHMgd2l0aCBsYXp5IHNob3VsZCBvbmx5IGJlIHVwZGF0ZWQgd2hlbiBub3QgaW4gZm9jdXNcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgIHJldHVybiB2YWx1ZS50cmltKCkgIT09IG5ld1ZhbC50cmltKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlICE9PSBuZXdWYWxcbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59XG5cbi8qICAqL1xuXG52YXIgcGFyc2VTdHlsZVRleHQgPSBjYWNoZWQoZnVuY3Rpb24gKGNzc1RleHQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IC86KC4rKS87XG4gIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICB2YXIgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZURhdGEgKGRhdGEpIHtcbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgLy8gYW5kIGlzIGFsd2F5cyBhIGZyZXNoIG9iamVjdCwgc28gaXQncyBzYWZlIHRvIG1lcmdlIGludG8gaXRcbiAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICA/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcbiAgICA6IHN0eWxlXG59XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3RcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICByZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuICB9XG4gIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgcmV0dXJuIGJpbmRpbmdTdHlsZVxufVxuXG4vKipcbiAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBzdHlsZURhdGE7XG5cbiAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChcbiAgICAgICAgY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhICYmXG4gICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcbnZhciBzZXRQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWwpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsKTtcbiAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG4gICAgICAvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHZlbmRvck5hbWVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciBlbXB0eVN0eWxlO1xudmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuICBlbXB0eVN0eWxlID0gZW1wdHlTdHlsZSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gZW1wdHlTdHlsZSkpIHtcbiAgICByZXR1cm4gcHJvcFxuICB9XG4gIHZhciBjYXBOYW1lID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9yTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICBpZiAobmFtZSBpbiBlbXB0eVN0eWxlKSB7XG4gICAgICByZXR1cm4gbmFtZVxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuICApIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjdXIsIG5hbWU7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcbiAgdmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cbiAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgdmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gIC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtlbHkgd2FudHNcbiAgLy8gdG8gbXV0YXRlIGl0LlxuICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICA/IGV4dGVuZCh7fSwgc3R5bGUpXG4gICAgOiBzdHlsZTtcblxuICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgZm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG4gICAgaWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG4gICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgIGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuICAgIGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG4gICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG4gICAgfVxuICB9XG59XG5cbnZhciBzdHlsZSA9IHtcbiAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG4gICAgfVxuICAgIGlmICghZWwuY2xhc3NMaXN0Lmxlbmd0aCkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBjdXIgPSBjdXIudHJpbSgpO1xuICAgIGlmIChjdXIpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZik7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZilcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICBsZWF2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlXCIpLFxuICAgIGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcbiAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICB9XG59KTtcblxudmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xudmFyIFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG52YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbnZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbnZhciB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG52YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xudmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgIHdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgYW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gIH1cbn1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG52YXIgcmFmID0gaW5Ccm93c2VyXG4gID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbiAgICA6IHNldFRpbWVvdXRcbiAgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiAoZm4pIHsgcmV0dXJuIGZuKCk7IH07XG5cbmZ1bmN0aW9uIG5leHRGcmFtZSAoZm4pIHtcbiAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICByYWYoZm4pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gIHZhciB0cmFuc2l0aW9uQ2xhc3NlcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pO1xuICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgIHRyYW5zaXRpb25DbGFzc2VzLnB1c2goY2xzKTtcbiAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG59XG5cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG4gIGVsLFxuICBleHBlY3RlZFR5cGUsXG4gIGNiXG4pIHtcbiAgdmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuICB2YXIgdHlwZSA9IHJlZi50eXBlO1xuICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICB2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcbiAgaWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cbiAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICB2YXIgZW5kZWQgPSAwO1xuICB2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICBjYigpO1xuICB9O1xuICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gZWwpIHtcbiAgICAgIGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuICAgICAgICBlbmQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgZW5kKCk7XG4gICAgfVxuICB9LCB0aW1lb3V0ICsgMSk7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbn1cblxudmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgdmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcbiAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG4gIHZhciB0eXBlO1xuICB2YXIgdGltZW91dCA9IDA7XG4gIHZhciBwcm9wQ291bnQgPSAwO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgIHR5cGUgPSB0aW1lb3V0ID4gMFxuICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgIDogQU5JTUFUSU9OXG4gICAgICA6IG51bGw7XG4gICAgcHJvcENvdW50ID0gdHlwZVxuICAgICAgPyB0eXBlID09PSBUUkFOU0lUSU9OXG4gICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICA6IDA7XG4gIH1cbiAgdmFyIGhhc1RyYW5zZm9ybSA9XG4gICAgdHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGltZW91dDogdGltZW91dCxcbiAgICBwcm9wQ291bnQ6IHByb3BDb3VudCxcbiAgICBoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHdoaWxlIChkZWxheXMubGVuZ3RoIDwgZHVyYXRpb25zLmxlbmd0aCkge1xuICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLm1heC5hcHBseShudWxsLCBkdXJhdGlvbnMubWFwKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIHRvTXMgKHMpIHtcbiAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgdmFyIGVudGVyQWN0aXZlQ2xhc3MgPSBkYXRhLmVudGVyQWN0aXZlQ2xhc3M7XG4gIHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG4gIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG4gICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlLmNvbnRleHQ7XG4gIH1cblxuICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgaWYgKGlzQXBwZWFyICYmICFhcHBlYXIgJiYgYXBwZWFyICE9PSAnJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN0YXJ0Q2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJDbGFzc1xuICAgID8gYXBwZWFyQ2xhc3NcbiAgICA6IGVudGVyQ2xhc3M7XG4gIHZhciBhY3RpdmVDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgPyBhcHBlYXJBY3RpdmVDbGFzc1xuICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIHRvQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJUb0NsYXNzXG4gICAgPyBhcHBlYXJUb0NsYXNzXG4gICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuICAgIDogYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcbiAgICA6IGVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlckhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG4gICAgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICA/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG4gICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICB2YXIgZXhwbGljaXRFbnRlckR1cmF0aW9uID0gdG9OdW1iZXIoXG4gICAgaXNPYmplY3QoZHVyYXRpb24pXG4gICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICA6IGR1cmF0aW9uXG4gICk7XG5cbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChlbnRlckhvb2spO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgIH1cbiAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlckVudGVySG9vayAmJiBhZnRlckVudGVySG9vayhlbCk7XG4gICAgfVxuICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2bm9kZS5kYXRhLnNob3cpIHtcbiAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gIH1cblxuICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuXG4gIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIHJtKClcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuICB2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgdmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcbiAgdmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG4gIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gIHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cbiAgdmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgPyBkdXJhdGlvbi5sZWF2ZVxuICAgICAgOiBkdXJhdGlvblxuICApO1xuXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgIFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG4gICAgICB2bm9kZS5jb250ZXh0XG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgd2FybihcbiAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgaWYgKGlzVW5kZWYoZm4pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG4gIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgIC8vIGludm9rZXJcbiAgICByZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcbiAgICAgIEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcbiAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgIDogaW52b2tlckZuc1xuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcbiAgfVxufVxuXG5mdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG4gIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICBlbnRlcih2bm9kZSk7XG4gIH1cbn1cblxudmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gIGNyZWF0ZTogX2VudGVyLFxuICBhY3RpdmF0ZTogX2VudGVyLFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl1cblxuLyogICovXG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbnZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbnZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmIChpc0lFOSkge1xuICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKGVsICYmIGVsLnZtb2RlbCkge1xuICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGRpcmVjdGl2ZSA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIC8vICM2OTAzXG4gICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgZWwudm1vZGVsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIHByZXZPcHRpb25zID0gZWwuX3ZPcHRpb25zO1xuICAgICAgdmFyIGN1ck9wdGlvbnMgPSBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgIC8vIHRyaWdnZXIgY2hhbmdlIGV2ZW50IGlmXG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIG9wdGlvbiBmb3VuZCBmb3IgYXQgbGVhc3Qgb25lIHZhbHVlXG4gICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGN1ck9wdGlvbnMpOyB9KVxuICAgICAgICAgIDogYmluZGluZy52YWx1ZSAhPT0gYmluZGluZy5vbGRWYWx1ZSAmJiBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChpc0lFIHx8IGlzRWRnZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgIH0sIDApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjdHVhbGx5U2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF2YWx1ZSA9PT0gIW9sZFZhbHVlKSB7IHJldHVybiB9XG4gICAgdm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcbiAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uJCQxKSB7XG4gICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG4gICAgfVxuICB9LFxuXG4gIHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcbiAgICBlbCxcbiAgICBiaW5kaW5nLFxuICAgIHZub2RlLFxuICAgIG9sZFZub2RlLFxuICAgIGlzRGVzdHJveVxuICApIHtcbiAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgc2hvdzogc2hvd1xufVxuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcbiAgICApIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG4gICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgIC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG4gICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgIHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgIC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcbiAgICAvLyBkdXJpbmcgZW50ZXJpbmcuXG4gICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgIGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG4gICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgIDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICA6IGNoaWxkLmtleTtcblxuICAgIHZhciBkYXRhID0gKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgdmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuICAgIC8vIG1hcmsgdi1zaG93XG4gICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG4gICAgICBjaGlsZC5kYXRhLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG9sZENoaWxkICYmXG4gICAgICBvbGRDaGlsZC5kYXRhICYmXG4gICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgIWlzQXN5bmNQbGFjZWhvbGRlcihvbGRDaGlsZCkgJiZcbiAgICAgIC8vICM2Njg3IGNvbXBvbmVudCByb290IGlzIGEgY29tbWVudCBub2RlXG4gICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgKSB7XG4gICAgICAvLyByZXBsYWNlIG9sZCBjaGlsZCB0cmFuc2l0aW9uIGRhdGEgd2l0aCBmcmVzaCBvbmVcbiAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgIHZhciBvbGREYXRhID0gb2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKTtcbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcbiAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGRcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhd0NoaWxkXG4gIH1cbn1cblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxQZW5kaW5nQ2JzIChjKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgIGMuZWxtLl9tb3ZlQ2IoKTtcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9lbnRlckNiKSB7XG4gICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcbiAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gIHZhciBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICB2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgYy5kYXRhLm1vdmVkID0gdHJ1ZTtcbiAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBcInRyYW5zbGF0ZShcIiArIGR4ICsgXCJweCxcIiArIGR5ICsgXCJweClcIjtcbiAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gIH1cbn1cblxudmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcbiAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgVHJhbnNpdGlvbkdyb3VwOiBUcmFuc2l0aW9uR3JvdXBcbn1cblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZS5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblZ1ZS5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5WdWUuY29uZmlnLmdldFRhZ05hbWVzcGFjZSA9IGdldFRhZ05hbWVzcGFjZTtcblZ1ZS5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZS5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5leHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBtb3VudENvbXBvbmVudCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5pZiAoaW5Ccm93c2VyKSB7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb25maWcuZGV2dG9vbHMpIHtcbiAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIGlzQ2hyb21lXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Rlc3QnICYmXG4gICAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJ1xuICAgICkge1xuICAgICAgY29uc29sZVtjb25zb2xlLmluZm8gPyAnaW5mbycgOiAnbG9nJ10oXG4gICAgICAgIFwiWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcblwiICtcbiAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICBcIlNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCAwKTtcbn1cblxuLyogICovXG5cbnZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xudmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG52YXIgYnVpbGRSZWdleCA9IGNhY2hlZChmdW5jdGlvbiAoZGVsaW1pdGVycykge1xuICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpXG59KTtcblxuXG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgcmF3VG9rZW5zID0gW107XG4gIHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICB3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcbiAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgIGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgcmF3VG9rZW5zLnB1c2godG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICAvLyB0YWcgdG9rZW5cbiAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgdG9rZW5zLnB1c2goKFwiX3MoXCIgKyBleHAgKyBcIilcIikpO1xuICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICB9XG4gIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGV4cHJlc3Npb246IHRva2Vucy5qb2luKCcrJyksXG4gICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgc3RhdGljQ2xhc3MpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChyZXMpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gIH1cbiAgdmFyIGNsYXNzQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnY2xhc3MnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEgKGVsKSB7XG4gIHZhciBkYXRhID0gJyc7XG4gIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgIGRhdGEgKz0gXCJzdGF0aWNDbGFzczpcIiArIChlbC5zdGF0aWNDbGFzcykgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgZGF0YSArPSBcImNsYXNzOlwiICsgKGVsLmNsYXNzQmluZGluZykgKyBcIixcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIga2xhc3MkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlLFxuICBnZW5EYXRhOiBnZW5EYXRhXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG4gIHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgaWYgKHN0YXRpY1N0eWxlKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAge1xuICAgICAgdmFyIHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+LidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICB9XG5cbiAgdmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcbiAgdmFyIGRhdGEgPSAnJztcbiAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICBkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIHN0eWxlJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICBnZW5EYXRhOiBnZW5EYXRhJDFcbn1cblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG4pO1xuXG4vLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cbi8vIChhbmQgd2hpY2ggY2xvc2UgdGhlbXNlbHZlcylcbnZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgJ2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG4pO1xuXG4vLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4vLyBQaHJhc2luZyBDb250ZW50IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RvbS5odG1sI3BocmFzaW5nLWNvbnRlbnRcbnZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcbiAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSwnICtcbiAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAndGl0bGUsdHIsdHJhY2snXG4pO1xuXG4vKipcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuICovXG5cbi8qIVxuICogSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xudmFyIGF0dHJpYnV0ZSA9IC9eXFxzKihbXlxcc1wiJzw+XFwvPV0rKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuLy8gY291bGQgdXNlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8xOTk5L1JFQy14bWwtbmFtZXMtMTk5OTAxMTQvI05ULVFOYW1lXG4vLyBidXQgZm9yIFZ1ZSB0ZW1wbGF0ZXMgd2UgY2FuIGVuZm9yY2UgYSBzaW1wbGUgY2hhcnNldFxudmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xudmFyIHFuYW1lQ2FwdHVyZSA9IFwiKCg/OlwiICsgbmNuYW1lICsgXCJcXFxcOik/XCIgKyBuY25hbWUgKyBcIilcIjtcbnZhciBzdGFydFRhZ09wZW4gPSBuZXcgUmVnRXhwKChcIl48XCIgKyBxbmFtZUNhcHR1cmUpKTtcbnZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG52YXIgZW5kVGFnID0gbmV3IFJlZ0V4cCgoXCJePFxcXFwvXCIgKyBxbmFtZUNhcHR1cmUgKyBcIltePl0qPlwiKSk7XG52YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxudmFyIGNvbW1lbnQgPSAvXjwhXFwtLS87XG52YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cbnZhciBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZmFsc2U7XG4neCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcbiAgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xufSk7XG5cbi8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxudmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xudmFyIHJlQ2FjaGUgPSB7fTtcblxudmFyIGRlY29kaW5nTWFwID0ge1xuICAnJmx0Oyc6ICc8JyxcbiAgJyZndDsnOiAnPicsXG4gICcmcXVvdDsnOiAnXCInLFxuICAnJmFtcDsnOiAnJicsXG4gICcmIzEwOyc6ICdcXG4nLFxuICAnJiM5Oyc6ICdcXHQnXG59O1xudmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG52YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMHwjOSk7L2c7XG5cbi8vICM1OTkyXG52YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lID0gZnVuY3Rpb24gKHRhZywgaHRtbCkgeyByZXR1cm4gdGFnICYmIGlzSWdub3JlTmV3bGluZVRhZyh0YWcpICYmIGh0bWxbMF0gPT09ICdcXG4nOyB9O1xuXG5mdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcbiAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBkZWNvZGluZ01hcFttYXRjaF07IH0pXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG4gIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICB2YXIgY2FuQmVMZWZ0T3BlblRhZyQkMSA9IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyB8fCBubztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gIHdoaWxlIChodG1sKSB7XG4gICAgbGFzdCA9IGh0bWw7XG4gICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICBpZiAoIWxhc3RUYWcgfHwgIWlzUGxhaW5UZXh0RWxlbWVudChsYXN0VGFnKSkge1xuICAgICAgdmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcbiAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgIGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICBpZiAoY29tbWVudEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zaG91bGRLZWVwQ29tbWVudCkge1xuICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWR2YW5jZShjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29uZGl0aW9uYWxfY29tbWVudCNEb3dubGV2ZWwtcmV2ZWFsZWRfY29uZGl0aW9uYWxfY29tbWVudFxuICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICB2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxFbmQgPj0gMCkge1xuICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICB2YXIgZG9jdHlwZU1hdGNoID0gaHRtbC5tYXRjaChkb2N0eXBlKTtcbiAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgIGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuZCB0YWc6XG4gICAgICAgIHZhciBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgdmFyIGN1ckluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgIHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICBpZiAoc3RhcnRUYWdNYXRjaCkge1xuICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUobGFzdFRhZywgaHRtbCkpIHtcbiAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCA9ICh2b2lkIDApLCBuZXh0ID0gKHZvaWQgMCk7XG4gICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICBpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuICAgICAgICAgIHRleHRFbmQgKz0gbmV4dDtcbiAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG4gICAgICAgIGFkdmFuY2UodGV4dEVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0RW5kIDwgMCkge1xuICAgICAgICB0ZXh0ID0gaHRtbDtcbiAgICAgICAgaHRtbCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG4gICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbmRUYWdMZW5ndGggPSAwO1xuICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fCAocmVDYWNoZVtzdGFja2VkVGFnXSA9IG5ldyBSZWdFeHAoJyhbXFxcXHNcXFxcU10qPykoPC8nICsgc3RhY2tlZFRhZyArICdbXj5dKj4pJywgJ2knKSk7XG4gICAgICB2YXIgcmVzdCQxID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG4gICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICB0ZXh0ID0gdGV4dFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gIHBhcnNlRW5kVGFnKCk7XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSAobikge1xuICAgIGluZGV4ICs9IG47XG4gICAgaHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICB0YWdOYW1lOiBzdGFydFsxXSxcbiAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgIH07XG4gICAgICBhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG4gICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgd2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5hdHRycy5wdXNoKGF0dHIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICBhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG4gICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgIHZhciB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcblxuICAgIGlmIChleHBlY3RIVE1MKSB7XG4gICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcobGFzdFRhZyk7XG4gICAgICB9XG4gICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmFyeSA9IGlzVW5hcnlUYWckJDEodGFnTmFtZSkgfHwgISF1bmFyeVNsYXNoO1xuXG4gICAgdmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgLy8gaGFja2lzaCB3b3JrIGFyb3VuZCBGRiBidWcgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MzY5Nzc4XG4gICAgICBpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG4gICAgICAgIGlmIChhcmdzWzRdID09PSAnJykgeyBkZWxldGUgYXJnc1s0XTsgfVxuICAgICAgICBpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbM10gfHwgYXJnc1s0XSB8fCBhcmdzWzVdIHx8ICcnO1xuICAgICAgdmFyIHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgIDogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcztcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICB2YWx1ZTogZGVjb2RlQXR0cih2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICghdW5hcnkpIHtcbiAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzIH0pO1xuICAgICAgbGFzdFRhZyA9IHRhZ05hbWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICBpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICBmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuICAgICAgICBpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgIHBvcyA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG4gICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICkge1xuICAgICAgICAgIG9wdGlvbnMud2FybihcbiAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcbiAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICBvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBvblJFID0gL15AfF52LW9uOi87XG52YXIgZGlyUkUgPSAvXnYtfF5AfF46LztcbnZhciBmb3JBbGlhc1JFID0gLyhbXl0qPylcXHMrKD86aW58b2YpXFxzKyhbXl0qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbnZhciBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuXG52YXIgYXJnUkUgPSAvOiguKikkLztcbnZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xudmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxudmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG52YXIgd2FybiQyO1xudmFyIGRlbGltaXRlcnM7XG52YXIgdHJhbnNmb3JtcztcbnZhciBwcmVUcmFuc2Zvcm1zO1xudmFyIHBvc3RUcmFuc2Zvcm1zO1xudmFyIHBsYXRmb3JtSXNQcmVUYWc7XG52YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbnZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUFTVEVsZW1lbnQgKFxuICB0YWcsXG4gIGF0dHJzLFxuICBwYXJlbnRcbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDEsXG4gICAgdGFnOiB0YWcsXG4gICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICBhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjaGlsZHJlbjogW11cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgSFRNTCBzdHJpbmcgdG8gQVNULlxuICovXG5mdW5jdGlvbiBwYXJzZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgd2FybiQyID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXG4gIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcblxuICB0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG4gIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgcG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cbiAgZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHByZXNlcnZlV2hpdGVzcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSBmYWxzZTtcbiAgdmFyIHJvb3Q7XG4gIHZhciBjdXJyZW50UGFyZW50O1xuICB2YXIgaW5WUHJlID0gZmFsc2U7XG4gIHZhciBpblByZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gd2Fybk9uY2UgKG1zZykge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgd2FybiQyKG1zZyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VFbGVtZW50IChlbGVtZW50KSB7XG4gICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICBpblZQcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICBpblByZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG4gICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgIFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWxlbWVudCA9IHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1ByZShlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgIGluUHJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgcHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgIHByb2Nlc3NJZihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIC8vIGVsZW1lbnQtc2NvcGUgc3R1ZmZcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICBcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcbiAgICAgICAgICAgIFwiSWYgeW91IGFyZSB1c2luZyB2LWlmIG9uIG11bHRpcGxlIGVsZW1lbnRzLCBcIiArXG4gICAgICAgICAgICBcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG4gICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgY3VycmVudFBhcmVudC5wbGFpbiA9IGZhbHNlO1xuICAgICAgICAgIHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuICAgICAgICBzdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvc2VFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgICAnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgKFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG4gICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW47XG4gICAgICB0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcbiAgICAgICAgPyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuICAgICAgICAvLyBvbmx5IHByZXNlcnZlIHdoaXRlc3BhY2UgaWYgaXRzIG5vdCByaWdodCBhZnRlciBhIHN0YXJ0aW5nIHRhZ1xuICAgICAgICA6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghaW5WUHJlICYmIHRleHQgIT09ICcgJyAmJiAocmVzID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHJlcy5leHByZXNzaW9uLFxuICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fCAhY2hpbGRyZW4ubGVuZ3RoIHx8IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWVudDogZnVuY3Rpb24gY29tbWVudCAodGV4dCkge1xuICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogMyxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgaXNDb21tZW50OiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcm9vdFxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUHJlIChlbCkge1xuICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgIGVsLnByZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuICB2YXIgbCA9IGVsLmF0dHJzTGlzdC5sZW5ndGg7XG4gIGlmIChsKSB7XG4gICAgdmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICBuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcbiAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGVsLmF0dHJzTGlzdFtpXS52YWx1ZSlcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlbC5wcmUpIHtcbiAgICAvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG4gICAgZWwucGxhaW4gPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcbiAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gIGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWVsZW1lbnQuYXR0cnNMaXN0Lmxlbmd0aDtcblxuICBwcm9jZXNzUmVmKGVsZW1lbnQpO1xuICBwcm9jZXNzU2xvdChlbGVtZW50KTtcbiAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgZWxlbWVudCA9IHRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucykgfHwgZWxlbWVudDtcbiAgfVxuICBwcm9jZXNzQXR0cnMoZWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG4gIHZhciBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICBpZiAoZXhwKSB7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgd2FybiQyKFwiPHRlbXBsYXRlPiBjYW5ub3QgYmUga2V5ZWQuIFBsYWNlIHRoZSBrZXkgb24gcmVhbCBlbGVtZW50cyBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZWwua2V5ID0gZXhwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gIHZhciByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICBpZiAocmVmKSB7XG4gICAgZWwucmVmID0gcmVmO1xuICAgIGVsLnJlZkluRm9yID0gY2hlY2tJbkZvcihlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0ZvciAoZWwpIHtcbiAgdmFyIGV4cDtcbiAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICB2YXIgcmVzID0gcGFyc2VGb3IoZXhwKTtcbiAgICBpZiAocmVzKSB7XG4gICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cblxuXG5mdW5jdGlvbiBwYXJzZUZvciAoZXhwKSB7XG4gIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICBpZiAoIWluTWF0Y2gpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gIHZhciBhbGlhcyA9IGluTWF0Y2hbMV0udHJpbSgpLnJlcGxhY2Uoc3RyaXBQYXJlbnNSRSwgJycpO1xuICB2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgIHJlcy5hbGlhcyA9IGFsaWFzLnJlcGxhY2UoZm9ySXRlcmF0b3JSRSwgJycpO1xuICAgIHJlcy5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaFsyXSkge1xuICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3YXJuJDIoXG4gICAgICBcInYtXCIgKyAoZWwuZWxzZWlmID8gKCdlbHNlLWlmPVwiJyArIGVsLmVsc2VpZiArICdcIicpIDogJ2Vsc2UnKSArIFwiIFwiICtcbiAgICAgIFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG4gIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLmtleSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICBcImFuZCBjYW4gcG9zc2libHkgZXhwYW5kIGludG8gbXVsdGlwbGUgZWxlbWVudHMuIFwiICtcbiAgICAgICAgXCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsb3RTY29wZTtcbiAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNsb3RTY29wZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJ0aGUgXFxcInNjb3BlXFxcIiBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBzbG90cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgXCIgK1xuICAgICAgICAgIFwicmVwbGFjZWQgYnkgXFxcInNsb3Qtc2NvcGVcXFwiIHNpbmNlIDIuNS4gVGhlIG5ldyBcXFwic2xvdC1zY29wZVxcXCIgYXR0cmlidXRlIFwiICtcbiAgICAgICAgICBcImNhbiBhbHNvIGJlIHVzZWQgb24gcGxhaW4gZWxlbWVudHMgaW4gYWRkaXRpb24gdG8gPHRlbXBsYXRlPiB0byBcIiArXG4gICAgICAgICAgXCJkZW5vdGUgc2NvcGVkIHNsb3RzLlwiLFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RTY29wZSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpO1xuICAgIH0gZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xuICAgICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gICAgfVxuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuICAgICAge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgIC8vICM2ODg3IGZpcmVmb3ggZG9lc24ndCB1cGRhdGUgbXV0ZWQgc3RhdGUgaWYgc2V0IHZpYSBhdHRyaWJ1dGVcbiAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgaWYgKCFlbC5jb21wb25lbnQgJiZcbiAgICAgICAgICBuYW1lID09PSAnbXV0ZWQnICYmXG4gICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgIGFkZFByb3AoZWwsIG5hbWUsICd0cnVlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gIHZhciBwYXJlbnQgPSBlbDtcbiAgd2hpbGUgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG4gIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gIGlmIChtYXRjaCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBtYXRjaC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7IHJldFttLnNsaWNlKDEpXSA9IHRydWU7IH0pO1xuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdICYmICFpc0lFICYmICFpc0VkZ2VcbiAgICApIHtcbiAgICAgIHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuICAgIH1cbiAgICBtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gbWFwXG59XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSdcbn1cblxuZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG4gIHJldHVybiAoXG4gICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgKGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuICAgICAgIWVsLmF0dHJzTWFwLnR5cGUgfHxcbiAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgKSlcbiAgKVxufVxuXG52YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcbnZhciBpZU5TUHJlZml4ID0gL15OU1xcZCs6LztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBhdHRyID0gYXR0cnNbaV07XG4gICAgaWYgKCFpZU5TQnVnLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgcmVzLnB1c2goYXR0cik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgdmFyIF9lbCA9IGVsO1xuICB3aGlsZSAoX2VsKSB7XG4gICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgd2FybiQyKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICBcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcbiAgICAgICAgXCJ3cml0aW5nIHRvIHRoZSBhbGlhcyBpcyBsaWtlIG1vZGlmeWluZyBhIGZ1bmN0aW9uIGxvY2FsIHZhcmlhYmxlLiBcIiArXG4gICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogRXhwYW5kIGlucHV0W3YtbW9kZWxdIHdpdGggZHlhbm1pYyB0eXBlIGJpbmRpbmdzIGludG8gdi1pZi1lbHNlIGNoYWluc1xuICogVHVybiB0aGlzOlxuICogICA8aW5wdXQgdi1tb2RlbD1cImRhdGFbdHlwZV1cIiA6dHlwZT1cInR5cGVcIj5cbiAqIGludG8gdGhpczpcbiAqICAgPGlucHV0IHYtaWY9XCJ0eXBlID09PSAnY2hlY2tib3gnXCIgdHlwZT1cImNoZWNrYm94XCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZS1pZj1cInR5cGUgPT09ICdyYWRpbydcIiB0eXBlPVwicmFkaW9cIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICogICA8aW5wdXQgdi1lbHNlIDp0eXBlPVwidHlwZVwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKi9cblxuZnVuY3Rpb24gcHJlVHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICBpZiAoIW1hcFsndi1tb2RlbCddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgdHlwZUJpbmRpbmc7XG4gICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgfVxuICAgIGlmICghbWFwLnR5cGUgJiYgIXR5cGVCaW5kaW5nICYmIG1hcFsndi1iaW5kJ10pIHtcbiAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgIH1cblxuICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgIHZhciBpZkNvbmRpdGlvbkV4dHJhID0gaWZDb25kaXRpb24gPyAoXCImJihcIiArIGlmQ29uZGl0aW9uICsgXCIpXCIpIDogXCJcIjtcbiAgICAgIHZhciBoYXNFbHNlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScsIHRydWUpICE9IG51bGw7XG4gICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgLy8gMS4gY2hlY2tib3hcbiAgICAgIHZhciBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgIGJyYW5jaDAuaWYgPSBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J2NoZWNrYm94J1wiICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBicmFuY2gwLmlmLFxuICAgICAgICBibG9jazogYnJhbmNoMFxuICAgICAgfSk7XG4gICAgICAvLyAyLiBhZGQgcmFkaW8gZWxzZS1pZiBjb25kaXRpb25cbiAgICAgIHZhciBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgZXhwOiBcIihcIiArIHR5cGVCaW5kaW5nICsgXCIpPT09J3JhZGlvJ1wiICsgaWZDb25kaXRpb25FeHRyYSxcbiAgICAgICAgYmxvY2s6IGJyYW5jaDFcbiAgICAgIH0pO1xuICAgICAgLy8gMy4gb3RoZXJcbiAgICAgIHZhciBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGlmQ29uZGl0aW9uLFxuICAgICAgICBibG9jazogYnJhbmNoMlxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICBicmFuY2gwLmVsc2VpZiA9IGVsc2VJZkNvbmRpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVBU1RFbGVtZW50IChlbCkge1xuICByZXR1cm4gY3JlYXRlQVNURWxlbWVudChlbC50YWcsIGVsLmF0dHJzTGlzdC5zbGljZSgpLCBlbC5wYXJlbnQpXG59XG5cbnZhciBtb2RlbCQyID0ge1xuICBwcmVUcmFuc2Zvcm1Ob2RlOiBwcmVUcmFuc2Zvcm1Ob2RlXG59XG5cbnZhciBtb2R1bGVzJDEgPSBbXG4gIGtsYXNzJDEsXG4gIHN0eWxlJDEsXG4gIG1vZGVsJDJcbl1cblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59XG5cbi8qICAqL1xuXG52YXIgYmFzZU9wdGlvbnMgPSB7XG4gIGV4cGVjdEhUTUw6IHRydWUsXG4gIG1vZHVsZXM6IG1vZHVsZXMkMSxcbiAgZGlyZWN0aXZlczogZGlyZWN0aXZlcyQxLFxuICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gIGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG4gIG11c3RVc2VQcm9wOiBtdXN0VXNlUHJvcCxcbiAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgaXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcbiAgZ2V0VGFnTmFtZXNwYWNlOiBnZXRUYWdOYW1lc3BhY2UsXG4gIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxufTtcblxuLyogICovXG5cbnZhciBpc1N0YXRpY0tleTtcbnZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWc7XG5cbnZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG4gIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICBtYXJrU3RhdGljJDEocm9vdCk7XG4gIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG4gIHJldHVybiBtYWtlTWFwKFxuICAgICd0eXBlLHRhZyxhdHRyc0xpc3QsYXR0cnNNYXAscGxhaW4scGFyZW50LGNoaWxkcmVuLGF0dHJzJyArXG4gICAgKGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG4gIClcbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG4gIG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcbiAgICAvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG4gICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgIGlmIChcbiAgICAgICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG4gICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICBub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIG1hcmtTdGF0aWMkMShjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICB2YXIgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrO1xuICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgIG5vZGUuc3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY1Jvb3RzIChub2RlLCBpc0luRm9yKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICB9XG4gICAgLy8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcbiAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICBpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcbiAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICApKSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSB0cnVlO1xuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuaWZDb25kaXRpb25zW2kkMV0uYmxvY2ssIGlzSW5Gb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiAhIShub2RlLnByZSB8fCAoXG4gICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2VcbiAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgIWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG4gICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG4gICkpXG59XG5cbmZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG4gIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICBpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAobm9kZS5mb3IpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxudmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xudmFyIHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG5cbi8vIEtleWJvYXJkRXZlbnQua2V5Q29kZSBhbGlhc2VzXG52YXIga2V5Q29kZXMgPSB7XG4gIGVzYzogMjcsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzcGFjZTogMzIsXG4gIHVwOiAzOCxcbiAgbGVmdDogMzcsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gICdkZWxldGUnOiBbOCwgNDZdXG59O1xuXG4vLyBLZXlib2FyZEV2ZW50LmtleSBhbGlhc2VzXG52YXIga2V5TmFtZXMgPSB7XG4gIGVzYzogJ0VzY2FwZScsXG4gIHRhYjogJ1RhYicsXG4gIGVudGVyOiAnRW50ZXInLFxuICBzcGFjZTogJyAnLFxuICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICB1cDogWydVcCcsICdBcnJvd1VwJ10sXG4gIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICBkb3duOiBbJ0Rvd24nLCAnQXJyb3dEb3duJ10sXG4gICdkZWxldGUnOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnXVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlLFxuICB3YXJuXG4pIHtcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIigkZXZlbnQpXCIpXG4gICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGtleUNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICB2YXIga2V5TmFtZSA9IGtleU5hbWVzW2tleV07XG4gIHJldHVybiAoXG4gICAgXCJfaygkZXZlbnQua2V5Q29kZSxcIiArXG4gICAgKEpTT04uc3RyaW5naWZ5KGtleSkpICsgXCIsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgXCIkZXZlbnQua2V5LFwiICtcbiAgICBcIlwiICsgKEpTT04uc3RyaW5naWZ5KGtleU5hbWUpKSArXG4gICAgXCIpXCJcbiAgKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gb24gKGVsLCBkaXIpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRpci5tb2RpZmllcnMpIHtcbiAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgfVxuICBlbC53cmFwTGlzdGVuZXJzID0gZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcIl9nKFwiICsgY29kZSArIFwiLFwiICsgKGRpci52YWx1ZSkgKyBcIilcIik7IH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kJDEgKGVsLCBkaXIpIHtcbiAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgXCIsXCIgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAndHJ1ZScgOiAnZmFsc2UnKSArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMuc3luYyA/ICcsdHJ1ZScgOiAnJykgKyBcIilcIilcbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgb246IG9uLFxuICBiaW5kOiBiaW5kJDEsXG4gIGNsb2FrOiBub29wXG59XG5cbi8qICAqL1xuXG52YXIgQ29kZWdlblN0YXRlID0gZnVuY3Rpb24gQ29kZWdlblN0YXRlIChvcHRpb25zKSB7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMud2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgdGhpcy50cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG4gIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICB0aGlzLmRpcmVjdGl2ZXMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiYXNlRGlyZWN0aXZlcyksIG9wdGlvbnMuZGlyZWN0aXZlcyk7XG4gIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICB0aGlzLm9uY2VJZCA9IDA7XG4gIHRoaXMuc3RhdGljUmVuZGVyRm5zID0gW107XG59O1xuXG5cblxuZnVuY3Rpb24gZ2VuZXJhdGUgKFxuICBhc3QsXG4gIG9wdGlvbnNcbikge1xuICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICB2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSkgOiAnX2MoXCJkaXZcIiknO1xuICByZXR1cm4ge1xuICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwsIHN0YXRlKSB7XG4gIGlmIChlbC5zdGF0aWNSb290ICYmICFlbC5zdGF0aWNQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5vbmNlICYmICFlbC5vbmNlUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbk9uY2UoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RUYXJnZXQpIHtcbiAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgcmV0dXJuIGdlblNsb3QoZWwsIHN0YXRlKVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG4gICAgdmFyIGNvZGU7XG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb2RlID0gc3RhdGUudHJhbnNmb3Jtc1tpXShlbCwgY29kZSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbmZ1bmN0aW9uIGdlblN0YXRpYyAoZWwsIHN0YXRlKSB7XG4gIGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG4gIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIn1cIikpO1xuICByZXR1cm4gKFwiX20oXCIgKyAoc3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxufVxuXG4vLyB2LW9uY2VcbmZ1bmN0aW9uIGdlbk9uY2UgKGVsLCBzdGF0ZSkge1xuICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICBrZXkgPSBwYXJlbnQua2V5O1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRlLndhcm4oXG4gICAgICAgIFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgICByZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwiLFwiICsgKHN0YXRlLm9uY2VJZCsrKSArIFwiLFwiICsga2V5ICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblN0YXRpYyhlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuSWYgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gZ2VuSWZDb25kaXRpb25zKGVsLmlmQ29uZGl0aW9ucy5zbGljZSgpLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSlcbn1cblxuZnVuY3Rpb24gZ2VuSWZDb25kaXRpb25zIChcbiAgY29uZGl0aW9ucyxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0RW1wdHlcbikge1xuICBpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJ1xuICB9XG5cbiAgdmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcbiAgaWYgKGNvbmRpdGlvbi5leHApIHtcbiAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcbiAgfVxuXG4gIC8vIHYtaWYgd2l0aCB2LW9uY2Ugc2hvdWxkIGdlbmVyYXRlIGNvZGUgbGlrZSAoYSk/X20oMCk6X20oMSlcbiAgZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcbiAgICByZXR1cm4gYWx0R2VuXG4gICAgICA/IGFsdEdlbihlbCwgc3RhdGUpXG4gICAgICA6IGVsLm9uY2VcbiAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5Gb3IgKFxuICBlbCxcbiAgc3RhdGUsXG4gIGFsdEdlbixcbiAgYWx0SGVscGVyXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcbiAgICBlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDFcbiAgKSkge1xuICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuICB9XG4gIGlmIChhc3QudHlwZSA9PT0gMSkge1xuICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgIHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKFxuICBzbG90cyxcbiAgc3RhdGVcbikge1xuICByZXR1cm4gKFwic2NvcGVkU2xvdHM6X3UoW1wiICsgKE9iamVjdC5rZXlzKHNsb3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldLCBzdGF0ZSlcbiAgICB9KS5qb2luKCcsJykpICsgXCJdKVwiKVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSlcbiAgfVxuICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgKFN0cmluZyhlbC5zbG90U2NvcGUpKSArIFwiKXtcIiArXG4gICAgXCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG4gICAgICA/IGVsLmlmXG4gICAgICAgID8gKChlbC5pZikgKyBcIj9cIiArIChnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnKSArIFwiOnVuZGVmaW5lZFwiKVxuICAgICAgICA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCdcbiAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICByZXR1cm4gKFwie2tleTpcIiArIGtleSArIFwiLGZuOlwiICsgZm4gKyBcIn1cIilcbn1cblxuZnVuY3Rpb24gZ2VuRm9yU2NvcGVkU2xvdCAoXG4gIGtleSxcbiAgZWwsXG4gIHN0YXRlXG4pIHtcbiAgdmFyIGV4cCA9IGVsLmZvcjtcbiAgdmFyIGFsaWFzID0gZWwuYWxpYXM7XG4gIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgdmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICBcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsLCBzdGF0ZSkpICtcbiAgICAnfSknXG59XG5cbmZ1bmN0aW9uIGdlbkNoaWxkcmVuIChcbiAgZWwsXG4gIHN0YXRlLFxuICBjaGVja1NraXAsXG4gIGFsdEdlbkVsZW1lbnQsXG4gIGFsdEdlbk5vZGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgIHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG4gICAgLy8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgZWwkMS5mb3IgJiZcbiAgICAgIGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgKSB7XG4gICAgICByZXR1cm4gKGFsdEdlbkVsZW1lbnQgfHwgZ2VuRWxlbWVudCkoZWwkMSwgc3RhdGUpXG4gICAgfVxuICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbiwgc3RhdGUubWF5YmVDb21wb25lbnQpXG4gICAgICA6IDA7XG4gICAgdmFyIGdlbiA9IGFsdEdlbk5vZGUgfHwgZ2VuTm9kZTtcbiAgICByZXR1cm4gKFwiW1wiICsgKGNoaWxkcmVuLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gZ2VuKGMsIHN0YXRlKTsgfSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuICB9XG59XG5cbi8vIGRldGVybWluZSB0aGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgZm9yIHRoZSBjaGlsZHJlbiBhcnJheS5cbi8vIDA6IG5vIG5vcm1hbGl6YXRpb24gbmVlZGVkXG4vLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4vLyAyOiBmdWxsIG5vcm1hbGl6YXRpb24gbmVlZGVkXG5mdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoXG4gIGNoaWxkcmVuLFxuICBtYXliZUNvbXBvbmVudFxuKSB7XG4gIHZhciByZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAyO1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgcmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xufVxuXG5mdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGdlbkVsZW1lbnQobm9kZSwgc3RhdGUpXG4gIH0gaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgIHJldHVybiBnZW5Db21tZW50KG5vZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdlblRleHQobm9kZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG4gIHJldHVybiAoXCJfdihcIiArICh0ZXh0LnR5cGUgPT09IDJcbiAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgOiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgcmV0dXJuIChcIl9lKFwiICsgKEpTT04uc3RyaW5naWZ5KGNvbW1lbnQudGV4dCkpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICB2YXIgc2xvdE5hbWUgPSBlbC5zbG90TmFtZSB8fCAnXCJkZWZhdWx0XCInO1xuICB2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICB2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuICB2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcbiAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICByZXMgKz0gXCIsbnVsbFwiO1xuICB9XG4gIGlmIChhdHRycykge1xuICAgIHJlcyArPSBcIixcIiArIGF0dHJzO1xuICB9XG4gIGlmIChiaW5kJCQxKSB7XG4gICAgcmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG4gIH1cbiAgcmV0dXJuIHJlcyArICcpJ1xufVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICBjb21wb25lbnROYW1lLFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG59XG5cbmZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIHJlcyArPSBcIlxcXCJcIiArIChwcm9wLm5hbWUpICsgXCJcXFwiOlwiICsgKHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKSkgKyBcIixcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcbn1cblxuLy8gIzM4OTUsICM0MjY4XG5mdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcbiAgcmV0dXJuIHRleHRcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcbn1cblxuLyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG52YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbnZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCl8XFxcXGInKSArICdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpJyk7XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcbnZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5mdW5jdGlvbiBkZXRlY3RFcnJvcnMgKGFzdCkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIGlmIChhc3QpIHtcbiAgICBjaGVja05vZGUoYXN0LCBlcnJvcnMpO1xuICB9XG4gIHJldHVybiBlcnJvcnNcbn1cblxuZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgdmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG4gIGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuICAgIGVycm9ycy5wdXNoKFxuICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcbiAgICApO1xuICB9XG4gIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcbiAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuICBjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoXG4gIGlkZW50LFxuICB0eXBlLFxuICB0ZXh0LFxuICBlcnJvcnNcbikge1xuICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBuZXcgRnVuY3Rpb24oKFwidmFyIFwiICsgaWRlbnQgKyBcIj1fXCIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGtleXdvcmRNYXRjaCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKS5tYXRjaChwcm9oaWJpdGVkS2V5d29yZFJFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IGtleXdvcmQgYXMgcHJvcGVydHkgbmFtZTogXCIgK1xuICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMucHVzaChcbiAgICAgICAgXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKGUubWVzc2FnZSkgKyBcIiBpblxcblxcblwiICtcbiAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCIgIFJhdyBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkgKyBcIlxcblwiXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb24gKGNvZGUsIGVycm9ycykge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICByZXR1cm4gbm9vcFxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4gKGNvbXBpbGUpIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICB0ZW1wbGF0ZSxcbiAgICBvcHRpb25zLFxuICAgIHZtXG4gICkge1xuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIG9wdGlvbnMpO1xuICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgZGVsZXRlIG9wdGlvbnMud2FybjtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIHtcbiAgICAgIC8vIGRldGVjdCBwb3NzaWJsZSBDU1AgcmVzdHJpY3Rpb25cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgJ0l0IHNlZW1zIHlvdSBhcmUgdXNpbmcgdGhlIHN0YW5kYWxvbmUgYnVpbGQgb2YgVnVlLmpzIGluIGFuICcgK1xuICAgICAgICAgICAgJ2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICdyZWxheGluZyB0aGUgcG9saWN5IHRvIGFsbG93IHVuc2FmZS1ldmFsIG9yIHByZS1jb21waWxpbmcgeW91ciAnICtcbiAgICAgICAgICAgICd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FjaGVcbiAgICB2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG4gICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgIDogdGVtcGxhdGU7XG4gICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgfVxuXG4gICAgLy8gY29tcGlsZVxuICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgLy8gY2hlY2sgY29tcGlsYXRpb24gZXJyb3JzL3RpcHNcbiAgICB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICB7XG4gICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgZm5HZW5FcnJvcnMubWFwKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSByZWYuZXJyO1xuICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgcmV0dXJuICgoZXJyLnRvU3RyaW5nKCkpICsgXCIgaW5cXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiKTtcbiAgICAgICAgfSkuam9pbignXFxuJyksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKGNhY2hlW2tleV0gPSByZXMpXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyQ3JlYXRvciAoYmFzZUNvbXBpbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIGNvbXBpbGUgKFxuICAgICAgdGVtcGxhdGUsXG4gICAgICBvcHRpb25zXG4gICAgKSB7XG4gICAgICB2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG4gICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICB2YXIgdGlwcyA9IFtdO1xuICAgICAgZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXApIHtcbiAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgIGlmIChvcHRpb25zLm1vZHVsZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMubW9kdWxlcyA9XG4gICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLFxuICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcbiAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcbiAgICAgIHtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLm9wdGltaXplICE9PSBmYWxzZSkge1xuICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIGFzdDogYXN0LFxuICAgIHJlbmRlcjogY29kZS5yZW5kZXIsXG4gICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICB9XG59KTtcblxuLyogICovXG5cbnZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbnZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cbi8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xudmFyIGRpdjtcbmZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xuICBkaXYgPSBkaXYgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBocmVmID8gXCI8YSBocmVmPVxcXCJcXG5cXFwiLz5cIiA6IFwiPGRpdiBhPVxcXCJcXG5cXFwiLz5cIjtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcbn1cblxuLy8gIzM2NjM6IElFIGVuY29kZXMgbmV3bGluZXMgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgb3RoZXIgYnJvd3NlcnMgZG9uJ3RcbnZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbi8vICM2ODI4OiBjaHJvbWUgZW5jb2RlcyBjb250ZW50IGluIGFbaHJlZl1cbnZhciBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUodHJ1ZSkgOiBmYWxzZTtcblxuLyogICovXG5cbnZhciBpZFRvVGVtcGxhdGUgPSBjYWNoZWQoZnVuY3Rpb24gKGlkKSB7XG4gIHZhciBlbCA9IHF1ZXJ5KGlkKTtcbiAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxufSk7XG5cbnZhciBtb3VudCA9IFZ1ZS5wcm90b3R5cGUuJG1vdW50O1xuVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCJEbyBub3QgbW91bnQgVnVlIHRvIDxodG1sPiBvciA8Ym9keT4gLSBtb3VudCB0byBub3JtYWwgZWxlbWVudHMgaW5zdGVhZC5cIlxuICAgICk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgaWYgKCFvcHRpb25zLnJlbmRlcikge1xuICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB7XG4gICAgICAgICAgd2FybignaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246JyArIHRlbXBsYXRlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgIHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgbWFyaygnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodGhpcy5fbmFtZSkgKyBcIiBjb21waWxlXCIpLCAnY29tcGlsZScsICdjb21waWxlIGVuZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxufTtcblxuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgaWYgKGVsLm91dGVySFRNTCkge1xuICAgIHJldHVybiBlbC5vdXRlckhUTUxcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgfVxufVxuXG5WdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxucmV0dXJuIFZ1ZTtcblxufSkpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/vendor/vue.js\n")}});