!function(Q){var F={};function B(U){if(F[U])return F[U].exports;var s=F[U]={i:U,l:!1,exports:{}};return Q[U].call(s.exports,s,s.exports,B),s.l=!0,s.exports}B.m=Q,B.c=F,B.d=function(Q,F,U){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:U})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(B.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var s in Q)B.d(U,s,function(F){return Q[F]}.bind(null,s));return U},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="http://localhost:8888/",B(B.s="./src/vendor/vue-router.js")}({"./src/vendor/vue-router.js":
/*!**********************************!*\
  !*** ./src/vendor/vue-router.js ***!
  \**********************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/**\n  * vue-router v3.0.1\n  * (c) 2017 Evan You\n  * @license MIT\n  */\n(function (global, factory) {\n   true ? module.exports = factory() : undefined;\n})(this, function () {\n  'use strict';\n  /*  */\n\n  function assert(condition, message) {\n    if (!condition) {\n      throw new Error(\"[vue-router] \" + message);\n    }\n  }\n\n  function warn(condition, message) {\n    if (\"development\" !== 'production' && !condition) {\n      typeof console !== 'undefined' && console.warn(\"[vue-router] \" + message);\n    }\n  }\n\n  function isError(err) {\n    return Object.prototype.toString.call(err).indexOf('Error') > -1;\n  }\n\n  var View = {\n    name: 'router-view',\n    functional: true,\n    props: {\n      name: {\n        type: String,\n        default: 'default'\n      }\n    },\n    render: function render(_, ref) {\n      var props = ref.props;\n      var children = ref.children;\n      var parent = ref.parent;\n      var data = ref.data;\n      data.routerView = true; // directly use parent context's createElement() function\n      // so that components rendered by router-view can resolve named slots\n\n      var h = parent.$createElement;\n      var name = props.name;\n      var route = parent.$route;\n      var cache = parent._routerViewCache || (parent._routerViewCache = {}); // determine current view depth, also check to see if the tree\n      // has been toggled inactive but kept-alive.\n\n      var depth = 0;\n      var inactive = false;\n\n      while (parent && parent._routerRoot !== parent) {\n        if (parent.$vnode && parent.$vnode.data.routerView) {\n          depth++;\n        }\n\n        if (parent._inactive) {\n          inactive = true;\n        }\n\n        parent = parent.$parent;\n      }\n\n      data.routerViewDepth = depth; // render previous view if the tree is inactive and kept-alive\n\n      if (inactive) {\n        return h(cache[name], data, children);\n      }\n\n      var matched = route.matched[depth]; // render empty node if no matched route\n\n      if (!matched) {\n        cache[name] = null;\n        return h();\n      }\n\n      var component = cache[name] = matched.components[name]; // attach instance registration hook\n      // this will be called in the instance's injected lifecycle hooks\n\n      data.registerRouteInstance = function (vm, val) {\n        // val could be undefined for unregistration\n        var current = matched.instances[name];\n\n        if (val && current !== vm || !val && current === vm) {\n          matched.instances[name] = val;\n        }\n      } // also register instance in prepatch hook\n      // in case the same component instance is reused across different routes\n      ;\n\n      (data.hook || (data.hook = {})).prepatch = function (_, vnode) {\n        matched.instances[name] = vnode.componentInstance;\n      }; // resolve props\n\n\n      var propsToPass = data.props = resolveProps(route, matched.props && matched.props[name]);\n\n      if (propsToPass) {\n        // clone to prevent mutation\n        propsToPass = data.props = extend({}, propsToPass); // pass non-declared props as attrs\n\n        var attrs = data.attrs = data.attrs || {};\n\n        for (var key in propsToPass) {\n          if (!component.props || !(key in component.props)) {\n            attrs[key] = propsToPass[key];\n            delete propsToPass[key];\n          }\n        }\n      }\n\n      return h(component, data, children);\n    }\n  };\n\n  function resolveProps(route, config) {\n    switch (typeof config) {\n      case 'undefined':\n        return;\n\n      case 'object':\n        return config;\n\n      case 'function':\n        return config(route);\n\n      case 'boolean':\n        return config ? route.params : undefined;\n\n      default:\n        {\n          warn(false, \"props in \\\"\" + route.path + \"\\\" is a \" + typeof config + \", \" + \"expecting an object, function or boolean.\");\n        }\n    }\n  }\n\n  function extend(to, from) {\n    for (var key in from) {\n      to[key] = from[key];\n    }\n\n    return to;\n  }\n  /*  */\n\n\n  var encodeReserveRE = /[!'()*]/g;\n\n  var encodeReserveReplacer = function (c) {\n    return '%' + c.charCodeAt(0).toString(16);\n  };\n\n  var commaRE = /%2C/g; // fixed encodeURIComponent which is more conformant to RFC3986:\n  // - escapes [!'()*]\n  // - preserve commas\n\n  var encode = function (str) {\n    return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, ',');\n  };\n\n  var decode = decodeURIComponent;\n\n  function resolveQuery(query, extraQuery, _parseQuery) {\n    if (extraQuery === void 0) extraQuery = {};\n    var parse = _parseQuery || parseQuery;\n    var parsedQuery;\n\n    try {\n      parsedQuery = parse(query || '');\n    } catch (e) {\n      \"development\" !== 'production' && warn(false, e.message);\n      parsedQuery = {};\n    }\n\n    for (var key in extraQuery) {\n      parsedQuery[key] = extraQuery[key];\n    }\n\n    return parsedQuery;\n  }\n\n  function parseQuery(query) {\n    var res = {};\n    query = query.trim().replace(/^(\\?|#|&)/, '');\n\n    if (!query) {\n      return res;\n    }\n\n    query.split('&').forEach(function (param) {\n      var parts = param.replace(/\\+/g, ' ').split('=');\n      var key = decode(parts.shift());\n      var val = parts.length > 0 ? decode(parts.join('=')) : null;\n\n      if (res[key] === undefined) {\n        res[key] = val;\n      } else if (Array.isArray(res[key])) {\n        res[key].push(val);\n      } else {\n        res[key] = [res[key], val];\n      }\n    });\n    return res;\n  }\n\n  function stringifyQuery(obj) {\n    var res = obj ? Object.keys(obj).map(function (key) {\n      var val = obj[key];\n\n      if (val === undefined) {\n        return '';\n      }\n\n      if (val === null) {\n        return encode(key);\n      }\n\n      if (Array.isArray(val)) {\n        var result = [];\n        val.forEach(function (val2) {\n          if (val2 === undefined) {\n            return;\n          }\n\n          if (val2 === null) {\n            result.push(encode(key));\n          } else {\n            result.push(encode(key) + '=' + encode(val2));\n          }\n        });\n        return result.join('&');\n      }\n\n      return encode(key) + '=' + encode(val);\n    }).filter(function (x) {\n      return x.length > 0;\n    }).join('&') : null;\n    return res ? \"?\" + res : '';\n  }\n  /*  */\n\n\n  var trailingSlashRE = /\\/?$/;\n\n  function createRoute(record, location, redirectedFrom, router) {\n    var stringifyQuery$$1 = router && router.options.stringifyQuery;\n    var query = location.query || {};\n\n    try {\n      query = clone(query);\n    } catch (e) {}\n\n    var route = {\n      name: location.name || record && record.name,\n      meta: record && record.meta || {},\n      path: location.path || '/',\n      hash: location.hash || '',\n      query: query,\n      params: location.params || {},\n      fullPath: getFullPath(location, stringifyQuery$$1),\n      matched: record ? formatMatch(record) : []\n    };\n\n    if (redirectedFrom) {\n      route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);\n    }\n\n    return Object.freeze(route);\n  }\n\n  function clone(value) {\n    if (Array.isArray(value)) {\n      return value.map(clone);\n    } else if (value && typeof value === 'object') {\n      var res = {};\n\n      for (var key in value) {\n        res[key] = clone(value[key]);\n      }\n\n      return res;\n    } else {\n      return value;\n    }\n  } // the starting route that represents the initial state\n\n\n  var START = createRoute(null, {\n    path: '/'\n  });\n\n  function formatMatch(record) {\n    var res = [];\n\n    while (record) {\n      res.unshift(record);\n      record = record.parent;\n    }\n\n    return res;\n  }\n\n  function getFullPath(ref, _stringifyQuery) {\n    var path = ref.path;\n    var query = ref.query;\n    if (query === void 0) query = {};\n    var hash = ref.hash;\n    if (hash === void 0) hash = '';\n    var stringify = _stringifyQuery || stringifyQuery;\n    return (path || '/') + stringify(query) + hash;\n  }\n\n  function isSameRoute(a, b) {\n    if (b === START) {\n      return a === b;\n    } else if (!b) {\n      return false;\n    } else if (a.path && b.path) {\n      return a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') && a.hash === b.hash && isObjectEqual(a.query, b.query);\n    } else if (a.name && b.name) {\n      return a.name === b.name && a.hash === b.hash && isObjectEqual(a.query, b.query) && isObjectEqual(a.params, b.params);\n    } else {\n      return false;\n    }\n  }\n\n  function isObjectEqual(a, b) {\n    if (a === void 0) a = {};\n    if (b === void 0) b = {}; // handle null value #1566\n\n    if (!a || !b) {\n      return a === b;\n    }\n\n    var aKeys = Object.keys(a);\n    var bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      return false;\n    }\n\n    return aKeys.every(function (key) {\n      var aVal = a[key];\n      var bVal = b[key]; // check nested equality\n\n      if (typeof aVal === 'object' && typeof bVal === 'object') {\n        return isObjectEqual(aVal, bVal);\n      }\n\n      return String(aVal) === String(bVal);\n    });\n  }\n\n  function isIncludedRoute(current, target) {\n    return current.path.replace(trailingSlashRE, '/').indexOf(target.path.replace(trailingSlashRE, '/')) === 0 && (!target.hash || current.hash === target.hash) && queryIncludes(current.query, target.query);\n  }\n\n  function queryIncludes(current, target) {\n    for (var key in target) {\n      if (!(key in current)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /*  */\n  // work around weird flow bug\n\n\n  var toTypes = [String, Object];\n  var eventTypes = [String, Array];\n  var Link = {\n    name: 'router-link',\n    props: {\n      to: {\n        type: toTypes,\n        required: true\n      },\n      tag: {\n        type: String,\n        default: 'a'\n      },\n      exact: Boolean,\n      append: Boolean,\n      replace: Boolean,\n      activeClass: String,\n      exactActiveClass: String,\n      event: {\n        type: eventTypes,\n        default: 'click'\n      }\n    },\n    render: function render(h) {\n      var this$1 = this;\n      var router = this.$router;\n      var current = this.$route;\n      var ref = router.resolve(this.to, current, this.append);\n      var location = ref.location;\n      var route = ref.route;\n      var href = ref.href;\n      var classes = {};\n      var globalActiveClass = router.options.linkActiveClass;\n      var globalExactActiveClass = router.options.linkExactActiveClass; // Support global empty active class\n\n      var activeClassFallback = globalActiveClass == null ? 'router-link-active' : globalActiveClass;\n      var exactActiveClassFallback = globalExactActiveClass == null ? 'router-link-exact-active' : globalExactActiveClass;\n      var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;\n      var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;\n      var compareTarget = location.path ? createRoute(null, location, null, router) : route;\n      classes[exactActiveClass] = isSameRoute(current, compareTarget);\n      classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);\n\n      var handler = function (e) {\n        if (guardEvent(e)) {\n          if (this$1.replace) {\n            router.replace(location);\n          } else {\n            router.push(location);\n          }\n        }\n      };\n\n      var on = {\n        click: guardEvent\n      };\n\n      if (Array.isArray(this.event)) {\n        this.event.forEach(function (e) {\n          on[e] = handler;\n        });\n      } else {\n        on[this.event] = handler;\n      }\n\n      var data = {\n        class: classes\n      };\n\n      if (this.tag === 'a') {\n        data.on = on;\n        data.attrs = {\n          href: href\n        };\n      } else {\n        // find the first <a> child and apply listener and href\n        var a = findAnchor(this.$slots.default);\n\n        if (a) {\n          // in case the <a> is a static node\n          a.isStatic = false;\n          var extend = _Vue.util.extend;\n          var aData = a.data = extend({}, a.data);\n          aData.on = on;\n          var aAttrs = a.data.attrs = extend({}, a.data.attrs);\n          aAttrs.href = href;\n        } else {\n          // doesn't have <a> child, apply listener to self\n          data.on = on;\n        }\n      }\n\n      return h(this.tag, data, this.$slots.default);\n    }\n  };\n\n  function guardEvent(e) {\n    // don't redirect with control keys\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) {\n      return;\n    } // don't redirect when preventDefault called\n\n\n    if (e.defaultPrevented) {\n      return;\n    } // don't redirect on right click\n\n\n    if (e.button !== undefined && e.button !== 0) {\n      return;\n    } // don't redirect if `target=\"_blank\"`\n\n\n    if (e.currentTarget && e.currentTarget.getAttribute) {\n      var target = e.currentTarget.getAttribute('target');\n\n      if (/\\b_blank\\b/i.test(target)) {\n        return;\n      }\n    } // this may be a Weex event which doesn't have this method\n\n\n    if (e.preventDefault) {\n      e.preventDefault();\n    }\n\n    return true;\n  }\n\n  function findAnchor(children) {\n    if (children) {\n      var child;\n\n      for (var i = 0; i < children.length; i++) {\n        child = children[i];\n\n        if (child.tag === 'a') {\n          return child;\n        }\n\n        if (child.children && (child = findAnchor(child.children))) {\n          return child;\n        }\n      }\n    }\n  }\n\n  var _Vue;\n\n  function install(Vue) {\n    if (install.installed && _Vue === Vue) {\n      return;\n    }\n\n    install.installed = true;\n    _Vue = Vue;\n\n    var isDef = function (v) {\n      return v !== undefined;\n    };\n\n    var registerInstance = function (vm, callVal) {\n      var i = vm.$options._parentVnode;\n\n      if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {\n        i(vm, callVal);\n      }\n    };\n\n    Vue.mixin({\n      beforeCreate: function beforeCreate() {\n        if (isDef(this.$options.router)) {\n          this._routerRoot = this;\n          this._router = this.$options.router;\n\n          this._router.init(this);\n\n          Vue.util.defineReactive(this, '_route', this._router.history.current);\n        } else {\n          this._routerRoot = this.$parent && this.$parent._routerRoot || this;\n        }\n\n        registerInstance(this, this);\n      },\n      destroyed: function destroyed() {\n        registerInstance(this);\n      }\n    });\n    Object.defineProperty(Vue.prototype, '$router', {\n      get: function get() {\n        return this._routerRoot._router;\n      }\n    });\n    Object.defineProperty(Vue.prototype, '$route', {\n      get: function get() {\n        return this._routerRoot._route;\n      }\n    });\n    Vue.component('router-view', View);\n    Vue.component('router-link', Link);\n    var strats = Vue.config.optionMergeStrategies; // use the same hook merging strategy for route hooks\n\n    strats.beforeRouteEnter = strats.beforeRouteLeave = strats.beforeRouteUpdate = strats.created;\n  }\n  /*  */\n\n\n  var inBrowser = typeof window !== 'undefined';\n  /*  */\n\n  function resolvePath(relative, base, append) {\n    var firstChar = relative.charAt(0);\n\n    if (firstChar === '/') {\n      return relative;\n    }\n\n    if (firstChar === '?' || firstChar === '#') {\n      return base + relative;\n    }\n\n    var stack = base.split('/'); // remove trailing segment if:\n    // - not appending\n    // - appending to trailing slash (last segment is empty)\n\n    if (!append || !stack[stack.length - 1]) {\n      stack.pop();\n    } // resolve relative path\n\n\n    var segments = relative.replace(/^\\//, '').split('/');\n\n    for (var i = 0; i < segments.length; i++) {\n      var segment = segments[i];\n\n      if (segment === '..') {\n        stack.pop();\n      } else if (segment !== '.') {\n        stack.push(segment);\n      }\n    } // ensure leading slash\n\n\n    if (stack[0] !== '') {\n      stack.unshift('');\n    }\n\n    return stack.join('/');\n  }\n\n  function parsePath(path) {\n    var hash = '';\n    var query = '';\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      hash = path.slice(hashIndex);\n      path = path.slice(0, hashIndex);\n    }\n\n    var queryIndex = path.indexOf('?');\n\n    if (queryIndex >= 0) {\n      query = path.slice(queryIndex + 1);\n      path = path.slice(0, queryIndex);\n    }\n\n    return {\n      path: path,\n      query: query,\n      hash: hash\n    };\n  }\n\n  function cleanPath(path) {\n    return path.replace(/\\/\\//g, '/');\n  }\n\n  var isarray = Array.isArray || function (arr) {\n    return Object.prototype.toString.call(arr) == '[object Array]';\n  };\n  /**\n   * Expose `pathToRegexp`.\n   */\n\n\n  var pathToRegexp_1 = pathToRegexp;\n  var parse_1 = parse;\n  var compile_1 = compile;\n  var tokensToFunction_1 = tokensToFunction;\n  var tokensToRegExp_1 = tokensToRegExp;\n  /**\n   * The main path matching regexp utility.\n   *\n   * @type {RegExp}\n   */\n\n  var PATH_REGEXP = new RegExp([// Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)', // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'].join('|'), 'g');\n  /**\n   * Parse a string for the raw tokens.\n   *\n   * @param  {string}  str\n   * @param  {Object=} options\n   * @return {!Array}\n   */\n\n  function parse(str, options) {\n    var tokens = [];\n    var key = 0;\n    var index = 0;\n    var path = '';\n    var defaultDelimiter = options && options.delimiter || '/';\n    var res;\n\n    while ((res = PATH_REGEXP.exec(str)) != null) {\n      var m = res[0];\n      var escaped = res[1];\n      var offset = res.index;\n      path += str.slice(index, offset);\n      index = offset + m.length; // Ignore already escaped sequences.\n\n      if (escaped) {\n        path += escaped[1];\n        continue;\n      }\n\n      var next = str[index];\n      var prefix = res[2];\n      var name = res[3];\n      var capture = res[4];\n      var group = res[5];\n      var modifier = res[6];\n      var asterisk = res[7]; // Push the current path onto the tokens.\n\n      if (path) {\n        tokens.push(path);\n        path = '';\n      }\n\n      var partial = prefix != null && next != null && next !== prefix;\n      var repeat = modifier === '+' || modifier === '*';\n      var optional = modifier === '?' || modifier === '*';\n      var delimiter = res[2] || defaultDelimiter;\n      var pattern = capture || group;\n      tokens.push({\n        name: name || key++,\n        prefix: prefix || '',\n        delimiter: delimiter,\n        optional: optional,\n        repeat: repeat,\n        partial: partial,\n        asterisk: !!asterisk,\n        pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'\n      });\n    } // Match any characters still remaining.\n\n\n    if (index < str.length) {\n      path += str.substr(index);\n    } // If the path exists, push it onto the end.\n\n\n    if (path) {\n      tokens.push(path);\n    }\n\n    return tokens;\n  }\n  /**\n   * Compile a string to a template function for the path.\n   *\n   * @param  {string}             str\n   * @param  {Object=}            options\n   * @return {!function(Object=, Object=)}\n   */\n\n\n  function compile(str, options) {\n    return tokensToFunction(parse(str, options));\n  }\n  /**\n   * Prettier encoding of URI path segments.\n   *\n   * @param  {string}\n   * @return {string}\n   */\n\n\n  function encodeURIComponentPretty(str) {\n    return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n  /**\n   * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n   *\n   * @param  {string}\n   * @return {string}\n   */\n\n\n  function encodeAsterisk(str) {\n    return encodeURI(str).replace(/[?#]/g, function (c) {\n      return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n    });\n  }\n  /**\n   * Expose a method for transforming tokens into the path function.\n   */\n\n\n  function tokensToFunction(tokens) {\n    // Compile all the tokens into regexps.\n    var matches = new Array(tokens.length); // Compile all the patterns before compilation.\n\n    for (var i = 0; i < tokens.length; i++) {\n      if (typeof tokens[i] === 'object') {\n        matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n      }\n    }\n\n    return function (obj, opts) {\n      var path = '';\n      var data = obj || {};\n      var options = opts || {};\n      var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (typeof token === 'string') {\n          path += token;\n          continue;\n        }\n\n        var value = data[token.name];\n        var segment;\n\n        if (value == null) {\n          if (token.optional) {\n            // Prepend partial segment prefixes.\n            if (token.partial) {\n              path += token.prefix;\n            }\n\n            continue;\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to be defined');\n          }\n        }\n\n        if (isarray(value)) {\n          if (!token.repeat) {\n            throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`');\n          }\n\n          if (value.length === 0) {\n            if (token.optional) {\n              continue;\n            } else {\n              throw new TypeError('Expected \"' + token.name + '\" to not be empty');\n            }\n          }\n\n          for (var j = 0; j < value.length; j++) {\n            segment = encode(value[j]);\n\n            if (!matches[i].test(segment)) {\n              throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`');\n            }\n\n            path += (j === 0 ? token.prefix : token.delimiter) + segment;\n          }\n\n          continue;\n        }\n\n        segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n        if (!matches[i].test(segment)) {\n          throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"');\n        }\n\n        path += token.prefix + segment;\n      }\n\n      return path;\n    };\n  }\n  /**\n   * Escape a regular expression string.\n   *\n   * @param  {string} str\n   * @return {string}\n   */\n\n\n  function escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1');\n  }\n  /**\n   * Escape the capturing group by escaping special characters and meaning.\n   *\n   * @param  {string} group\n   * @return {string}\n   */\n\n\n  function escapeGroup(group) {\n    return group.replace(/([=!:$\\/()])/g, '\\\\$1');\n  }\n  /**\n   * Attach the keys as a property of the regexp.\n   *\n   * @param  {!RegExp} re\n   * @param  {Array}   keys\n   * @return {!RegExp}\n   */\n\n\n  function attachKeys(re, keys) {\n    re.keys = keys;\n    return re;\n  }\n  /**\n   * Get the flags for a regexp from the options.\n   *\n   * @param  {Object} options\n   * @return {string}\n   */\n\n\n  function flags(options) {\n    return options.sensitive ? '' : 'i';\n  }\n  /**\n   * Pull out keys from a regexp.\n   *\n   * @param  {!RegExp} path\n   * @param  {!Array}  keys\n   * @return {!RegExp}\n   */\n\n\n  function regexpToRegexp(path, keys) {\n    // Use a negative lookahead to match only capturing groups.\n    var groups = path.source.match(/\\((?!\\?)/g);\n\n    if (groups) {\n      for (var i = 0; i < groups.length; i++) {\n        keys.push({\n          name: i,\n          prefix: null,\n          delimiter: null,\n          optional: false,\n          repeat: false,\n          partial: false,\n          asterisk: false,\n          pattern: null\n        });\n      }\n    }\n\n    return attachKeys(path, keys);\n  }\n  /**\n   * Transform an array into a regexp.\n   *\n   * @param  {!Array}  path\n   * @param  {Array}   keys\n   * @param  {!Object} options\n   * @return {!RegExp}\n   */\n\n\n  function arrayToRegexp(path, keys, options) {\n    var parts = [];\n\n    for (var i = 0; i < path.length; i++) {\n      parts.push(pathToRegexp(path[i], keys, options).source);\n    }\n\n    var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n    return attachKeys(regexp, keys);\n  }\n  /**\n   * Create a path regexp from string input.\n   *\n   * @param  {string}  path\n   * @param  {!Array}  keys\n   * @param  {!Object} options\n   * @return {!RegExp}\n   */\n\n\n  function stringToRegexp(path, keys, options) {\n    return tokensToRegExp(parse(path, options), keys, options);\n  }\n  /**\n   * Expose a function for taking tokens and returning a RegExp.\n   *\n   * @param  {!Array}          tokens\n   * @param  {(Array|Object)=} keys\n   * @param  {Object=}         options\n   * @return {!RegExp}\n   */\n\n\n  function tokensToRegExp(tokens, keys, options) {\n    if (!isarray(keys)) {\n      options =\n      /** @type {!Object} */\n      keys || options;\n      keys = [];\n    }\n\n    options = options || {};\n    var strict = options.strict;\n    var end = options.end !== false;\n    var route = ''; // Iterate over the tokens and create our regexp string.\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        route += escapeString(token);\n      } else {\n        var prefix = escapeString(token.prefix);\n        var capture = '(?:' + token.pattern + ')';\n        keys.push(token);\n\n        if (token.repeat) {\n          capture += '(?:' + prefix + capture + ')*';\n        }\n\n        if (token.optional) {\n          if (!token.partial) {\n            capture = '(?:' + prefix + '(' + capture + '))?';\n          } else {\n            capture = prefix + '(' + capture + ')?';\n          }\n        } else {\n          capture = prefix + '(' + capture + ')';\n        }\n\n        route += capture;\n      }\n    }\n\n    var delimiter = escapeString(options.delimiter || '/');\n    var endsWithDelimiter = route.slice(-delimiter.length) === delimiter; // In non-strict mode we allow a slash at the end of match. If the path to\n    // match already ends with a slash, we remove it for consistency. The slash\n    // is valid at the end of a path match, not in the middle. This is important\n    // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n\n    if (!strict) {\n      route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n    }\n\n    if (end) {\n      route += '$';\n    } else {\n      // In non-ending mode, we need the capturing groups to match as much as\n      // possible by using a positive lookahead to the end or next path segment.\n      route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n    }\n\n    return attachKeys(new RegExp('^' + route, flags(options)), keys);\n  }\n  /**\n   * Normalize the given path string, returning a regular expression.\n   *\n   * An empty array can be passed in for the keys, which will hold the\n   * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n   *\n   * @param  {(string|RegExp|Array)} path\n   * @param  {(Array|Object)=}       keys\n   * @param  {Object=}               options\n   * @return {!RegExp}\n   */\n\n\n  function pathToRegexp(path, keys, options) {\n    if (!isarray(keys)) {\n      options =\n      /** @type {!Object} */\n      keys || options;\n      keys = [];\n    }\n\n    options = options || {};\n\n    if (path instanceof RegExp) {\n      return regexpToRegexp(path,\n      /** @type {!Array} */\n      keys);\n    }\n\n    if (isarray(path)) {\n      return arrayToRegexp(\n      /** @type {!Array} */\n      path,\n      /** @type {!Array} */\n      keys, options);\n    }\n\n    return stringToRegexp(\n    /** @type {string} */\n    path,\n    /** @type {!Array} */\n    keys, options);\n  }\n\n  pathToRegexp_1.parse = parse_1;\n  pathToRegexp_1.compile = compile_1;\n  pathToRegexp_1.tokensToFunction = tokensToFunction_1;\n  pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;\n  /*  */\n  // $flow-disable-line\n\n  var regexpCompileCache = Object.create(null);\n\n  function fillParams(path, params, routeMsg) {\n    try {\n      var filler = regexpCompileCache[path] || (regexpCompileCache[path] = pathToRegexp_1.compile(path));\n      return filler(params || {}, {\n        pretty: true\n      });\n    } catch (e) {\n      {\n        warn(false, \"missing param for \" + routeMsg + \": \" + e.message);\n      }\n      return '';\n    }\n  }\n  /*  */\n\n\n  function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {\n    // the path list is used to control path matching priority\n    var pathList = oldPathList || []; // $flow-disable-line\n\n    var pathMap = oldPathMap || Object.create(null); // $flow-disable-line\n\n    var nameMap = oldNameMap || Object.create(null);\n    routes.forEach(function (route) {\n      addRouteRecord(pathList, pathMap, nameMap, route);\n    }); // ensure wildcard routes are always at the end\n\n    for (var i = 0, l = pathList.length; i < l; i++) {\n      if (pathList[i] === '*') {\n        pathList.push(pathList.splice(i, 1)[0]);\n        l--;\n        i--;\n      }\n    }\n\n    return {\n      pathList: pathList,\n      pathMap: pathMap,\n      nameMap: nameMap\n    };\n  }\n\n  function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {\n    var path = route.path;\n    var name = route.name;\n    {\n      assert(path != null, \"\\\"path\\\" is required in a route configuration.\");\n      assert(typeof route.component !== 'string', \"route config \\\"component\\\" for path: \" + String(path || name) + \" cannot be a \" + \"string id. Use an actual component instead.\");\n    }\n    var pathToRegexpOptions = route.pathToRegexpOptions || {};\n    var normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict);\n\n    if (typeof route.caseSensitive === 'boolean') {\n      pathToRegexpOptions.sensitive = route.caseSensitive;\n    }\n\n    var record = {\n      path: normalizedPath,\n      regex: compileRouteRegex(normalizedPath, pathToRegexpOptions),\n      components: route.components || {\n        default: route.component\n      },\n      instances: {},\n      name: name,\n      parent: parent,\n      matchAs: matchAs,\n      redirect: route.redirect,\n      beforeEnter: route.beforeEnter,\n      meta: route.meta || {},\n      props: route.props == null ? {} : route.components ? route.props : {\n        default: route.props\n      }\n    };\n\n    if (route.children) {\n      // Warn if route is named, does not redirect and has a default child route.\n      // If users navigate to this route by name, the default child will\n      // not be rendered (GH Issue #629)\n      {\n        if (route.name && !route.redirect && route.children.some(function (child) {\n          return /^\\/?$/.test(child.path);\n        })) {\n          warn(false, \"Named Route '\" + route.name + \"' has a default child route. \" + \"When navigating to this named route (:to=\\\"{name: '\" + route.name + \"'\\\"), \" + \"the default child route will not be rendered. Remove the name from \" + \"this route and use the name of the default child route for named \" + \"links instead.\");\n        }\n      }\n      route.children.forEach(function (child) {\n        var childMatchAs = matchAs ? cleanPath(matchAs + \"/\" + child.path) : undefined;\n        addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);\n      });\n    }\n\n    if (route.alias !== undefined) {\n      var aliases = Array.isArray(route.alias) ? route.alias : [route.alias];\n      aliases.forEach(function (alias) {\n        var aliasRoute = {\n          path: alias,\n          children: route.children\n        };\n        addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs\n        );\n      });\n    }\n\n    if (!pathMap[record.path]) {\n      pathList.push(record.path);\n      pathMap[record.path] = record;\n    }\n\n    if (name) {\n      if (!nameMap[name]) {\n        nameMap[name] = record;\n      } else if (\"development\" !== 'production' && !matchAs) {\n        warn(false, \"Duplicate named routes definition: \" + \"{ name: \\\"\" + name + \"\\\", path: \\\"\" + record.path + \"\\\" }\");\n      }\n    }\n  }\n\n  function compileRouteRegex(path, pathToRegexpOptions) {\n    var regex = pathToRegexp_1(path, [], pathToRegexpOptions);\n    {\n      var keys = Object.create(null);\n      regex.keys.forEach(function (key) {\n        warn(!keys[key.name], \"Duplicate param keys in route with path: \\\"\" + path + \"\\\"\");\n        keys[key.name] = true;\n      });\n    }\n    return regex;\n  }\n\n  function normalizePath(path, parent, strict) {\n    if (!strict) {\n      path = path.replace(/\\/$/, '');\n    }\n\n    if (path[0] === '/') {\n      return path;\n    }\n\n    if (parent == null) {\n      return path;\n    }\n\n    return cleanPath(parent.path + \"/\" + path);\n  }\n  /*  */\n\n\n  function normalizeLocation(raw, current, append, router) {\n    var next = typeof raw === 'string' ? {\n      path: raw\n    } : raw; // named target\n\n    if (next.name || next._normalized) {\n      return next;\n    } // relative params\n\n\n    if (!next.path && next.params && current) {\n      next = assign({}, next);\n      next._normalized = true;\n      var params = assign(assign({}, current.params), next.params);\n\n      if (current.name) {\n        next.name = current.name;\n        next.params = params;\n      } else if (current.matched.length) {\n        var rawPath = current.matched[current.matched.length - 1].path;\n        next.path = fillParams(rawPath, params, \"path \" + current.path);\n      } else {\n        warn(false, \"relative params navigation requires a current route.\");\n      }\n\n      return next;\n    }\n\n    var parsedPath = parsePath(next.path || '');\n    var basePath = current && current.path || '/';\n    var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;\n    var query = resolveQuery(parsedPath.query, next.query, router && router.options.parseQuery);\n    var hash = next.hash || parsedPath.hash;\n\n    if (hash && hash.charAt(0) !== '#') {\n      hash = \"#\" + hash;\n    }\n\n    return {\n      _normalized: true,\n      path: path,\n      query: query,\n      hash: hash\n    };\n  }\n\n  function assign(a, b) {\n    for (var key in b) {\n      a[key] = b[key];\n    }\n\n    return a;\n  }\n  /*  */\n\n\n  function createMatcher(routes, router) {\n    var ref = createRouteMap(routes);\n    var pathList = ref.pathList;\n    var pathMap = ref.pathMap;\n    var nameMap = ref.nameMap;\n\n    function addRoutes(routes) {\n      createRouteMap(routes, pathList, pathMap, nameMap);\n    }\n\n    function match(raw, currentRoute, redirectedFrom) {\n      var location = normalizeLocation(raw, currentRoute, false, router);\n      var name = location.name;\n\n      if (name) {\n        var record = nameMap[name];\n        {\n          warn(record, \"Route with name '\" + name + \"' does not exist\");\n        }\n\n        if (!record) {\n          return _createRoute(null, location);\n        }\n\n        var paramNames = record.regex.keys.filter(function (key) {\n          return !key.optional;\n        }).map(function (key) {\n          return key.name;\n        });\n\n        if (typeof location.params !== 'object') {\n          location.params = {};\n        }\n\n        if (currentRoute && typeof currentRoute.params === 'object') {\n          for (var key in currentRoute.params) {\n            if (!(key in location.params) && paramNames.indexOf(key) > -1) {\n              location.params[key] = currentRoute.params[key];\n            }\n          }\n        }\n\n        if (record) {\n          location.path = fillParams(record.path, location.params, \"named route \\\"\" + name + \"\\\"\");\n          return _createRoute(record, location, redirectedFrom);\n        }\n      } else if (location.path) {\n        location.params = {};\n\n        for (var i = 0; i < pathList.length; i++) {\n          var path = pathList[i];\n          var record$1 = pathMap[path];\n\n          if (matchRoute(record$1.regex, location.path, location.params)) {\n            return _createRoute(record$1, location, redirectedFrom);\n          }\n        }\n      } // no match\n\n\n      return _createRoute(null, location);\n    }\n\n    function redirect(record, location) {\n      var originalRedirect = record.redirect;\n      var redirect = typeof originalRedirect === 'function' ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;\n\n      if (typeof redirect === 'string') {\n        redirect = {\n          path: redirect\n        };\n      }\n\n      if (!redirect || typeof redirect !== 'object') {\n        {\n          warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n        }\n        return _createRoute(null, location);\n      }\n\n      var re = redirect;\n      var name = re.name;\n      var path = re.path;\n      var query = location.query;\n      var hash = location.hash;\n      var params = location.params;\n      query = re.hasOwnProperty('query') ? re.query : query;\n      hash = re.hasOwnProperty('hash') ? re.hash : hash;\n      params = re.hasOwnProperty('params') ? re.params : params;\n\n      if (name) {\n        // resolved named direct\n        var targetRecord = nameMap[name];\n        {\n          assert(targetRecord, \"redirect failed: named route \\\"\" + name + \"\\\" not found.\");\n        }\n        return match({\n          _normalized: true,\n          name: name,\n          query: query,\n          hash: hash,\n          params: params\n        }, undefined, location);\n      } else if (path) {\n        // 1. resolve relative redirect\n        var rawPath = resolveRecordPath(path, record); // 2. resolve params\n\n        var resolvedPath = fillParams(rawPath, params, \"redirect route with path \\\"\" + rawPath + \"\\\"\"); // 3. rematch with existing query and hash\n\n        return match({\n          _normalized: true,\n          path: resolvedPath,\n          query: query,\n          hash: hash\n        }, undefined, location);\n      } else {\n        {\n          warn(false, \"invalid redirect option: \" + JSON.stringify(redirect));\n        }\n        return _createRoute(null, location);\n      }\n    }\n\n    function alias(record, location, matchAs) {\n      var aliasedPath = fillParams(matchAs, location.params, \"aliased route with path \\\"\" + matchAs + \"\\\"\");\n      var aliasedMatch = match({\n        _normalized: true,\n        path: aliasedPath\n      });\n\n      if (aliasedMatch) {\n        var matched = aliasedMatch.matched;\n        var aliasedRecord = matched[matched.length - 1];\n        location.params = aliasedMatch.params;\n        return _createRoute(aliasedRecord, location);\n      }\n\n      return _createRoute(null, location);\n    }\n\n    function _createRoute(record, location, redirectedFrom) {\n      if (record && record.redirect) {\n        return redirect(record, redirectedFrom || location);\n      }\n\n      if (record && record.matchAs) {\n        return alias(record, location, record.matchAs);\n      }\n\n      return createRoute(record, location, redirectedFrom, router);\n    }\n\n    return {\n      match: match,\n      addRoutes: addRoutes\n    };\n  }\n\n  function matchRoute(regex, path, params) {\n    var m = path.match(regex);\n\n    if (!m) {\n      return false;\n    } else if (!params) {\n      return true;\n    }\n\n    for (var i = 1, len = m.length; i < len; ++i) {\n      var key = regex.keys[i - 1];\n      var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];\n\n      if (key) {\n        params[key.name] = val;\n      }\n    }\n\n    return true;\n  }\n\n  function resolveRecordPath(path, record) {\n    return resolvePath(path, record.parent ? record.parent.path : '/', true);\n  }\n  /*  */\n\n\n  var positionStore = Object.create(null);\n\n  function setupScroll() {\n    // Fix for #1585 for Firefox\n    window.history.replaceState({\n      key: getStateKey()\n    }, '');\n    window.addEventListener('popstate', function (e) {\n      saveScrollPosition();\n\n      if (e.state && e.state.key) {\n        setStateKey(e.state.key);\n      }\n    });\n  }\n\n  function handleScroll(router, to, from, isPop) {\n    if (!router.app) {\n      return;\n    }\n\n    var behavior = router.options.scrollBehavior;\n\n    if (!behavior) {\n      return;\n    }\n\n    {\n      assert(typeof behavior === 'function', \"scrollBehavior must be a function\");\n    } // wait until re-render finishes before scrolling\n\n    router.app.$nextTick(function () {\n      var position = getScrollPosition();\n      var shouldScroll = behavior(to, from, isPop ? position : null);\n\n      if (!shouldScroll) {\n        return;\n      }\n\n      if (typeof shouldScroll.then === 'function') {\n        shouldScroll.then(function (shouldScroll) {\n          scrollToPosition(shouldScroll, position);\n        }).catch(function (err) {\n          {\n            assert(false, err.toString());\n          }\n        });\n      } else {\n        scrollToPosition(shouldScroll, position);\n      }\n    });\n  }\n\n  function saveScrollPosition() {\n    var key = getStateKey();\n\n    if (key) {\n      positionStore[key] = {\n        x: window.pageXOffset,\n        y: window.pageYOffset\n      };\n    }\n  }\n\n  function getScrollPosition() {\n    var key = getStateKey();\n\n    if (key) {\n      return positionStore[key];\n    }\n  }\n\n  function getElementPosition(el, offset) {\n    var docEl = document.documentElement;\n    var docRect = docEl.getBoundingClientRect();\n    var elRect = el.getBoundingClientRect();\n    return {\n      x: elRect.left - docRect.left - offset.x,\n      y: elRect.top - docRect.top - offset.y\n    };\n  }\n\n  function isValidPosition(obj) {\n    return isNumber(obj.x) || isNumber(obj.y);\n  }\n\n  function normalizePosition(obj) {\n    return {\n      x: isNumber(obj.x) ? obj.x : window.pageXOffset,\n      y: isNumber(obj.y) ? obj.y : window.pageYOffset\n    };\n  }\n\n  function normalizeOffset(obj) {\n    return {\n      x: isNumber(obj.x) ? obj.x : 0,\n      y: isNumber(obj.y) ? obj.y : 0\n    };\n  }\n\n  function isNumber(v) {\n    return typeof v === 'number';\n  }\n\n  function scrollToPosition(shouldScroll, position) {\n    var isObject = typeof shouldScroll === 'object';\n\n    if (isObject && typeof shouldScroll.selector === 'string') {\n      var el = document.querySelector(shouldScroll.selector);\n\n      if (el) {\n        var offset = shouldScroll.offset && typeof shouldScroll.offset === 'object' ? shouldScroll.offset : {};\n        offset = normalizeOffset(offset);\n        position = getElementPosition(el, offset);\n      } else if (isValidPosition(shouldScroll)) {\n        position = normalizePosition(shouldScroll);\n      }\n    } else if (isObject && isValidPosition(shouldScroll)) {\n      position = normalizePosition(shouldScroll);\n    }\n\n    if (position) {\n      window.scrollTo(position.x, position.y);\n    }\n  }\n  /*  */\n\n\n  var supportsPushState = inBrowser && function () {\n    var ua = window.navigator.userAgent;\n\n    if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {\n      return false;\n    }\n\n    return window.history && 'pushState' in window.history;\n  }(); // use User Timing api (if present) for more accurate key precision\n\n\n  var Time = inBrowser && window.performance && window.performance.now ? window.performance : Date;\n\n  var _key = genKey();\n\n  function genKey() {\n    return Time.now().toFixed(3);\n  }\n\n  function getStateKey() {\n    return _key;\n  }\n\n  function setStateKey(key) {\n    _key = key;\n  }\n\n  function pushState(url, replace) {\n    saveScrollPosition(); // try...catch the pushState call to get around Safari\n    // DOM Exception 18 where it limits to 100 pushState calls\n\n    var history = window.history;\n\n    try {\n      if (replace) {\n        history.replaceState({\n          key: _key\n        }, '', url);\n      } else {\n        _key = genKey();\n        history.pushState({\n          key: _key\n        }, '', url);\n      }\n    } catch (e) {\n      window.location[replace ? 'replace' : 'assign'](url);\n    }\n  }\n\n  function replaceState(url) {\n    pushState(url, true);\n  }\n  /*  */\n\n\n  function runQueue(queue, fn, cb) {\n    var step = function (index) {\n      if (index >= queue.length) {\n        cb();\n      } else {\n        if (queue[index]) {\n          fn(queue[index], function () {\n            step(index + 1);\n          });\n        } else {\n          step(index + 1);\n        }\n      }\n    };\n\n    step(0);\n  }\n  /*  */\n\n\n  function resolveAsyncComponents(matched) {\n    return function (to, from, next) {\n      var hasAsync = false;\n      var pending = 0;\n      var error = null;\n      flatMapComponents(matched, function (def, _, match, key) {\n        // if it's a function and doesn't have cid attached,\n        // assume it's an async component resolve function.\n        // we are not using Vue's default async resolving mechanism because\n        // we want to halt the navigation until the incoming component has been\n        // resolved.\n        if (typeof def === 'function' && def.cid === undefined) {\n          hasAsync = true;\n          pending++;\n          var resolve = once(function (resolvedDef) {\n            if (isESModule(resolvedDef)) {\n              resolvedDef = resolvedDef.default;\n            } // save resolved on async factory in case it's used elsewhere\n\n\n            def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef);\n            match.components[key] = resolvedDef;\n            pending--;\n\n            if (pending <= 0) {\n              next();\n            }\n          });\n          var reject = once(function (reason) {\n            var msg = \"Failed to resolve async component \" + key + \": \" + reason;\n            \"development\" !== 'production' && warn(false, msg);\n\n            if (!error) {\n              error = isError(reason) ? reason : new Error(msg);\n              next(error);\n            }\n          });\n          var res;\n\n          try {\n            res = def(resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n\n          if (res) {\n            if (typeof res.then === 'function') {\n              res.then(resolve, reject);\n            } else {\n              // new syntax in Vue 2.3\n              var comp = res.component;\n\n              if (comp && typeof comp.then === 'function') {\n                comp.then(resolve, reject);\n              }\n            }\n          }\n        }\n      });\n\n      if (!hasAsync) {\n        next();\n      }\n    };\n  }\n\n  function flatMapComponents(matched, fn) {\n    return flatten(matched.map(function (m) {\n      return Object.keys(m.components).map(function (key) {\n        return fn(m.components[key], m.instances[key], m, key);\n      });\n    }));\n  }\n\n  function flatten(arr) {\n    return Array.prototype.concat.apply([], arr);\n  }\n\n  var hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\n  function isESModule(obj) {\n    return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';\n  } // in Webpack 2, require.ensure now also returns a Promise\n  // so the resolve/reject functions may get called an extra time\n  // if the user uses an arrow function shorthand that happens to\n  // return that Promise.\n\n\n  function once(fn) {\n    var called = false;\n    return function () {\n      var args = [],\n          len = arguments.length;\n\n      while (len--) args[len] = arguments[len];\n\n      if (called) {\n        return;\n      }\n\n      called = true;\n      return fn.apply(this, args);\n    };\n  }\n  /*  */\n\n\n  var History = function History(router, base) {\n    this.router = router;\n    this.base = normalizeBase(base); // start with a route object that stands for \"nowhere\"\n\n    this.current = START;\n    this.pending = null;\n    this.ready = false;\n    this.readyCbs = [];\n    this.readyErrorCbs = [];\n    this.errorCbs = [];\n  };\n\n  History.prototype.listen = function listen(cb) {\n    this.cb = cb;\n  };\n\n  History.prototype.onReady = function onReady(cb, errorCb) {\n    if (this.ready) {\n      cb();\n    } else {\n      this.readyCbs.push(cb);\n\n      if (errorCb) {\n        this.readyErrorCbs.push(errorCb);\n      }\n    }\n  };\n\n  History.prototype.onError = function onError(errorCb) {\n    this.errorCbs.push(errorCb);\n  };\n\n  History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {\n    var this$1 = this;\n    var route = this.router.match(location, this.current);\n    this.confirmTransition(route, function () {\n      this$1.updateRoute(route);\n      onComplete && onComplete(route);\n      this$1.ensureURL(); // fire ready cbs once\n\n      if (!this$1.ready) {\n        this$1.ready = true;\n        this$1.readyCbs.forEach(function (cb) {\n          cb(route);\n        });\n      }\n    }, function (err) {\n      if (onAbort) {\n        onAbort(err);\n      }\n\n      if (err && !this$1.ready) {\n        this$1.ready = true;\n        this$1.readyErrorCbs.forEach(function (cb) {\n          cb(err);\n        });\n      }\n    });\n  };\n\n  History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {\n    var this$1 = this;\n    var current = this.current;\n\n    var abort = function (err) {\n      if (isError(err)) {\n        if (this$1.errorCbs.length) {\n          this$1.errorCbs.forEach(function (cb) {\n            cb(err);\n          });\n        } else {\n          warn(false, 'uncaught error during route navigation:');\n          console.error(err);\n        }\n      }\n\n      onAbort && onAbort(err);\n    };\n\n    if (isSameRoute(route, current) && // in the case the route map has been dynamically appended to\n    route.matched.length === current.matched.length) {\n      this.ensureURL();\n      return abort();\n    }\n\n    var ref = resolveQueue(this.current.matched, route.matched);\n    var updated = ref.updated;\n    var deactivated = ref.deactivated;\n    var activated = ref.activated;\n    var queue = [].concat( // in-component leave guards\n    extractLeaveGuards(deactivated), // global before hooks\n    this.router.beforeHooks, // in-component update hooks\n    extractUpdateHooks(updated), // in-config enter guards\n    activated.map(function (m) {\n      return m.beforeEnter;\n    }), // async components\n    resolveAsyncComponents(activated));\n    this.pending = route;\n\n    var iterator = function (hook, next) {\n      if (this$1.pending !== route) {\n        return abort();\n      }\n\n      try {\n        hook(route, current, function (to) {\n          if (to === false || isError(to)) {\n            // next(false) -> abort navigation, ensure current URL\n            this$1.ensureURL(true);\n            abort(to);\n          } else if (typeof to === 'string' || typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) {\n            // next('/') or next({ path: '/' }) -> redirect\n            abort();\n\n            if (typeof to === 'object' && to.replace) {\n              this$1.replace(to);\n            } else {\n              this$1.push(to);\n            }\n          } else {\n            // confirm transition and pass on the value\n            next(to);\n          }\n        });\n      } catch (e) {\n        abort(e);\n      }\n    };\n\n    runQueue(queue, iterator, function () {\n      var postEnterCbs = [];\n\n      var isValid = function () {\n        return this$1.current === route;\n      }; // wait until async components are resolved before\n      // extracting in-component enter guards\n\n\n      var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);\n      var queue = enterGuards.concat(this$1.router.resolveHooks);\n      runQueue(queue, iterator, function () {\n        if (this$1.pending !== route) {\n          return abort();\n        }\n\n        this$1.pending = null;\n        onComplete(route);\n\n        if (this$1.router.app) {\n          this$1.router.app.$nextTick(function () {\n            postEnterCbs.forEach(function (cb) {\n              cb();\n            });\n          });\n        }\n      });\n    });\n  };\n\n  History.prototype.updateRoute = function updateRoute(route) {\n    var prev = this.current;\n    this.current = route;\n    this.cb && this.cb(route);\n    this.router.afterHooks.forEach(function (hook) {\n      hook && hook(route, prev);\n    });\n  };\n\n  function normalizeBase(base) {\n    if (!base) {\n      if (inBrowser) {\n        // respect <base> tag\n        var baseEl = document.querySelector('base');\n        base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin\n\n        base = base.replace(/^https?:\\/\\/[^\\/]+/, '');\n      } else {\n        base = '/';\n      }\n    } // make sure there's the starting slash\n\n\n    if (base.charAt(0) !== '/') {\n      base = '/' + base;\n    } // remove trailing slash\n\n\n    return base.replace(/\\/$/, '');\n  }\n\n  function resolveQueue(current, next) {\n    var i;\n    var max = Math.max(current.length, next.length);\n\n    for (i = 0; i < max; i++) {\n      if (current[i] !== next[i]) {\n        break;\n      }\n    }\n\n    return {\n      updated: next.slice(0, i),\n      activated: next.slice(i),\n      deactivated: current.slice(i)\n    };\n  }\n\n  function extractGuards(records, name, bind, reverse) {\n    var guards = flatMapComponents(records, function (def, instance, match, key) {\n      var guard = extractGuard(def, name);\n\n      if (guard) {\n        return Array.isArray(guard) ? guard.map(function (guard) {\n          return bind(guard, instance, match, key);\n        }) : bind(guard, instance, match, key);\n      }\n    });\n    return flatten(reverse ? guards.reverse() : guards);\n  }\n\n  function extractGuard(def, key) {\n    if (typeof def !== 'function') {\n      // extend now so that global mixins are applied.\n      def = _Vue.extend(def);\n    }\n\n    return def.options[key];\n  }\n\n  function extractLeaveGuards(deactivated) {\n    return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true);\n  }\n\n  function extractUpdateHooks(updated) {\n    return extractGuards(updated, 'beforeRouteUpdate', bindGuard);\n  }\n\n  function bindGuard(guard, instance) {\n    if (instance) {\n      return function boundRouteGuard() {\n        return guard.apply(instance, arguments);\n      };\n    }\n  }\n\n  function extractEnterGuards(activated, cbs, isValid) {\n    return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {\n      return bindEnterGuard(guard, match, key, cbs, isValid);\n    });\n  }\n\n  function bindEnterGuard(guard, match, key, cbs, isValid) {\n    return function routeEnterGuard(to, from, next) {\n      return guard(to, from, function (cb) {\n        next(cb);\n\n        if (typeof cb === 'function') {\n          cbs.push(function () {\n            // #750\n            // if a router-view is wrapped with an out-in transition,\n            // the instance may not have been registered at this time.\n            // we will need to poll for registration until current route\n            // is no longer valid.\n            poll(cb, match.instances, key, isValid);\n          });\n        }\n      });\n    };\n  }\n\n  function poll(cb, // somehow flow cannot infer this is a function\n  instances, key, isValid) {\n    if (instances[key]) {\n      cb(instances[key]);\n    } else if (isValid()) {\n      setTimeout(function () {\n        poll(cb, instances, key, isValid);\n      }, 16);\n    }\n  }\n  /*  */\n\n\n  var HTML5History = function (History$$1) {\n    function HTML5History(router, base) {\n      var this$1 = this;\n      History$$1.call(this, router, base);\n      var expectScroll = router.options.scrollBehavior;\n\n      if (expectScroll) {\n        setupScroll();\n      }\n\n      var initLocation = getLocation(this.base);\n      window.addEventListener('popstate', function (e) {\n        var current = this$1.current; // Avoiding first `popstate` event dispatched in some browsers but first\n        // history route not updated since async guard at the same time.\n\n        var location = getLocation(this$1.base);\n\n        if (this$1.current === START && location === initLocation) {\n          return;\n        }\n\n        this$1.transitionTo(location, function (route) {\n          if (expectScroll) {\n            handleScroll(router, route, current, true);\n          }\n        });\n      });\n    }\n\n    if (History$$1) HTML5History.__proto__ = History$$1;\n    HTML5History.prototype = Object.create(History$$1 && History$$1.prototype);\n    HTML5History.prototype.constructor = HTML5History;\n\n    HTML5History.prototype.go = function go(n) {\n      window.history.go(n);\n    };\n\n    HTML5History.prototype.push = function push(location, onComplete, onAbort) {\n      var this$1 = this;\n      var ref = this;\n      var fromRoute = ref.current;\n      this.transitionTo(location, function (route) {\n        pushState(cleanPath(this$1.base + route.fullPath));\n        handleScroll(this$1.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      }, onAbort);\n    };\n\n    HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {\n      var this$1 = this;\n      var ref = this;\n      var fromRoute = ref.current;\n      this.transitionTo(location, function (route) {\n        replaceState(cleanPath(this$1.base + route.fullPath));\n        handleScroll(this$1.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      }, onAbort);\n    };\n\n    HTML5History.prototype.ensureURL = function ensureURL(push) {\n      if (getLocation(this.base) !== this.current.fullPath) {\n        var current = cleanPath(this.base + this.current.fullPath);\n        push ? pushState(current) : replaceState(current);\n      }\n    };\n\n    HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {\n      return getLocation(this.base);\n    };\n\n    return HTML5History;\n  }(History);\n\n  function getLocation(base) {\n    var path = window.location.pathname;\n\n    if (base && path.indexOf(base) === 0) {\n      path = path.slice(base.length);\n    }\n\n    return (path || '/') + window.location.search + window.location.hash;\n  }\n  /*  */\n\n\n  var HashHistory = function (History$$1) {\n    function HashHistory(router, base, fallback) {\n      History$$1.call(this, router, base); // check history fallback deeplinking\n\n      if (fallback && checkFallback(this.base)) {\n        return;\n      }\n\n      ensureSlash();\n    }\n\n    if (History$$1) HashHistory.__proto__ = History$$1;\n    HashHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n    HashHistory.prototype.constructor = HashHistory; // this is delayed until the app mounts\n    // to avoid the hashchange listener being fired too early\n\n    HashHistory.prototype.setupListeners = function setupListeners() {\n      var this$1 = this;\n      var router = this.router;\n      var expectScroll = router.options.scrollBehavior;\n      var supportsScroll = supportsPushState && expectScroll;\n\n      if (supportsScroll) {\n        setupScroll();\n      }\n\n      window.addEventListener(supportsPushState ? 'popstate' : 'hashchange', function () {\n        var current = this$1.current;\n\n        if (!ensureSlash()) {\n          return;\n        }\n\n        this$1.transitionTo(getHash(), function (route) {\n          if (supportsScroll) {\n            handleScroll(this$1.router, route, current, true);\n          }\n\n          if (!supportsPushState) {\n            replaceHash(route.fullPath);\n          }\n        });\n      });\n    };\n\n    HashHistory.prototype.push = function push(location, onComplete, onAbort) {\n      var this$1 = this;\n      var ref = this;\n      var fromRoute = ref.current;\n      this.transitionTo(location, function (route) {\n        pushHash(route.fullPath);\n        handleScroll(this$1.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      }, onAbort);\n    };\n\n    HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n      var this$1 = this;\n      var ref = this;\n      var fromRoute = ref.current;\n      this.transitionTo(location, function (route) {\n        replaceHash(route.fullPath);\n        handleScroll(this$1.router, route, fromRoute, false);\n        onComplete && onComplete(route);\n      }, onAbort);\n    };\n\n    HashHistory.prototype.go = function go(n) {\n      window.history.go(n);\n    };\n\n    HashHistory.prototype.ensureURL = function ensureURL(push) {\n      var current = this.current.fullPath;\n\n      if (getHash() !== current) {\n        push ? pushHash(current) : replaceHash(current);\n      }\n    };\n\n    HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n      return getHash();\n    };\n\n    return HashHistory;\n  }(History);\n\n  function checkFallback(base) {\n    var location = getLocation(base);\n\n    if (!/^\\/#/.test(location)) {\n      window.location.replace(cleanPath(base + '/#' + location));\n      return true;\n    }\n  }\n\n  function ensureSlash() {\n    var path = getHash();\n\n    if (path.charAt(0) === '/') {\n      return true;\n    }\n\n    replaceHash('/' + path);\n    return false;\n  }\n\n  function getHash() {\n    // We can't use window.location.hash here because it's not\n    // consistent across browsers - Firefox will pre-decode it!\n    var href = window.location.href;\n    var index = href.indexOf('#');\n    return index === -1 ? '' : href.slice(index + 1);\n  }\n\n  function getUrl(path) {\n    var href = window.location.href;\n    var i = href.indexOf('#');\n    var base = i >= 0 ? href.slice(0, i) : href;\n    return base + \"#\" + path;\n  }\n\n  function pushHash(path) {\n    if (supportsPushState) {\n      pushState(getUrl(path));\n    } else {\n      window.location.hash = path;\n    }\n  }\n\n  function replaceHash(path) {\n    if (supportsPushState) {\n      replaceState(getUrl(path));\n    } else {\n      window.location.replace(getUrl(path));\n    }\n  }\n  /*  */\n\n\n  var AbstractHistory = function (History$$1) {\n    function AbstractHistory(router, base) {\n      History$$1.call(this, router, base);\n      this.stack = [];\n      this.index = -1;\n    }\n\n    if (History$$1) AbstractHistory.__proto__ = History$$1;\n    AbstractHistory.prototype = Object.create(History$$1 && History$$1.prototype);\n    AbstractHistory.prototype.constructor = AbstractHistory;\n\n    AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {\n      var this$1 = this;\n      this.transitionTo(location, function (route) {\n        this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);\n        this$1.index++;\n        onComplete && onComplete(route);\n      }, onAbort);\n    };\n\n    AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {\n      var this$1 = this;\n      this.transitionTo(location, function (route) {\n        this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);\n        onComplete && onComplete(route);\n      }, onAbort);\n    };\n\n    AbstractHistory.prototype.go = function go(n) {\n      var this$1 = this;\n      var targetIndex = this.index + n;\n\n      if (targetIndex < 0 || targetIndex >= this.stack.length) {\n        return;\n      }\n\n      var route = this.stack[targetIndex];\n      this.confirmTransition(route, function () {\n        this$1.index = targetIndex;\n        this$1.updateRoute(route);\n      });\n    };\n\n    AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {\n      var current = this.stack[this.stack.length - 1];\n      return current ? current.fullPath : '/';\n    };\n\n    AbstractHistory.prototype.ensureURL = function ensureURL() {// noop\n    };\n\n    return AbstractHistory;\n  }(History);\n  /*  */\n\n\n  var VueRouter = function VueRouter(options) {\n    if (options === void 0) options = {};\n    this.app = null;\n    this.apps = [];\n    this.options = options;\n    this.beforeHooks = [];\n    this.resolveHooks = [];\n    this.afterHooks = [];\n    this.matcher = createMatcher(options.routes || [], this);\n    var mode = options.mode || 'hash';\n    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false;\n\n    if (this.fallback) {\n      mode = 'hash';\n    }\n\n    if (!inBrowser) {\n      mode = 'abstract';\n    }\n\n    this.mode = mode;\n\n    switch (mode) {\n      case 'history':\n        this.history = new HTML5History(this, options.base);\n        break;\n\n      case 'hash':\n        this.history = new HashHistory(this, options.base, this.fallback);\n        break;\n\n      case 'abstract':\n        this.history = new AbstractHistory(this, options.base);\n        break;\n\n      default:\n        {\n          assert(false, \"invalid mode: \" + mode);\n        }\n    }\n  };\n\n  var prototypeAccessors = {\n    currentRoute: {\n      configurable: true\n    }\n  };\n\n  VueRouter.prototype.match = function match(raw, current, redirectedFrom) {\n    return this.matcher.match(raw, current, redirectedFrom);\n  };\n\n  prototypeAccessors.currentRoute.get = function () {\n    return this.history && this.history.current;\n  };\n\n  VueRouter.prototype.init = function init(app\n  /* Vue component instance */\n  ) {\n    var this$1 = this;\n    \"development\" !== 'production' && assert(install.installed, \"not installed. Make sure to call `Vue.use(VueRouter)` \" + \"before creating root instance.\");\n    this.apps.push(app); // main app already initialized.\n\n    if (this.app) {\n      return;\n    }\n\n    this.app = app;\n    var history = this.history;\n\n    if (history instanceof HTML5History) {\n      history.transitionTo(history.getCurrentLocation());\n    } else if (history instanceof HashHistory) {\n      var setupHashListener = function () {\n        history.setupListeners();\n      };\n\n      history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);\n    }\n\n    history.listen(function (route) {\n      this$1.apps.forEach(function (app) {\n        app._route = route;\n      });\n    });\n  };\n\n  VueRouter.prototype.beforeEach = function beforeEach(fn) {\n    return registerHook(this.beforeHooks, fn);\n  };\n\n  VueRouter.prototype.beforeResolve = function beforeResolve(fn) {\n    return registerHook(this.resolveHooks, fn);\n  };\n\n  VueRouter.prototype.afterEach = function afterEach(fn) {\n    return registerHook(this.afterHooks, fn);\n  };\n\n  VueRouter.prototype.onReady = function onReady(cb, errorCb) {\n    this.history.onReady(cb, errorCb);\n  };\n\n  VueRouter.prototype.onError = function onError(errorCb) {\n    this.history.onError(errorCb);\n  };\n\n  VueRouter.prototype.push = function push(location, onComplete, onAbort) {\n    this.history.push(location, onComplete, onAbort);\n  };\n\n  VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {\n    this.history.replace(location, onComplete, onAbort);\n  };\n\n  VueRouter.prototype.go = function go(n) {\n    this.history.go(n);\n  };\n\n  VueRouter.prototype.back = function back() {\n    this.go(-1);\n  };\n\n  VueRouter.prototype.forward = function forward() {\n    this.go(1);\n  };\n\n  VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {\n    var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;\n\n    if (!route) {\n      return [];\n    }\n\n    return [].concat.apply([], route.matched.map(function (m) {\n      return Object.keys(m.components).map(function (key) {\n        return m.components[key];\n      });\n    }));\n  };\n\n  VueRouter.prototype.resolve = function resolve(to, current, append) {\n    var location = normalizeLocation(to, current || this.history.current, append, this);\n    var route = this.match(location, current);\n    var fullPath = route.redirectedFrom || route.fullPath;\n    var base = this.history.base;\n    var href = createHref(base, fullPath, this.mode);\n    return {\n      location: location,\n      route: route,\n      href: href,\n      // for backwards compat\n      normalizedTo: location,\n      resolved: route\n    };\n  };\n\n  VueRouter.prototype.addRoutes = function addRoutes(routes) {\n    this.matcher.addRoutes(routes);\n\n    if (this.history.current !== START) {\n      this.history.transitionTo(this.history.getCurrentLocation());\n    }\n  };\n\n  Object.defineProperties(VueRouter.prototype, prototypeAccessors);\n\n  function registerHook(list, fn) {\n    list.push(fn);\n    return function () {\n      var i = list.indexOf(fn);\n\n      if (i > -1) {\n        list.splice(i, 1);\n      }\n    };\n  }\n\n  function createHref(base, fullPath, mode) {\n    var path = mode === 'hash' ? '#' + fullPath : fullPath;\n    return base ? cleanPath(base + '/' + path) : path;\n  }\n\n  VueRouter.install = install;\n  VueRouter.version = '3.0.1';\n\n  if (inBrowser && window.Vue) {\n    window.Vue.use(VueRouter);\n  }\n\n  return VueRouter;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL3Z1ZS1yb3V0ZXIuanM/YWRjNCJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwibW9kdWxlIiwiZXhwb3J0cyIsImFzc2VydCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsIndhcm4iLCJjb25zb2xlIiwiaXNFcnJvciIsImVyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImluZGV4T2YiLCJWaWV3IiwibmFtZSIsImZ1bmN0aW9uYWwiLCJwcm9wcyIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwicmVuZGVyIiwiXyIsInJlZiIsImNoaWxkcmVuIiwicGFyZW50IiwiZGF0YSIsInJvdXRlclZpZXciLCJoIiwiJGNyZWF0ZUVsZW1lbnQiLCJyb3V0ZSIsIiRyb3V0ZSIsImNhY2hlIiwiX3JvdXRlclZpZXdDYWNoZSIsImRlcHRoIiwiaW5hY3RpdmUiLCJfcm91dGVyUm9vdCIsIiR2bm9kZSIsIl9pbmFjdGl2ZSIsIiRwYXJlbnQiLCJyb3V0ZXJWaWV3RGVwdGgiLCJtYXRjaGVkIiwiY29tcG9uZW50IiwiY29tcG9uZW50cyIsInJlZ2lzdGVyUm91dGVJbnN0YW5jZSIsInZtIiwidmFsIiwiY3VycmVudCIsImluc3RhbmNlcyIsImhvb2siLCJwcmVwYXRjaCIsInZub2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJwcm9wc1RvUGFzcyIsInJlc29sdmVQcm9wcyIsImV4dGVuZCIsImF0dHJzIiwia2V5IiwiY29uZmlnIiwicGFyYW1zIiwidW5kZWZpbmVkIiwicGF0aCIsInRvIiwiZnJvbSIsImVuY29kZVJlc2VydmVSRSIsImVuY29kZVJlc2VydmVSZXBsYWNlciIsImMiLCJjaGFyQ29kZUF0IiwiY29tbWFSRSIsImVuY29kZSIsInN0ciIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXNvbHZlUXVlcnkiLCJxdWVyeSIsImV4dHJhUXVlcnkiLCJfcGFyc2VRdWVyeSIsInBhcnNlIiwicGFyc2VRdWVyeSIsInBhcnNlZFF1ZXJ5IiwiZSIsInJlcyIsInRyaW0iLCJzcGxpdCIsImZvckVhY2giLCJwYXJhbSIsInBhcnRzIiwic2hpZnQiLCJsZW5ndGgiLCJqb2luIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsInN0cmluZ2lmeVF1ZXJ5Iiwib2JqIiwia2V5cyIsIm1hcCIsInJlc3VsdCIsInZhbDIiLCJmaWx0ZXIiLCJ4IiwidHJhaWxpbmdTbGFzaFJFIiwiY3JlYXRlUm91dGUiLCJyZWNvcmQiLCJsb2NhdGlvbiIsInJlZGlyZWN0ZWRGcm9tIiwicm91dGVyIiwic3RyaW5naWZ5UXVlcnkkJDEiLCJvcHRpb25zIiwiY2xvbmUiLCJtZXRhIiwiaGFzaCIsImZ1bGxQYXRoIiwiZ2V0RnVsbFBhdGgiLCJmb3JtYXRNYXRjaCIsImZyZWV6ZSIsInZhbHVlIiwiU1RBUlQiLCJ1bnNoaWZ0IiwiX3N0cmluZ2lmeVF1ZXJ5Iiwic3RyaW5naWZ5IiwiaXNTYW1lUm91dGUiLCJhIiwiYiIsImlzT2JqZWN0RXF1YWwiLCJhS2V5cyIsImJLZXlzIiwiZXZlcnkiLCJhVmFsIiwiYlZhbCIsImlzSW5jbHVkZWRSb3V0ZSIsInRhcmdldCIsInF1ZXJ5SW5jbHVkZXMiLCJ0b1R5cGVzIiwiZXZlbnRUeXBlcyIsIkxpbmsiLCJyZXF1aXJlZCIsInRhZyIsImV4YWN0IiwiQm9vbGVhbiIsImFwcGVuZCIsImFjdGl2ZUNsYXNzIiwiZXhhY3RBY3RpdmVDbGFzcyIsImV2ZW50IiwidGhpcyQxIiwiJHJvdXRlciIsInJlc29sdmUiLCJocmVmIiwiY2xhc3NlcyIsImdsb2JhbEFjdGl2ZUNsYXNzIiwibGlua0FjdGl2ZUNsYXNzIiwiZ2xvYmFsRXhhY3RBY3RpdmVDbGFzcyIsImxpbmtFeGFjdEFjdGl2ZUNsYXNzIiwiYWN0aXZlQ2xhc3NGYWxsYmFjayIsImV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayIsImNvbXBhcmVUYXJnZXQiLCJoYW5kbGVyIiwiZ3VhcmRFdmVudCIsIm9uIiwiY2xpY2siLCJjbGFzcyIsImZpbmRBbmNob3IiLCIkc2xvdHMiLCJpc1N0YXRpYyIsIl9WdWUiLCJ1dGlsIiwiYURhdGEiLCJhQXR0cnMiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiZGVmYXVsdFByZXZlbnRlZCIsImJ1dHRvbiIsImN1cnJlbnRUYXJnZXQiLCJnZXRBdHRyaWJ1dGUiLCJ0ZXN0IiwicHJldmVudERlZmF1bHQiLCJjaGlsZCIsImkiLCJpbnN0YWxsIiwiVnVlIiwiaW5zdGFsbGVkIiwiaXNEZWYiLCJ2IiwicmVnaXN0ZXJJbnN0YW5jZSIsImNhbGxWYWwiLCIkb3B0aW9ucyIsIl9wYXJlbnRWbm9kZSIsIm1peGluIiwiYmVmb3JlQ3JlYXRlIiwiX3JvdXRlciIsImluaXQiLCJkZWZpbmVSZWFjdGl2ZSIsImhpc3RvcnkiLCJkZXN0cm95ZWQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsIl9yb3V0ZSIsInN0cmF0cyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsImJlZm9yZVJvdXRlRW50ZXIiLCJiZWZvcmVSb3V0ZUxlYXZlIiwiYmVmb3JlUm91dGVVcGRhdGUiLCJjcmVhdGVkIiwiaW5Ccm93c2VyIiwid2luZG93IiwicmVzb2x2ZVBhdGgiLCJyZWxhdGl2ZSIsImJhc2UiLCJmaXJzdENoYXIiLCJjaGFyQXQiLCJzdGFjayIsInBvcCIsInNlZ21lbnRzIiwic2VnbWVudCIsInBhcnNlUGF0aCIsImhhc2hJbmRleCIsInNsaWNlIiwicXVlcnlJbmRleCIsImNsZWFuUGF0aCIsImlzYXJyYXkiLCJhcnIiLCJwYXRoVG9SZWdleHBfMSIsInBhdGhUb1JlZ2V4cCIsInBhcnNlXzEiLCJjb21waWxlXzEiLCJjb21waWxlIiwidG9rZW5zVG9GdW5jdGlvbl8xIiwidG9rZW5zVG9GdW5jdGlvbiIsInRva2Vuc1RvUmVnRXhwXzEiLCJ0b2tlbnNUb1JlZ0V4cCIsIlBBVEhfUkVHRVhQIiwiUmVnRXhwIiwidG9rZW5zIiwiaW5kZXgiLCJkZWZhdWx0RGVsaW1pdGVyIiwiZGVsaW1pdGVyIiwiZXhlYyIsIm0iLCJlc2NhcGVkIiwib2Zmc2V0IiwibmV4dCIsInByZWZpeCIsImNhcHR1cmUiLCJncm91cCIsIm1vZGlmaWVyIiwiYXN0ZXJpc2siLCJwYXJ0aWFsIiwicmVwZWF0Iiwib3B0aW9uYWwiLCJwYXR0ZXJuIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJzdWJzdHIiLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJ0b1VwcGVyQ2FzZSIsImVuY29kZUFzdGVyaXNrIiwibWF0Y2hlcyIsIm9wdHMiLCJwcmV0dHkiLCJ0b2tlbiIsIlR5cGVFcnJvciIsIkpTT04iLCJqIiwiYXR0YWNoS2V5cyIsInJlIiwiZmxhZ3MiLCJzZW5zaXRpdmUiLCJyZWdleHBUb1JlZ2V4cCIsImdyb3VwcyIsInNvdXJjZSIsIm1hdGNoIiwiYXJyYXlUb1JlZ2V4cCIsInJlZ2V4cCIsInN0cmluZ1RvUmVnZXhwIiwic3RyaWN0IiwiZW5kIiwiZW5kc1dpdGhEZWxpbWl0ZXIiLCJyZWdleHBDb21waWxlQ2FjaGUiLCJjcmVhdGUiLCJmaWxsUGFyYW1zIiwicm91dGVNc2ciLCJmaWxsZXIiLCJjcmVhdGVSb3V0ZU1hcCIsInJvdXRlcyIsIm9sZFBhdGhMaXN0Iiwib2xkUGF0aE1hcCIsIm9sZE5hbWVNYXAiLCJwYXRoTGlzdCIsInBhdGhNYXAiLCJuYW1lTWFwIiwiYWRkUm91dGVSZWNvcmQiLCJsIiwic3BsaWNlIiwibWF0Y2hBcyIsInBhdGhUb1JlZ2V4cE9wdGlvbnMiLCJub3JtYWxpemVkUGF0aCIsIm5vcm1hbGl6ZVBhdGgiLCJjYXNlU2Vuc2l0aXZlIiwicmVnZXgiLCJjb21waWxlUm91dGVSZWdleCIsInJlZGlyZWN0IiwiYmVmb3JlRW50ZXIiLCJzb21lIiwiY2hpbGRNYXRjaEFzIiwiYWxpYXMiLCJhbGlhc2VzIiwiYWxpYXNSb3V0ZSIsIm5vcm1hbGl6ZUxvY2F0aW9uIiwicmF3IiwiX25vcm1hbGl6ZWQiLCJhc3NpZ24iLCJyYXdQYXRoIiwicGFyc2VkUGF0aCIsImJhc2VQYXRoIiwiY3JlYXRlTWF0Y2hlciIsImFkZFJvdXRlcyIsImN1cnJlbnRSb3V0ZSIsIl9jcmVhdGVSb3V0ZSIsInBhcmFtTmFtZXMiLCJyZWNvcmQkMSIsIm1hdGNoUm91dGUiLCJvcmlnaW5hbFJlZGlyZWN0IiwiaGFzT3duUHJvcGVydHkiLCJ0YXJnZXRSZWNvcmQiLCJyZXNvbHZlUmVjb3JkUGF0aCIsInJlc29sdmVkUGF0aCIsImFsaWFzZWRQYXRoIiwiYWxpYXNlZE1hdGNoIiwiYWxpYXNlZFJlY29yZCIsImxlbiIsInBvc2l0aW9uU3RvcmUiLCJzZXR1cFNjcm9sbCIsInJlcGxhY2VTdGF0ZSIsImdldFN0YXRlS2V5IiwiYWRkRXZlbnRMaXN0ZW5lciIsInNhdmVTY3JvbGxQb3NpdGlvbiIsInN0YXRlIiwic2V0U3RhdGVLZXkiLCJoYW5kbGVTY3JvbGwiLCJpc1BvcCIsImFwcCIsImJlaGF2aW9yIiwic2Nyb2xsQmVoYXZpb3IiLCIkbmV4dFRpY2siLCJwb3NpdGlvbiIsImdldFNjcm9sbFBvc2l0aW9uIiwic2hvdWxkU2Nyb2xsIiwidGhlbiIsInNjcm9sbFRvUG9zaXRpb24iLCJjYXRjaCIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZ2V0RWxlbWVudFBvc2l0aW9uIiwiZWwiLCJkb2NFbCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZG9jUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImVsUmVjdCIsImxlZnQiLCJ0b3AiLCJpc1ZhbGlkUG9zaXRpb24iLCJpc051bWJlciIsIm5vcm1hbGl6ZVBvc2l0aW9uIiwibm9ybWFsaXplT2Zmc2V0IiwiaXNPYmplY3QiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJzY3JvbGxUbyIsInN1cHBvcnRzUHVzaFN0YXRlIiwidWEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJEYXRlIiwiX2tleSIsImdlbktleSIsInRvRml4ZWQiLCJwdXNoU3RhdGUiLCJ1cmwiLCJydW5RdWV1ZSIsInF1ZXVlIiwiZm4iLCJjYiIsInN0ZXAiLCJyZXNvbHZlQXN5bmNDb21wb25lbnRzIiwiaGFzQXN5bmMiLCJwZW5kaW5nIiwiZXJyb3IiLCJmbGF0TWFwQ29tcG9uZW50cyIsImRlZiIsImNpZCIsIm9uY2UiLCJyZXNvbHZlZERlZiIsImlzRVNNb2R1bGUiLCJyZXNvbHZlZCIsInJlamVjdCIsInJlYXNvbiIsIm1zZyIsImNvbXAiLCJmbGF0dGVuIiwiY29uY2F0IiwiYXBwbHkiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIl9fZXNNb2R1bGUiLCJjYWxsZWQiLCJhcmdzIiwiYXJndW1lbnRzIiwiSGlzdG9yeSIsIm5vcm1hbGl6ZUJhc2UiLCJyZWFkeSIsInJlYWR5Q2JzIiwicmVhZHlFcnJvckNicyIsImVycm9yQ2JzIiwibGlzdGVuIiwib25SZWFkeSIsImVycm9yQ2IiLCJvbkVycm9yIiwidHJhbnNpdGlvblRvIiwib25Db21wbGV0ZSIsIm9uQWJvcnQiLCJjb25maXJtVHJhbnNpdGlvbiIsInVwZGF0ZVJvdXRlIiwiZW5zdXJlVVJMIiwiYWJvcnQiLCJyZXNvbHZlUXVldWUiLCJ1cGRhdGVkIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJleHRyYWN0TGVhdmVHdWFyZHMiLCJiZWZvcmVIb29rcyIsImV4dHJhY3RVcGRhdGVIb29rcyIsIml0ZXJhdG9yIiwicG9zdEVudGVyQ2JzIiwiaXNWYWxpZCIsImVudGVyR3VhcmRzIiwiZXh0cmFjdEVudGVyR3VhcmRzIiwicmVzb2x2ZUhvb2tzIiwicHJldiIsImFmdGVySG9va3MiLCJiYXNlRWwiLCJtYXgiLCJNYXRoIiwiZXh0cmFjdEd1YXJkcyIsInJlY29yZHMiLCJiaW5kIiwicmV2ZXJzZSIsImd1YXJkcyIsImluc3RhbmNlIiwiZ3VhcmQiLCJleHRyYWN0R3VhcmQiLCJiaW5kR3VhcmQiLCJib3VuZFJvdXRlR3VhcmQiLCJjYnMiLCJiaW5kRW50ZXJHdWFyZCIsInJvdXRlRW50ZXJHdWFyZCIsInBvbGwiLCJzZXRUaW1lb3V0IiwiSFRNTDVIaXN0b3J5IiwiSGlzdG9yeSQkMSIsImV4cGVjdFNjcm9sbCIsImluaXRMb2NhdGlvbiIsImdldExvY2F0aW9uIiwiX19wcm90b19fIiwiY29uc3RydWN0b3IiLCJnbyIsIm4iLCJmcm9tUm91dGUiLCJnZXRDdXJyZW50TG9jYXRpb24iLCJwYXRobmFtZSIsInNlYXJjaCIsIkhhc2hIaXN0b3J5IiwiZmFsbGJhY2siLCJjaGVja0ZhbGxiYWNrIiwiZW5zdXJlU2xhc2giLCJzZXR1cExpc3RlbmVycyIsInN1cHBvcnRzU2Nyb2xsIiwiZ2V0SGFzaCIsInJlcGxhY2VIYXNoIiwicHVzaEhhc2giLCJnZXRVcmwiLCJBYnN0cmFjdEhpc3RvcnkiLCJ0YXJnZXRJbmRleCIsIlZ1ZVJvdXRlciIsImFwcHMiLCJtYXRjaGVyIiwibW9kZSIsInByb3RvdHlwZUFjY2Vzc29ycyIsImNvbmZpZ3VyYWJsZSIsInNldHVwSGFzaExpc3RlbmVyIiwiYmVmb3JlRWFjaCIsInJlZ2lzdGVySG9vayIsImJlZm9yZVJlc29sdmUiLCJhZnRlckVhY2giLCJiYWNrIiwiZm9yd2FyZCIsImdldE1hdGNoZWRDb21wb25lbnRzIiwiY3JlYXRlSHJlZiIsIm5vcm1hbGl6ZWRUbyIsImRlZmluZVByb3BlcnRpZXMiLCJsaXN0IiwidmVyc2lvbiIsInVzZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0FBS0MsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7QUFDM0IsVUFBK0RDLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQkYsT0FBTyxFQUF2RixHQUNBLFNBREE7QUFHQSxDQUpBLEVBSUMsSUFKRCxFQUlRLFlBQVk7QUFBRTtBQUV2Qjs7QUFFQSxXQUFTRyxNQUFULENBQWlCQyxTQUFqQixFQUE0QkMsT0FBNUIsRUFBcUM7QUFDbkMsUUFBSSxDQUFDRCxTQUFMLEVBQWdCO0FBQ2QsWUFBTSxJQUFJRSxL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R0FMRDs7QUFPQXRkLFFBQU0sQ0FBQ3FmLGdCQUFQLENBQXlCaEIsU0FBUyxDQUFDcGUsU0FBbkMsRUFBOEN3ZSxrQkFBOUM7O0FBRUEsV0FBU0ksWUFBVCxDQUF1QlMsSUFBdkIsRUFBNkJ4SCxFQUE3QixFQUFpQztBQUMvQndILFFBQUksQ0FBQ2phLElBQUwsQ0FBVXlTLEVBQVY7QUFDQSxXQUFPLFlBQVk7QUFDakIsVUFBSWxOLENBQUMsR0FBRzBVLElBQUksQ0FBQ2xmLE9BQUwsQ0FBYTBYLEVBQWIsQ0FBUjs7QUFDQSxVQUFJbE4sQ0FBQyxHQUFHLENBQUMsQ0FBVCxFQUFZO0FBQUUwVSxZQUFJLENBQUN0TixNQUFMLENBQVlwSCxDQUFaLEVBQWUsQ0FBZjtBQUFvQjtBQUNuQyxLQUhEO0FBSUQ7O0FBRUQsV0FBU3VVLFVBQVQsQ0FBcUJ6UyxJQUFyQixFQUEyQmpHLFFBQTNCLEVBQXFDK1gsSUFBckMsRUFBMkM7QUFDekMsUUFBSXBiLElBQUksR0FBR29iLElBQUksS0FBSyxNQUFULEdBQWtCLE1BQU0vWCxRQUF4QixHQUFtQ0EsUUFBOUM7QUFDQSxXQUFPaUcsSUFBSSxHQUFHVyxTQUFTLENBQUNYLElBQUksR0FBRyxHQUFQLEdBQWF0SixJQUFkLENBQVosR0FBa0NBLElBQTdDO0FBQ0Q7O0FBRURpYixXQUFTLENBQUN4VCxPQUFWLEdBQW9CQSxPQUFwQjtBQUNBd1QsV0FBUyxDQUFDa0IsT0FBVixHQUFvQixPQUFwQjs7QUFFQSxNQUFJalQsU0FBUyxJQUFJQyxNQUFNLENBQUN6QixHQUF4QixFQUE2QjtBQUMzQnlCLFVBQU0sQ0FBQ3pCLEdBQVAsQ0FBVzBVLEdBQVgsQ0FBZW5CLFNBQWY7QUFDRDs7QUFFRCxTQUFPQSxTQUFQO0FBRUMsQ0Fqa0ZBLENBQUQiLCJmaWxlIjoiLi9zcmMvdmVuZG9yL3Z1ZS1yb3V0ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgKiB2dWUtcm91dGVyIHYzLjAuMVxuICAqIChjKSAyMDE3IEV2YW4gWW91XG4gICogQGxpY2Vuc2UgTUlUXG4gICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG5cdChnbG9iYWwuVnVlUm91dGVyID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gYXNzZXJ0IChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKFwiW3Z1ZS1yb3V0ZXJdIFwiICsgbWVzc2FnZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybiAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29uZGl0aW9uKSB7XG4gICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2FybigoXCJbdnVlLXJvdXRlcl0gXCIgKyBtZXNzYWdlKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFcnJvciAoZXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKS5pbmRleE9mKCdFcnJvcicpID4gLTFcbn1cblxudmFyIFZpZXcgPSB7XG4gIG5hbWU6ICdyb3V0ZXItdmlldycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoXywgcmVmKSB7XG4gICAgdmFyIHByb3BzID0gcmVmLnByb3BzO1xuICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICB2YXIgcGFyZW50ID0gcmVmLnBhcmVudDtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuXG4gICAgZGF0YS5yb3V0ZXJWaWV3ID0gdHJ1ZTtcblxuICAgIC8vIGRpcmVjdGx5IHVzZSBwYXJlbnQgY29udGV4dCdzIGNyZWF0ZUVsZW1lbnQoKSBmdW5jdGlvblxuICAgIC8vIHNvIHRoYXQgY29tcG9uZW50cyByZW5kZXJlZCBieSByb3V0ZXItdmlldyBjYW4gcmVzb2x2ZSBuYW1lZCBzbG90c1xuICAgIHZhciBoID0gcGFyZW50LiRjcmVhdGVFbGVtZW50O1xuICAgIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgICB2YXIgcm91dGUgPSBwYXJlbnQuJHJvdXRlO1xuICAgIHZhciBjYWNoZSA9IHBhcmVudC5fcm91dGVyVmlld0NhY2hlIHx8IChwYXJlbnQuX3JvdXRlclZpZXdDYWNoZSA9IHt9KTtcblxuICAgIC8vIGRldGVybWluZSBjdXJyZW50IHZpZXcgZGVwdGgsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZSB0cmVlXG4gICAgLy8gaGFzIGJlZW4gdG9nZ2xlZCBpbmFjdGl2ZSBidXQga2VwdC1hbGl2ZS5cbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBpbmFjdGl2ZSA9IGZhbHNlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9yb3V0ZXJSb290ICE9PSBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuJHZub2RlICYmIHBhcmVudC4kdm5vZGUuZGF0YS5yb3V0ZXJWaWV3KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Ll9pbmFjdGl2ZSkge1xuICAgICAgICBpbmFjdGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICB9XG4gICAgZGF0YS5yb3V0ZXJWaWV3RGVwdGggPSBkZXB0aDtcblxuICAgIC8vIHJlbmRlciBwcmV2aW91cyB2aWV3IGlmIHRoZSB0cmVlIGlzIGluYWN0aXZlIGFuZCBrZXB0LWFsaXZlXG4gICAgaWYgKGluYWN0aXZlKSB7XG4gICAgICByZXR1cm4gaChjYWNoZVtuYW1lXSwgZGF0YSwgY2hpbGRyZW4pXG4gICAgfVxuXG4gICAgdmFyIG1hdGNoZWQgPSByb3V0ZS5tYXRjaGVkW2RlcHRoXTtcbiAgICAvLyByZW5kZXIgZW1wdHkgbm9kZSBpZiBubyBtYXRjaGVkIHJvdXRlXG4gICAgaWYgKCFtYXRjaGVkKSB7XG4gICAgICBjYWNoZVtuYW1lXSA9IG51bGw7XG4gICAgICByZXR1cm4gaCgpXG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudCA9IGNhY2hlW25hbWVdID0gbWF0Y2hlZC5jb21wb25lbnRzW25hbWVdO1xuXG4gICAgLy8gYXR0YWNoIGluc3RhbmNlIHJlZ2lzdHJhdGlvbiBob29rXG4gICAgLy8gdGhpcyB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgaW5zdGFuY2UncyBpbmplY3RlZCBsaWZlY3ljbGUgaG9va3NcbiAgICBkYXRhLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSA9IGZ1bmN0aW9uICh2bSwgdmFsKSB7XG4gICAgICAvLyB2YWwgY291bGQgYmUgdW5kZWZpbmVkIGZvciB1bnJlZ2lzdHJhdGlvblxuICAgICAgdmFyIGN1cnJlbnQgPSBtYXRjaGVkLmluc3RhbmNlc1tuYW1lXTtcbiAgICAgIGlmIChcbiAgICAgICAgKHZhbCAmJiBjdXJyZW50ICE9PSB2bSkgfHxcbiAgICAgICAgKCF2YWwgJiYgY3VycmVudCA9PT0gdm0pXG4gICAgICApIHtcbiAgICAgICAgbWF0Y2hlZC5pbnN0YW5jZXNbbmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWxzbyByZWdpc3RlciBpbnN0YW5jZSBpbiBwcmVwYXRjaCBob29rXG4gICAgLy8gaW4gY2FzZSB0aGUgc2FtZSBjb21wb25lbnQgaW5zdGFuY2UgaXMgcmV1c2VkIGFjcm9zcyBkaWZmZXJlbnQgcm91dGVzXG4gICAgOyhkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KSkucHJlcGF0Y2ggPSBmdW5jdGlvbiAoXywgdm5vZGUpIHtcbiAgICAgIG1hdGNoZWQuaW5zdGFuY2VzW25hbWVdID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgfTtcblxuICAgIC8vIHJlc29sdmUgcHJvcHNcbiAgICB2YXIgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gcmVzb2x2ZVByb3BzKHJvdXRlLCBtYXRjaGVkLnByb3BzICYmIG1hdGNoZWQucHJvcHNbbmFtZV0pO1xuICAgIGlmIChwcm9wc1RvUGFzcykge1xuICAgICAgLy8gY2xvbmUgdG8gcHJldmVudCBtdXRhdGlvblxuICAgICAgcHJvcHNUb1Bhc3MgPSBkYXRhLnByb3BzID0gZXh0ZW5kKHt9LCBwcm9wc1RvUGFzcyk7XG4gICAgICAvLyBwYXNzIG5vbi1kZWNsYXJlZCBwcm9wcyBhcyBhdHRyc1xuICAgICAgdmFyIGF0dHJzID0gZGF0YS5hdHRycyA9IGRhdGEuYXR0cnMgfHwge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNUb1Bhc3MpIHtcbiAgICAgICAgaWYgKCFjb21wb25lbnQucHJvcHMgfHwgIShrZXkgaW4gY29tcG9uZW50LnByb3BzKSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSBwcm9wc1RvUGFzc1trZXldO1xuICAgICAgICAgIGRlbGV0ZSBwcm9wc1RvUGFzc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgoY29tcG9uZW50LCBkYXRhLCBjaGlsZHJlbilcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVzb2x2ZVByb3BzIChyb3V0ZSwgY29uZmlnKSB7XG4gIHN3aXRjaCAodHlwZW9mIGNvbmZpZykge1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICByZXR1cm5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIGNvbmZpZ1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiBjb25maWcocm91dGUpXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gY29uZmlnID8gcm91dGUucGFyYW1zIDogdW5kZWZpbmVkXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICBcInByb3BzIGluIFxcXCJcIiArIChyb3V0ZS5wYXRoKSArIFwiXFxcIiBpcyBhIFwiICsgKHR5cGVvZiBjb25maWcpICsgXCIsIFwiICtcbiAgICAgICAgICBcImV4cGVjdGluZyBhbiBvYmplY3QsIGZ1bmN0aW9uIG9yIGJvb2xlYW4uXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBleHRlbmQgKHRvLCBmcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyogICovXG5cbnZhciBlbmNvZGVSZXNlcnZlUkUgPSAvWyEnKCkqXS9nO1xudmFyIGVuY29kZVJlc2VydmVSZXBsYWNlciA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpOyB9O1xudmFyIGNvbW1hUkUgPSAvJTJDL2c7XG5cbi8vIGZpeGVkIGVuY29kZVVSSUNvbXBvbmVudCB3aGljaCBpcyBtb3JlIGNvbmZvcm1hbnQgdG8gUkZDMzk4Njpcbi8vIC0gZXNjYXBlcyBbIScoKSpdXG4vLyAtIHByZXNlcnZlIGNvbW1hc1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIC5yZXBsYWNlKGVuY29kZVJlc2VydmVSRSwgZW5jb2RlUmVzZXJ2ZVJlcGxhY2VyKVxuICAucmVwbGFjZShjb21tYVJFLCAnLCcpOyB9O1xuXG52YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xuXG5mdW5jdGlvbiByZXNvbHZlUXVlcnkgKFxuICBxdWVyeSxcbiAgZXh0cmFRdWVyeSxcbiAgX3BhcnNlUXVlcnlcbikge1xuICBpZiAoIGV4dHJhUXVlcnkgPT09IHZvaWQgMCApIGV4dHJhUXVlcnkgPSB7fTtcblxuICB2YXIgcGFyc2UgPSBfcGFyc2VRdWVyeSB8fCBwYXJzZVF1ZXJ5O1xuICB2YXIgcGFyc2VkUXVlcnk7XG4gIHRyeSB7XG4gICAgcGFyc2VkUXVlcnkgPSBwYXJzZShxdWVyeSB8fCAnJyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBlLm1lc3NhZ2UpO1xuICAgIHBhcnNlZFF1ZXJ5ID0ge307XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIGV4dHJhUXVlcnkpIHtcbiAgICBwYXJzZWRRdWVyeVtrZXldID0gZXh0cmFRdWVyeVtrZXldO1xuICB9XG4gIHJldHVybiBwYXJzZWRRdWVyeVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5IChxdWVyeSkge1xuICB2YXIgcmVzID0ge307XG5cbiAgcXVlcnkgPSBxdWVyeS50cmltKCkucmVwbGFjZSgvXihcXD98I3wmKS8sICcnKTtcblxuICBpZiAoIXF1ZXJ5KSB7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgcXVlcnkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0cy5zaGlmdCgpKTtcbiAgICB2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMFxuICAgICAgPyBkZWNvZGUocGFydHMuam9pbignPScpKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKHJlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXNba2V5XSkpIHtcbiAgICAgIHJlc1trZXldLnB1c2godmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2tleV0gPSBbcmVzW2tleV0sIHZhbF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVF1ZXJ5IChvYmopIHtcbiAgdmFyIHJlcyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG5cbiAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoa2V5KVxuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhbC5mb3JFYWNoKGZ1bmN0aW9uICh2YWwyKSB7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsMiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGVuY29kZShrZXkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2YWwyKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKVxuICB9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgubGVuZ3RoID4gMDsgfSkuam9pbignJicpIDogbnVsbDtcbiAgcmV0dXJuIHJlcyA/IChcIj9cIiArIHJlcykgOiAnJ1xufVxuXG4vKiAgKi9cblxuXG52YXIgdHJhaWxpbmdTbGFzaFJFID0gL1xcLz8kLztcblxuZnVuY3Rpb24gY3JlYXRlUm91dGUgKFxuICByZWNvcmQsXG4gIGxvY2F0aW9uLFxuICByZWRpcmVjdGVkRnJvbSxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHN0cmluZ2lmeVF1ZXJ5JCQxID0gcm91dGVyICYmIHJvdXRlci5vcHRpb25zLnN0cmluZ2lmeVF1ZXJ5O1xuXG4gIHZhciBxdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5IHx8IHt9O1xuICB0cnkge1xuICAgIHF1ZXJ5ID0gY2xvbmUocXVlcnkpO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByb3V0ZSA9IHtcbiAgICBuYW1lOiBsb2NhdGlvbi5uYW1lIHx8IChyZWNvcmQgJiYgcmVjb3JkLm5hbWUpLFxuICAgIG1ldGE6IChyZWNvcmQgJiYgcmVjb3JkLm1ldGEpIHx8IHt9LFxuICAgIHBhdGg6IGxvY2F0aW9uLnBhdGggfHwgJy8nLFxuICAgIGhhc2g6IGxvY2F0aW9uLmhhc2ggfHwgJycsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIHBhcmFtczogbG9jYXRpb24ucGFyYW1zIHx8IHt9LFxuICAgIGZ1bGxQYXRoOiBnZXRGdWxsUGF0aChsb2NhdGlvbiwgc3RyaW5naWZ5UXVlcnkkJDEpLFxuICAgIG1hdGNoZWQ6IHJlY29yZCA/IGZvcm1hdE1hdGNoKHJlY29yZCkgOiBbXVxuICB9O1xuICBpZiAocmVkaXJlY3RlZEZyb20pIHtcbiAgICByb3V0ZS5yZWRpcmVjdGVkRnJvbSA9IGdldEZ1bGxQYXRoKHJlZGlyZWN0ZWRGcm9tLCBzdHJpbmdpZnlRdWVyeSQkMSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5mcmVlemUocm91dGUpXG59XG5cbmZ1bmN0aW9uIGNsb25lICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKGNsb25lKVxuICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICByZXNba2V5XSA9IGNsb25lKHZhbHVlW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cblxuLy8gdGhlIHN0YXJ0aW5nIHJvdXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5pdGlhbCBzdGF0ZVxudmFyIFNUQVJUID0gY3JlYXRlUm91dGUobnVsbCwge1xuICBwYXRoOiAnLydcbn0pO1xuXG5mdW5jdGlvbiBmb3JtYXRNYXRjaCAocmVjb3JkKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgd2hpbGUgKHJlY29yZCkge1xuICAgIHJlcy51bnNoaWZ0KHJlY29yZCk7XG4gICAgcmVjb3JkID0gcmVjb3JkLnBhcmVudDtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldEZ1bGxQYXRoIChcbiAgcmVmLFxuICBfc3RyaW5naWZ5UXVlcnlcbikge1xuICB2YXIgcGF0aCA9IHJlZi5wYXRoO1xuICB2YXIgcXVlcnkgPSByZWYucXVlcnk7IGlmICggcXVlcnkgPT09IHZvaWQgMCApIHF1ZXJ5ID0ge307XG4gIHZhciBoYXNoID0gcmVmLmhhc2g7IGlmICggaGFzaCA9PT0gdm9pZCAwICkgaGFzaCA9ICcnO1xuXG4gIHZhciBzdHJpbmdpZnkgPSBfc3RyaW5naWZ5UXVlcnkgfHwgc3RyaW5naWZ5UXVlcnk7XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgc3RyaW5naWZ5KHF1ZXJ5KSArIGhhc2hcbn1cblxuZnVuY3Rpb24gaXNTYW1lUm91dGUgKGEsIGIpIHtcbiAgaWYgKGIgPT09IFNUQVJUKSB7XG4gICAgcmV0dXJuIGEgPT09IGJcbiAgfSBlbHNlIGlmICghYikge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGEucGF0aCAmJiBiLnBhdGgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnJykgPT09IGIucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJycpICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KVxuICAgIClcbiAgfSBlbHNlIGlmIChhLm5hbWUgJiYgYi5uYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGEubmFtZSA9PT0gYi5uYW1lICYmXG4gICAgICBhLmhhc2ggPT09IGIuaGFzaCAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnF1ZXJ5LCBiLnF1ZXJ5KSAmJlxuICAgICAgaXNPYmplY3RFcXVhbChhLnBhcmFtcywgYi5wYXJhbXMpXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0RXF1YWwgKGEsIGIpIHtcbiAgaWYgKCBhID09PSB2b2lkIDAgKSBhID0ge307XG4gIGlmICggYiA9PT0gdm9pZCAwICkgYiA9IHt9O1xuXG4gIC8vIGhhbmRsZSBudWxsIHZhbHVlICMxNTY2XG4gIGlmICghYSB8fCAhYikgeyByZXR1cm4gYSA9PT0gYiB9XG4gIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIGFLZXlzLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgYVZhbCA9IGFba2V5XTtcbiAgICB2YXIgYlZhbCA9IGJba2V5XTtcbiAgICAvLyBjaGVjayBuZXN0ZWQgZXF1YWxpdHlcbiAgICBpZiAodHlwZW9mIGFWYWwgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiVmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0RXF1YWwoYVZhbCwgYlZhbClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyhhVmFsKSA9PT0gU3RyaW5nKGJWYWwpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGlzSW5jbHVkZWRSb3V0ZSAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIHJldHVybiAoXG4gICAgY3VycmVudC5wYXRoLnJlcGxhY2UodHJhaWxpbmdTbGFzaFJFLCAnLycpLmluZGV4T2YoXG4gICAgICB0YXJnZXQucGF0aC5yZXBsYWNlKHRyYWlsaW5nU2xhc2hSRSwgJy8nKVxuICAgICkgPT09IDAgJiZcbiAgICAoIXRhcmdldC5oYXNoIHx8IGN1cnJlbnQuaGFzaCA9PT0gdGFyZ2V0Lmhhc2gpICYmXG4gICAgcXVlcnlJbmNsdWRlcyhjdXJyZW50LnF1ZXJ5LCB0YXJnZXQucXVlcnkpXG4gIClcbn1cblxuZnVuY3Rpb24gcXVlcnlJbmNsdWRlcyAoY3VycmVudCwgdGFyZ2V0KSB7XG4gIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIShrZXkgaW4gY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKiAgKi9cblxuLy8gd29yayBhcm91bmQgd2VpcmQgZmxvdyBidWdcbnZhciB0b1R5cGVzID0gW1N0cmluZywgT2JqZWN0XTtcbnZhciBldmVudFR5cGVzID0gW1N0cmluZywgQXJyYXldO1xuXG52YXIgTGluayA9IHtcbiAgbmFtZTogJ3JvdXRlci1saW5rJyxcbiAgcHJvcHM6IHtcbiAgICB0bzoge1xuICAgICAgdHlwZTogdG9UeXBlcyxcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSxcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdhJ1xuICAgIH0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXZlbnQ6IHtcbiAgICAgIHR5cGU6IGV2ZW50VHlwZXMsXG4gICAgICBkZWZhdWx0OiAnY2xpY2snXG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJvdXRlciA9IHRoaXMuJHJvdXRlcjtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuJHJvdXRlO1xuICAgIHZhciByZWYgPSByb3V0ZXIucmVzb2x2ZSh0aGlzLnRvLCBjdXJyZW50LCB0aGlzLmFwcGVuZCk7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVmLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZSA9IHJlZi5yb3V0ZTtcbiAgICB2YXIgaHJlZiA9IHJlZi5ocmVmO1xuXG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsQWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPSByb3V0ZXIub3B0aW9ucy5saW5rRXhhY3RBY3RpdmVDbGFzcztcbiAgICAvLyBTdXBwb3J0IGdsb2JhbCBlbXB0eSBhY3RpdmUgY2xhc3NcbiAgICB2YXIgYWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEFjdGl2ZUNsYXNzID09IG51bGxcbiAgICAgICAgICAgID8gJ3JvdXRlci1saW5rLWFjdGl2ZSdcbiAgICAgICAgICAgIDogZ2xvYmFsQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3NGYWxsYmFjayA9IGdsb2JhbEV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyAncm91dGVyLWxpbmstZXhhY3QtYWN0aXZlJ1xuICAgICAgICAgICAgOiBnbG9iYWxFeGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBhY3RpdmVDbGFzcyA9IHRoaXMuYWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyBhY3RpdmVDbGFzc0ZhbGxiYWNrXG4gICAgICAgICAgICA6IHRoaXMuYWN0aXZlQ2xhc3M7XG4gICAgdmFyIGV4YWN0QWN0aXZlQ2xhc3MgPSB0aGlzLmV4YWN0QWN0aXZlQ2xhc3MgPT0gbnVsbFxuICAgICAgICAgICAgPyBleGFjdEFjdGl2ZUNsYXNzRmFsbGJhY2tcbiAgICAgICAgICAgIDogdGhpcy5leGFjdEFjdGl2ZUNsYXNzO1xuICAgIHZhciBjb21wYXJlVGFyZ2V0ID0gbG9jYXRpb24ucGF0aFxuICAgICAgPyBjcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbiwgbnVsbCwgcm91dGVyKVxuICAgICAgOiByb3V0ZTtcblxuICAgIGNsYXNzZXNbZXhhY3RBY3RpdmVDbGFzc10gPSBpc1NhbWVSb3V0ZShjdXJyZW50LCBjb21wYXJlVGFyZ2V0KTtcbiAgICBjbGFzc2VzW2FjdGl2ZUNsYXNzXSA9IHRoaXMuZXhhY3RcbiAgICAgID8gY2xhc3Nlc1tleGFjdEFjdGl2ZUNsYXNzXVxuICAgICAgOiBpc0luY2x1ZGVkUm91dGUoY3VycmVudCwgY29tcGFyZVRhcmdldCk7XG5cbiAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZ3VhcmRFdmVudChlKSkge1xuICAgICAgICBpZiAodGhpcyQxLnJlcGxhY2UpIHtcbiAgICAgICAgICByb3V0ZXIucmVwbGFjZShsb2NhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm91dGVyLnB1c2gobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvbiA9IHsgY2xpY2s6IGd1YXJkRXZlbnQgfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmV2ZW50KSkge1xuICAgICAgdGhpcy5ldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7IG9uW2VdID0gaGFuZGxlcjsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9uW3RoaXMuZXZlbnRdID0gaGFuZGxlcjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNsYXNzOiBjbGFzc2VzXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnRhZyA9PT0gJ2EnKSB7XG4gICAgICBkYXRhLm9uID0gb247XG4gICAgICBkYXRhLmF0dHJzID0geyBocmVmOiBocmVmIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IDxhPiBjaGlsZCBhbmQgYXBwbHkgbGlzdGVuZXIgYW5kIGhyZWZcbiAgICAgIHZhciBhID0gZmluZEFuY2hvcih0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIC8vIGluIGNhc2UgdGhlIDxhPiBpcyBhIHN0YXRpYyBub2RlXG4gICAgICAgIGEuaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGV4dGVuZCA9IF9WdWUudXRpbC5leHRlbmQ7XG4gICAgICAgIHZhciBhRGF0YSA9IGEuZGF0YSA9IGV4dGVuZCh7fSwgYS5kYXRhKTtcbiAgICAgICAgYURhdGEub24gPSBvbjtcbiAgICAgICAgdmFyIGFBdHRycyA9IGEuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYS5kYXRhLmF0dHJzKTtcbiAgICAgICAgYUF0dHJzLmhyZWYgPSBocmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9lc24ndCBoYXZlIDxhPiBjaGlsZCwgYXBwbHkgbGlzdGVuZXIgdG8gc2VsZlxuICAgICAgICBkYXRhLm9uID0gb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGgodGhpcy50YWcsIGRhdGEsIHRoaXMuJHNsb3RzLmRlZmF1bHQpXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGd1YXJkRXZlbnQgKGUpIHtcbiAgLy8gZG9uJ3QgcmVkaXJlY3Qgd2l0aCBjb250cm9sIGtleXNcbiAgaWYgKGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkgeyByZXR1cm4gfVxuICAvLyBkb24ndCByZWRpcmVjdCB3aGVuIHByZXZlbnREZWZhdWx0IGNhbGxlZFxuICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IG9uIHJpZ2h0IGNsaWNrXG4gIGlmIChlLmJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9uICE9PSAwKSB7IHJldHVybiB9XG4gIC8vIGRvbid0IHJlZGlyZWN0IGlmIGB0YXJnZXQ9XCJfYmxhbmtcImBcbiAgaWYgKGUuY3VycmVudFRhcmdldCAmJiBlLmN1cnJlbnRUYXJnZXQuZ2V0QXR0cmlidXRlKSB7XG4gICAgdmFyIHRhcmdldCA9IGUuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICAgIGlmICgvXFxiX2JsYW5rXFxiL2kudGVzdCh0YXJnZXQpKSB7IHJldHVybiB9XG4gIH1cbiAgLy8gdGhpcyBtYXkgYmUgYSBXZWV4IGV2ZW50IHdoaWNoIGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZFxuICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBmaW5kQW5jaG9yIChjaGlsZHJlbikge1xuICBpZiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgY2hpbGQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICdhJykge1xuICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbiAmJiAoY2hpbGQgPSBmaW5kQW5jaG9yKGNoaWxkLmNoaWxkcmVuKSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBfVnVlO1xuXG5mdW5jdGlvbiBpbnN0YWxsIChWdWUpIHtcbiAgaWYgKGluc3RhbGwuaW5zdGFsbGVkICYmIF9WdWUgPT09IFZ1ZSkgeyByZXR1cm4gfVxuICBpbnN0YWxsLmluc3RhbGxlZCA9IHRydWU7XG5cbiAgX1Z1ZSA9IFZ1ZTtcblxuICB2YXIgaXNEZWYgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdiAhPT0gdW5kZWZpbmVkOyB9O1xuXG4gIHZhciByZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24gKHZtLCBjYWxsVmFsKSB7XG4gICAgdmFyIGkgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gICAgaWYgKGlzRGVmKGkpICYmIGlzRGVmKGkgPSBpLmRhdGEpICYmIGlzRGVmKGkgPSBpLnJlZ2lzdGVyUm91dGVJbnN0YW5jZSkpIHtcbiAgICAgIGkodm0sIGNhbGxWYWwpO1xuICAgIH1cbiAgfTtcblxuICBWdWUubWl4aW4oe1xuICAgIGJlZm9yZUNyZWF0ZTogZnVuY3Rpb24gYmVmb3JlQ3JlYXRlICgpIHtcbiAgICAgIGlmIChpc0RlZih0aGlzLiRvcHRpb25zLnJvdXRlcikpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHRoaXMuJG9wdGlvbnMucm91dGVyO1xuICAgICAgICB0aGlzLl9yb3V0ZXIuaW5pdCh0aGlzKTtcbiAgICAgICAgVnVlLnV0aWwuZGVmaW5lUmVhY3RpdmUodGhpcywgJ19yb3V0ZScsIHRoaXMuX3JvdXRlci5oaXN0b3J5LmN1cnJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcm91dGVyUm9vdCA9ICh0aGlzLiRwYXJlbnQgJiYgdGhpcy4kcGFyZW50Ll9yb3V0ZXJSb290KSB8fCB0aGlzO1xuICAgICAgfVxuICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCB0aGlzKTtcbiAgICB9LFxuICAgIGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcbiAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRyb3V0ZXInLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGVyIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckcm91dGUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkgeyByZXR1cm4gdGhpcy5fcm91dGVyUm9vdC5fcm91dGUgfVxuICB9KTtcblxuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItdmlldycsIFZpZXcpO1xuICBWdWUuY29tcG9uZW50KCdyb3V0ZXItbGluaycsIExpbmspO1xuXG4gIHZhciBzdHJhdHMgPSBWdWUuY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbiAgLy8gdXNlIHRoZSBzYW1lIGhvb2sgbWVyZ2luZyBzdHJhdGVneSBmb3Igcm91dGUgaG9va3NcbiAgc3RyYXRzLmJlZm9yZVJvdXRlRW50ZXIgPSBzdHJhdHMuYmVmb3JlUm91dGVMZWF2ZSA9IHN0cmF0cy5iZWZvcmVSb3V0ZVVwZGF0ZSA9IHN0cmF0cy5jcmVhdGVkO1xufVxuXG4vKiAgKi9cblxudmFyIGluQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gcmVzb2x2ZVBhdGggKFxuICByZWxhdGl2ZSxcbiAgYmFzZSxcbiAgYXBwZW5kXG4pIHtcbiAgdmFyIGZpcnN0Q2hhciA9IHJlbGF0aXZlLmNoYXJBdCgwKTtcbiAgaWYgKGZpcnN0Q2hhciA9PT0gJy8nKSB7XG4gICAgcmV0dXJuIHJlbGF0aXZlXG4gIH1cblxuICBpZiAoZmlyc3RDaGFyID09PSAnPycgfHwgZmlyc3RDaGFyID09PSAnIycpIHtcbiAgICByZXR1cm4gYmFzZSArIHJlbGF0aXZlXG4gIH1cblxuICB2YXIgc3RhY2sgPSBiYXNlLnNwbGl0KCcvJyk7XG5cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNlZ21lbnQgaWY6XG4gIC8vIC0gbm90IGFwcGVuZGluZ1xuICAvLyAtIGFwcGVuZGluZyB0byB0cmFpbGluZyBzbGFzaCAobGFzdCBzZWdtZW50IGlzIGVtcHR5KVxuICBpZiAoIWFwcGVuZCB8fCAhc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICBzdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIHJlc29sdmUgcmVsYXRpdmUgcGF0aFxuICB2YXIgc2VnbWVudHMgPSByZWxhdGl2ZS5yZXBsYWNlKC9eXFwvLywgJycpLnNwbGl0KCcvJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChzZWdtZW50ID09PSAnLi4nKSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKHNlZ21lbnQgIT09ICcuJykge1xuICAgICAgc3RhY2sucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBlbnN1cmUgbGVhZGluZyBzbGFzaFxuICBpZiAoc3RhY2tbMF0gIT09ICcnKSB7XG4gICAgc3RhY2sudW5zaGlmdCgnJyk7XG4gIH1cblxuICByZXR1cm4gc3RhY2suam9pbignLycpXG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICB2YXIgaGFzaCA9ICcnO1xuICB2YXIgcXVlcnkgPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgIGhhc2ggPSBwYXRoLnNsaWNlKGhhc2hJbmRleCk7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgfVxuXG4gIHZhciBxdWVyeUluZGV4ID0gcGF0aC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxdWVyeUluZGV4ID49IDApIHtcbiAgICBxdWVyeSA9IHBhdGguc2xpY2UocXVlcnlJbmRleCArIDEpO1xuICAgIHBhdGggPSBwYXRoLnNsaWNlKDAsIHF1ZXJ5SW5kZXgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBoYXNoOiBoYXNoXG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5QYXRoIChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UoL1xcL1xcLy9nLCAnLycpXG59XG5cbnZhciBpc2FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgYHBhdGhUb1JlZ2V4cGAuXG4gKi9cbnZhciBwYXRoVG9SZWdleHBfMSA9IHBhdGhUb1JlZ2V4cDtcbnZhciBwYXJzZV8xID0gcGFyc2U7XG52YXIgY29tcGlsZV8xID0gY29tcGlsZTtcbnZhciB0b2tlbnNUb0Z1bmN0aW9uXzEgPSB0b2tlbnNUb0Z1bmN0aW9uO1xudmFyIHRva2Vuc1RvUmVnRXhwXzEgPSB0b2tlbnNUb1JlZ0V4cDtcblxuLyoqXG4gKiBUaGUgbWFpbiBwYXRoIG1hdGNoaW5nIHJlZ2V4cCB1dGlsaXR5LlxuICpcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbnZhciBQQVRIX1JFR0VYUCA9IG5ldyBSZWdFeHAoW1xuICAvLyBNYXRjaCBlc2NhcGVkIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYXBwZWFyIGluIGZ1dHVyZSBtYXRjaGVzLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgd29uJ3QgdHJhbnNmb3JtLlxuICAnKFxcXFxcXFxcLiknLFxuICAvLyBNYXRjaCBFeHByZXNzLXN0eWxlIHBhcmFtZXRlcnMgYW5kIHVuLW5hbWVkIHBhcmFtZXRlcnMgd2l0aCBhIHByZWZpeFxuICAvLyBhbmQgb3B0aW9uYWwgc3VmZml4ZXMuIE1hdGNoZXMgYXBwZWFyIGFzOlxuICAvL1xuICAvLyBcIi86dGVzdChcXFxcZCspP1wiID0+IFtcIi9cIiwgXCJ0ZXN0XCIsIFwiXFxkK1wiLCB1bmRlZmluZWQsIFwiP1wiLCB1bmRlZmluZWRdXG4gIC8vIFwiL3JvdXRlKFxcXFxkKylcIiAgPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiXFxkK1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgLy8gXCIvKlwiICAgICAgICAgICAgPT4gW1wiL1wiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFwiKlwiXVxuICAnKFtcXFxcLy5dKT8oPzooPzpcXFxcOihcXFxcdyspKD86XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSk/fFxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpKFsrKj9dKT98KFxcXFwqKSknXG5dLmpvaW4oJ3wnKSwgJ2cnKTtcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIga2V5ID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHBhdGggPSAnJztcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJztcbiAgdmFyIHJlcztcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdO1xuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdO1xuICAgIHZhciBvZmZzZXQgPSByZXMuaW5kZXg7XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldCk7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aDtcblxuICAgIC8vIElnbm9yZSBhbHJlYWR5IGVzY2FwZWQgc2VxdWVuY2VzLlxuICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICBwYXRoICs9IGVzY2FwZWRbMV07XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XTtcbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdO1xuICAgIHZhciBuYW1lID0gcmVzWzNdO1xuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdO1xuICAgIHZhciBncm91cCA9IHJlc1s1XTtcbiAgICB2YXIgbW9kaWZpZXIgPSByZXNbNl07XG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddO1xuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gICAgICBwYXRoID0gJyc7XG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4O1xuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKic7XG4gICAgdmFyIG9wdGlvbmFsID0gbW9kaWZpZXIgPT09ICc/JyB8fCBtb2RpZmllciA9PT0gJyonO1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlcjtcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXA7XG5cbiAgICB0b2tlbnMucHVzaCh7XG4gICAgICBuYW1lOiBuYW1lIHx8IGtleSsrLFxuICAgICAgcHJlZml4OiBwcmVmaXggfHwgJycsXG4gICAgICBkZWxpbWl0ZXI6IGRlbGltaXRlcixcbiAgICAgIG9wdGlvbmFsOiBvcHRpb25hbCxcbiAgICAgIHJlcGVhdDogcmVwZWF0LFxuICAgICAgcGFydGlhbDogcGFydGlhbCxcbiAgICAgIGFzdGVyaXNrOiAhIWFzdGVyaXNrLFxuICAgICAgcGF0dGVybjogcGF0dGVybiA/IGVzY2FwZUdyb3VwKHBhdHRlcm4pIDogKGFzdGVyaXNrID8gJy4qJyA6ICdbXicgKyBlc2NhcGVTdHJpbmcoZGVsaW1pdGVyKSArICddKz8nKVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KTtcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aCk7XG4gIH1cblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQ29tcGlsZSBhIHN0cmluZyB0byBhIHRlbXBsYXRlIGZ1bmN0aW9uIGZvciB0aGUgcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICAgIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshZnVuY3Rpb24oT2JqZWN0PSwgT2JqZWN0PSl9XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHN0ciwgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9GdW5jdGlvbihwYXJzZShzdHIsIG9wdGlvbnMpKVxufVxuXG4vKipcbiAqIFByZXR0aWVyIGVuY29kaW5nIG9mIFVSSSBwYXRoIHNlZ21lbnRzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50UHJldHR5IChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1tcXC8/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRW5jb2RlIHRoZSBhc3RlcmlzayBwYXJhbWV0ZXIuIFNpbWlsYXIgdG8gYHByZXR0eWAsIGJ1dCBhbGxvd3Mgc2xhc2hlcy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZUFzdGVyaXNrIChzdHIpIHtcbiAgcmV0dXJuIGVuY29kZVVSSShzdHIpLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogRXhwb3NlIGEgbWV0aG9kIGZvciB0cmFuc2Zvcm1pbmcgdG9rZW5zIGludG8gdGhlIHBhdGggZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvRnVuY3Rpb24gKHRva2Vucykge1xuICAvLyBDb21waWxlIGFsbCB0aGUgdG9rZW5zIGludG8gcmVnZXhwcy5cbiAgdmFyIG1hdGNoZXMgPSBuZXcgQXJyYXkodG9rZW5zLmxlbmd0aCk7XG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuICAgIHZhciBkYXRhID0gb2JqIHx8IHt9O1xuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuO1xuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV07XG4gICAgICB2YXIgc2VnbWVudDtcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYWxsIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbWF0Y2ggXCInICsgdG9rZW4ucGF0dGVybiArICdcIiwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkgKyAnYCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aCArPSAoaiA9PT0gMCA/IHRva2VuLnByZWZpeCA6IHRva2VuLmRlbGltaXRlcikgKyBzZWdtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKTtcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIGEgcmVndWxhciBleHByZXNzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcgKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbLisqPz1eIToke30oKVtcXF18XFwvXFxcXF0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEVzY2FwZSB0aGUgY2FwdHVyaW5nIGdyb3VwIGJ5IGVzY2FwaW5nIHNwZWNpYWwgY2hhcmFjdGVycyBhbmQgbWVhbmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGdyb3VwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUdyb3VwIChncm91cCkge1xuICByZXR1cm4gZ3JvdXAucmVwbGFjZSgvKFs9ITokXFwvKCldKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBBdHRhY2ggdGhlIGtleXMgYXMgYSBwcm9wZXJ0eSBvZiB0aGUgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHJlXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhdHRhY2hLZXlzIChyZSwga2V5cykge1xuICByZS5rZXlzID0ga2V5cztcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpO1xuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocGF0aCwga2V5cylcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gYXJyYXkgaW50byBhIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBwYXRoXG4gKiBAcGFyYW0gIHtBcnJheX0gICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBhcnJheVRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSk7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpO1xuXG4gIHJldHVybiBhdHRhY2hLZXlzKHJlZ2V4cCwga2V5cylcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwYXRoIHJlZ2V4cCBmcm9tIHN0cmluZyBpbnB1dC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBwYXRoXG4gKiBAcGFyYW0gIHshQXJyYXl9ICBrZXlzXG4gKiBAcGFyYW0gIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICByZXR1cm4gdG9rZW5zVG9SZWdFeHAocGFyc2UocGF0aCwgb3B0aW9ucyksIGtleXMsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogRXhwb3NlIGEgZnVuY3Rpb24gZm9yIHRha2luZyB0b2tlbnMgYW5kIHJldHVybmluZyBhIFJlZ0V4cC5cbiAqXG4gKiBAcGFyYW0gIHshQXJyYXl9ICAgICAgICAgIHRva2Vuc1xuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHRva2Vuc1RvUmVnRXhwICh0b2tlbnMsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucyk7XG4gICAga2V5cyA9IFtdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHN0cmljdCA9IG9wdGlvbnMuc3RyaWN0O1xuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlO1xuICB2YXIgcm91dGUgPSAnJztcblxuICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRva2VucyBhbmQgY3JlYXRlIG91ciByZWdleHAgc3RyaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeCk7XG4gICAgICB2YXIgY2FwdHVyZSA9ICcoPzonICsgdG9rZW4ucGF0dGVybiArICcpJztcblxuICAgICAga2V5cy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKic7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICBpZiAoIXRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICBjYXB0dXJlID0gJyg/OicgKyBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJykpPyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJztcbiAgICAgIH1cblxuICAgICAgcm91dGUgKz0gY2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJyk7XG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyO1xuXG4gIC8vIEluIG5vbi1zdHJpY3QgbW9kZSB3ZSBhbGxvdyBhIHNsYXNoIGF0IHRoZSBlbmQgb2YgbWF0Y2guIElmIHRoZSBwYXRoIHRvXG4gIC8vIG1hdGNoIGFscmVhZHkgZW5kcyB3aXRoIGEgc2xhc2gsIHdlIHJlbW92ZSBpdCBmb3IgY29uc2lzdGVuY3kuIFRoZSBzbGFzaFxuICAvLyBpcyB2YWxpZCBhdCB0aGUgZW5kIG9mIGEgcGF0aCBtYXRjaCwgbm90IGluIHRoZSBtaWRkbGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gIC8vIGluIG5vbi1lbmRpbmcgbW9kZSwgd2hlcmUgXCIvdGVzdC9cIiBzaG91bGRuJ3QgbWF0Y2ggXCIvdGVzdC8vcm91dGVcIi5cbiAgaWYgKCFzdHJpY3QpIHtcbiAgICByb3V0ZSA9IChlbmRzV2l0aERlbGltaXRlciA/IHJvdXRlLnNsaWNlKDAsIC1kZWxpbWl0ZXIubGVuZ3RoKSA6IHJvdXRlKSArICcoPzonICsgZGVsaW1pdGVyICsgJyg/PSQpKT8nO1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJztcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknO1xuICB9XG5cbiAgcmV0dXJuIGF0dGFjaEtleXMobmV3IFJlZ0V4cCgnXicgKyByb3V0ZSwgZmxhZ3Mob3B0aW9ucykpLCBrZXlzKVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgZ2l2ZW4gcGF0aCBzdHJpbmcsIHJldHVybmluZyBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBBbiBlbXB0eSBhcnJheSBjYW4gYmUgcGFzc2VkIGluIGZvciB0aGUga2V5cywgd2hpY2ggd2lsbCBob2xkIHRoZVxuICogcGxhY2Vob2xkZXIga2V5IGRlc2NyaXB0aW9ucy4gRm9yIGV4YW1wbGUsIHVzaW5nIGAvdXNlci86aWRgLCBga2V5c2Agd2lsbFxuICogY29udGFpbiBgW3sgbmFtZTogJ2lkJywgZGVsaW1pdGVyOiAnLycsIG9wdGlvbmFsOiBmYWxzZSwgcmVwZWF0OiBmYWxzZSB9XWAuXG4gKlxuICogQHBhcmFtICB7KHN0cmluZ3xSZWdFeHB8QXJyYXkpfSBwYXRoXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19ICAgICAgIGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcGF0aFRvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpO1xuICAgIGtleXMgPSBbXTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChwYXRoIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgcmV0dXJuIHJlZ2V4cFRvUmVnZXhwKHBhdGgsIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cykpXG4gIH1cblxuICBpZiAoaXNhcnJheShwYXRoKSkge1xuICAgIHJldHVybiBhcnJheVRvUmVnZXhwKC8qKiBAdHlwZSB7IUFycmF5fSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gc3RyaW5nVG9SZWdleHAoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbn1cblxucGF0aFRvUmVnZXhwXzEucGFyc2UgPSBwYXJzZV8xO1xucGF0aFRvUmVnZXhwXzEuY29tcGlsZSA9IGNvbXBpbGVfMTtcbnBhdGhUb1JlZ2V4cF8xLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXzE7XG5wYXRoVG9SZWdleHBfMS50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXzE7XG5cbi8qICAqL1xuXG4vLyAkZmxvdy1kaXNhYmxlLWxpbmVcbnZhciByZWdleHBDb21waWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBmaWxsUGFyYW1zIChcbiAgcGF0aCxcbiAgcGFyYW1zLFxuICByb3V0ZU1zZ1xuKSB7XG4gIHRyeSB7XG4gICAgdmFyIGZpbGxlciA9XG4gICAgICByZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gfHxcbiAgICAgIChyZWdleHBDb21waWxlQ2FjaGVbcGF0aF0gPSBwYXRoVG9SZWdleHBfMS5jb21waWxlKHBhdGgpKTtcbiAgICByZXR1cm4gZmlsbGVyKHBhcmFtcyB8fCB7fSwgeyBwcmV0dHk6IHRydWUgfSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIHtcbiAgICAgIHdhcm4oZmFsc2UsIChcIm1pc3NpbmcgcGFyYW0gZm9yIFwiICsgcm91dGVNc2cgKyBcIjogXCIgKyAoZS5tZXNzYWdlKSkpO1xuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlUm91dGVNYXAgKFxuICByb3V0ZXMsXG4gIG9sZFBhdGhMaXN0LFxuICBvbGRQYXRoTWFwLFxuICBvbGROYW1lTWFwXG4pIHtcbiAgLy8gdGhlIHBhdGggbGlzdCBpcyB1c2VkIHRvIGNvbnRyb2wgcGF0aCBtYXRjaGluZyBwcmlvcml0eVxuICB2YXIgcGF0aExpc3QgPSBvbGRQYXRoTGlzdCB8fCBbXTtcbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIHZhciBwYXRoTWFwID0gb2xkUGF0aE1hcCB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgdmFyIG5hbWVNYXAgPSBvbGROYW1lTWFwIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcm91dGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIHJvdXRlKTtcbiAgfSk7XG5cbiAgLy8gZW5zdXJlIHdpbGRjYXJkIHJvdXRlcyBhcmUgYWx3YXlzIGF0IHRoZSBlbmRcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoTGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAocGF0aExpc3RbaV0gPT09ICcqJykge1xuICAgICAgcGF0aExpc3QucHVzaChwYXRoTGlzdC5zcGxpY2UoaSwgMSlbMF0pO1xuICAgICAgbC0tO1xuICAgICAgaS0tO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aExpc3Q6IHBhdGhMaXN0LFxuICAgIHBhdGhNYXA6IHBhdGhNYXAsXG4gICAgbmFtZU1hcDogbmFtZU1hcFxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJvdXRlUmVjb3JkIChcbiAgcGF0aExpc3QsXG4gIHBhdGhNYXAsXG4gIG5hbWVNYXAsXG4gIHJvdXRlLFxuICBwYXJlbnQsXG4gIG1hdGNoQXNcbikge1xuICB2YXIgcGF0aCA9IHJvdXRlLnBhdGg7XG4gIHZhciBuYW1lID0gcm91dGUubmFtZTtcbiAge1xuICAgIGFzc2VydChwYXRoICE9IG51bGwsIFwiXFxcInBhdGhcXFwiIGlzIHJlcXVpcmVkIGluIGEgcm91dGUgY29uZmlndXJhdGlvbi5cIik7XG4gICAgYXNzZXJ0KFxuICAgICAgdHlwZW9mIHJvdXRlLmNvbXBvbmVudCAhPT0gJ3N0cmluZycsXG4gICAgICBcInJvdXRlIGNvbmZpZyBcXFwiY29tcG9uZW50XFxcIiBmb3IgcGF0aDogXCIgKyAoU3RyaW5nKHBhdGggfHwgbmFtZSkpICsgXCIgY2Fubm90IGJlIGEgXCIgK1xuICAgICAgXCJzdHJpbmcgaWQuIFVzZSBhbiBhY3R1YWwgY29tcG9uZW50IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG5cbiAgdmFyIHBhdGhUb1JlZ2V4cE9wdGlvbnMgPSByb3V0ZS5wYXRoVG9SZWdleHBPcHRpb25zIHx8IHt9O1xuICB2YXIgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKFxuICAgIHBhdGgsXG4gICAgcGFyZW50LFxuICAgIHBhdGhUb1JlZ2V4cE9wdGlvbnMuc3RyaWN0XG4gICk7XG5cbiAgaWYgKHR5cGVvZiByb3V0ZS5jYXNlU2Vuc2l0aXZlID09PSAnYm9vbGVhbicpIHtcbiAgICBwYXRoVG9SZWdleHBPcHRpb25zLnNlbnNpdGl2ZSA9IHJvdXRlLmNhc2VTZW5zaXRpdmU7XG4gIH1cblxuICB2YXIgcmVjb3JkID0ge1xuICAgIHBhdGg6IG5vcm1hbGl6ZWRQYXRoLFxuICAgIHJlZ2V4OiBjb21waWxlUm91dGVSZWdleChub3JtYWxpemVkUGF0aCwgcGF0aFRvUmVnZXhwT3B0aW9ucyksXG4gICAgY29tcG9uZW50czogcm91dGUuY29tcG9uZW50cyB8fCB7IGRlZmF1bHQ6IHJvdXRlLmNvbXBvbmVudCB9LFxuICAgIGluc3RhbmNlczoge30sXG4gICAgbmFtZTogbmFtZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBtYXRjaEFzOiBtYXRjaEFzLFxuICAgIHJlZGlyZWN0OiByb3V0ZS5yZWRpcmVjdCxcbiAgICBiZWZvcmVFbnRlcjogcm91dGUuYmVmb3JlRW50ZXIsXG4gICAgbWV0YTogcm91dGUubWV0YSB8fCB7fSxcbiAgICBwcm9wczogcm91dGUucHJvcHMgPT0gbnVsbFxuICAgICAgPyB7fVxuICAgICAgOiByb3V0ZS5jb21wb25lbnRzXG4gICAgICAgID8gcm91dGUucHJvcHNcbiAgICAgICAgOiB7IGRlZmF1bHQ6IHJvdXRlLnByb3BzIH1cbiAgfTtcblxuICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAvLyBXYXJuIGlmIHJvdXRlIGlzIG5hbWVkLCBkb2VzIG5vdCByZWRpcmVjdCBhbmQgaGFzIGEgZGVmYXVsdCBjaGlsZCByb3V0ZS5cbiAgICAvLyBJZiB1c2VycyBuYXZpZ2F0ZSB0byB0aGlzIHJvdXRlIGJ5IG5hbWUsIHRoZSBkZWZhdWx0IGNoaWxkIHdpbGxcbiAgICAvLyBub3QgYmUgcmVuZGVyZWQgKEdIIElzc3VlICM2MjkpXG4gICAge1xuICAgICAgaWYgKHJvdXRlLm5hbWUgJiYgIXJvdXRlLnJlZGlyZWN0ICYmIHJvdXRlLmNoaWxkcmVuLnNvbWUoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiAvXlxcLz8kLy50ZXN0KGNoaWxkLnBhdGgpOyB9KSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIFwiTmFtZWQgUm91dGUgJ1wiICsgKHJvdXRlLm5hbWUpICsgXCInIGhhcyBhIGRlZmF1bHQgY2hpbGQgcm91dGUuIFwiICtcbiAgICAgICAgICBcIldoZW4gbmF2aWdhdGluZyB0byB0aGlzIG5hbWVkIHJvdXRlICg6dG89XFxcIntuYW1lOiAnXCIgKyAocm91dGUubmFtZSkgKyBcIidcXFwiKSwgXCIgK1xuICAgICAgICAgIFwidGhlIGRlZmF1bHQgY2hpbGQgcm91dGUgd2lsbCBub3QgYmUgcmVuZGVyZWQuIFJlbW92ZSB0aGUgbmFtZSBmcm9tIFwiICtcbiAgICAgICAgICBcInRoaXMgcm91dGUgYW5kIHVzZSB0aGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBjaGlsZCByb3V0ZSBmb3IgbmFtZWQgXCIgK1xuICAgICAgICAgIFwibGlua3MgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICByb3V0ZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdmFyIGNoaWxkTWF0Y2hBcyA9IG1hdGNoQXNcbiAgICAgICAgPyBjbGVhblBhdGgoKG1hdGNoQXMgKyBcIi9cIiArIChjaGlsZC5wYXRoKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgYWRkUm91dGVSZWNvcmQocGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXAsIGNoaWxkLCByZWNvcmQsIGNoaWxkTWF0Y2hBcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocm91dGUuYWxpYXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBhbGlhc2VzID0gQXJyYXkuaXNBcnJheShyb3V0ZS5hbGlhcylcbiAgICAgID8gcm91dGUuYWxpYXNcbiAgICAgIDogW3JvdXRlLmFsaWFzXTtcblxuICAgIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICAgIHZhciBhbGlhc1JvdXRlID0ge1xuICAgICAgICBwYXRoOiBhbGlhcyxcbiAgICAgICAgY2hpbGRyZW46IHJvdXRlLmNoaWxkcmVuXG4gICAgICB9O1xuICAgICAgYWRkUm91dGVSZWNvcmQoXG4gICAgICAgIHBhdGhMaXN0LFxuICAgICAgICBwYXRoTWFwLFxuICAgICAgICBuYW1lTWFwLFxuICAgICAgICBhbGlhc1JvdXRlLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIHJlY29yZC5wYXRoIHx8ICcvJyAvLyBtYXRjaEFzXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFwYXRoTWFwW3JlY29yZC5wYXRoXSkge1xuICAgIHBhdGhMaXN0LnB1c2gocmVjb3JkLnBhdGgpO1xuICAgIHBhdGhNYXBbcmVjb3JkLnBhdGhdID0gcmVjb3JkO1xuICB9XG5cbiAgaWYgKG5hbWUpIHtcbiAgICBpZiAoIW5hbWVNYXBbbmFtZV0pIHtcbiAgICAgIG5hbWVNYXBbbmFtZV0gPSByZWNvcmQ7XG4gICAgfSBlbHNlIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhbWF0Y2hBcykge1xuICAgICAgd2FybihcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIFwiRHVwbGljYXRlIG5hbWVkIHJvdXRlcyBkZWZpbml0aW9uOiBcIiArXG4gICAgICAgIFwieyBuYW1lOiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBwYXRoOiBcXFwiXCIgKyAocmVjb3JkLnBhdGgpICsgXCJcXFwiIH1cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGlsZVJvdXRlUmVnZXggKHBhdGgsIHBhdGhUb1JlZ2V4cE9wdGlvbnMpIHtcbiAgdmFyIHJlZ2V4ID0gcGF0aFRvUmVnZXhwXzEocGF0aCwgW10sIHBhdGhUb1JlZ2V4cE9wdGlvbnMpO1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJlZ2V4LmtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB3YXJuKCFrZXlzW2tleS5uYW1lXSwgKFwiRHVwbGljYXRlIHBhcmFtIGtleXMgaW4gcm91dGUgd2l0aCBwYXRoOiBcXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIpKTtcbiAgICAgIGtleXNba2V5Lm5hbWVdID0gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVnZXhcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aCAocGF0aCwgcGFyZW50LCBzdHJpY3QpIHtcbiAgaWYgKCFzdHJpY3QpIHsgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTsgfVxuICBpZiAocGF0aFswXSA9PT0gJy8nKSB7IHJldHVybiBwYXRoIH1cbiAgaWYgKHBhcmVudCA9PSBudWxsKSB7IHJldHVybiBwYXRoIH1cbiAgcmV0dXJuIGNsZWFuUGF0aCgoKHBhcmVudC5wYXRoKSArIFwiL1wiICsgcGF0aCkpXG59XG5cbi8qICAqL1xuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2F0aW9uIChcbiAgcmF3LFxuICBjdXJyZW50LFxuICBhcHBlbmQsXG4gIHJvdXRlclxuKSB7XG4gIHZhciBuZXh0ID0gdHlwZW9mIHJhdyA9PT0gJ3N0cmluZycgPyB7IHBhdGg6IHJhdyB9IDogcmF3O1xuICAvLyBuYW1lZCB0YXJnZXRcbiAgaWYgKG5leHQubmFtZSB8fCBuZXh0Ll9ub3JtYWxpemVkKSB7XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIC8vIHJlbGF0aXZlIHBhcmFtc1xuICBpZiAoIW5leHQucGF0aCAmJiBuZXh0LnBhcmFtcyAmJiBjdXJyZW50KSB7XG4gICAgbmV4dCA9IGFzc2lnbih7fSwgbmV4dCk7XG4gICAgbmV4dC5fbm9ybWFsaXplZCA9IHRydWU7XG4gICAgdmFyIHBhcmFtcyA9IGFzc2lnbihhc3NpZ24oe30sIGN1cnJlbnQucGFyYW1zKSwgbmV4dC5wYXJhbXMpO1xuICAgIGlmIChjdXJyZW50Lm5hbWUpIHtcbiAgICAgIG5leHQubmFtZSA9IGN1cnJlbnQubmFtZTtcbiAgICAgIG5leHQucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5tYXRjaGVkLmxlbmd0aCkge1xuICAgICAgdmFyIHJhd1BhdGggPSBjdXJyZW50Lm1hdGNoZWRbY3VycmVudC5tYXRjaGVkLmxlbmd0aCAtIDFdLnBhdGg7XG4gICAgICBuZXh0LnBhdGggPSBmaWxsUGFyYW1zKHJhd1BhdGgsIHBhcmFtcywgKFwicGF0aCBcIiArIChjdXJyZW50LnBhdGgpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oZmFsc2UsIFwicmVsYXRpdmUgcGFyYW1zIG5hdmlnYXRpb24gcmVxdWlyZXMgYSBjdXJyZW50IHJvdXRlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRcbiAgfVxuXG4gIHZhciBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKG5leHQucGF0aCB8fCAnJyk7XG4gIHZhciBiYXNlUGF0aCA9IChjdXJyZW50ICYmIGN1cnJlbnQucGF0aCkgfHwgJy8nO1xuICB2YXIgcGF0aCA9IHBhcnNlZFBhdGgucGF0aFxuICAgID8gcmVzb2x2ZVBhdGgocGFyc2VkUGF0aC5wYXRoLCBiYXNlUGF0aCwgYXBwZW5kIHx8IG5leHQuYXBwZW5kKVxuICAgIDogYmFzZVBhdGg7XG5cbiAgdmFyIHF1ZXJ5ID0gcmVzb2x2ZVF1ZXJ5KFxuICAgIHBhcnNlZFBhdGgucXVlcnksXG4gICAgbmV4dC5xdWVyeSxcbiAgICByb3V0ZXIgJiYgcm91dGVyLm9wdGlvbnMucGFyc2VRdWVyeVxuICApO1xuXG4gIHZhciBoYXNoID0gbmV4dC5oYXNoIHx8IHBhcnNlZFBhdGguaGFzaDtcbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xuICAgIGhhc2ggPSBcIiNcIiArIGhhc2g7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgIHBhdGg6IHBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGhhc2g6IGhhc2hcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24gKGEsIGIpIHtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBhW2tleV0gPSBiW2tleV07XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLyogICovXG5cblxuZnVuY3Rpb24gY3JlYXRlTWF0Y2hlciAoXG4gIHJvdXRlcyxcbiAgcm91dGVyXG4pIHtcbiAgdmFyIHJlZiA9IGNyZWF0ZVJvdXRlTWFwKHJvdXRlcyk7XG4gIHZhciBwYXRoTGlzdCA9IHJlZi5wYXRoTGlzdDtcbiAgdmFyIHBhdGhNYXAgPSByZWYucGF0aE1hcDtcbiAgdmFyIG5hbWVNYXAgPSByZWYubmFtZU1hcDtcblxuICBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICAgIGNyZWF0ZVJvdXRlTWFwKHJvdXRlcywgcGF0aExpc3QsIHBhdGhNYXAsIG5hbWVNYXApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2ggKFxuICAgIHJhdyxcbiAgICBjdXJyZW50Um91dGUsXG4gICAgcmVkaXJlY3RlZEZyb21cbiAgKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gbm9ybWFsaXplTG9jYXRpb24ocmF3LCBjdXJyZW50Um91dGUsIGZhbHNlLCByb3V0ZXIpO1xuICAgIHZhciBuYW1lID0gbG9jYXRpb24ubmFtZTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICB2YXIgcmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIHtcbiAgICAgICAgd2FybihyZWNvcmQsIChcIlJvdXRlIHdpdGggbmFtZSAnXCIgKyBuYW1lICsgXCInIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVjb3JkKSB7IHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pIH1cbiAgICAgIHZhciBwYXJhbU5hbWVzID0gcmVjb3JkLnJlZ2V4LmtleXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAha2V5Lm9wdGlvbmFsOyB9KVxuICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleS5uYW1lOyB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbi5wYXJhbXMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhcmFtcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFJvdXRlICYmIHR5cGVvZiBjdXJyZW50Um91dGUucGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY3VycmVudFJvdXRlLnBhcmFtcykge1xuICAgICAgICAgIGlmICghKGtleSBpbiBsb2NhdGlvbi5wYXJhbXMpICYmIHBhcmFtTmFtZXMuaW5kZXhPZihrZXkpID4gLTEpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnBhcmFtc1trZXldID0gY3VycmVudFJvdXRlLnBhcmFtc1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkKSB7XG4gICAgICAgIGxvY2F0aW9uLnBhdGggPSBmaWxsUGFyYW1zKHJlY29yZC5wYXRoLCBsb2NhdGlvbi5wYXJhbXMsIChcIm5hbWVkIHJvdXRlIFxcXCJcIiArIG5hbWUgKyBcIlxcXCJcIikpO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aCkge1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aExpc3RbaV07XG4gICAgICAgIHZhciByZWNvcmQkMSA9IHBhdGhNYXBbcGF0aF07XG4gICAgICAgIGlmIChtYXRjaFJvdXRlKHJlY29yZCQxLnJlZ2V4LCBsb2NhdGlvbi5wYXRoLCBsb2NhdGlvbi5wYXJhbXMpKSB7XG4gICAgICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShyZWNvcmQkMSwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG5vIG1hdGNoXG4gICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZGlyZWN0IChcbiAgICByZWNvcmQsXG4gICAgbG9jYXRpb25cbiAgKSB7XG4gICAgdmFyIG9yaWdpbmFsUmVkaXJlY3QgPSByZWNvcmQucmVkaXJlY3Q7XG4gICAgdmFyIHJlZGlyZWN0ID0gdHlwZW9mIG9yaWdpbmFsUmVkaXJlY3QgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBvcmlnaW5hbFJlZGlyZWN0KGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIG51bGwsIHJvdXRlcikpXG4gICAgICAgIDogb3JpZ2luYWxSZWRpcmVjdDtcblxuICAgIGlmICh0eXBlb2YgcmVkaXJlY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZWRpcmVjdCA9IHsgcGF0aDogcmVkaXJlY3QgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlZGlyZWN0IHx8IHR5cGVvZiByZWRpcmVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBmYWxzZSwgKFwiaW52YWxpZCByZWRpcmVjdCBvcHRpb246IFwiICsgKEpTT04uc3RyaW5naWZ5KHJlZGlyZWN0KSkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2NyZWF0ZVJvdXRlKG51bGwsIGxvY2F0aW9uKVxuICAgIH1cblxuICAgIHZhciByZSA9IHJlZGlyZWN0O1xuICAgIHZhciBuYW1lID0gcmUubmFtZTtcbiAgICB2YXIgcGF0aCA9IHJlLnBhdGg7XG4gICAgdmFyIHF1ZXJ5ID0gbG9jYXRpb24ucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuICAgIHZhciBwYXJhbXMgPSBsb2NhdGlvbi5wYXJhbXM7XG4gICAgcXVlcnkgPSByZS5oYXNPd25Qcm9wZXJ0eSgncXVlcnknKSA/IHJlLnF1ZXJ5IDogcXVlcnk7XG4gICAgaGFzaCA9IHJlLmhhc093blByb3BlcnR5KCdoYXNoJykgPyByZS5oYXNoIDogaGFzaDtcbiAgICBwYXJhbXMgPSByZS5oYXNPd25Qcm9wZXJ0eSgncGFyYW1zJykgPyByZS5wYXJhbXMgOiBwYXJhbXM7XG5cbiAgICBpZiAobmFtZSkge1xuICAgICAgLy8gcmVzb2x2ZWQgbmFtZWQgZGlyZWN0XG4gICAgICB2YXIgdGFyZ2V0UmVjb3JkID0gbmFtZU1hcFtuYW1lXTtcbiAgICAgIHtcbiAgICAgICAgYXNzZXJ0KHRhcmdldFJlY29yZCwgKFwicmVkaXJlY3QgZmFpbGVkOiBuYW1lZCByb3V0ZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG5vdCBmb3VuZC5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoKHtcbiAgICAgICAgX25vcm1hbGl6ZWQ6IHRydWUsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICAgIH0sIHVuZGVmaW5lZCwgbG9jYXRpb24pXG4gICAgfSBlbHNlIGlmIChwYXRoKSB7XG4gICAgICAvLyAxLiByZXNvbHZlIHJlbGF0aXZlIHJlZGlyZWN0XG4gICAgICB2YXIgcmF3UGF0aCA9IHJlc29sdmVSZWNvcmRQYXRoKHBhdGgsIHJlY29yZCk7XG4gICAgICAvLyAyLiByZXNvbHZlIHBhcmFtc1xuICAgICAgdmFyIHJlc29sdmVkUGF0aCA9IGZpbGxQYXJhbXMocmF3UGF0aCwgcGFyYW1zLCAoXCJyZWRpcmVjdCByb3V0ZSB3aXRoIHBhdGggXFxcIlwiICsgcmF3UGF0aCArIFwiXFxcIlwiKSk7XG4gICAgICAvLyAzLiByZW1hdGNoIHdpdGggZXhpc3RpbmcgcXVlcnkgYW5kIGhhc2hcbiAgICAgIHJldHVybiBtYXRjaCh7XG4gICAgICAgIF9ub3JtYWxpemVkOiB0cnVlLFxuICAgICAgICBwYXRoOiByZXNvbHZlZFBhdGgsXG4gICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgaGFzaDogaGFzaFxuICAgICAgfSwgdW5kZWZpbmVkLCBsb2NhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICB3YXJuKGZhbHNlLCAoXCJpbnZhbGlkIHJlZGlyZWN0IG9wdGlvbjogXCIgKyAoSlNPTi5zdHJpbmdpZnkocmVkaXJlY3QpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jcmVhdGVSb3V0ZShudWxsLCBsb2NhdGlvbilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhbGlhcyAoXG4gICAgcmVjb3JkLFxuICAgIGxvY2F0aW9uLFxuICAgIG1hdGNoQXNcbiAgKSB7XG4gICAgdmFyIGFsaWFzZWRQYXRoID0gZmlsbFBhcmFtcyhtYXRjaEFzLCBsb2NhdGlvbi5wYXJhbXMsIChcImFsaWFzZWQgcm91dGUgd2l0aCBwYXRoIFxcXCJcIiArIG1hdGNoQXMgKyBcIlxcXCJcIikpO1xuICAgIHZhciBhbGlhc2VkTWF0Y2ggPSBtYXRjaCh7XG4gICAgICBfbm9ybWFsaXplZDogdHJ1ZSxcbiAgICAgIHBhdGg6IGFsaWFzZWRQYXRoXG4gICAgfSk7XG4gICAgaWYgKGFsaWFzZWRNYXRjaCkge1xuICAgICAgdmFyIG1hdGNoZWQgPSBhbGlhc2VkTWF0Y2gubWF0Y2hlZDtcbiAgICAgIHZhciBhbGlhc2VkUmVjb3JkID0gbWF0Y2hlZFttYXRjaGVkLmxlbmd0aCAtIDFdO1xuICAgICAgbG9jYXRpb24ucGFyYW1zID0gYWxpYXNlZE1hdGNoLnBhcmFtcztcbiAgICAgIHJldHVybiBfY3JlYXRlUm91dGUoYWxpYXNlZFJlY29yZCwgbG9jYXRpb24pXG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlUm91dGUobnVsbCwgbG9jYXRpb24pXG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlUm91dGUgKFxuICAgIHJlY29yZCxcbiAgICBsb2NhdGlvbixcbiAgICByZWRpcmVjdGVkRnJvbVxuICApIHtcbiAgICBpZiAocmVjb3JkICYmIHJlY29yZC5yZWRpcmVjdCkge1xuICAgICAgcmV0dXJuIHJlZGlyZWN0KHJlY29yZCwgcmVkaXJlY3RlZEZyb20gfHwgbG9jYXRpb24pXG4gICAgfVxuICAgIGlmIChyZWNvcmQgJiYgcmVjb3JkLm1hdGNoQXMpIHtcbiAgICAgIHJldHVybiBhbGlhcyhyZWNvcmQsIGxvY2F0aW9uLCByZWNvcmQubWF0Y2hBcylcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJvdXRlKHJlY29yZCwgbG9jYXRpb24sIHJlZGlyZWN0ZWRGcm9tLCByb3V0ZXIpXG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1hdGNoOiBtYXRjaCxcbiAgICBhZGRSb3V0ZXM6IGFkZFJvdXRlc1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGUgKFxuICByZWdleCxcbiAgcGF0aCxcbiAgcGFyYW1zXG4pIHtcbiAgdmFyIG0gPSBwYXRoLm1hdGNoKHJlZ2V4KTtcblxuICBpZiAoIW0pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSBtLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIGtleSA9IHJlZ2V4LmtleXNbaSAtIDFdO1xuICAgIHZhciB2YWwgPSB0eXBlb2YgbVtpXSA9PT0gJ3N0cmluZycgPyBkZWNvZGVVUklDb21wb25lbnQobVtpXSkgOiBtW2ldO1xuICAgIGlmIChrZXkpIHtcbiAgICAgIHBhcmFtc1trZXkubmFtZV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVJlY29yZFBhdGggKHBhdGgsIHJlY29yZCkge1xuICByZXR1cm4gcmVzb2x2ZVBhdGgocGF0aCwgcmVjb3JkLnBhcmVudCA/IHJlY29yZC5wYXJlbnQucGF0aCA6ICcvJywgdHJ1ZSlcbn1cblxuLyogICovXG5cblxudmFyIHBvc2l0aW9uU3RvcmUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBzZXR1cFNjcm9sbCAoKSB7XG4gIC8vIEZpeCBmb3IgIzE1ODUgZm9yIEZpcmVmb3hcbiAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBnZXRTdGF0ZUtleSgpIH0sICcnKTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24gKGUpIHtcbiAgICBzYXZlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICBpZiAoZS5zdGF0ZSAmJiBlLnN0YXRlLmtleSkge1xuICAgICAgc2V0U3RhdGVLZXkoZS5zdGF0ZS5rZXkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNjcm9sbCAoXG4gIHJvdXRlcixcbiAgdG8sXG4gIGZyb20sXG4gIGlzUG9wXG4pIHtcbiAgaWYgKCFyb3V0ZXIuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgYmVoYXZpb3IgPSByb3V0ZXIub3B0aW9ucy5zY3JvbGxCZWhhdmlvcjtcbiAgaWYgKCFiZWhhdmlvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAge1xuICAgIGFzc2VydCh0eXBlb2YgYmVoYXZpb3IgPT09ICdmdW5jdGlvbicsIFwic2Nyb2xsQmVoYXZpb3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgLy8gd2FpdCB1bnRpbCByZS1yZW5kZXIgZmluaXNoZXMgYmVmb3JlIHNjcm9sbGluZ1xuICByb3V0ZXIuYXBwLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB2YXIgc2hvdWxkU2Nyb2xsID0gYmVoYXZpb3IodG8sIGZyb20sIGlzUG9wID8gcG9zaXRpb24gOiBudWxsKTtcblxuICAgIGlmICghc2hvdWxkU2Nyb2xsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNob3VsZFNjcm9sbC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzaG91bGRTY3JvbGwudGhlbihmdW5jdGlvbiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICAgIHNjcm9sbFRvUG9zaXRpb24oKHNob3VsZFNjcm9sbCksIHBvc2l0aW9uKTtcbiAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAge1xuICAgICAgICAgIGFzc2VydChmYWxzZSwgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Nyb2xsVG9Qb3NpdGlvbihzaG91bGRTY3JvbGwsIHBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzYXZlU2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHBvc2l0aW9uU3RvcmVba2V5XSA9IHtcbiAgICAgIHg6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgIHk6IHdpbmRvdy5wYWdlWU9mZnNldFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUG9zaXRpb24gKCkge1xuICB2YXIga2V5ID0gZ2V0U3RhdGVLZXkoKTtcbiAgaWYgKGtleSkge1xuICAgIHJldHVybiBwb3NpdGlvblN0b3JlW2tleV1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50UG9zaXRpb24gKGVsLCBvZmZzZXQpIHtcbiAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZG9jUmVjdCA9IGRvY0VsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgeDogZWxSZWN0LmxlZnQgLSBkb2NSZWN0LmxlZnQgLSBvZmZzZXQueCxcbiAgICB5OiBlbFJlY3QudG9wIC0gZG9jUmVjdC50b3AgLSBvZmZzZXQueVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRQb3NpdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc051bWJlcihvYmoueCkgfHwgaXNOdW1iZXIob2JqLnkpXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aW9uIChvYmopIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBpc051bWJlcihvYmoueCkgPyBvYmoueCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICB5OiBpc051bWJlcihvYmoueSkgPyBvYmoueSA6IHdpbmRvdy5wYWdlWU9mZnNldFxuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9mZnNldCAob2JqKSB7XG4gIHJldHVybiB7XG4gICAgeDogaXNOdW1iZXIob2JqLngpID8gb2JqLnggOiAwLFxuICAgIHk6IGlzTnVtYmVyKG9iai55KSA/IG9iai55IDogMFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyICh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gc2Nyb2xsVG9Qb3NpdGlvbiAoc2hvdWxkU2Nyb2xsLCBwb3NpdGlvbikge1xuICB2YXIgaXNPYmplY3QgPSB0eXBlb2Ygc2hvdWxkU2Nyb2xsID09PSAnb2JqZWN0JztcbiAgaWYgKGlzT2JqZWN0ICYmIHR5cGVvZiBzaG91bGRTY3JvbGwuc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzaG91bGRTY3JvbGwuc2VsZWN0b3IpO1xuICAgIGlmIChlbCkge1xuICAgICAgdmFyIG9mZnNldCA9IHNob3VsZFNjcm9sbC5vZmZzZXQgJiYgdHlwZW9mIHNob3VsZFNjcm9sbC5vZmZzZXQgPT09ICdvYmplY3QnID8gc2hvdWxkU2Nyb2xsLm9mZnNldCA6IHt9O1xuICAgICAgb2Zmc2V0ID0gbm9ybWFsaXplT2Zmc2V0KG9mZnNldCk7XG4gICAgICBwb3NpdGlvbiA9IGdldEVsZW1lbnRQb3NpdGlvbihlbCwgb2Zmc2V0KTtcbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgICBwb3NpdGlvbiA9IG5vcm1hbGl6ZVBvc2l0aW9uKHNob3VsZFNjcm9sbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0ICYmIGlzVmFsaWRQb3NpdGlvbihzaG91bGRTY3JvbGwpKSB7XG4gICAgcG9zaXRpb24gPSBub3JtYWxpemVQb3NpdGlvbihzaG91bGRTY3JvbGwpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9uKSB7XG4gICAgd2luZG93LnNjcm9sbFRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgc3VwcG9ydHNQdXNoU3RhdGUgPSBpbkJyb3dzZXIgJiYgKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKFxuICAgICh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJlxuICAgIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcbiAgICB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5XG59KSgpO1xuXG4vLyB1c2UgVXNlciBUaW1pbmcgYXBpIChpZiBwcmVzZW50KSBmb3IgbW9yZSBhY2N1cmF0ZSBrZXkgcHJlY2lzaW9uXG52YXIgVGltZSA9IGluQnJvd3NlciAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vd1xuICA/IHdpbmRvdy5wZXJmb3JtYW5jZVxuICA6IERhdGU7XG5cbnZhciBfa2V5ID0gZ2VuS2V5KCk7XG5cbmZ1bmN0aW9uIGdlbktleSAoKSB7XG4gIHJldHVybiBUaW1lLm5vdygpLnRvRml4ZWQoMylcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVLZXkgKCkge1xuICByZXR1cm4gX2tleVxufVxuXG5mdW5jdGlvbiBzZXRTdGF0ZUtleSAoa2V5KSB7XG4gIF9rZXkgPSBrZXk7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdGF0ZSAodXJsLCByZXBsYWNlKSB7XG4gIHNhdmVTY3JvbGxQb3NpdGlvbigpO1xuICAvLyB0cnkuLi5jYXRjaCB0aGUgcHVzaFN0YXRlIGNhbGwgdG8gZ2V0IGFyb3VuZCBTYWZhcmlcbiAgLy8gRE9NIEV4Y2VwdGlvbiAxOCB3aGVyZSBpdCBsaW1pdHMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxsc1xuICB2YXIgaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGtleTogX2tleSB9LCAnJywgdXJsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2tleSA9IGdlbktleSgpO1xuICAgICAgaGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IF9rZXkgfSwgJycsIHVybCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgd2luZG93LmxvY2F0aW9uW3JlcGxhY2UgPyAncmVwbGFjZScgOiAnYXNzaWduJ10odXJsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlU3RhdGUgKHVybCkge1xuICBwdXNoU3RhdGUodXJsLCB0cnVlKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJ1blF1ZXVlIChxdWV1ZSwgZm4sIGNiKSB7XG4gIHZhciBzdGVwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgY2IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1ZXVlW2luZGV4XSkge1xuICAgICAgICBmbihxdWV1ZVtpbmRleF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGVwKGluZGV4ICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlcChpbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RlcCgwKTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudHMgKG1hdGNoZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0bywgZnJvbSwgbmV4dCkge1xuICAgIHZhciBoYXNBc3luYyA9IGZhbHNlO1xuICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuXG4gICAgZmxhdE1hcENvbXBvbmVudHMobWF0Y2hlZCwgZnVuY3Rpb24gKGRlZiwgXywgbWF0Y2gsIGtleSkge1xuICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uIGFuZCBkb2Vzbid0IGhhdmUgY2lkIGF0dGFjaGVkLFxuICAgICAgLy8gYXNzdW1lIGl0J3MgYW4gYXN5bmMgY29tcG9uZW50IHJlc29sdmUgZnVuY3Rpb24uXG4gICAgICAvLyB3ZSBhcmUgbm90IHVzaW5nIFZ1ZSdzIGRlZmF1bHQgYXN5bmMgcmVzb2x2aW5nIG1lY2hhbmlzbSBiZWNhdXNlXG4gICAgICAvLyB3ZSB3YW50IHRvIGhhbHQgdGhlIG5hdmlnYXRpb24gdW50aWwgdGhlIGluY29taW5nIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgLy8gcmVzb2x2ZWQuXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWYuY2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaGFzQXN5bmMgPSB0cnVlO1xuICAgICAgICBwZW5kaW5nKys7XG5cbiAgICAgICAgdmFyIHJlc29sdmUgPSBvbmNlKGZ1bmN0aW9uIChyZXNvbHZlZERlZikge1xuICAgICAgICAgIGlmIChpc0VTTW9kdWxlKHJlc29sdmVkRGVmKSkge1xuICAgICAgICAgICAgcmVzb2x2ZWREZWYgPSByZXNvbHZlZERlZi5kZWZhdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzYXZlIHJlc29sdmVkIG9uIGFzeW5jIGZhY3RvcnkgaW4gY2FzZSBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgICAgZGVmLnJlc29sdmVkID0gdHlwZW9mIHJlc29sdmVkRGVmID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHJlc29sdmVkRGVmXG4gICAgICAgICAgICA6IF9WdWUuZXh0ZW5kKHJlc29sdmVkRGVmKTtcbiAgICAgICAgICBtYXRjaC5jb21wb25lbnRzW2tleV0gPSByZXNvbHZlZERlZjtcbiAgICAgICAgICBwZW5kaW5nLS07XG4gICAgICAgICAgaWYgKHBlbmRpbmcgPD0gMCkge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudCBcIiArIGtleSArIFwiOiBcIiArIHJlYXNvbjtcbiAgICAgICAgICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKGZhbHNlLCBtc2cpO1xuICAgICAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yID0gaXNFcnJvcihyZWFzb24pXG4gICAgICAgICAgICAgID8gcmVhc29uXG4gICAgICAgICAgICAgIDogbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICBuZXh0KGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzID0gZGVmKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5ldyBzeW50YXggaW4gVnVlIDIuM1xuICAgICAgICAgICAgdmFyIGNvbXAgPSByZXMuY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXAgJiYgdHlwZW9mIGNvbXAudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBjb21wLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICghaGFzQXN5bmMpIHsgbmV4dCgpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdE1hcENvbXBvbmVudHMgKFxuICBtYXRjaGVkLFxuICBmblxuKSB7XG4gIHJldHVybiBmbGF0dGVuKG1hdGNoZWQubWFwKGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG0uY29tcG9uZW50cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGZuKFxuICAgICAgbS5jb21wb25lbnRzW2tleV0sXG4gICAgICBtLmluc3RhbmNlc1trZXldLFxuICAgICAgbSwga2V5XG4gICAgKTsgfSlcbiAgfSkpXG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW4gKGFycikge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJyKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxuZnVuY3Rpb24gaXNFU01vZHVsZSAob2JqKSB7XG4gIHJldHVybiBvYmouX19lc01vZHVsZSB8fCAoaGFzU3ltYm9sICYmIG9ialtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnTW9kdWxlJylcbn1cblxuLy8gaW4gV2VicGFjayAyLCByZXF1aXJlLmVuc3VyZSBub3cgYWxzbyByZXR1cm5zIGEgUHJvbWlzZVxuLy8gc28gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9ucyBtYXkgZ2V0IGNhbGxlZCBhbiBleHRyYSB0aW1lXG4vLyBpZiB0aGUgdXNlciB1c2VzIGFuIGFycm93IGZ1bmN0aW9uIHNob3J0aGFuZCB0aGF0IGhhcHBlbnMgdG9cbi8vIHJldHVybiB0aGF0IFByb21pc2UuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgaWYgKGNhbGxlZCkgeyByZXR1cm4gfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gIH1cbn1cblxuLyogICovXG5cbnZhciBIaXN0b3J5ID0gZnVuY3Rpb24gSGlzdG9yeSAocm91dGVyLCBiYXNlKSB7XG4gIHRoaXMucm91dGVyID0gcm91dGVyO1xuICB0aGlzLmJhc2UgPSBub3JtYWxpemVCYXNlKGJhc2UpO1xuICAvLyBzdGFydCB3aXRoIGEgcm91dGUgb2JqZWN0IHRoYXQgc3RhbmRzIGZvciBcIm5vd2hlcmVcIlxuICB0aGlzLmN1cnJlbnQgPSBTVEFSVDtcbiAgdGhpcy5wZW5kaW5nID0gbnVsbDtcbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICB0aGlzLnJlYWR5Q2JzID0gW107XG4gIHRoaXMucmVhZHlFcnJvckNicyA9IFtdO1xuICB0aGlzLmVycm9yQ2JzID0gW107XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5saXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4gKGNiKSB7XG4gIHRoaXMuY2IgPSBjYjtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLm9uUmVhZHkgPSBmdW5jdGlvbiBvblJlYWR5IChjYiwgZXJyb3JDYikge1xuICBpZiAodGhpcy5yZWFkeSkge1xuICAgIGNiKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWFkeUNicy5wdXNoKGNiKTtcbiAgICBpZiAoZXJyb3JDYikge1xuICAgICAgdGhpcy5yZWFkeUVycm9yQ2JzLnB1c2goZXJyb3JDYik7XG4gICAgfVxuICB9XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXJyb3JDYikge1xuICB0aGlzLmVycm9yQ2JzLnB1c2goZXJyb3JDYik7XG59O1xuXG5IaXN0b3J5LnByb3RvdHlwZS50cmFuc2l0aW9uVG8gPSBmdW5jdGlvbiB0cmFuc2l0aW9uVG8gKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJvdXRlID0gdGhpcy5yb3V0ZXIubWF0Y2gobG9jYXRpb24sIHRoaXMuY3VycmVudCk7XG4gIHRoaXMuY29uZmlybVRyYW5zaXRpb24ocm91dGUsIGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzJDEudXBkYXRlUm91dGUocm91dGUpO1xuICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgdGhpcyQxLmVuc3VyZVVSTCgpO1xuXG4gICAgLy8gZmlyZSByZWFkeSBjYnMgb25jZVxuICAgIGlmICghdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5Q2JzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IGNiKHJvdXRlKTsgfSk7XG4gICAgfVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKG9uQWJvcnQpIHtcbiAgICAgIG9uQWJvcnQoZXJyKTtcbiAgICB9XG4gICAgaWYgKGVyciAmJiAhdGhpcyQxLnJlYWR5KSB7XG4gICAgICB0aGlzJDEucmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcyQxLnJlYWR5RXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoZXJyKTsgfSk7XG4gICAgfVxuICB9KTtcbn07XG5cbkhpc3RvcnkucHJvdG90eXBlLmNvbmZpcm1UcmFuc2l0aW9uID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb24gKHJvdXRlLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gIHZhciBhYm9ydCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoaXNFcnJvcihlcnIpKSB7XG4gICAgICBpZiAodGhpcyQxLmVycm9yQ2JzLmxlbmd0aCkge1xuICAgICAgICB0aGlzJDEuZXJyb3JDYnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgY2IoZXJyKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKGZhbHNlLCAndW5jYXVnaHQgZXJyb3IgZHVyaW5nIHJvdXRlIG5hdmlnYXRpb246Jyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb25BYm9ydCAmJiBvbkFib3J0KGVycik7XG4gIH07XG4gIGlmIChcbiAgICBpc1NhbWVSb3V0ZShyb3V0ZSwgY3VycmVudCkgJiZcbiAgICAvLyBpbiB0aGUgY2FzZSB0aGUgcm91dGUgbWFwIGhhcyBiZWVuIGR5bmFtaWNhbGx5IGFwcGVuZGVkIHRvXG4gICAgcm91dGUubWF0Y2hlZC5sZW5ndGggPT09IGN1cnJlbnQubWF0Y2hlZC5sZW5ndGhcbiAgKSB7XG4gICAgdGhpcy5lbnN1cmVVUkwoKTtcbiAgICByZXR1cm4gYWJvcnQoKVxuICB9XG5cbiAgdmFyIHJlZiA9IHJlc29sdmVRdWV1ZSh0aGlzLmN1cnJlbnQubWF0Y2hlZCwgcm91dGUubWF0Y2hlZCk7XG4gICAgdmFyIHVwZGF0ZWQgPSByZWYudXBkYXRlZDtcbiAgICB2YXIgZGVhY3RpdmF0ZWQgPSByZWYuZGVhY3RpdmF0ZWQ7XG4gICAgdmFyIGFjdGl2YXRlZCA9IHJlZi5hY3RpdmF0ZWQ7XG5cbiAgdmFyIHF1ZXVlID0gW10uY29uY2F0KFxuICAgIC8vIGluLWNvbXBvbmVudCBsZWF2ZSBndWFyZHNcbiAgICBleHRyYWN0TGVhdmVHdWFyZHMoZGVhY3RpdmF0ZWQpLFxuICAgIC8vIGdsb2JhbCBiZWZvcmUgaG9va3NcbiAgICB0aGlzLnJvdXRlci5iZWZvcmVIb29rcyxcbiAgICAvLyBpbi1jb21wb25lbnQgdXBkYXRlIGhvb2tzXG4gICAgZXh0cmFjdFVwZGF0ZUhvb2tzKHVwZGF0ZWQpLFxuICAgIC8vIGluLWNvbmZpZyBlbnRlciBndWFyZHNcbiAgICBhY3RpdmF0ZWQubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtLmJlZm9yZUVudGVyOyB9KSxcbiAgICAvLyBhc3luYyBjb21wb25lbnRzXG4gICAgcmVzb2x2ZUFzeW5jQ29tcG9uZW50cyhhY3RpdmF0ZWQpXG4gICk7XG5cbiAgdGhpcy5wZW5kaW5nID0gcm91dGU7XG4gIHZhciBpdGVyYXRvciA9IGZ1bmN0aW9uIChob29rLCBuZXh0KSB7XG4gICAgaWYgKHRoaXMkMS5wZW5kaW5nICE9PSByb3V0ZSkge1xuICAgICAgcmV0dXJuIGFib3J0KClcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGhvb2socm91dGUsIGN1cnJlbnQsIGZ1bmN0aW9uICh0bykge1xuICAgICAgICBpZiAodG8gPT09IGZhbHNlIHx8IGlzRXJyb3IodG8pKSB7XG4gICAgICAgICAgLy8gbmV4dChmYWxzZSkgLT4gYWJvcnQgbmF2aWdhdGlvbiwgZW5zdXJlIGN1cnJlbnQgVVJMXG4gICAgICAgICAgdGhpcyQxLmVuc3VyZVVSTCh0cnVlKTtcbiAgICAgICAgICBhYm9ydCh0byk7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgdHlwZW9mIHRvID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIChcbiAgICAgICAgICAgIHR5cGVvZiB0by5wYXRoID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHRvLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbmV4dCgnLycpIG9yIG5leHQoeyBwYXRoOiAnLycgfSkgLT4gcmVkaXJlY3RcbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09ICdvYmplY3QnICYmIHRvLnJlcGxhY2UpIHtcbiAgICAgICAgICAgIHRoaXMkMS5yZXBsYWNlKHRvKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcyQxLnB1c2godG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25maXJtIHRyYW5zaXRpb24gYW5kIHBhc3Mgb24gdGhlIHZhbHVlXG4gICAgICAgICAgbmV4dCh0byk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGFib3J0KGUpO1xuICAgIH1cbiAgfTtcblxuICBydW5RdWV1ZShxdWV1ZSwgaXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcG9zdEVudGVyQ2JzID0gW107XG4gICAgdmFyIGlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEuY3VycmVudCA9PT0gcm91dGU7IH07XG4gICAgLy8gd2FpdCB1bnRpbCBhc3luYyBjb21wb25lbnRzIGFyZSByZXNvbHZlZCBiZWZvcmVcbiAgICAvLyBleHRyYWN0aW5nIGluLWNvbXBvbmVudCBlbnRlciBndWFyZHNcbiAgICB2YXIgZW50ZXJHdWFyZHMgPSBleHRyYWN0RW50ZXJHdWFyZHMoYWN0aXZhdGVkLCBwb3N0RW50ZXJDYnMsIGlzVmFsaWQpO1xuICAgIHZhciBxdWV1ZSA9IGVudGVyR3VhcmRzLmNvbmNhdCh0aGlzJDEucm91dGVyLnJlc29sdmVIb29rcyk7XG4gICAgcnVuUXVldWUocXVldWUsIGl0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcyQxLnBlbmRpbmcgIT09IHJvdXRlKSB7XG4gICAgICAgIHJldHVybiBhYm9ydCgpXG4gICAgICB9XG4gICAgICB0aGlzJDEucGVuZGluZyA9IG51bGw7XG4gICAgICBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICAgIGlmICh0aGlzJDEucm91dGVyLmFwcCkge1xuICAgICAgICB0aGlzJDEucm91dGVyLmFwcC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBvc3RFbnRlckNicy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgeyBjYigpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuSGlzdG9yeS5wcm90b3R5cGUudXBkYXRlUm91dGUgPSBmdW5jdGlvbiB1cGRhdGVSb3V0ZSAocm91dGUpIHtcbiAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gIHRoaXMuY3VycmVudCA9IHJvdXRlO1xuICB0aGlzLmNiICYmIHRoaXMuY2Iocm91dGUpO1xuICB0aGlzLnJvdXRlci5hZnRlckhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBob29rICYmIGhvb2socm91dGUsIHByZXYpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUJhc2UgKGJhc2UpIHtcbiAgaWYgKCFiYXNlKSB7XG4gICAgaWYgKGluQnJvd3Nlcikge1xuICAgICAgLy8gcmVzcGVjdCA8YmFzZT4gdGFnXG4gICAgICB2YXIgYmFzZUVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYmFzZScpO1xuICAgICAgYmFzZSA9IChiYXNlRWwgJiYgYmFzZUVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKSB8fCAnLyc7XG4gICAgICAvLyBzdHJpcCBmdWxsIFVSTCBvcmlnaW5cbiAgICAgIGJhc2UgPSBiYXNlLnJlcGxhY2UoL15odHRwcz86XFwvXFwvW15cXC9dKy8sICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZSA9ICcvJztcbiAgICB9XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHRoZXJlJ3MgdGhlIHN0YXJ0aW5nIHNsYXNoXG4gIGlmIChiYXNlLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgYmFzZSA9ICcvJyArIGJhc2U7XG4gIH1cbiAgLy8gcmVtb3ZlIHRyYWlsaW5nIHNsYXNoXG4gIHJldHVybiBiYXNlLnJlcGxhY2UoL1xcLyQvLCAnJylcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVF1ZXVlIChcbiAgY3VycmVudCxcbiAgbmV4dFxuKSB7XG4gIHZhciBpO1xuICB2YXIgbWF4ID0gTWF0aC5tYXgoY3VycmVudC5sZW5ndGgsIG5leHQubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgaWYgKGN1cnJlbnRbaV0gIT09IG5leHRbaV0pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdXBkYXRlZDogbmV4dC5zbGljZSgwLCBpKSxcbiAgICBhY3RpdmF0ZWQ6IG5leHQuc2xpY2UoaSksXG4gICAgZGVhY3RpdmF0ZWQ6IGN1cnJlbnQuc2xpY2UoaSlcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmRzIChcbiAgcmVjb3JkcyxcbiAgbmFtZSxcbiAgYmluZCxcbiAgcmV2ZXJzZVxuKSB7XG4gIHZhciBndWFyZHMgPSBmbGF0TWFwQ29tcG9uZW50cyhyZWNvcmRzLCBmdW5jdGlvbiAoZGVmLCBpbnN0YW5jZSwgbWF0Y2gsIGtleSkge1xuICAgIHZhciBndWFyZCA9IGV4dHJhY3RHdWFyZChkZWYsIG5hbWUpO1xuICAgIGlmIChndWFyZCkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZ3VhcmQpXG4gICAgICAgID8gZ3VhcmQubWFwKGZ1bmN0aW9uIChndWFyZCkgeyByZXR1cm4gYmluZChndWFyZCwgaW5zdGFuY2UsIG1hdGNoLCBrZXkpOyB9KVxuICAgICAgICA6IGJpbmQoZ3VhcmQsIGluc3RhbmNlLCBtYXRjaCwga2V5KVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBmbGF0dGVuKHJldmVyc2UgPyBndWFyZHMucmV2ZXJzZSgpIDogZ3VhcmRzKVxufVxuXG5mdW5jdGlvbiBleHRyYWN0R3VhcmQgKFxuICBkZWYsXG4gIGtleVxuKSB7XG4gIGlmICh0eXBlb2YgZGVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZXh0ZW5kIG5vdyBzbyB0aGF0IGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQuXG4gICAgZGVmID0gX1Z1ZS5leHRlbmQoZGVmKTtcbiAgfVxuICByZXR1cm4gZGVmLm9wdGlvbnNba2V5XVxufVxuXG5mdW5jdGlvbiBleHRyYWN0TGVhdmVHdWFyZHMgKGRlYWN0aXZhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKGRlYWN0aXZhdGVkLCAnYmVmb3JlUm91dGVMZWF2ZScsIGJpbmRHdWFyZCwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gZXh0cmFjdFVwZGF0ZUhvb2tzICh1cGRhdGVkKSB7XG4gIHJldHVybiBleHRyYWN0R3VhcmRzKHVwZGF0ZWQsICdiZWZvcmVSb3V0ZVVwZGF0ZScsIGJpbmRHdWFyZClcbn1cblxuZnVuY3Rpb24gYmluZEd1YXJkIChndWFyZCwgaW5zdGFuY2UpIHtcbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kUm91dGVHdWFyZCAoKSB7XG4gICAgICByZXR1cm4gZ3VhcmQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXh0cmFjdEVudGVyR3VhcmRzIChcbiAgYWN0aXZhdGVkLFxuICBjYnMsXG4gIGlzVmFsaWRcbikge1xuICByZXR1cm4gZXh0cmFjdEd1YXJkcyhhY3RpdmF0ZWQsICdiZWZvcmVSb3V0ZUVudGVyJywgZnVuY3Rpb24gKGd1YXJkLCBfLCBtYXRjaCwga2V5KSB7XG4gICAgcmV0dXJuIGJpbmRFbnRlckd1YXJkKGd1YXJkLCBtYXRjaCwga2V5LCBjYnMsIGlzVmFsaWQpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJpbmRFbnRlckd1YXJkIChcbiAgZ3VhcmQsXG4gIG1hdGNoLFxuICBrZXksXG4gIGNicyxcbiAgaXNWYWxpZFxuKSB7XG4gIHJldHVybiBmdW5jdGlvbiByb3V0ZUVudGVyR3VhcmQgKHRvLCBmcm9tLCBuZXh0KSB7XG4gICAgcmV0dXJuIGd1YXJkKHRvLCBmcm9tLCBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIG5leHQoY2IpO1xuICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gIzc1MFxuICAgICAgICAgIC8vIGlmIGEgcm91dGVyLXZpZXcgaXMgd3JhcHBlZCB3aXRoIGFuIG91dC1pbiB0cmFuc2l0aW9uLFxuICAgICAgICAgIC8vIHRoZSBpbnN0YW5jZSBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIGF0IHRoaXMgdGltZS5cbiAgICAgICAgICAvLyB3ZSB3aWxsIG5lZWQgdG8gcG9sbCBmb3IgcmVnaXN0cmF0aW9uIHVudGlsIGN1cnJlbnQgcm91dGVcbiAgICAgICAgICAvLyBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAgICAgcG9sbChjYiwgbWF0Y2guaW5zdGFuY2VzLCBrZXksIGlzVmFsaWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvbGwgKFxuICBjYiwgLy8gc29tZWhvdyBmbG93IGNhbm5vdCBpbmZlciB0aGlzIGlzIGEgZnVuY3Rpb25cbiAgaW5zdGFuY2VzLFxuICBrZXksXG4gIGlzVmFsaWRcbikge1xuICBpZiAoaW5zdGFuY2VzW2tleV0pIHtcbiAgICBjYihpbnN0YW5jZXNba2V5XSk7XG4gIH0gZWxzZSBpZiAoaXNWYWxpZCgpKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBwb2xsKGNiLCBpbnN0YW5jZXMsIGtleSwgaXNWYWxpZCk7XG4gICAgfSwgMTYpO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBIVE1MNUhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gSFRNTDVIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuXG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuXG4gICAgaWYgKGV4cGVjdFNjcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB2YXIgaW5pdExvY2F0aW9uID0gZ2V0TG9jYXRpb24odGhpcy5iYXNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzJDEuY3VycmVudDtcblxuICAgICAgLy8gQXZvaWRpbmcgZmlyc3QgYHBvcHN0YXRlYCBldmVudCBkaXNwYXRjaGVkIGluIHNvbWUgYnJvd3NlcnMgYnV0IGZpcnN0XG4gICAgICAvLyBoaXN0b3J5IHJvdXRlIG5vdCB1cGRhdGVkIHNpbmNlIGFzeW5jIGd1YXJkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRMb2NhdGlvbih0aGlzJDEuYmFzZSk7XG4gICAgICBpZiAodGhpcyQxLmN1cnJlbnQgPT09IFNUQVJUICYmIGxvY2F0aW9uID09PSBpbml0TG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMkMS50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICBpZiAoZXhwZWN0U2Nyb2xsKSB7XG4gICAgICAgICAgaGFuZGxlU2Nyb2xsKHJvdXRlciwgcm91dGUsIGN1cnJlbnQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhUTUw1SGlzdG9yeS5fX3Byb3RvX18gPSBIaXN0b3J5JCQxO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSGlzdG9yeSQkMSAmJiBIaXN0b3J5JCQxLnByb3RvdHlwZSApO1xuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSFRNTDVIaXN0b3J5O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhUTUw1SGlzdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2ggKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcmVmID0gdGhpcztcbiAgICB2YXIgZnJvbVJvdXRlID0gcmVmLmN1cnJlbnQ7XG4gICAgdGhpcy50cmFuc2l0aW9uVG8obG9jYXRpb24sIGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgcHVzaFN0YXRlKGNsZWFuUGF0aCh0aGlzJDEuYmFzZSArIHJvdXRlLmZ1bGxQYXRoKSk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIVE1MNUhpc3RvcnkucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHJlcGxhY2VTdGF0ZShjbGVhblBhdGgodGhpcyQxLmJhc2UgKyByb3V0ZS5mdWxsUGF0aCkpO1xuICAgICAgaGFuZGxlU2Nyb2xsKHRoaXMkMS5yb3V0ZXIsIHJvdXRlLCBmcm9tUm91dGUsIGZhbHNlKTtcbiAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZShyb3V0ZSk7XG4gICAgfSwgb25BYm9ydCk7XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICBpZiAoZ2V0TG9jYXRpb24odGhpcy5iYXNlKSAhPT0gdGhpcy5jdXJyZW50LmZ1bGxQYXRoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGNsZWFuUGF0aCh0aGlzLmJhc2UgKyB0aGlzLmN1cnJlbnQuZnVsbFBhdGgpO1xuICAgICAgcHVzaCA/IHB1c2hTdGF0ZShjdXJyZW50KSA6IHJlcGxhY2VTdGF0ZShjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSFRNTDVIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHJldHVybiBnZXRMb2NhdGlvbih0aGlzLmJhc2UpXG4gIH07XG5cbiAgcmV0dXJuIEhUTUw1SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBnZXRMb2NhdGlvbiAoYmFzZSkge1xuICB2YXIgcGF0aCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZTtcbiAgaWYgKGJhc2UgJiYgcGF0aC5pbmRleE9mKGJhc2UpID09PSAwKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoYmFzZS5sZW5ndGgpO1xuICB9XG4gIHJldHVybiAocGF0aCB8fCAnLycpICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoXG59XG5cbi8qICAqL1xuXG5cbnZhciBIYXNoSGlzdG9yeSA9IChmdW5jdGlvbiAoSGlzdG9yeSQkMSkge1xuICBmdW5jdGlvbiBIYXNoSGlzdG9yeSAocm91dGVyLCBiYXNlLCBmYWxsYmFjaykge1xuICAgIEhpc3RvcnkkJDEuY2FsbCh0aGlzLCByb3V0ZXIsIGJhc2UpO1xuICAgIC8vIGNoZWNrIGhpc3RvcnkgZmFsbGJhY2sgZGVlcGxpbmtpbmdcbiAgICBpZiAoZmFsbGJhY2sgJiYgY2hlY2tGYWxsYmFjayh0aGlzLmJhc2UpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZW5zdXJlU2xhc2goKTtcbiAgfVxuXG4gIGlmICggSGlzdG9yeSQkMSApIEhhc2hIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEhpc3RvcnkkJDEgJiYgSGlzdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaEhpc3Rvcnk7XG5cbiAgLy8gdGhpcyBpcyBkZWxheWVkIHVudGlsIHRoZSBhcHAgbW91bnRzXG4gIC8vIHRvIGF2b2lkIHRoZSBoYXNoY2hhbmdlIGxpc3RlbmVyIGJlaW5nIGZpcmVkIHRvbyBlYXJseVxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuc2V0dXBMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXR1cExpc3RlbmVycyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcm91dGVyID0gdGhpcy5yb3V0ZXI7XG4gICAgdmFyIGV4cGVjdFNjcm9sbCA9IHJvdXRlci5vcHRpb25zLnNjcm9sbEJlaGF2aW9yO1xuICAgIHZhciBzdXBwb3J0c1Njcm9sbCA9IHN1cHBvcnRzUHVzaFN0YXRlICYmIGV4cGVjdFNjcm9sbDtcblxuICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgc2V0dXBTY3JvbGwoKTtcbiAgICB9XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihzdXBwb3J0c1B1c2hTdGF0ZSA/ICdwb3BzdGF0ZScgOiAnaGFzaGNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcyQxLmN1cnJlbnQ7XG4gICAgICBpZiAoIWVuc3VyZVNsYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB0aGlzJDEudHJhbnNpdGlvblRvKGdldEhhc2goKSwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Njcm9sbCkge1xuICAgICAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgICAgICAgIHJlcGxhY2VIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgdmFyIGZyb21Sb3V0ZSA9IHJlZi5jdXJyZW50O1xuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHB1c2hIYXNoKHJvdXRlLmZ1bGxQYXRoKTtcbiAgICAgIGhhbmRsZVNjcm9sbCh0aGlzJDEucm91dGVyLCByb3V0ZSwgZnJvbVJvdXRlLCBmYWxzZSk7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZSAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciByZWYgPSB0aGlzO1xuICAgIHZhciBmcm9tUm91dGUgPSByZWYuY3VycmVudDtcbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXBsYWNlSGFzaChyb3V0ZS5mdWxsUGF0aCk7XG4gICAgICBoYW5kbGVTY3JvbGwodGhpcyQxLnJvdXRlciwgcm91dGUsIGZyb21Sb3V0ZSwgZmFsc2UpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBIYXNoSGlzdG9yeS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiBnbyAobikge1xuICAgIHdpbmRvdy5oaXN0b3J5LmdvKG4pO1xuICB9O1xuXG4gIEhhc2hIaXN0b3J5LnByb3RvdHlwZS5lbnN1cmVVUkwgPSBmdW5jdGlvbiBlbnN1cmVVUkwgKHB1c2gpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudC5mdWxsUGF0aDtcbiAgICBpZiAoZ2V0SGFzaCgpICE9PSBjdXJyZW50KSB7XG4gICAgICBwdXNoID8gcHVzaEhhc2goY3VycmVudCkgOiByZXBsYWNlSGFzaChjdXJyZW50KTtcbiAgICB9XG4gIH07XG5cbiAgSGFzaEhpc3RvcnkucHJvdG90eXBlLmdldEN1cnJlbnRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEN1cnJlbnRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEhhc2goKVxuICB9O1xuXG4gIHJldHVybiBIYXNoSGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG5mdW5jdGlvbiBjaGVja0ZhbGxiYWNrIChiYXNlKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdldExvY2F0aW9uKGJhc2UpO1xuICBpZiAoIS9eXFwvIy8udGVzdChsb2NhdGlvbikpIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShcbiAgICAgIGNsZWFuUGF0aChiYXNlICsgJy8jJyArIGxvY2F0aW9uKVxuICAgICk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnN1cmVTbGFzaCAoKSB7XG4gIHZhciBwYXRoID0gZ2V0SGFzaCgpO1xuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmVwbGFjZUhhc2goJy8nICsgcGF0aCk7XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoICgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zbGljZShpbmRleCArIDEpXG59XG5cbmZ1bmN0aW9uIGdldFVybCAocGF0aCkge1xuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaSA9IGhyZWYuaW5kZXhPZignIycpO1xuICB2YXIgYmFzZSA9IGkgPj0gMCA/IGhyZWYuc2xpY2UoMCwgaSkgOiBocmVmO1xuICByZXR1cm4gKGJhc2UgKyBcIiNcIiArIHBhdGgpXG59XG5cbmZ1bmN0aW9uIHB1c2hIYXNoIChwYXRoKSB7XG4gIGlmIChzdXBwb3J0c1B1c2hTdGF0ZSkge1xuICAgIHB1c2hTdGF0ZShnZXRVcmwocGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYWNlSGFzaCAocGF0aCkge1xuICBpZiAoc3VwcG9ydHNQdXNoU3RhdGUpIHtcbiAgICByZXBsYWNlU3RhdGUoZ2V0VXJsKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShnZXRVcmwocGF0aCkpO1xuICB9XG59XG5cbi8qICAqL1xuXG5cbnZhciBBYnN0cmFjdEhpc3RvcnkgPSAoZnVuY3Rpb24gKEhpc3RvcnkkJDEpIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3RIaXN0b3J5IChyb3V0ZXIsIGJhc2UpIHtcbiAgICBIaXN0b3J5JCQxLmNhbGwodGhpcywgcm91dGVyLCBiYXNlKTtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5pbmRleCA9IC0xO1xuICB9XG5cbiAgaWYgKCBIaXN0b3J5JCQxICkgQWJzdHJhY3RIaXN0b3J5Ll9fcHJvdG9fXyA9IEhpc3RvcnkkJDE7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBIaXN0b3J5JCQxICYmIEhpc3RvcnkkJDEucHJvdG90eXBlICk7XG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBYnN0cmFjdEhpc3Rvcnk7XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaCAobG9jYXRpb24sIG9uQ29tcGxldGUsIG9uQWJvcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMudHJhbnNpdGlvblRvKGxvY2F0aW9uLCBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgIHRoaXMkMS5zdGFjayA9IHRoaXMkMS5zdGFjay5zbGljZSgwLCB0aGlzJDEuaW5kZXggKyAxKS5jb25jYXQocm91dGUpO1xuICAgICAgdGhpcyQxLmluZGV4Kys7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUocm91dGUpO1xuICAgIH0sIG9uQWJvcnQpO1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UgKGxvY2F0aW9uLCBvbkNvbXBsZXRlLCBvbkFib3J0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLnRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICB0aGlzJDEuc3RhY2sgPSB0aGlzJDEuc3RhY2suc2xpY2UoMCwgdGhpcyQxLmluZGV4KS5jb25jYXQocm91dGUpO1xuICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKHJvdXRlKTtcbiAgICB9LCBvbkFib3J0KTtcbiAgfTtcblxuICBBYnN0cmFjdEhpc3RvcnkucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB0YXJnZXRJbmRleCA9IHRoaXMuaW5kZXggKyBuO1xuICAgIGlmICh0YXJnZXRJbmRleCA8IDAgfHwgdGFyZ2V0SW5kZXggPj0gdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgcm91dGUgPSB0aGlzLnN0YWNrW3RhcmdldEluZGV4XTtcbiAgICB0aGlzLmNvbmZpcm1UcmFuc2l0aW9uKHJvdXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzJDEuaW5kZXggPSB0YXJnZXRJbmRleDtcbiAgICAgIHRoaXMkMS51cGRhdGVSb3V0ZShyb3V0ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgQWJzdHJhY3RIaXN0b3J5LnByb3RvdHlwZS5nZXRDdXJyZW50TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRDdXJyZW50TG9jYXRpb24gKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5mdWxsUGF0aCA6ICcvJ1xuICB9O1xuXG4gIEFic3RyYWN0SGlzdG9yeS5wcm90b3R5cGUuZW5zdXJlVVJMID0gZnVuY3Rpb24gZW5zdXJlVVJMICgpIHtcbiAgICAvLyBub29wXG4gIH07XG5cbiAgcmV0dXJuIEFic3RyYWN0SGlzdG9yeTtcbn0oSGlzdG9yeSkpO1xuXG4vKiAgKi9cblxudmFyIFZ1ZVJvdXRlciA9IGZ1bmN0aW9uIFZ1ZVJvdXRlciAob3B0aW9ucykge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB0aGlzLmFwcCA9IG51bGw7XG4gIHRoaXMuYXBwcyA9IFtdO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmJlZm9yZUhvb2tzID0gW107XG4gIHRoaXMucmVzb2x2ZUhvb2tzID0gW107XG4gIHRoaXMuYWZ0ZXJIb29rcyA9IFtdO1xuICB0aGlzLm1hdGNoZXIgPSBjcmVhdGVNYXRjaGVyKG9wdGlvbnMucm91dGVzIHx8IFtdLCB0aGlzKTtcblxuICB2YXIgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAnaGFzaCc7XG4gIHRoaXMuZmFsbGJhY2sgPSBtb2RlID09PSAnaGlzdG9yeScgJiYgIXN1cHBvcnRzUHVzaFN0YXRlICYmIG9wdGlvbnMuZmFsbGJhY2sgIT09IGZhbHNlO1xuICBpZiAodGhpcy5mYWxsYmFjaykge1xuICAgIG1vZGUgPSAnaGFzaCc7XG4gIH1cbiAgaWYgKCFpbkJyb3dzZXIpIHtcbiAgICBtb2RlID0gJ2Fic3RyYWN0JztcbiAgfVxuICB0aGlzLm1vZGUgPSBtb2RlO1xuXG4gIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgJ2hpc3RvcnknOlxuICAgICAgdGhpcy5oaXN0b3J5ID0gbmV3IEhUTUw1SGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIYXNoSGlzdG9yeSh0aGlzLCBvcHRpb25zLmJhc2UsIHRoaXMuZmFsbGJhY2spO1xuICAgICAgYnJlYWtcbiAgICBjYXNlICdhYnN0cmFjdCc6XG4gICAgICB0aGlzLmhpc3RvcnkgPSBuZXcgQWJzdHJhY3RIaXN0b3J5KHRoaXMsIG9wdGlvbnMuYmFzZSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGFzc2VydChmYWxzZSwgKFwiaW52YWxpZCBtb2RlOiBcIiArIG1vZGUpKTtcbiAgICAgIH1cbiAgfVxufTtcblxudmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY3VycmVudFJvdXRlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiBtYXRjaCAoXG4gIHJhdyxcbiAgY3VycmVudCxcbiAgcmVkaXJlY3RlZEZyb21cbikge1xuICByZXR1cm4gdGhpcy5tYXRjaGVyLm1hdGNoKHJhdywgY3VycmVudCwgcmVkaXJlY3RlZEZyb20pXG59O1xuXG5wcm90b3R5cGVBY2Nlc3NvcnMuY3VycmVudFJvdXRlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaGlzdG9yeSAmJiB0aGlzLmhpc3RvcnkuY3VycmVudFxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoYXBwIC8qIFZ1ZSBjb21wb25lbnQgaW5zdGFuY2UgKi8pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBhc3NlcnQoXG4gICAgaW5zdGFsbC5pbnN0YWxsZWQsXG4gICAgXCJub3QgaW5zdGFsbGVkLiBNYWtlIHN1cmUgdG8gY2FsbCBgVnVlLnVzZShWdWVSb3V0ZXIpYCBcIiArXG4gICAgXCJiZWZvcmUgY3JlYXRpbmcgcm9vdCBpbnN0YW5jZS5cIlxuICApO1xuXG4gIHRoaXMuYXBwcy5wdXNoKGFwcCk7XG5cbiAgLy8gbWFpbiBhcHAgYWxyZWFkeSBpbml0aWFsaXplZC5cbiAgaWYgKHRoaXMuYXBwKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmFwcCA9IGFwcDtcblxuICB2YXIgaGlzdG9yeSA9IHRoaXMuaGlzdG9yeTtcblxuICBpZiAoaGlzdG9yeSBpbnN0YW5jZW9mIEhUTUw1SGlzdG9yeSkge1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKGhpc3RvcnkuZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGhpc3RvcnkgaW5zdGFuY2VvZiBIYXNoSGlzdG9yeSkge1xuICAgIHZhciBzZXR1cEhhc2hMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhpc3Rvcnkuc2V0dXBMaXN0ZW5lcnMoKTtcbiAgICB9O1xuICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKFxuICAgICAgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSxcbiAgICAgIHNldHVwSGFzaExpc3RlbmVyLFxuICAgICAgc2V0dXBIYXNoTGlzdGVuZXJcbiAgICApO1xuICB9XG5cbiAgaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgdGhpcyQxLmFwcHMuZm9yRWFjaChmdW5jdGlvbiAoYXBwKSB7XG4gICAgICBhcHAuX3JvdXRlID0gcm91dGU7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iZWZvcmVFYWNoID0gZnVuY3Rpb24gYmVmb3JlRWFjaCAoZm4pIHtcbiAgcmV0dXJuIHJlZ2lzdGVySG9vayh0aGlzLmJlZm9yZUhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUuYmVmb3JlUmVzb2x2ZSA9IGZ1bmN0aW9uIGJlZm9yZVJlc29sdmUgKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5yZXNvbHZlSG9va3MsIGZuKVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZnRlckVhY2ggPSBmdW5jdGlvbiBhZnRlckVhY2ggKGZuKSB7XG4gIHJldHVybiByZWdpc3Rlckhvb2sodGhpcy5hZnRlckhvb2tzLCBmbilcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25SZWFkeSA9IGZ1bmN0aW9uIG9uUmVhZHkgKGNiLCBlcnJvckNiKSB7XG4gIHRoaXMuaGlzdG9yeS5vblJlYWR5KGNiLCBlcnJvckNiKTtcbn07XG5cblZ1ZVJvdXRlci5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKGVycm9yQ2IpIHtcbiAgdGhpcy5oaXN0b3J5Lm9uRXJyb3IoZXJyb3JDYik7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucHVzaChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlIChsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCkge1xuICB0aGlzLmhpc3RvcnkucmVwbGFjZShsb2NhdGlvbiwgb25Db21wbGV0ZSwgb25BYm9ydCk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gZ28gKG4pIHtcbiAgdGhpcy5oaXN0b3J5LmdvKG4pO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5iYWNrID0gZnVuY3Rpb24gYmFjayAoKSB7XG4gIHRoaXMuZ28oLTEpO1xufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24gZm9yd2FyZCAoKSB7XG4gIHRoaXMuZ28oMSk7XG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLmdldE1hdGNoZWRDb21wb25lbnRzID0gZnVuY3Rpb24gZ2V0TWF0Y2hlZENvbXBvbmVudHMgKHRvKSB7XG4gIHZhciByb3V0ZSA9IHRvXG4gICAgPyB0by5tYXRjaGVkXG4gICAgICA/IHRvXG4gICAgICA6IHRoaXMucmVzb2x2ZSh0bykucm91dGVcbiAgICA6IHRoaXMuY3VycmVudFJvdXRlO1xuICBpZiAoIXJvdXRlKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdC5hcHBseShbXSwgcm91dGUubWF0Y2hlZC5tYXAoZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobS5jb21wb25lbnRzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG0uY29tcG9uZW50c1trZXldXG4gICAgfSlcbiAgfSkpXG59O1xuXG5WdWVSb3V0ZXIucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlIChcbiAgdG8sXG4gIGN1cnJlbnQsXG4gIGFwcGVuZFxuKSB7XG4gIHZhciBsb2NhdGlvbiA9IG5vcm1hbGl6ZUxvY2F0aW9uKFxuICAgIHRvLFxuICAgIGN1cnJlbnQgfHwgdGhpcy5oaXN0b3J5LmN1cnJlbnQsXG4gICAgYXBwZW5kLFxuICAgIHRoaXNcbiAgKTtcbiAgdmFyIHJvdXRlID0gdGhpcy5tYXRjaChsb2NhdGlvbiwgY3VycmVudCk7XG4gIHZhciBmdWxsUGF0aCA9IHJvdXRlLnJlZGlyZWN0ZWRGcm9tIHx8IHJvdXRlLmZ1bGxQYXRoO1xuICB2YXIgYmFzZSA9IHRoaXMuaGlzdG9yeS5iYXNlO1xuICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYoYmFzZSwgZnVsbFBhdGgsIHRoaXMubW9kZSk7XG4gIHJldHVybiB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHJvdXRlOiByb3V0ZSxcbiAgICBocmVmOiBocmVmLFxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgbm9ybWFsaXplZFRvOiBsb2NhdGlvbixcbiAgICByZXNvbHZlZDogcm91dGVcbiAgfVxufTtcblxuVnVlUm91dGVyLnByb3RvdHlwZS5hZGRSb3V0ZXMgPSBmdW5jdGlvbiBhZGRSb3V0ZXMgKHJvdXRlcykge1xuICB0aGlzLm1hdGNoZXIuYWRkUm91dGVzKHJvdXRlcyk7XG4gIGlmICh0aGlzLmhpc3RvcnkuY3VycmVudCAhPT0gU1RBUlQpIHtcbiAgICB0aGlzLmhpc3RvcnkudHJhbnNpdGlvblRvKHRoaXMuaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb24oKSk7XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWdWVSb3V0ZXIucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuZnVuY3Rpb24gcmVnaXN0ZXJIb29rIChsaXN0LCBmbikge1xuICBsaXN0LnB1c2goZm4pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gbGlzdC5pbmRleE9mKGZuKTtcbiAgICBpZiAoaSA+IC0xKSB7IGxpc3Quc3BsaWNlKGksIDEpOyB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZiAoYmFzZSwgZnVsbFBhdGgsIG1vZGUpIHtcbiAgdmFyIHBhdGggPSBtb2RlID09PSAnaGFzaCcgPyAnIycgKyBmdWxsUGF0aCA6IGZ1bGxQYXRoO1xuICByZXR1cm4gYmFzZSA/IGNsZWFuUGF0aChiYXNlICsgJy8nICsgcGF0aCkgOiBwYXRoXG59XG5cblZ1ZVJvdXRlci5pbnN0YWxsID0gaW5zdGFsbDtcblZ1ZVJvdXRlci52ZXJzaW9uID0gJzMuMC4xJztcblxuaWYgKGluQnJvd3NlciAmJiB3aW5kb3cuVnVlKSB7XG4gIHdpbmRvdy5WdWUudXNlKFZ1ZVJvdXRlcik7XG59XG5cbnJldHVybiBWdWVSb3V0ZXI7XG5cbn0pKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/vendor/vue-router.js\n")}});